***Nell B. Dale, Chip Weems, Mark R. Headington - Introduction to Java and Software Design_ Swing Update-Jones & Bartlett Publishers (2000)***


































 

J O N E S  A N D  B A R T L E T T  C O M P U T E R  S C I E N C E

TE
AM
FL
Y

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

Team-Fly® 



SWING UPDATE

Nell Dale
University of Texas, Austin

Chip Weems
University of Massachusetts, Amherst

Mark Headington
University of Wisconsin–La Crosse

INTRODUCTION to

java Softwareand
D e s i g n

TM



Copyright © 2002, 2001 by Jones and Bartlett Publishers, Inc.

All rights reserved.  No part of the material protected by this copyright notice may be reproduced or utilized

in any form, electronic or mechanical, including photocopying, recording, or any information storage or

retrieval system, without written permission from the copyright owner.

ISBN: 0-7637-2030-5

This text (ISBN 0-7637-2030-5 © 2002) represents an update of the original © 2001 edition (ISBN 0-7637-

1064-4)

Library of Congress Cataloging-in-Publication Data

Dale, Nell B.

Introduction to Java and software design : swing update / Nell Dale, Chip Weems, Mark Headington.

p. cm.

ISBN 0-7637-2030-5

1. Java (Computer program language) 2. Computer software—Development. I. Weems,

Chip. II. Headington, Mark R. III. Title.

QA76.73.J38 D343 2001

005.13'3—dc21 2001038230

Chief Executive Officer:  Clayton Jones

Chief Operating Officer:  Don W. Jones, Jr.

V.P., Managing Editor:  Judith H. Hauck

V.P., Design and Production:  Anne Spencer

V.P., Manufacturing and Inventory Control:  Therese Bräuer 

Senior Acquisitions Editor: Michael Stranz

Development and Product Manager: Amy Rose

Production Assistant: Tara McCormick

Editorial Assistant: Amanda Green

Cover Design: Kristin E. Ohlin

Project Coordination: Trillium Project Management

Composition: Northeast Compositors, Inc.

Text Design: Anne Spencer

Printing and Binding: Courier Westford

Cover printing: John Pow Company, Inc.

This book was typeset in QuarkXPress 4.1 on a Macintosh G4. The font families used were Rotis Sans Serif,

Rotis Serif, and Prestige Elite. The second printing was printed on 45 lb. Utopia Book Matte. 

Printed in the United States of America

04  03  02  01 00 10  9  8  7  6  5  4  3  2 1

World Headquarters

Jones and Bartlett Publishers 

40 Tall Pine Drive

Sudbury, MA 01776

978-443-5000

info@jbpub.com

www.jbpub.com

Jones and Bartlett Publishers

Canada

2406 Nikanna Road

Mississauga, ON L5C 2W6

CANADA

Jones and Bartlett Publishers 

International

Barb House, Barb Mews

London W6 7PA

UK

DaleJVTTL  7/12/01  9:04 AM  Page ii



To Al, my husband and best friend, and to our children and
our children’s children.

N.D. 

To Lisa, Charlie, and Abby with love.

C.W.

To Professor John Dyer-Bennet, with great respect.

M.H.

To quote Mephistopheles, one of the chief devils, and tempter of Faust,

…My friend, I shall be pedagogic,
And say you ought to start with Logic…
…Days will be spent to let you know
That what you once did at one blow,
Like eating and drinking so easy and free,
Can only be done with One, Two, Three.
Yet the web of thought has no such creases
And is more like a weaver’s masterpieces;
One step, a thousand threads arise,
Hither and thither shoots each shuttle,
The threads flow on, unseen and subtle,
Each blow effects a thousand ties.
The philosopher comes with analysis
And proves it had to be like this;
The first was so, the second so,
And hence the third and fourth was so,
And were not the first and second here,
Then the third and fourth could never appear.
That is what all the students believe,
But they have never learned to weave.

As you study this book, do not let the logic of algorithms bind your
imagination, but rather make it your tool for weaving masterpieces of
thought.

J. W. von Goeth, Faust, Walter Kaufman trans., New York, 1963, 199.





     

Introduction to Java and Software Design represents a significant transition in thedevelopment of the Dale series, with much that is new. This book has been devel-oped from the ground up to be a Java text. It is not a “Java translation” of our
previous texts. However, we have retained our familiar easy-to-read style and clear
approach to introducing new topics. The chapters retain the same overall organiza-
tion with each chapter containing a full problem-solving case study, testing and
debugging hints, summary, and five types of end-of-chapter exercises. Also, some
topics—such as problem solving—are independent of the programming language and
thus contain familiar discussions.

The text uses real Java I/O classes rather than ones we supply. We have seen
many introductory programming texts that introduce either C- or Pascal-like com-
mand-line I/O classes or simplified windowing classes that automatically handle
events. However, our view is that event-driven I/O is the dominant model not only in
Java but in the modern world of programming in general. Students come to our
classes already familiar with event-driven interfaces and expect to learn how to write
programs that have them.

Event handling is now a fundamental control structure and must be treated that
way from the start. We therefore introduce event handling even before branching
and looping. On the other hand, it is easy for students to be overwhelmed by the
sheer number and complexity of Java I/O classes. We have taken great care to select
a tiny but sufficient subset of the library to illustrate all of the fundamental concepts.
The result is that when students are finished with the course, they can write real Java
programs without being dependent on a text-supplied library. They also have devel-
oped the ability to extend their knowledge of I/O classes to include the many
optional features that are available.

There is some confusion, which we would like to address, about what the term
“Java 2” refers to. Java 2 refers to the second version of the Sun Java Software
Development Kit (compilers, debuggers, and other tools). We do not cover these spe-
cific tools, as they are often hidden inside of an integrated development environ-
ment, and there are too many different environments to cover them all at a useful



level of detail. It was in version 1.2 that the Java class library was heavily extended
with new classes such as Swing. Other than Swing and the comparable interface, most
of the new classes are well beyond the introductory computer science curriculum. The
remaining classes that might be presented at this level are unnecessary for covering the
curriculum. They are bells and whistles that may be interesting in their own right, but
omitting them has no impact on learning the fundamentals of problem solving and soft-
ware design. The Java language itself has not changed since version 1.1. Thus, the Java
that students learn from this text is fully compatible with Java 2, as well as with version
1.3 of the language.

In this book  we consciously chose the AWT library over Swing for pragmatic rea-
sons. At this point, Swing is not available on all platforms, and our experience has been
that some Swing implementations aren’t stable or are inconsistent with others. These are
the kinds of problems that greatly trouble beginners, so we’ve chosen to avoid them by
using the older, more reliable AWT package in this first edition. In addition, at this level
the programming differences between AWT and Swing are quite trivial. For those stu-
dents and instructors who would like to experiment with Swing, Appendix H describes
how to convert our AWT programs to Swing, and provides as an example a Swing ver-
sion of the case study program from Chapter 6.

All of the programs In this book have been tested with Symantec Café® and
Metrowerks CodeWarrior®. The program code is available for download from the Jones
and Bartlett web site at www.jbpub.com/disks.

Chapter Coverage

Chapter 1 begins with basic definitions, computer concepts, problem-solving techniques,
ethical issues, and a case study. We introduce objects from the very beginning, with
their definition in this first chapter and the consistent use of object-oriented terminol-
ogy.

In Chapter 2 we examine the String class and aspects of its interface. Through the
next several chapters, we introduce new library classes and point out their design fea-
tures. We also tread carefully through the process of declaring a reference variable,
instantiating an object, assigning it to the variable, and using the object. These are diffi-
cult but essential concepts for beginners to grasp. Our goal is for students to gradually
develop a complete and deep understanding of what an object is, how it works, and
what makes its interface well-designed. Then, by Chapters 7 and 8, students are ready to
build significant and realistic classes.

Chapter 2 further covers sequential control flow, and simple output to system.out.
This gets students off to a quick start with a working program and past the mechanics
of program entry and execution. Then, in Chapter 3 we switch to using the Frame class
and a Label for output. Simple event handling is then introduced for a WindowClosing
event. The WindowClosing event is conceptually simpler than others because it doesn’t
need to be registered. Its handler can be written with a simple syntactic template that
uses Java’s anonymous inner-class mechanism to avoid becoming bogged down in gen-
eral class syntax at this early stage.

In Chapter 4, we turn to the numeric types and expression syntax. We cover type
conversions, precedence rules, the use of numeric types, and additional methods that

vi | Preface



can be applied to String objects. We also reinforce the distinction between the reference
and primitive types in this chapter. Students gain further experience with Frame output
and event handling in this chapter.

With Chapter 5, we take the next step in event handling by introducing the essen-
tial elements of an input dialog. Students learn how to use a TextField for data input
and a Button to signal when the field is ready. The Button class is the first event source
they see that must be registered. The concepts of an event source, an action listener, and
an event handler are covered in the simplest context possible. Together, these constructs
enable the students to implement a program with an event loop for reading a series of
inputs. One of the key pedagogical differences in moving to event-driven I/O is that the
looping control structure isn’t required, as it would be in a command-line I/O environ-
ment.

Along the way, students are introduced to the syntax for a specific user-defined
class and method that conforms to the ActionListener interface. This experience with the
syntax, though limited, simplifies its formal introduction in Chapter 7. We also examine
the conversion of strings to numeric values. The chapter closes with a discussion of
object-oriented design that introduces the CRC card (Classes, Responsibilities, and Col-
laborators) as a mechanism for organizing an object oriented design.

The primary goal of Chapter 6 is to introduce branching and the boolean type. But
the motivation for its use, in the end, is for students to be able to handle events from
multiple sources in a single event handler. Students then have learned all of the basic
user interface elements necessary to write a wide range of interactive programs.

Chapters 7 and 8 are the heart of the text. In these chapters we bring together all of
the informal discussion of classes and objects to formally introduce the mechanisms for
defining new classes, methods, and derived classes. Students learn how to read the doc-
umentation for a class hierarchy and how to determine the inherited members of a class.
They also see how the classes are related through Java’s scope rules. Package syntax is
introduced so that multifile programs can be written and user-defined classes can be
created and imported to other code. The key object-oriented concepts of encapsulation,
inheritance, and polymorphism are treated thoroughly, and their use is demonstrated in
the case studies.

Users who are familiar with procedural languages may wonder, at this point, “What
happened to looping?” The answer is that event driven I/O has permitted us to postpone
it to Chapter 9, where it naturally fits with file I/O and prepares students for the upcom-
ing chapters on arrays. As always, we cover the basic concepts of looping using only
the while loop. Object-oriented languages haven’t changed the basic fact that beginners
have to make conceptual leaps to understand looping. Because there is more syntax to
learn in an object-oriented language, it is tempting to relegate all those “old-fashioned”
control structures to a single chapter and just breeze by them as if they are suddenly
made easier in the presence of the additional complexity.

We find that students are still well-served by a careful study of the basic program-
ming elements. We focus on how loops are used in algorithms while introducing only
the minimum syntax necessary to illustrate the concepts. In that way, students don’t
develop the misperception that the different forms of control structures are bound to the
different syntactic structures in a language. This approach also avoids the situation that
we commonly see in which a student is focused on their confusion over choosing

Preface | vii



among different looping statements when they are really still unsure of the underlying
algorithmic mechanism that they wish to express. For those instructors who feel
strongly that they prefer to show students all of the control structure syntax at one
time, Chapter 10 covers the additional branching and looping structures in a manner
that enables appropriate sections to be covered as extensions to Chapters 6 and 9.

Chapter 10 is the “ice cream and cake” section of the book, covering the additional
control structures that make the coding of certain algorithms easier. In addition to the
switch, do, and for statements, Chapter 10 introduces the concept of exception handling.
We show students how to use a try-catch statement to catch exceptions. Because we’ve
already covered inheritance, it is a simple matter to define new exception classes that
can be thrown between sections of user code. Students then are able to write code that
is robust in the face of errors that cannot be handled directly with testing and branch-
ing.

Chapters 11, 12, and 13 are devoted to composite data structures. In Chapter 12, the
basic concept of a composite structure is introduced and illustrated with the Java array.
In Chapter 13, we show how an array can be used to implement a general-purpose list
class. Our prior class designs have been in the context of specific applications, and this
is the first taste of an object-oriented design that does not have a predefined client.
Then, in Chapter 13, we extend the discussion of arrays to multiple dimensions, and
through a case study we show how they can be used to represent mathematical matri-
ces. Given this numerically motivated case study, it is also natural to review the limita-
tions of floating-point numbers as they are represented in the computer.

Chapter 14 concludes the text with a quick tour of the concept of recursion and
some example algorithms. As in our previous texts, this chapter is designed so that it
can be assigned for reading along with earlier chapters. The first half of the chapter can
be covered after Chapter 6, although the contrasting iterative examples won’t be read-
able until after Chapter 9. The second half of the chapter can be read after Chapter 11,
as it applies recursion to arrays.

Chapter Features

Goals Each chapter begins with a list of learning objectives for the student. These
goals are reinforced and tested in the end-of-chapter exercises.

Problem-Solving Case Studies A full development of a problem from its statement to a
working Java application is developed. In chapters beginning with 5, the CRC card
design strategy is employed to develop object-oriented designs that are then translated
into code. Test plans and sample test data are also presented for many of these case
studies.

Testing and Debugging These sections consider the implications of the chapter material
with regard to testing of applications or classes. They conclude with a list of testing and
debugging hints.

Quick Checks These questions test the student’s recall of major points associated with
the chapter goals. Upon reading each question, the student immediately should know

viii | Preface



the answer, which he or she can verify by glancing at the answer at the end of the
section. The page number on which the concept is discussed appears at the end of each
question so that the student can review the material in the event of an incorrect
response.

Exam Preparation Exercises To help the student prepare for tests, these questions
usually have objective answers and are designed to be answerable with a few minutes
of work. Answers to selected questions are given in the back of the book, and the
remaining questions are answered in the Instructor’s Guide.

Programming Warm-Up Exercises These questions provide the student with experience
in writing Java code fragments. The student can practice the syntactic constructs in
each chapter without the burden of writing a complete program.

Programming Problems These exercises require the student to design solutions and
write complete Java applications.

Case Study Follow-Up Exercises Much of modern programming practice involves
reading and modifying existing code. These exercises provide the student with an
opportunity to strengthen this critical skill by answering questions about the case study
code, or making changes to it.

Supplements

Instructor’s ToolKit CD-ROM

Also available to adopters on request from the publisher is a powerful teaching tool
entitled Instructor’s ToolKit. This CD-ROM contains an electronic version of the Instruc-
tor’s Guide, a computerized test bank, PowerPoint lecture presentations, and the com-
plete programs from the text (see below).

Programs

The programs contain the source code for all of the complete Java applications and
stand-alone classes that are found within the textbook. They are available on the
Instructor’s ToolKit CD-ROM and also as a free download for instructors’ and students
from the publisher’s Web site: www.jbpub.com/disks. The programs from all of the case
studies, plus several programs that appear in the chapter bodies are included. Fragments
or snippets of code are not included nor are the solutions to the chapter-ending Pro-
gramming Problems. These application files can be viewed or edited using any standard
text editor, but in order to compile and run the applications, a Java compiler must be
used.

Student Lecture Companion: A Note-Taking Guide

Designed from the PowerPoint™ presentation developed for this text, the Student Lec-
ture Companion is an invaluable tool for learning. The notebook is designed to encour-
age students to focus their energies on listening to the lecture as they fill in additional

Preface | ix



details. The skeletal outline concept helps students organize their notes and readily rec-
ognize the important concepts in each chapter.

A Laboratory Course in Java

Written by Nell Dale, this lab manual follows the organization of the text. The lab man-
ual is designed to allow the instructor maximum flexibility and may be used in both
open and closed laboratory settings. Each chapter contains three types of activities:
Prelab, Inlab, and Postlab. Each lesson is broken into exercises that thoroughly demon-
strate the concept covered in the chapter. A disk that contains the applications, applica-
tion shells (partial applications), and data files accompanies the lab manual.

Acknowledgments

We would like to thank the many individuals who have helped us in the preparation of
this text. We are indebted to the members of the faculties of the Computer Science
Departments at the University of Texas at Austin, The University of Massachusetts at
Amherst, and the University of Wisconsin–La Crosse.

We extend special thanks to Jeff Brumfield for developing the syntax template
metalanguage and allowing us to use it in this text.

For their many helpful suggestions, we thank the lecturers, teaching assistants, con-
sultants, and student proctors who run the courses for which this book was written, and
the students themselves.

We are grateful to the following people who took the time to review the manuscript
at various stages in its development: John Connely, California Polytechnic State Univer-
sity; John Beidler, University of Scranton; Hang Lau, Concordia University; Thomas
Mertz, Millersville University; Bina Ramamurthy, State University of New York College
at Buffalo; James Roberts, Carnegie Mellon University; David Shultz, University of New
Mexico; Kenneth Slonneger, University of Iowa; Sylvia Sorkin, Community College of
Baltimore County.

We also thank Brooke Albright, Bobbie Lewis, and Mike and Sigrid Wile along with
the many people at Jones and Bartlett who contributed so much, especially J. Michael
Stranz, Jennifer Jacobson, Anne Spencer, and W. Scott Smith. Our very special thanks
go to Amy Rose, our Project Manager, who taught us a lesson in professionalism while
she was winning her gold stars.

Anyone who has ever written a book—or is related to someone who has—can appre-
ciate the amount of time involved in such a project. To our families—all the Dale clan
and the extended Dale family (too numerous to name); to Lisa, Charlie, and Abby; to
Anne, Brady, and Kari—thanks for your tremendous support and indulgence.

N. D.
C. W.
M. H.

x | Preface

TE
AM
FL
Y

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

Team-Fly® 



          

Preface v

1 Overview of Programming and Problem Solving 11.1 Overview of Programming 2
What Is Programming? 2
How Do We Write a Program? 3
Theoretical Foundations: Binary Representation of 

Data 8
1.2 How Is a Program Converted into a Form That a Computer Can Use? 9
1.3 How is Interpreting a Program Different from Executing It? 13
1.4 How Is Compilation Related to Interpretation and Execution? 14
1.5 What Kinds of Instructions Can be Written in a 

Programming Language? 16
Object-Oriented Programming Languages 18

1.6 What Is a Computer? 19
1.7 Ethics and Responsibilities in the Computing Profession 22

Software Piracy 24
Privacy of Data 24
Use of Computer Resources 25
Software Engineering 26



1.8 Problem-Solving Techniques 27
Ask Questions 27
Look for Things That Are Familiar 28
Solve by Analogy 28
Means-Ends Analysis 29
Divide and Conquer 30
The Building-Block Approach 31
Merging Solutions 31
Mental Blocks: The Fear of Starting 32
Algorithmic Problem Solving 33

Problem-Solving Case Study: A Company Payroll Program 33
Summary 40
Quick Check 41
Exam Preparation Exercises 42
Programming Warm-Up Exercises 44
Case Study Follow-Up Exercises 44

2 Java Syntax and Semantics, and the Program Entry Process 47
2.1 Syntax and Semantics 48

Theoretical Foundations: Metalanguages 49
Syntax Templates 51
Naming Program Elements: Identifiers 52
Matters of Style: Using Meaningful, Readable Identifiers 54

2.2 Data Types 54
Background Information: Data Storage 55

2.3 Classes and Objects 56
2.4 Defining Terms: Declarations 59

Matters of Style: Capitalization of Identifiers 63
2.5 Taking Action: Executable Statements 64

Beyond Minimalism: Adding Comments to a Program 70
Program Construction 71
Blocks 73

2.6 Program Entry, Correction, and Execution 75
Entering a Program 75
Compiling and Running a Program 76
Finishing Up 77

xii | Contents



Problem-Solving Case Study: Display a Date in Multiple Formats 78
Testing and Debugging 81
Summary of Classes 82
Summary 83
Quick Check 83
Exam Preparation Exercises 86
Programming Warm-Up Exercises 88
Programming Problems 90
Case Study Follow-Up Exercises 91

3 Event-Driven Output 933.1 Classes and Methods 94
Frames 94
Background Information: The Origins of Java 101

3.2 Formatting Output 103
Using GridLayout for Tabular Output 103
Alignment of Text within Labels 104

3.3 Handling Events 105
3.4 Register an Event Listener 106
3.5 Event-Handler Methods 108

Problem-Solving Case Study: Display a Date in Multiple 
Formats 112

Testing and Debugging 115
Summary of Classes 116
Summary 117
Quick Check 117
Exam Preparation Exercises 118
Programming Warm-Up Exercises 119
Programming Problems 121
Case Study Follow-Up Exercises 122

4 Numeric Types and Expressions 1234.1 Overview of Java Data Types 124
4.2 Numeric Data Types 126

Integral Types 126
Floating-Point Types 128

Contents | xiii



4.3 Declarations for Numeric Types 129
Named Constant Declarations 129
Software Engineering Tip: Using Named Constants Instead of 

Literals 130
Variable Declarations 130

4.4 Simple Arithmetic Expressions 131
Arithmetic Operators 131
Increment and Decrement Operators 135

4.5 Compound Arithmetic Expressions 136
Precedence Rules 136
Type Conversion and Type Casting 138
May We Introduce: Blaise Pascal 144

4.6 Additional Mathematical Methods 145
Matters of Style: Program Formatting 146

4.7 Additional String Operations 149
The length Method 149
The substring Method 151

4.8 Formatting Numeric Types 153
Software Engineering Tip: Understanding Before Changing 154

Problem-Solving Case Study: Map Measurements 155
Testing and Debugging 160
Summary of Classes 161
Summary 162
Quick Check 162
Exam Preparation Exercises 164
Programming Warm-Up Exercises 168
Programming Problems 171
Case Study Follow-Up Exercises 173

5 Event-Driven Input and Software Design Strategies 1755.1 Getting Data into Programs 176
5.2 Entering Data Using Fields in a Frame 177
5.3 Creating a Data Entry Field 179
5.4 Extracting a Value from a Field 180
5.5 Creating a Button 182
5.6 Creating and Registering a Button Event Listener 184

xiv | Contents



5.7 Handling a Button Event 188
5.8 Interactive Input/Output 191
5.9 Converting Strings to Numeric Values 192
5.10 Noninteractive Input/Output 195
5.11 Software Design Strategies 195
5.12 What are Objects and Classes? 196
5.13 Object-Oriented Design 200

Object-Oriented Problem Solving 201
Identifying the Classes 202
Initial Responsibilities 204
A First Scenario Walk-Through 204
Subsequent Scenarios 207
Inheritance 208
Enhancing CRC Cards with Additional Information 208

5.14 Functional Decomposition 210
Writing Modules 211
Pseudocode 212
Software Engineering Tip: Documentation 212

Problem-Solving Case Study: Averaging Rainfall Amounts 213
Background Information: Programming at Many Scales 220

Testing and Debugging 221
Summary of Classes 223
Summary 224
Quick Check 225
Exam Preparation Exercises 226
Programming Warm-Up Exercises 227
Programming Problems 228
Case Study Follow-Up Exercises 229

6 Conditions, Logical Expressions, and Selection Control 
Structures 231
6.1 Flow of Control 232

Selection 233
6.2 Conditions and Logical Expressions 234

The boolean Data Type 234
Logical Expressions 234

Contents | xv



Background Information: George Boole 242
Precedence of Operators 243
Software Engineering Tip: Changing English Statements into 

Logical Expressions 245
Relational Operators with Floating-Point Types 246

6.3 The if statement 247
The if-else Form 247
Blocks (Compound Statements) 249
Matters of Style: Braces and Blocks 251
The if Form 252

6.4 Nested if Statements 254
The Dangling else 257

6.5 Handling Multiple Button Events 258
Problem-Solving Case Study: A Simple Calculator 262
Testing and Debugging 270
Summary of Classes 277
Summary 278
Quick Check 278
Exam Preparation Exercises 279
Programming Warm-Up Exercises 283
Programming Problems 286
Case Study Follow-Up Exercises 289

7 Classes and Methods 2937.1 Encapsulation 294
Abstraction 296
Theoretical Foundations: Categories of Instance 

Responsibility 298
7.2 Class Interface Design 299

Public Interface Design 300
7.3 Internal Data Representation 302

Data Lifetime 304
Internal Representation Example 307

7.4 Class Syntax 307
7.5 Declaring Methods 308

Parameters 311

xvi | Contents



A Parameter-Passing Analogy 315
Implementing a Responsibility as a Method 316
Constructors 318

7.6 Packages 320
Package Syntax 320
Packages with Multiple Compilation Units 321

Problem-Solving Case Study: Implementing the Name Class 322
Testing and Debugging 328
Summary of Classes 332
Summary 332
Quick Check 333
Exam Preparation Exercises 334
Programming Warm-Up Exercises 336
Programming Assignments 336
Case Study Follow-Up Exercises 337

8 Inheritance, Polymorphism, and Scope 3398.1 Inheritance 340
An Analogy 340

8.2 Inheritance and the Object-Oriented Design Process 342
8.3 How to Read a Class Hierarchy 346

Overriding 350
Hiding 350
Polymorphism 350

8.4 Derived Class Syntax 351
May We Introduce: Ada Lovelace 352

8.5 Scope of Access 353
Internal Scope 354
External Scope 357

8.6 Implementing a Derived Class 360
Constructors in Derived Classes 361
Overloading and Method Signatures 361
Accessing Overridden and Hidden Methods and Fields 363

8.7 Copy Constructors 365
Problem-Solving Case Study: Extending TextField for Numeric Input 

and Output 367

Contents | xvii



Testing and Debugging 371
Summary of Classes 378
Summary 378
Quick Check 379
Exam Preparation Exercises 380
Programming Warm-Up Exercises 381
Programming Problems 383
Case Study Follow-Up Exercises 383

9 File I/O and Looping 3859.1 File Input and Output 386
Files 386
Using Files 387
Extending File I/O with PrintWriter and BufferedReader

393
Exceptions with Input and Output 398
An Example Program Using Files 400

9.2 Looping 402
The while Statement 403
Phases of Loop Execution 404
Loops Using the while Statement 405
Count-Controlled Loops 406
Event-Controlled Loops 407
Looping Subtasks 412
How to Design Loops 415
Designing the Flow of Control 415
Designing the Process within the Loop 417
The Loop Exit 418
Nested Loops 418
General Pattern 419
Designing Nested Loops 422
Theoretical Foundations: Analysis of Algorithms 424

Problem-Solving Case Study: Average Income by Gender 429
Testing and Debugging 435
Summary of Classes 439
Summary 440

xviii | Contents



Quick Check 442
Exam Preparation Exercises 443
Programming Warm-Up Exercises 446
Programming Problems 448
Case Study Follow-Up Exercises 449

10 Additional Control Structures and Exceptions 45110.1 Additional Control Structures 452
The switch Statement 452
May We Introduce: Admiral Grace Murray Hopper 457
The do Statement 458
The for Statement 460
Guidelines for Choosing a Looping Statement 463

10.2 Exception-Handling Mechanism 463
The try-catch-finally Statement 463
Generating an Exception with throw 466
Exception Classes 469

10.3 Additional Java Operators 470
Assignment Operators and Assignment Expressions 471
Increment and Decrement Operators 472
The ?: Operator 474
Operator Precedence 474

Problem-Solving Case Study: Monthly Rainfall Averages 479
Testing and Debugging 484
Summary of Classes 484
Summary 485
Quick Check 485
Exam Preparation Exercises 487
Programming Warm-Up Exercises 489
Programming Problems 490
Case Study Follow-Up Exercises 493

11 One-Dimensional Arrays 49511.1 Atomic Data Types 496
11.2 Composite Data Types 498
11.3 One-Dimensional Arrays 499

Contents | xix



Accessing Individual Components 505
Out-of-Bounds Array Indexes 507
Aggregate Array Operations 508

11.4 Examples of Declaring and Processing Arrays 510
Occupancy Rates 510
Sales Figures 512
Letter Counts 513

11.5 Arrays of Objects 514
Arrays of Strings 514
Arrays of User-Defined Objects 517

11.6 Arrays and Methods 518
11.7 Special Kinds of Array Processing 518

Partial (or Sub) Array Processing 519
Indexes with Semantic Content 519

Problem-Solving Case Study: Comparison of Two Lists 519
Problem-Solving Case Study: Grading True/False Tests 525
Testing and Debugging 534
Summary of Classes 536
Summary 537
Quick Check 537
Exam Preparation Exercises 538
Programming Warm-Up Exercises 541
Programming Problems 542
Case Study Follow-Up Exercises 544

12 Array-Based Lists 54512.1 Lists 546
12.2 List Class 548

Brainstorming the List Class 548
CRC Card 548
Refining the Responsibilities 549
Internal Data Representation 552
Responsibility Algorithms for Class List 552
Test Plan 558

12.3 Sorting the List Items 559
Responsibility Algorithms for Class ListWithSort 560

xx | Contents

TE
AM
FL
Y

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

Team-Fly® 



Class ListWithSort 561
12.4 Sorted List 563

Brainstorming Sorted List 563
Responsibility Algorithms for Class SortedList 565
Test Plan 569

12.5 The List Class Hierarchy and Abstract Classes 569
12.6 Searching 571

Sequential Search 571
Binary Search 572
Theoretical Foundations: Complexity of Searching and 

Sorting 578
12.7 Generic Lists 579

Comparable Interface 579
Polymorphism 582

Problem-Solving Case Study: Exam Attendance 583
Testing and Debugging 592
Summary of Classes 592
Summary 593
Quick Check 594
Exam Preparation Exercises 595
Programming Warm-Up Exercises 596
Programming Problems 597
Case Study Follow-Up Exercises 598

13 Multidimensional Arrays and Numeric Computation 59913.1 Two-Dimensional Arrays 600
Array Declaration and Instantiation 601
Accessing Individual Components 602
Using Initializer Lists 603

13.2 Processing Two-Dimensional Arrays 604
Sum the Rows 605
Sum the Columns 607
Initialize the Array 608
Row Processing 609
Column Processing 609
Two-Dimensional Arrays and Methods 609

Contents | xxi



13.3 Multidimensional Arrays 610
Vector Class 611

13.4 Floating-Point Numbers 612
Representation of Floating-Point Numbers 612
Arithmetic with Floating-Point Numbers 615
Implementation of Floating-Point Numbers in the Computer 616
Background Information: Practical Implications of Limited 

Precision 621
Software Engineering Tip: Choosing a Numeric Data Type 622

Problem-Solving Case Study: Matrix Manipulation 623
Testing and Debugging 633
Summary of Classes 634
Summary 635
Quick Check 636
Exam Preparation Exercises 637
Programming Warm-Up Exercises 640
Programming Problems 642
Case Study Follow-Up Exercises 645

14 Recursion 64714.1 What is Recursion? 648
Power Function Definition 648
Power Function Implementation 649

14.2 More Examples with Simple Variables 651
Calculating the Factorial Function 651
Iterative Solution 654
Recursive Solution 654
Converting Decimal Integers to Binary 654
Towers of Hanoi 658

14.3 Recursive Algorithms with Structured Variables 662
Printing the Values in an Array 662
Binary Search 664

14.4 Recursion or Iteration? 666
Testing and Debugging 666
Summary 667
Quick Check 667

xxii | Contents



Exam Preparation Exercises 668
Programming Warm-Up Exercises 669
Programming Problems 671

Appendix A Java Reserved Words 673
Appendix B Operator Precedence 674
Appendix C Primitive Data Types 675
Appendix D ASCII Subset of Unicode 676
Appendix E Decimal Format Type 678
Appendix F Program Style, Formatting, and Documentation 683
Appendix G Applets 688
Glossary 693
Answers to Selected Exercises 709
Index 745

Contents | xxiii





            

To be able to define computer program, algorithm,
and high-level programming language.

To be able to list the basic stages involved in writing
a computer program.

To be able to distinguish between machine code and
Bytecode.

To be able to describe what compilers and interpreters
are and what they do.

To be able to describe the compilation, execution, and
interpretation processes.

To be able to list the major components of a computer
and describe how they work together.

To be able to distinguish between hardware and soft-
ware.

To be able to discuss some of the basic ethical issues
confronting computing professionals.

To be able to apply an appropriate problem-solving
method for developing an algorithmic solution to a
problem.

Overview of
Programming and
Problem Solving

G
oals



2 | Chapter 1:  Overview of Programming and Problem Solving

*By permission. From Merriam-Webster’s Collegiate Dictionary, Tenth Edition © 1994 by Merriam-Webster Inc.

1.1 Overview of Programming
What a brief definition for something that has, in just
a few decades, changed the way of life in industrial-
ized societies! Computers touch all areas of our lives:
paying bills, driving cars, using the telephone, shop-
ping. In fact, it might be easier to list those areas of
our lives in which we do not use computers. You are
probably most familiar with computers through the

use of games, word processors, Web browsers, and other programs. Be forewarned: This
book is not just about using computers. This is a text to teach you how to program
them.*

What Is Programming?

Much of human behavior and thought is characterized by logical sequences of actions
applied to objects. Since infancy, you have been learning how to act, how to do things;
and you have learned to expect certain behavior from other people.

A lot of what you do every day you do automatically. Fortunately, it is not neces-
sary for you to consciously think of every step involved in a process as simple as turn-
ing a page by hand:

1. Lift hand.

2. Move hand to right side of book.

3. Grasp top-right corner of page.

4. Move hand from right to left until page is positioned so that you can read what is
on the other side.

5. Let go of page.

Think how many neurons must fire and how many muscles must respond, all in a cer-
tain order or sequence, to move your arm and hand. Yet you do it unconsciously.

Much of what you do unconsciously you once had to learn. Watch how a baby con-
centrates on putting one foot before the other while learning to walk. Then watch a
group of three-year-olds playing tag.

On a broader scale, mathematics never could have been developed without logical
sequences of steps for manipulating symbols to solve problems and prove theorems.
Mass production never would have worked without operations taking place on compo-
nent parts in a certain order. Our whole civilization is based on the order of things and
actions.

com·put·er \k� m-’pyüt-� r\  n. often attrib (1646): one
that computes; specif: a programmable electronic
device that can store, retrieve, and process data*



1.1 Overview of Programming | 3

We create order, both consciously and unconsciously, through a process called
programming. This book is concerned with
the programming of one tool in particular,
the computer.

Notice that the key word in the definition
of computer is data. Computers manipulate
data. When you write a program (a plan) for
a computer, you specify the properties of the
data and the operations that can be applied
to it. Those operations are then combined as
necessary to solve a problem. Data is infor-
mation in a form the computer can use—for
example, numbers and letters. Information is
any knowledge that can be communicated,
including abstract ideas and concepts such as
“the Earth is round.”

Data comes in many different forms: let-
ters, words, integer numbers, real numbers,
dates, times, coordinates on a map, and so
on. Virtually any kind of information can be
represented as data, or as a combination of
data and operations on it. Each kind of data
in the computer is said to have a specific data type. For example, if we say that two
data items are of type int (a name that Java uses for integer numbers), we know how
they are represented in memory and that we can apply arithmetic operations to them.

Just as a concert program lists the pieces to be performed and the order in which
the players perform them, a computer program lists the types of data that are to be used
and the sequence of steps the computer performs on them. From now on, when we use
the words programming and program, we mean computer programming and computer
program.

The computer allows us to do tasks more efficiently, quickly, and accurately than
we could by hand—if we could do them by hand at all. In order for this powerful
machine to be a useful tool, it must be programmed. That is, we must specify what we
want done and how. We do this through programming.

How Do We Write a Program?

A computer is not intelligent. It cannot analyze a problem and come up with a solution.
A human (the programmer) must analyze the problem, develop the instructions for solv-
ing the problem, and then have the computer carry out the instructions. What’s the
advantage of using a computer if it can’t solve problems? Once we have written a solu-
tion for the computer, the computer can repeat the solution very quickly and consis-
tently, again and again. The computer frees people from repetitive and boring tasks.

To write a program for a computer to follow, we must go through a two-phase
process: problem solving and implementation (see Figure 1.1).

Programming Planning or scheduling the perform-
ance of a task or an event.

Electronic Computer A programmable device that
can store, retrieve, and process data.

Data Information in a form a computer can use.

Information Any knowledge that can be communi-
cated.

Data type The specification of how information is
represented in the computer as data and the set of
operations that can be applied to it.

Computer programming The process of specifying
the data types and the operations for a computer to
apply to data in order to solve a problem.

Computer program Data type specifications and
instructions for carrying out operations that are used
by a computer to solve a problem.



4 | Chapter 1:  Overview of Programming and Problem Solving

PROBLEM-SOLVING PHASE IMPLEMENTATION PHASE

Analysis
and

specification

General solution
(algorithm)

Concrete solution
(program)

Test

Maintenance phase

Verify

Figure 1.1 Programming process

Problem-Solving Phase

1. Analysis and Specification. Understand (define) the problem and what the solution
must do.

2. General Solution (Algorithm). Specify the required data types and the logical
sequences of steps that solve the problem.

3. Verify. Follow the steps exactly to see if the solution really does solve the problem.

Implementation Phase

1. Concrete Solution (Program). Translate the algorithm (the general solution) into a
programming language.

2. Test. Have the computer follow the instructions. Then manually check the results. If
you find errors, analyze the program and the algorithm to determine the source of
the errors, and then make corrections.

Once a program has been written, it enters a third phase: maintenance.

Maintenance Phase

1. Use. Use the program.

2. Maintain. Modify the program to meet changing requirements or to correct any
errors that show up in using it.

The programmer begins the programming process
by analyzing the problem, breaking it into manage-
able pieces, and developing a general solution for
each piece called an algorithm. The solutions to the
pieces are collected together to form a program that

Algorithm Instructions for solving a problem or sub-
problem in a finite amount of time using a finite
amount of data.



1.1 Overview of Programming | 5

1. Insert the key.
2. Make sure the transmission is in Park (or Neutral).
3. Depress the gas pedal.
4. Turn the key to the start position.
5. If the engine starts within six seconds, release the key to the ignition position.
6. If the engine doesn’t start in six seconds, release the key and gas pedal, wait ten seconds, and repeat Steps 3

through 6, but not more than five times.
7. If the car doesn’t start, call the garage.

solves the original problem. Understanding and analyzing a problem take up much more
time than Figure 1.1 implies. They are the heart of the programming process.

If our definitions of a computer program and an algorithm look similar, it is
because a program is simply an algorithm that has been written for a computer.

An algorithm is a verbal or written description of a logical sequence of actions
applied to objects. We use algorithms every day. Recipes, instructions, and directions are
all examples of algorithms that are not programs.

When you start your car, you follow a step-by-step procedure. The algorithm might
look something like this:

Without the phrase “but not more than five times” in Step 6, you could be trying to
start the car forever. Why? Because if something is wrong with the car, repeating Steps
3 through 6 over and over will not start it. This kind of never-ending situation is called
an infinite loop. If we leave the phrase “but not more than five times” out of Step 6, the
procedure doesn’t fit our definition of an algorithm. An algorithm must terminate in a
finite amount of time for all possible conditions.

Suppose a programmer needs an algorithm to determine an employee’s weekly
wages. The algorithm reflects what would be done by hand:

1. Look up the employee’s pay rate.
2. Determine the hours worked during the week.
3. If the number of hours worked is less than or equal to 40, multiply the hours by the pay rate to calculate regular

wages.
4. If the number of hours worked is greater than 40, multiply 40 by the pay rate to calculate regular wages, and then

multiply the difference between the hours worked and 40 by 11� 2 times the pay rate to calculate overtime wages.
5. Add the regular wages to the overtime wages (if any) to determine total wages for the week.



The steps the computer follows are often the same steps you would use to do the calcu-
lations by hand.

After developing a general solution, the programmer tests the algorithm, “walking
through” each step mentally or manually with paper and pencil. If the algorithm doesn’t
work, the programmer repeats the problem-solving process, analyzing the problem
again and coming up with another algorithm. Often the second algorithm is just a vari-
ation of the first. When the programmer is satisfied with the algorithm, he or she trans-

lates it into a programming language. We use the Java
programming language in this book.

A programming language is a simplified form of
English (with math symbols) that adheres to a strict
set of grammatical rules. English is far too compli-
cated and ambiguous for today’s computers to follow.

Programming languages, because they limit vocabulary and grammar, are much
simpler.

Although a programming language is simple in form, it is not always easy to use.
Try giving someone directions to the nearest airport using a limited vocabulary of no
more than 25 words, and you begin to see the problem. Programming forces you to
write very simple, exact instructions.

Translating an algorithm into a programming language is called coding the algo-
rithm. The products of the translation—the code for all the algorithms in the problem—
are tested by collecting them into a program and running (executing) the program on
the computer. If the program fails to produce the desired results, the programmer must
debug it—that is, determine what is wrong and then modify the program, or even one or
more of the algorithms, to fix it. The combination of coding and testing the algorithms

is called implementation.
Code is the product of translating an algorithm

into a programming language. The term code can refer
to a complete program or to any portion of a program.

There is no single way to implement an algorithm.
For example, an algorithm can be translated into more

than one programming language. Each translation produces a different implementation
(see Figure 1.2a). Even when two people translate an algorithm into the same program-
ming language, they are likely to come up with different implementations (see Figure
1.2b). Why? Because every programming language allows the programmer some flexi-
bility in how an algorithm is translated. Given this flexibility, people adopt their own
styles in writing programs, just as they do in writing short stories or essays. Once you
have some programming experience, you develop a style of your own. Throughout this
book, we offer tips on good programming style.

Some people try to speed up the programming process by going directly from the
problem definition to coding the program (see Figure 1.3). A shortcut here is very
tempting and at first seems to save a lot of time. However, for many reasons that
become obvious to you as you read this book, this kind of shortcut actually takes more
time and effort. Developing a general solution before you write a program helps you
manage the problem, keep your thoughts straight, and avoid mistakes. If you don’t take
the time at the beginning to think out and polish your algorithm, you spend a lot of

6 | Chapter 1:  Overview of Programming and Problem Solving

Code Data type specifications and instructions for a
computer that are written in a programming language.

Programming language A set of rules, symbols, and
special words used to construct a computer program.

TE
AM
FL
Y

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

Team-Fly® 



1.1 Overview of Programming | 7

Algorithm Nell's C++ Code

Nell's Java Code

Nell's Ada Code

a. Algorithm translated into different languages

Algorithm Chip's Java Code

Nell's Java Code

Mark's Java Code

b. Algorithm translated by different people

Figure 1.2 Differences in implementation

Problem

Shortcut?

PROBLEM-SOLVING PHASE

Algorithm

IMPLEMENTATION PHASE

Code

Figure 1.3 Programming shortcut?



extra time debugging and revising your program. So think first and code later! The
sooner you start coding, the longer it takes to write a program that works.

Once a program has been put into use, it is often necessary to modify it. Modifica-
tion may involve fixing an error that is discovered during the use of the program or
changing the program in response to changes in the user’s requirements. Each time the
program is modified, it is necessary to repeat the problem-solving and implementation
phases for those aspects of the program that change. This phase of the programming
process is known as maintenance and actually accounts for the majority of the effort
expended on most programs. For example, a program that is implemented in a few
months may need to be maintained over a period of many years. Thus it is a cost-effec-
tive investment of time to carefully develop the initial problem solution and program
implementation. Together, the problem-solving, implementation, and maintenance
phases constitute the program’s life cycle.

In addition to solving the problem, implementing
the algorithm, and maintaining the program, writing
documentation is an important part of the program-
ming process. Documentation includes written expla-
nations of the problem being solved and the
organization of the solution, comments embedded
within the program itself, and user manuals that

describe how to use the program. Many different people are likely to work on a program
over a long period of time. Each of those people must be able to read and understand
the code.

Documentation The written text and comments that
make a program easier for others to understand, use,
and modify

t

8 | Chapter 1:  Overview of Programming and Problem Solving

Theoretical Foundations
Binary Representation of Data

In a computer, data is represented electronically by pulses of electricity. Electric circuits, in
their simplest form, are either on or off. Usually, a circuit that is on represents the number 1; a
circuit that is off represents the number 0. Any kind of data can be represented by combina-
tions of enough 1s and 0s. We simply have to choose which combination represents each
piece of data we are using. For example, we could arbitrarily choose the pattern 1101000110
to represent the name Java.

Data represented by 1s and 0s is in binary form. The binary (base–2) number system uses
only 1s and 0s to represent numbers. (The decimal [base–10] number system uses the digits 0
through 9.) The word bit (short for binary digit) often is used to refer to a single 1 or 0. So the
pattern 1101000110 has 10 bits. A binary number with 10 bits can represent 210 (1,024) dif-
ferent patterns. A byte is a group of eight bits; it can represent 28 (256) patterns. Inside the
computer, each character (such as the letter A, the letter g, or a question mark) is usually 

continued



represented by a byte.1 Groups of 16, 32, and 64 bits are generally referred to as words (although the
terms short word and long word are sometimes used to refer to 16-bit and 64-bit groups, respec-
tively).

The process of assigning bit patterns to pieces of data is called coding—the same name we give to
the process of translating an algorithm into a programming language. The names are the same
because the only language that the first computers recognized was binary in form. Thus, in the early
days of computers, programming meant translating both data and algorithms into patterns of 1s and
0s.

Binary coding schemes are still used inside the computer to represent both the instructions that it
follows and the data that it uses. For example, 16 bits can represent the decimal integers from 0 to
21621 (65,535). More complicated coding schemes are necessary to represent negative numbers, real
numbers, and numbers in scientific notation. Characters also can be represented by bit combinations.
In one coding scheme, 01001101 represents M and 01101101 represents m. 

The patterns of bits that represent data vary from one family of computers to another. Even on the
same computer, different programming languages can use different binary representations for the
same data. A single programming language may even use the same pattern of bits to represent dif-
ferent things in different contexts. (People do this too. The four letters that form the word tack have
different meanings depending on whether you are talking about upholstery, sailing, sewing, paint, or
horseback riding.) The point is that patterns of bits by themselves are meaningless. It is the way in
which the patterns are used that gives them their meaning.

Fortunately, we no longer have to work with binary coding schemes. Today the process of coding
is usually just a matter of writing down the data in letters, numbers, and symbols. The computer
automatically converts these letters, numbers, and symbols into binary form. Still, as you work with
computers, you continually run into numbers that are related to powers of 2—numbers like 256,
32,768, and 65,536—reminders that the binary number system is lurking somewhere nearby.

1Most programming languages use the American Standard Code for Information Interchange (ASCII) to represent the English
alphabet and other symbols. ASCII characters are stored in a single byte. Java recognizes both ASCII and a newer standard
called Unicode, which includes the alphabets of many other human languages. A single Unicode character takes up two bytes
in the computer’s memory.

Binary Representation of Data

1.2 How Is a Program Converted into a Form That a ComputerCan Use?1
In the computer, all data, whatever its form, is stored and used in binary codes, strings
of 1s and 0s. Instructions and data are stored together in the computer’s memory using
these binary codes. If you were to look at the binary codes representing instructions and

1.2 How Is a Program Converted into a Form That a Computer Can Use? | 9



data in memory, you could not tell the difference between them; they are distinguished
only by the manner in which the computer uses them. It is thus possible for the com-
puter to process its own instructions as a form of data.

When computers were first developed, the only
programming language available was the primitive
instruction set built into each machine, the machine
language, or machine code.

Even though most computers perform the same
kinds of operations, their designers choose different

sets of binary codes for each instruction. So the machine code for one family of com-
puters is not the same as for another.

When programmers used machine language for
programming, they had to enter the binary codes for
the various instructions, a tedious process that was
prone to error. Moreover, their programs were difficult
to read and modify. In time, assembly languages were
developed to make the programmer’s job easier.

Instructions in an assembly language are in an
easy-to-remember form called a mnemonic (pro-

nounced “ni-'män-ik”). Typical instructions for addition and subtraction might look
like this:

Assembly Language Machine Language

ADD 100101
SUB 010011

Although assembly language is easier for humans to work with, the computer can-
not directly execute the instructions. Because a computer can process its own instruc-
tions as a form of data, it is possible to write a program to translate assembly language

instructions into machine code. Such a program is
called an assembler.

Assembly language is a step in the right direc-
tion, but it still forces programmers to think in terms
of individual machine instructions. Eventually, com-
puter scientists developed high-level programming
languages. These languages are easier to use than
assembly languages or machine code because they are

closer to English and other natural languages (see Figure 1.4).
A program called a compiler translates algorithms written in certain high-level lan-

guages (Java, C++, Pascal, and Ada, for example) into machine language. If you write a
program in a high-level language, you can run it on any computer that has the appro-
priate compiler. This is possible because most high-level languages are standardized,
which means that an official description of the language exists.

Machine language The language, made up of binary-
coded instructions, that is used directly by the com-
puter

Assembly language A low-level programming lan-
guage in which a mnemonic is used to represent each
of the machine language instructions for a particular
computer

10 | Chapter 1:  Overview of Programming and Problem Solving

Assembler A program that translates an assembly
language program into machine code

Compiler A program that translates a program writ-
ten in a high-level language into machine code



Machine code
(computer)

High-level language
(C++, FORTRAN, Java, etc.)

Natural language
(English, French, German, etc.)

Human thought

Figure 1.4 Levels of abstraction

The text of an algorithm written in a
high-level language is called source code. To
the compiler, source code is just input data. It
translates the source code into a machine lan-
guage form called object code (see Figure
1.5).

A benefit of standardized high-level lan-
guages is that they allow you to write

1.2 How Is a Program Converted into a Form That a Computer Can Use? | 11

Source code Data type specifications and instruc-
tions written in a high-level programming language

Object code A machine language version of a source
code



Windows PC
C++ compiler

Windows PC
machine 
language

Windows PC
computer

UNIX 
workstation

C++ compiler
C++ Code

UNIX 
workstation

machine 
language

UNIX 
workstation
computer

Macintosh
C++ compiler

Macintosh
machine 
language

Macintosh
computer

COMPUTER
EXECUTES
TRANSLATOR
CODE
(COMPILER)

SOURCE CODE
(C++)

OBJECT
CODE
(MACHINE
LANGUAGE
VERSION OF
SOURCE CODE)

COMPUTER
EXECUTES
OBJECT
CODE

Figure 1.5 High-level programming languages allow programs to be compiled on different systems.

portable (or machine-independent) code. As Figure 1.5 emphasizes, a single C++ pro-
gram can be run on different machines, whereas a program written in assembly lan-
guage or machine language is not portable from one computer to another. Because each
computer family has its own machine language, a machine language program written
for computer A may not run on computer B.

Java takes a somewhat different approach than
we have described in order to achieve greater portabil-
ity. Java programs are translated into a standard
machine language called Bytecode.

However, there are no computers that actually
use Bytecode as their machine language. In order for

a computer to run Bytecode programs, it must have another program called the Java
Virtual Machine (JVM) that serves as a language interpreter for the program. Just as an
interpreter of human languages listens to words spoken in one language and speaks a
translation of them in a language that another person understands, the JVM reads the
Bytecode machine language instructions and translates them into machine language
operations that the particular computer executes. Interpretation is done as the program
is running, one instruction at a time. It is not the same as compilation, which is a sepa-

12 | Chapter 1:  Overview of Programming and Problem Solving

Bytecode A standard machine language into which
Java source code is compiled



rate step that translates all of the instructions in a program prior to execution. Figure
1.6 shows how the Java translation process achieves greater portability.

As Figure 1.6 illustrates, the compiled Java code can be run on any computer that
has the JVM program to interpret for it, which means that the Java program does not
have to be compiled for each different type of computer. This level of portability has
grown in importance as computers across the globe are connected by the World Wide
Web (sometimes simply called the Web). A programmer can write a Java program and
make its Bytecode available to the public via the Web without having to compile it for
all of the different types of computers that may be used to run it.

1.3 How Is Interpreting a Program Different from Executing It?
There is a significant distinction between
direct execution and interpretation of a pro-
gram. A computer can directly execute a pro-
gram that is compiled into machine language.
The JVM is one such machine language pro-
gram that is directly executed. The computer
cannot directly execute Bytecode. It must exe-
cute the JVM to interpret each Bytecode
instruction in order to run the compiled Java
program. The JVM does not produce machine code, like a compiler, but instead it reads
each Bytecode instruction and gives the computer a corresponding series of operations
to perform. Because each Bytecode instruction must first be interpreted, the computer
cannot run Bytecode programs as quickly as it can execute machine language. Slower
execution is the price we pay for increased portability.

1.3 How Is Interpreting a Program Different from Executing It? | 13

Java Program Java Compiler Java Bytecode UNIX Workstation
Running JVM

Windows PC
Running JVM

Macintosh
Running JVM

Figure 1.6 Java compiler produces Bytecode that can be run on any machine with the JVM.

Direct execution The process by which a computer
performs the actions specified in a machine language
program

Interpretation The translation, while a program is
running, of non–machine language instructions (such
as Bytecode) into executable operations



14 | Chapter 1:  Overview of Programming and Problem Solving

COMPILATION 5
EXECUTION 5

Source
code

Results
Input
data

Computer
executes
compiler

code

Computer executes
machine language

version of
source code

Code listing,
possibly with

error messages.

Machine language
version of

source code
(object code)

Loading

Figure 1.7 Compilation/Execution

1.4 How Is Compilation Related to Interpretation and Execution?
It is important to understand that compilation and execution are two distinct processes.
During compilation, the computer runs the compiler program. During execution, the
object program is loaded into the computer’s memory unit, replacing the compiler pro-
gram. The computer then directly executes the object program, doing whatever the pro-
gram instructs it to do (see Figure 1.7).

We can use the JVM as an example of the process shown in Figure 1.7. The JVM is
written in a high-level programming language such as C++ and then compiled into
machine language. The machine language is loaded into the computer’s memory, and
the JVM is executed. Its input is a Java program that has been compiled into Bytecode.
Its results are the series of actions that would take place if the computer could directly
execute Bytecode. Figure 1.8 illustrates this process.

In looking at Figure 1.8, it is important to understand that the output from the
compilers can be saved for future use. Once the JVM and the Java program have been
compiled, they can be used over and over without being compiled again. You never
need to compile the JVM because that has already been done for you. We have shown



1.4 How Is Compilation Related to Interpretation and Execution? | 15

Source code
in Java

Computer executes
Java compiler code

Bytecode version of
Java code

Computer executes
C++ compiler code

Machine language
version of JVM

JVM source
code in C++

Computer executes
machine language
version of JVM to
interpret Bytecode

Computer appears
to execute

Bytecode version
of Java code

Loading

Compilation

Execution

Figure 1.8 Compilation and execution of JVM combined with compilation and interpretation of Bytecode

its compilation in Figure 1.8 simply to illustrate the difference between the traditional
compile-execute steps and the compile-interpret steps that are used with Java.

Viewed from a different perspective, the JVM makes the computer look like a differ-
ent computer that has Bytecode as its machine language. The computer itself hasn’t
changed—it is still the same collection of electronic circuits—but the JVM makes it
appear that it has become a different machine. When a program is used to make one
computer act like another computer, we call it
a virtual machine. For convenience we may
refer to the computer as “executing a Java
program,” but keep in mind this is just short-
hand for saying that “the computer is execut-
ing the JVM running a Java program.”

Virtual machine A program that makes one computer
act like another



16 | Chapter 1:  Overview of Programming and Problem Solving

1.5 What Kinds of Instructions Can be Written in aProgramming Language?
The instructions in a programming language reflect the operations a computer can per-
form:

• A computer can transfer data from one place to another.
• A computer can get data from an input device (a keyboard or mouse, for exam-

ple) and write data to an output device (a screen, for example).
• A computer can store data into and retrieve data from its memory and secondary

storage (parts of a computer that we discuss in the next section).
• A computer can compare data values for equality or inequality and make deci-

sions based on the result.
• A computer can perform arithmetic operations (addition and subtraction, for

example) very quickly.
• A computer can branch to a different section of the instructions.

Programming languages require that we use certain control structures to express
algorithms as a source code. There are four basic ways of structuring statements
(instructions) in most programming languages: by sequence, selection, loop, and with
subprograms. Java adds a fifth way: asynchronously (see Figure 1.9). A sequence is a
series of statements that are executed one after another. Selection, the conditional con-
trol structure, executes different statements depending on certain conditions. The repeti-
tive control structure, the loop, repeats statements while certain conditions are met. The
subprogram allows us to structure our code by breaking it into smaller units. Asynchro-
nous control lets us write code that handles events that originate outside of our pro-
gram, such as the user clicking a button on the screen with their mouse. Each of these
ways of structuring statements controls the order in which the computer executes the
statements, which is why they are called control structures.

Assume you’re driving a car. Going down a straight stretch of road is like following
a sequence of instructions. When you come to a fork in the road, you must decide which
way to go and then take one or the other branch of the fork. This is what the computer
does when it encounters a selection control structure (sometimes called a branch or deci-
sion) in a program. Sometimes you have to go around the block several times to find a
place to park. The computer does the same sort of thing when it encounters a loop in a
program.

A subprogram is a named sequence of instructions written separately from the main
program. When the program executes an instruction that refers to the name of the sub-
program, the code for the subprogram is executed. When the subprogram has finished
executing, execution of the program resumes at the next instruction. Suppose, for
example, that every day you go to work at an office. The directions for getting from
home to work form a procedure called “Go to the office.” It makes sense, then, for
someone to give you directions to a meeting by saying, “Go to the office, then go four

TE
AM
FL
Y

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

Team-Fly® 



1.5 What Kinds of Instructions Can be Written in a Programming Language? | 17

SEQUENCE

SELECTION	      (also called branch or decision)

IF condition THEN statement1 ELSE statement2

LOOP      (also called repetition or iteration)

WHILE condition DO statement1

SUBPROGRAM           (also called procedure, function, method, or subroutine)

Statement1

Statement1

SUBPROGRAM1

SUBPROGRAM1

Statement2

Statement Statement Statement

Condition

Condition

True

True

False

False

a meaningful collection
of any of the above

EVENT
EVENTHANDLER

a subprogram executed
when an event occurs

Home

Office

P I Z Z A



PIZZA

PizzaPizza PizzaPizza

Figure 1.9 Basic control structures of programming languages



18 | Chapter 1:  Overview of Programming and Problem Solving

2Java actually allows us to write more general asynchronous programs using a construct called a thread.
Threaded programs are beyond the scope of this text. We restrict our use of asynchronous structures to han-
dling events.

blocks west”—without listing all the steps you have to take to get to the office. Subpro-
grams allow us to write parts of our programs separately and then assemble them into
final form. They can greatly simplify the task of writing large programs.

Responding to asynchronous events is like working as a pizza delivery person. You
wait around the dispatch station with all of the other delivery people. The dispatcher
calls your name and gives you some pizzas and a delivery address. You go deliver the
pizzas and return to the dispatch station. At the same time, other delivery people may
be out driving.2 The term asynchronous means “not at the same time.” In this context it
refers to the fact that the user can, for example, click the mouse on the screen at any
time while the program is running. The mouse click does not have to happen at some
particular time corresponding to certain instructions within the program. The event
shown in Figure 1.9 is like the dispatcher. You do not have to write it as part of your
program because it is included in Java. You simply write the event-handler sub-
programs that the event calls.

Object-Oriented Programming Languages

Early programming languages focused their attention on the operations and control
structures of programming. These procedural languages paid little explicit attention to
the relationships between the operations and the data. At that time, a typical computer
program used only simple data types such as integer and real numbers, which have
obvious sets of operations defined by mathematics. Those operations were built directly
into early programming languages. As people gained experience with the programming
process, they began to realize that in solving complex problems, it is helpful to define
new types of data, such as dates and times; these aren’t a standard part of a program-
ming language. Each new type of data typically has an associated set of operations,
such as determining the number of days between two dates.

Procedural languages thus evolved to include the feature of extensibility: the capa-
bility to define new data types. However, they still treated the data and operations as
separate parts of the program. A programmer could define a data type to represent the
time of day and then write a subprogram to compute the number of minutes between
two times, but could not explicitly indicate that the two are related.

Modern programming languages such as Java allow us to collect a data type and its
associated operations into a single entity called an
object. They are thus called object-oriented program-
ming languages. The advantage of an object is that it
makes the relationships between the data type and
operations explicit. The result is that an object is a
complete, self-contained unit that can be reused again

Object A collection of data values and associated
operations



1.6 What Is a Computer? | 19

in other programs. Reusability enables us to write a significant portion of our programs
using existing objects, thereby saving us a considerable amount of time and effort.

A class is a description of one or more
like objects. Classes are usually collected into
groups called packages. When we need an
object in a program, we instantiate the class
that describes the object. That is, we tell the
Java compiler to provide us with one or more
of the objects described by a specified class.
One characteristic of an object-oriented pro-
gramming language is having a large library
of classes. In this text we present only a small subset of the classes that are available
from the Java library. It is easy to be overwhelmed by the sheer size of Java’s library,
but many of those objects are highly specialized and unnecessary for learning the
essential concepts of programming.

In the next few chapters we consider how to write simple codes that instantiate just
a few of the classes in Java’s library. By Chapter 7 we develop enough of the basic con-
cepts of programming to start designing our own classes. Leading up to that point, we
learn how to write some specific classes using patterns of Java code that we provide.

1.6 What Is a Computer?
You can learn a programming language, how to write programs, and how to run (exe-
cute) these programs without knowing much about computers. But if you know some-
thing about the parts of a computer, you can better understand the effect of each
instruction in a programming language.

Most computers have six basic components: the memory unit, the arithmetic/logic
unit, the control unit, input devices, output devices, and auxiliary storage devices. Fig-
ure 1.10 is a stylized diagram of the basic
components of a computer.

The memory unit is an ordered sequence
of storage cells, each capable of holding a
piece of data. Each memory cell has a distinct
address to which we refer in order to store
data into it or retrieve data from it. These storage cells are called memory cells, or mem-
ory locations.3 The memory unit holds data (input data or the product of computation)
and instructions (programs), as shown in Figure 1.11.

Class A description of an object that specifies the
types of data values that it can hold and the operations
that it can perform

Instantiate To create an object based on the descrip-
tion supplied by a class

Memory unit Internal data storage in a computer

3The memory unit is also referred to as RAM, an acronym for random-access memory (because we can access
any location at random).



MEMORY

Your data

Your program

Figure 1.11 Memory

Output
device

Auxiliary
storage
device

Central processing unit

Control unit

Arithmetic/logic unit

Memory unit

Input
device

Figure 1.10 Basic components of a computer

The part of the computer that follows instruc-
tions is called the central processing unit (CPU). The
CPU usually has two components. The arithmetic/
logic unit (ALU) performs arithmetic operations
(addition, subtraction, multiplication, and division)
and logical operations (comparing two values). The
control unit controls the actions of the other compo-
nents so that program instructions are executed in
the correct order.

20 | Chapter 1:  Overview of Programming and Problem Solving

Central processing unit (CPU) The part of the com-
puter that executes the instructions (program) stored
in memory; made up of the arithmetic/logic unit and
the control unit

Arithmetic/Logic unit (ALU) The component of the
central processing unit that performs arithmetic and
logical operations

Control unit The component of the central process-
ing unit that controls the actions of the other compo-
nents so that instructions (the program) are executed
in the correct sequence



For us to use computers, we must have
some way of getting data into and out of
them. Input/Output (I/O) devices accept data
to be processed (input) and present data that
have been processed (output). A keyboard is a
common input device. Another is a mouse, a
“pointing” device. A video display is a common output device, as are printers and liquid
crystal display (LCD) screens.

For the most part, computers simply move and combine data in memory. The many
types of computers differ primarily in the size of their memories, the speed with which
data can be recalled, the efficiency with which data can be moved or combined, and
limitations on I/O devices.

When a program is executing, the computer proceeds through a series of steps, the
fetch-execute cycle:

1. The control unit retrieves (fetches) the next coded instruction from memory.

2. The instruction is translated into control signals.

3. The control signals tell the appropriate unit (arithmetic/logic unit, memory, I/O
device) to perform (execute) the instruction.

4. The sequence repeats from Step 1.

Computers can have a wide variety of
peripheral devices. An auxiliary storage
device, or secondary storage device, holds
coded data for the computer until we actually
want to use the data. Instead of inputting data
every time, we can input it once and have the
computer store it onto an auxiliary storage
device. Whenever we need to use the data, we
tell the computer to transfer the data from the auxiliary storage device to its memory.
An auxiliary storage device therefore serves as both an input and an output device.
Typical auxiliary storage devices are disk drives and magnetic tape drives. A disk drive
is a cross between a compact disk player and a tape recorder. It uses a thin disk made
out of magnetic material. A read/write head (similar to the record/playback head in a
tape recorder) travels across the spinning disk, retrieving or recording data. A CD-ROM
or a DVD-ROM drive uses a laser to read information stored optically on a plastic disk.
The CD-R and DVD-RAM forms of the CD and DVD can be used to both read and write
data. A magnetic tape drive is like a tape recorder and is most often used to back up
(make a copy of) the data on a disk in case
the disk is ever damaged.

Together, all of these physical compo-
nents are known as hardware. The programs
that allow the hardware to operate are called
software. Hardware usually is fixed in design;

1.6 What Is a Computer? | 21

Input/Output (I/O) devices The parts of the com-
puter that accept data to be processed (input) and
present the results of that processing (output)

Peripheral device An input, output, or auxiliary stor-
age device attached to a computer

Auxiliary storage device A device that stores data in
encoded form outside the computer’s main memory

Hardware The physical components of a computer

Software Computer programs; the set of all programs
available on a computer



software is easily changed. In fact, the ease with which software can be manipulated is
what makes the computer such a versatile, powerful tool.

In addition to the programs that we write or pur-
chase, there are programs in the computer that are
designed to simplify the user/computer interface,
making it easier for us to use the machine. The inter-
face between user and computer is a set of I/O
devices—for example, the keyboard, mouse, and a
screen—that allows the user to communicate with the
computer. We work with the keyboard, mouse, and

screen on our side of the interface boundary; wires attached to the keyboard and the
screen carry the electronic pulses that the computer works with on its side of the
interface boundary. At the boundary itself is a mechanism that translates information
for the two sides.

When we communicate directly with the computer
through an interface, we are using an interactive sys-
tem. Interactive systems allow direct entry of pro-
grams and data and provide immediate feedback to
the user. In contrast, batch systems require that all

data be entered before a program is run and provide feedback only after a program has
been executed. In this text we focus on interactive systems, although in Chapter 9 we
discuss file-oriented programs, which share certain similarities with batch systems.

The set of programs that simplifies the user/com-
puter interface and improves the efficiency of process-
ing is called system software. It includes the JVM and
the Java compiler as well as the operating system and
the editor (see Figure 1.12). The operating system
manages all of the computer’s resources. It can input
programs, call the compiler, execute object programs,

and carry out any other system commands. The editor is an interactive program used to
create and modify source programs or data.

1.7 Ethics and Responsibilities in the Computing Profession
Every profession operates with a set of ethics that help to define the responsibilities of
people who practice the profession. For example, medical professionals have an ethical
responsibility to keep information about their patients confidential. Engineers have an
ethical responsibility to their employers to protect proprietary information, but they also
have a responsibility to protect the public and the environment from harm that may
result from their work. Writers are ethically bound not to plagiarize the work of others,
and so on.

Operating system A set of programs that manages all
of the computer’s resources

Editor An interactive program used to create and
modify source programs or data

22 | Chapter 1:  Overview of Programming and Problem Solving

Interface A connecting link at a shared boundary
that allows independent systems to meet and act on or
communicate with each other

Interactive system A system that allows direct com-
munication between user and computer



INPUT

Program

Program entry
Data entry

COMPUTER

System software: operating system,
compiler, editor

Reports, lists

OUTPUT

Figure 1.12 User/Computer interface

The computer presents us with a vast new range of capabilities that can affect peo-
ple and the environment in dramatic ways. It thus challenges society with many new
ethical issues. Some of our existing ethical practices apply to the computer, whereas
other situations require new ethical rules. In some cases, there may not be established
guidelines, but it is up to you to decide what is ethical. In this section we examine some
common situations encountered in the computing profession that raise particular ethical
issues.

A professional in the computing industry, like any other professional, has knowl-
edge that enables him or her to do certain things that others cannot do. Knowing how
to access computers, how to program them, and how to manipulate data gives the com-
puter professional the ability to create new products, solve important problems, and

1.7 Ethics and Responsibilities in the Computing Profession | 23



help people to manage their interactions with the ever-more-complex world that we all
live in. Knowledge of computers can be a powerful means to effecting positive change.

Knowledge also can be used in unethical ways. A computer can be programmed to
trigger a terrorist’s bomb, to sabotage a competitor’s production line, or to steal money.
Although these blatant examples make an extreme point and are unethical in any con-
text, there are more subtle examples that are unique to computers.

Software Piracy

For example, computer software is easy to copy. But just like books, software is usually
copyrighted—it is illegal to copy software without the permission of its creator. Such

copying is called software piracy.
Copyright laws exist to protect the creators of

software (and books and art) so that they can make a
profit from the effort and money spent developing the
software. A major software package can cost millions

of dollars to develop, and this cost (along with the cost of producing the package, ship-
ping it, supporting customers, and allowing for retailer markup) is reflected in the pur-
chase price. If people make unauthorized copies of the software, then the company loses
those sales and either has to raise its prices to compensate or spend less money to
develop improved versions of the software—in either case, a desirable piece of software
becomes harder to obtain.

Software pirates sometimes rationalize their software theft with the excuse that
they’re just making one copy for their own use. It’s not that they’re selling a bunch of
bootleg copies, after all. But if thousands of people do the same, then it adds up to mil-
lions of dollars in lost revenue for the company, which leads to higher prices for every-
one.

Computing professionals have an ethical obligation to not engage in software
piracy and to try to stop it from occurring. You never should copy software without
permission. If someone asks you for a copy of a piece of software, you should refuse to
supply it. If someone says they just want to “borrow” the software so they can “try it
out,” tell them they are welcome to try it out on your machine (or at a retailer’s shop)
but not to make a copy.

This rule isn’t restricted to duplicating copyrighted software; it includes plagiarism
of all or part of code that belongs to anyone else. If someone gives you permission to
copy some of their code, then, just like any responsible writer, you should acknowledge
that person with a citation in the code.

Privacy of Data

The computer enables the compilation of databases containing useful information about
people, companies, geographic regions, and so on. These databases allow employers to
issue payroll checks, banks to cash a customer’s check at any branch, the government to
collect taxes, and mass merchandisers to send out junk mail. Even though we may not
care for every use of databases, they generally have positive benefits. However, they
also can be used in negative ways.

24 | Chapter 1:  Overview of Programming and Problem Solving

Software piracy The unauthorized copying of soft-
ware for either personal use or use by others



For example, a car thief who gains access to the state motor vehicle registry could
print out a “shopping list” of valuable car models together with their owners’ addresses.
An industrial spy might steal customer data from a company database and sell it to a
competitor. Although these are obviously illegal acts, computer professionals face other
situations that are not so obvious.

Suppose your job includes managing the company payroll database. In that data-
base are the names and salaries of the employees in the company. You might be
tempted to poke around in the database and see how your salary compares to your
associates—this act is unethical and an invasion of your associates’ right to privacy. This
information is confidential. Any information about a person that is not clearly public
should be considered confidential. An example of public information is a phone number
listed in a telephone directory. Private information includes any data that has been pro-
vided with an understanding that it will be used only for a specific purpose (such as the
data on a credit card application).

A computing professional has a responsibility to avoid taking advantage of special
access that he or she may have to confidential data. The professional also has a respon-
sibility to guard that data from unauthorized access. Guarding data can involve such
simple things as shredding old printouts, keeping backup copies in a locked cabinet, not
using passwords that are easy to guess (such as a name or word), and more complex
measures such as encryption (keeping it stored in a secret coded form).

Use of Computer Resources

If you’ve ever bought a computer, you know that it costs money. A personal computer
can be relatively inexpensive, but it is still a major purchase. Larger computers can cost
millions of dollars. Operating a PC may cost a few dollars a month for electricity and an
occasional outlay for paper, disks, and repairs. Larger computers can cost tens of thou-
sands of dollars per month to operate. Regardless of the type of computer, whoever
owns it has to pay these costs. They do so because the computer is a resource that justi-
fies its expense.

The computer is an unusual resource because it is valuable only when a program is
running. Thus, the computer’s time is really the valuable resource. There is no signifi-
cant physical difference between a computer that is working and one that is sitting idle.
By contrast, a car is in motion when it is being used. Thus, unauthorized use of a com-
puter is different from unauthorized use of a car. If one person uses another’s car with-
out permission, that individual must take possession of it physically—that is, steal it. If
someone uses a computer without permission, the computer isn’t physically stolen, but
just as in the case of car theft, the owner is being deprived of a resource that he or she
is paying for.

For some people, theft of computer resources is a game—like joyriding in a car. The
thief really doesn’t want the resources; it is just the challenge of breaking through a
computer’s security system and seeing how far he or she can get without being caught.
Success gives a thrilling boost to this sort of person’s ego. Many computer thieves think
that their actions are acceptable if they don’t do any harm, but whenever real work is
displaced from the computer by such activities, then harm is clearly being done. If noth-

1.7 Ethics and Responsibilities in the Computing Profession | 25



ing else, the thief is trespassing in the computer owner’s property. By analogy, consider
that even though no physical harm may be done by someone who breaks into your bed-
room and takes a nap while you are away, such an action is certainly disturbing to you
because it poses a threat of potential physical harm. In this case, and in the case of
breaking into a computer, mental harm can be done.

Other thieves can be malicious. Like a joyrider who purposely crashes a stolen car,
these people destroy or corrupt data to cause harm. They may feel a sense of power
from being able to hurt others with impunity. Sometimes these people leave behind pro-
grams that act as time bombs, to cause harm long after they have gone. Another kind of

program that may be left is a virus—a program that
replicates itself, often with the goal of spreading to
other computers. Viruses can be benign, causing no
other harm than to use up some resources. Others can
be destructive and cause widespread damage to data.
Incidents have occurred in which viruses have cost
billions of dollars in lost computer time and data.

Computing professionals have an ethical responsibility never to use computer
resources without permission. This includes activities such as doing personal work on an
employer’s computer. We also have a responsibility to help guard resources to which we
have access—by using unguessable passwords and keeping them secret, by watching for
signs of unusual computer use, by writing programs that do not provide loopholes in a
computer’s security system, and so on.

Software Engineering

Humans have come to depend greatly on computers in many aspects of their lives. That
reliance is fostered by the perception that computers function reliably; that is, they work
correctly most of the time. However, the reliability of a computer depends on the care
that is taken in writing its software.

Errors in a program can have serious consequences. Here are a few examples of real
incidents involving software errors. An error in the control software of the F–18 jet
fighter caused it to flip upside down the first time it flew across the equator. A rocket
launch went out of control and had to be blown up because there was a comma typed in
place of a period in its control software. A radiation therapy machine killed several
patients because a software error caused the machine to operate at full power when the
operator typed certain commands too quickly.

Even when the software is used in less critical situations, errors can have significant
effects. Examples of such errors include

• an error in your word processor that causes your term paper to be lost just hours
before it is due.

• an error in a statistical program that causes a scientist to draw a wrong conclu-
sion and publish a paper that must later be retracted.

• an error in a tax preparation program that produces an incorrect return, leading
to a fine.

26 | Chapter 1:  Overview of Programming and Problem Solving

Virus Code that replicates itself, often with the goal
of spreading to other computers without authorization,
and possibly with the intent of doing harm

TE
AM
FL
Y

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

Team-Fly® 



Programmers thus have a responsibility
to develop software that is free from errors.
The process that is used to develop correct
software is known as software engineering.

Software engineering has many aspects.
The software life cycle described at the begin-
ning of this chapter outlines the stages in the development of software. Different tech-
niques are used at each of these stages. We address many of the techniques in this text.
In Chapter 5 we introduce methodologies for developing correct algorithms. We discuss
strategies for testing and validating programs in every chapter. We use a modern pro-
gramming language that enables us to write readable, well-organized programs, and so
on. Some aspects of software engineering, such as the development of a formal, mathe-
matical specification for a program, are beyond the scope of this text.

1.8 Problem-Solving Techniques
You solve problems every day, often unaware of the process you are going through. In a
learning environment, you usually are given most of the information you need: a clear
statement of the problem, the necessary input, and the required output. In real life, the
process is not always so simple. You often have to define the problem yourself and then
decide what information you have to work with and what the results should be.

After you understand and analyze a problem, you must come up with a solution—an
algorithm. Earlier we defined an algorithm as a step-by-step procedure for solving a
problem in a finite amount of time with a finite amount of data. Although you work
with algorithms all the time, most of your experience with them is in the context of fol-
lowing them. You follow a recipe, play a game, assemble a toy, or take medicine. In the
problem-solving phase of computer programming, you will be designing algorithms, not
following them. This means you must be conscious of the strategies you use to solve
problems in order to apply them to programming problems.

Ask Questions

If you are given a task orally, you ask questions—When? Why? Where?—until you
understand exactly what you have to do. If your instructions are written, you might put
question marks in the margin, underline a word or a sentence, or in some other way
indicate that the task is not clear. Your questions may be answered by a later paragraph,
or you might have to discuss them with the person who gave you the task.

These are some of the questions you might ask in the context of programming:

• What do I have to work with—that is, what is my data?
• What do the data items look like?
• What are the operations to be performed on the data?
• How much data is there?

1.8 Problem-Solving Techniques | 27

Software engineering The application of traditional
engineering methodologies and techniques to the
development of software



LIST OF TEMPERATURES

HIGHEST = 95
LOWEST = 18

LIST OF TEST SCORES

HIGHEST = 98
LOWEST = 12

Use the same
method to
find these
values in

both cases.

42�
18
27
95
55
72�
33�
78�
86�
61�
58�
91

27�
14�
55�
98�
72�
66�
45�
12�
39�
70�
68

Figure 1.13 Look for things that are familiar.

• How will I know when I have processed all the data?
• What should my output look like?
• How many times is the process going to be repeated?
• What special error conditions might come up?

Look for Things That Are Familiar

Never reinvent the wheel. If a solution exists, use it. If you’ve solved the same or a simi-
lar problem before, just repeat your solution. People are good at recognizing similar sit-
uations. We don’t have to learn how to go to the store to buy milk, then to buy eggs,
and then to buy candy. We know that going to the store is always the same; only what
we buy is different.

In programming, certain problems occur again and again in different guises. A
good programmer immediately recognizes a subtask he or she has solved before and
plugs in the solution. For example, finding the daily high and low temperatures is really
the same problem as finding the highest and lowest grades on a test. You want the
largest and smallest values in a set of numbers (see Figure 1.13).

In Chapter 8, we see how this problem-solving strategy can be implemented in Java
using a mechanism called inheritance, which allows us to define a new object that adds
to the capabilities of an existing object.

Solve by Analogy

Often a problem reminds you of one you have seen before. You may find solving the
problem at hand easier if you remember how you solved the other problem. In other

28 | Chapter 1:  Overview of Programming and Problem Solving



1.8 Problem-Solving Techniques | 29

A library catalog system can give insight into how to organize a parts inventory.

CATALOG INVENTORY

Figure 1.14 Analogy

words, draw an analogy between the two problems. For example, a solution to a per-
spective projection problem from an art class might help you figure out how to compute
the distance to a landmark when you are on a cross-country hike. As you work your
way through the new problem, you come across things that are different than they were
in the old problem, but usually these are just details that you can deal with one at a
time.

Analogy is really just a broader application of the strategy of looking for things
that are familiar. When you are trying to find an algorithm for solving a problem, don’t
limit yourself to computer-oriented solutions. Step back and try to get a larger view of
the problem. Don’t worry if your analogy doesn’t match perfectly—the only reason for
starting with an analogy is that it gives you a place to start (see Figure 1.14). The best
programmers are people who have broad experience solving all kinds of problems.

Means-Ends Analysis

Often the beginning state and the ending state are given; the problem is to define a set
of actions that can be used to get from one to the other. Suppose you want to go from
Boston, Massachusetts to Austin, Texas. You know the beginning state (you are in
Boston) and the ending state (you want to be in Austin). The problem is how to get from
one to the other.

In this example, you have lots of choices. You can fly, walk, hitchhike, ride a bike,
or whatever. The method you choose depends on your circumstances. If you’re in a
hurry, you’ll probably decide to fly.

Once you’ve narrowed down the set of actions, you have to work out the details. It
may help to establish intermediate goals that are easier to meet than the overall goal.
Let’s say there is a really cheap, direct flight to Austin out of Newark, New Jersey. You
might decide to divide the trip into legs: Boston to Newark and then Newark to Austin.
Your intermediate goal is to get from Boston to Newark. Now you only have to examine
the means of meeting that intermediate goal (see Figure 1.15).

The overall strategy of means-ends analysis is to define the ends and then to ana-
lyze your means of getting between them. The process translates easily to computer pro-
gramming. You begin by writing down what the input is and what the output should be.



Start: Boston
Goal: Austin

Start: Boston
Goal: Austin

Solution: Take commuter flight to Newark and then catch cheap flight to Austin

Start: Boston
Intermediate Goal: Newark
Goal: Austin

Means: Fly, walk, hitchhike, bike,
    drive, sail, bus

Revised Means: Fly to Chicago and then Austin;
    fly to Newark and then Austin: fly to Atlanta and
    then Austin

Means to Intermediate Goal: Commuter flight, walk,
    hitchhike, bike, drive, sail, bus

Figure 1.15 Means-ends analysis

Hard problem

Easy
subproblem

Easy
subproblem

Easy
subsubproblem

Easy
subsubproblem

Hard
subproblem

Figure 1.16 Divide and conquer

Then you consider the actions a computer can perform and choose a sequence of
actions that can transform the input into the results.

Divide and Conquer

We often break up large problems into smaller units that are easier to handle. Cleaning
the whole house may seem overwhelming; cleaning the rooms one at a time seems
much more manageable. The same principle applies to programming. We break up a
large problem into smaller pieces that we can solve individually (see Figure 1.16). In
fact, the object-oriented design and functional decomposition methodologies, which we
describe in Chapter 5, are both based on the principle of divide and conquer.

30 | Chapter 1:  Overview of Programming and Problem Solving



EXISTING
SOFTWARE

NEW PROGRAM

Inventory System

EXISTING
SOFTWARE

Shipping
System

Parts
shipped

New code to mortar blocks together

Parts on
order

Accounts
Payable
System

Receiving
System

Parts
received

Parts sold,
not shipped

Accounts
Receivable

System

Figure 1.17 Building-block approach

The Building-Block Approach

Another way of attacking a large problem is to see if any solutions for smaller pieces of
the problem exist. It may be possible to put some of these solutions together end to end
to solve most of the big problem. This strategy is just a combination of the look-for-
familiar-things and divide-and-conquer approaches. You look at the big problem and
see that it can be divided into smaller problems for which solutions already exist. Solv-
ing the big problem is just a matter of putting the existing solutions together, like mor-
taring together blocks to form a wall (see Figure 1.17).

With an object-oriented programming language, we often solve a problem by first
looking in the class library to see what solutions have been developed previously and
then writing a small amount of additional code to put the pieces together. As we see
later, this problem-solving technique is the basis for the methodology called object-
based design.

Merging Solutions

Another way to combine existing solutions is to merge them on a step-by-step basis.
For example, to compute the average of a list of values, we must both sum and count
the values. If we already have separate solutions for summing values and for counting
the number of values, we can combine them. But if we first do the summing and then
do the counting, we have to read the list twice. We can save steps if we merge these two
solutions: read a value and then add it to the running total and add 1 to our count
before going on to the next value. Whenever the solutions to subproblems duplicate
steps, think about merging them instead of joining them end to end.

1.8 Problem-Solving Techniques | 31



32 | Chapter 1:  Overview of Programming and Problem Solving

Figure 1.18 Mental block

Mental Blocks: The Fear of Starting

Writers are all too familiar with the experience of staring at a blank page, not knowing
where to begin. Programmers have the same difficulty when they first tackle a big prob-
lem. They look at the problem and it seems overwhelming (see Figure 1.18).

Remember that you always have a place to begin solving any problem: Write it
down on paper in your own words so that you understand it. Once you paraphrase the
problem, you can focus on each of the subparts individually instead of trying to tackle
the entire problem at once. This process gives you a clearer picture of the overall prob-
lem. It helps you see pieces of the problem that look familiar or that are analogous to
other problems you have solved. And it pinpoints areas where something is unclear,
where you need more information.

As you write down a problem, you tend to group things together into small, under-
standable chunks of data and operations, which may be natural places to split the prob-
lem up—to divide and conquer. Your description of the problem may collect all of the
information about data and results into one place for easy reference. Then you can see
the beginning and ending states necessary for means-ends analysis.

Most mental blocks are caused by not really understanding the problem. Rewriting
the problem in your own words is a good way to focus on the subparts of the problem,
one at a time, and to understand what is required for a solution.

The Far Side cartoon
by Gary Larson is
reprinted by permis-
sion of Chronicle
Features, San Fran-
cisco, CA. All rights
reserved.



Problem-Solving Case Study | 33

Algorithmic Problem Solving

Coming up with an algorithm for solving a particular problem is not always cut-and-
dried. In fact, it is usually a trial-and-error process requiring several attempts and
refinements. We test each attempt to see if it really solves the problem. If it does, fine. If
it doesn’t, we try again. We typically use a combination of the techniques we’ve
described to solve any nontrivial problem.

Remember that the computer can only do certain things (see p. 16). Your primary
concern, then, is how to make the computer transform, manipulate, calculate, or process
the input data to produce the desired output. If you keep in mind the allowable instruc-
tions and data types in your programming language, you won’t design an algorithm
that is difficult or impossible to code.

In the case study that follows, we develop a program for calculating employees’
weekly wages. It typifies the thought processes involved in writing an algorithm and
coding it as a program, and it shows you what a complete Java program looks like.

Problem-Solving Case Study
A Company Payroll Program

Problem A company needs an program to figure its weekly payroll. The input data, consisting
of each employee’s identification number, pay rate, and hours worked, is on the file
datafile.dat in secondary storage. The program should input the data for each employee,
calculate the weekly wages, save the input information for each employee along with the
weekly wages on a file, and display the total wages for the week on the screen, so that the
payroll clerk can transfer the appropriate amount into the payroll account.

Discussion At first glance, this seems like a simple problem. But if you think about how you
would do it by hand, you see that you need to ask questions about the specifics of the process:
What is the employee data that we need and how is the data written on the file? How are
wages computed? In what file should the results be stored? How does the program know that
all of the employees have been processed? How should the total be displayed?

• The data for each employee includes an employee identification number, the
employee’s hourly pay rate, and the hours worked. Each data value is written on a sep-
arate line.

• Wages equal the employee’s pay rate times the number of hours worked up to 40
hours. If an employee worked more than 40 hours, wages equal the employee’s pay rate
times 40 hours, plus 11� 2 times the employee’s regular pay rate times the number of
hours worked above 40.

• The results should be stored in a file called payfile.dat.
• The program knows to finish the processing when there is no more data on the input

file.
• The total should be shown in a window on the screen that can be closed by the user.



34 | Chapter 1:  Overview of Programming and Problem Solving

We begin by looking for things that are familiar. An experienced Java programmer immedi-
ately recognizes that this problem contains many different objects that are represented as
classes in the Java library. The input file and the output file are objects, as is the window in
which the total payroll is displayed on the screen. Closing the window is an event represented
by another class in the library. The employee identification number, pay rate, hours worked,
wages earned, and total wages are objects in the problem that we must find a way to repre-
sent in our algorithm. Here’s a list of the objects we’ve identified:

• Input file, datafile.dat, represented by one of the Java file classes
• Output file, payfile.dat, represented by another Java file class
• Display window, represented by a Java Frame class
• Window closing event, represented by a Java Event class
• Employee identification number
• Pay rate
• Hours worked
• Wages
• Total wages

Now that we know the objects we are working with, we need to fit them together with
operations that enable them to exchange information. The operations coordinate the behavior
of the objects in a way that solves the problem, like the choreography that coordinates ballet
dancers to move around a stage, interacting with each other.

Let’s apply the divide-and-conquer approach to identify the main operations in which our
objects must participate. It’s clear that there are two main steps to be accomplished. One is to
process the input file, and the other is to display the total on the screen. Let’s look at each of
those steps separately, once again applying divide-and-conquer.

First we consider the processing of the data on the input file. Each data set represents one
employee, and we process each employee’s data in turn. There are three obvious steps in
almost any problem of this type. For each person, we must

1. Get the data
2. Compute the results
3. Output the results

Our first step is to get the data. (By get, we mean read or input the data.) We need three
pieces of data for each employee: employee identification number, hourly pay rate, and num-
ber of hours worked. Each data value is written on the input file. Therefore, to input the data,
we take these steps:

Read the employee number.
Read the pay rate.
Read the number of hours worked.

The next step is to compute the wages. Let’s expand this step with means-ends analysis.
Our starting point is the set of data values that was input; our desired ending, the payroll for
the week. The means at our disposal are the basic operations that the computer can perform,
which include calculation and control structures. Let’s begin by working backward from the
end.



Problem-Solving Case Study | 35

We know that there are two formulas for computing wages: one for regular hours and
one for overtime. If there is no overtime, wages are simply the pay rate times the number of
hours worked. If the number of hours worked is greater than 40, however, wages are 40 times
the pay rate, plus the number of overtime hours times 11� 2 times the pay rate. The overtime
hours are computed by subtracting 40 from the total number of hours worked. Here are the
two formulas:

We now have the means to compute wages for each person. Our intermediate goal is then
to execute the correct formula given the input data. We must decide which formula to use and
employ a branching control structure to make the computer execute the appropriate formula.
The decision that controls the branching structure is simply whether more than 40 hours have
been worked. We now have the means to get from our starting point to the desired end. To fig-
ure the wages, then, we take the following steps:

The last step, outputting the results, is simply a matter of directing the computer to write
the employee number, the pay rate, the number of hours worked, and the wages onto pay-
file.dat:

We now have an algorithm that processes the data for one employee. We need to extend this
algorithm to handle all of the employees. Let’s use the building-block approach to enclose our
three main steps (getting the data, computing the wages, and outputting the results) within a

Write the employee number, pay rate, hours worked, and wages onto payfile.dat

If hours worked is greater than 40.0, then
wages = (40.0 3 pay rate) + (hours worked 2 40.0) 3 1.5 3 pay rate

otherwise
wages = hours worked 3 pay rate

wages = hours worked 3 pay rate
wages = (40.0 3 pay rate) + (hours worked 2 40.0) 3 1.5 3 pay rate



36 | Chapter 1:  Overview of Programming and Problem Solving

looping structure that continues until each employee has been processed. Once we have computed
the wages for one employee, we need to add them to a running total so that we can display it at
the end of processing. Our algorithm now coordinates the behavior of the objects to accomplish
the first of our two major steps.

The second major step is to display the total wages. We again used divide-and-conquer
to break this into a series of steps:

Finally, we must take care of housekeeping chores. Before we start processing, we must
prepare the input file for reading, prepare the output file to receive the results, and set the
running total to zero.

What follows is the complete algorithm. Calculating the wages is written as a separate
subalgorithm that is defined below the main algorithm. Notice that the algorithm is simply a
very precise description of the same steps you would follow to do this process by hand.  

Main Algorithm
Prepare to read a list of employee information (open file object datafile.dat)
Prepare to write a list of the employees’ wages (open file object payfile.dat)
Set the total payroll to zero
while there is more data on file dataFile

Read employee number
Read the pay rate
Read the number of hours worked
Calculate pay
Add the employee’s wages to the total payroll
Write the employee number, pay rate, hours worked, and wages onto the list (file
payFile)

Prepare an empty window (a Frame class object)
Write the total into the window
Show the window on the screen
Respond to the window-closing event by removing the window and stopping the program

Prepare an empty window
Write the total into the window
Show the window on the screen
Respond to the window-closing event by removing the window and stopping the program

TE
AM
FL
Y

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

Team-Fly® 



Problem-Solving Case Study | 37

Before we implement this algorithm, we should test it by hand, simulating the algorithm
with specific data values. Case Study Follow-Up Exercise 2 asks you to carry out this test.

What follows is the Java program for this algorithm. It’s here to give you an idea of what
you’ll be learning. If you’ve had no previous exposure to programming, you probably won’t
understand most of the program. Don’t worry; you will soon. In fact, throughout this book as
we introduce new constructs, we refer you back to the Payroll program. One more thing:
The remarks following the symbols // are called comments. They are here to help you under-
stand the program; the compiler ignores them. Words enclosed by the symbols /* and */ also
are comments and are ignored by the compiler.

import java.awt.*;
import java.awt.event.*;
import java.io.*;

public class Payroll 
{
private static Frame outputDisplay;          // Declare a Frame for total

static double calcPay(double payRate,        // Employee’s pay rate
double hours)           // Hours worked

// CalcPay computes wages from the employee’s pay rate
// and the hours worked, taking overtime into account

{
final double MAX_HOURS = 40.0;             // Maximum normal work hours
final double OVERTIME = 1.5;               // Overtime pay rate factor
if (hours > MAX_HOURS)                    // Is there overtime?
return (MAX_HOURS * payRate) +          // Yes

(hours - MAX_HOURS) * payRate * OVERTIME;

Subalgorithm for Calculating Pay

 

if number of hours worked is greater than 40.0, then
wages = (40.0 3 pay rate) + (hours worked 2 40.0) 3 1.5 3 pay rate

else
wages = hours worked 3 pay rate



38 | Chapter 1:  Overview of Programming and Problem Solving

else
return hours * payRate;                   // No

}

public static void main(String args[]) 
throws IOException, NumberFormatException

// Main is where execution starts. It opens dataFile and payFile, and 
//   processes the data file. After that, it shows the total in a Frame on 
//   the screen and exits when the user closes the window
{
String empNum;                           // Employee ID Number
double payRate;                         // Employee’s pay rate
double hours;                          // Hours worked
double wages;                           // Wages earned
double total = 0.0;                      // Total company payroll
BufferedReader dataFile;                // Declare dataFile for input
PrintWriter payFile;                     // Declare payFile for printing
// Open company payroll files
dataFile = new BufferedReader(new FileReader("datafile.dat"));
payFile = new PrintWriter(new FileWriter("payfile.dat"));
// Process the input on dataFile, outputting results on payFile
empNum = dataFile.readLine();            // Read employee ID number
while (empNum != null)
{
payRate = Double.valueOf(dataFile.readLine()).doubleValue(); 

// Read payRate
hours = Double.valueOf(dataFile.readLine()).doubleValue();   

// Read hours
wages = CalcPay(payRate, hours);     // Compute wages
total = total + wages;                 // Add wages to total
// Put results into payFile
payFile.println(empNum + " " + payRate + " " + hours + " " + 

wages);
empNum = dataFile.readLine();          // Get next ID number

}

dataFile.close();                        // Close input file
payFile.close();                        // Close output file

// Create a Frame and display it on the screen
outputDisplay = new Frame();             // Instantiate a Frame object
// Specify layout manager for frame
outputDisplay.setLayout(new FlowLayout());



Problem-Solving Case Study | 39

outputDisplay.add(new Label("Total payroll for the week is $" + total));
outputDisplay.add(new Label("Close window to exit program."));
outputDisplay.pack();                    // Pack the frame
outputDisplay.show();                   // Show the frame on the screen
// Event handler for window closing
outputDisplay.addWindowListener(new WindowAdapter() 
// Create a WindowAdapter
{
// Method to handle event
public void windowClosing(WindowEvent event)
{
outputDisplay.dispose();           // Remove frame from the screen
System.exit(0);                    // Quit the program

}
});

}
}

Given the following input on file datafile.dat:

534923445
6.54
45
103428439
12.82
38
131909545
8.20
52
739219803
10.00
40

The program outputs the following on file payfile.dat:

534923445 6.54 45.0 310.65000000000003
103428439 12.82 38.0 487.16
131909545 8.2 52.0 475.6
739219803 10.0 40.0 400.0



40 | Chapter 1:  Overview of Programming and Problem Solving

And then it displays the following window:

For such a simple task, the length of this program is rather daunting. Don’t worry. A large part
of this program involves preparation for inputting and outputting data. These steps become
second nature to you very shortly, and you can use the same algorithmic steps again and again
(the building-block approach).

Summary
We think nothing of turning on the television and sitting down to watch it. It’s a com-
munication tool we use to enhance our lives. Computers are becoming as common as
televisions, just a normal part of our lives. And like televisions, computers are based on
complex principles but are designed for easy use.

Computers are dumb; they must be told what to do. A true computer error is
extremely rare (usually due to a component malfunction or an electrical fault). Because
we tell the computer what to do, most errors in computer-generated output are really
human errors.

Computer programming is the process of planning a sequence of steps for a computer
to apply to data. It involves a problem-solving phase and an implementation phase.
After analyzing a problem, we develop and test a general solution (algorithm). This gen-
eral solution becomes a concrete solution—our program—when we write it in a high-
level programming language. The sequence of instructions that makes up our program is
then either compiled into machine code (the language the computer uses) or Bytecode
(the language the Java Virtual Machine or JVM uses). After correcting any errors or
“bugs” that show up during testing, our program is ready to use.

Once we begin to use the program, it enters the maintenance phase. Maintenance
involves correcting any errors discovered while the program is being used and changing
the program to reflect changes in the user’s requirements.

Data and instructions are represented as binary numbers (numbers consisting of just
1s and 0s) in electronic computers. The process of converting data and instructions into
a form usable by the computer is called coding.

A programming language reflects the range of operations a computer can perform. In
this text, you will learn to write programs in the high-level programming language
called Java. The basic control structures in the Java programming language—sequence,
selection, loop, subprogram, and asynchronous—are based on the fundamental opera-



Quick Check | 41

tions of the computer. Java provides the ability to collect data and operations into self-
contained units called objects that can be reused in other programs.

Computers are composed of six basic parts: the memory unit, the arithmetic/logic
unit, the control unit, input drivers, output devices, and auxiliary storage devices. The
arithmetic/logic unit and control unit together are called the central processing unit. The
physical parts of the computer are called hardware. The programs that are executed by
the computer are called software.

System software is a set of programs designed to simplify the user/computer inter-
face. It includes the compiler, the operating system, the JVM, and the editor.

Computing professionals are guided by a set of ethics, as are members of other pro-
fessions. Among the responsibilities that we have are: copying software only with per-
mission and including attribution to other programmers when we make use of their
code, guarding the privacy of confidential data, using computer resources only with
permission, and carefully engineering our programs so that they work correctly.

We’ve said that problem solving is an integral part of the programming process.
Although you may have little experience programming computers, you have lots of
experience solving problems. The key is to stop and think about the strategies that you
use to solve problems, and then use those strategies to devise workable algorithms.
Among those strategies are asking questions, looking for things that are familiar, solv-
ing by analogy, applying means-ends analysis, dividing the problem into subproblems,
using existing solutions to small problems to solve a larger problem, merging solutions,
and paraphrasing the problem in order to overcome a mental block.

The computer is widely used today in science, engineering, business, government,
medicine, production of consumer goods, and the arts. Learning to program in Java can
help you use this powerful tool effectively.

Quick Check
The Quick Check is intended to help you decide if you’ve met the goals set forth at the
beginning of each chapter. If you understand the material in the chapter, the answer to
each question should be fairly obvious. After reading a question, check your response
against the answers listed at the end of the Quick Check. If you don’t know an answer
or don’t understand the answer that’s provided, turn to the page(s) listed at the end of
the question to review the material.

1. What is a computer program? (p. 3)
2. What are the three phases in a program’s life cycle? (p. 4)
3. Is an algorithm the same as a program? (p. 4–5)
4. What is a programming language? (p. 6)
5. What are the advantages of using a high-level programming language? 

(pp. 10–11)
6. What does a compiler do? (p. 10)
7. What is the difference between machine code and Bytecode? (pp. 12–13)
8. What part does the Java Virtual Machine play in the compilation and interpreta-

tion process? (pp. 12–13)
9. Name the five basic ways of structuring statements in Java. (pp. 16–18)



42 | Chapter 1:  Overview of Programming and Problem Solving

10. What are the six basic components of a computer? (pp. 19–21)
11. What is the difference between hardware and software? (pp. 21–22)
12. In what regard is theft of computer time like stealing a car? How are the two

crimes different? (pp. 25–26)
13. What is the divide-and-conquer approach? (p. 30)

Answers

1. A computer program is a sequence of instructions performed by a computer. 2. The three
phases of a program’s life cycle are problem solving, implementation, and maintenance. 3. No.
All programs are algorithms, but not all algorithms are programs. 4. A set of rules, symbols,
and special words used to construct a program. 5. A high-level programming language is easier
to use than an assembly language or a machine language, and programs written in a high-level
language can be run on many different computers. 6. The compiler translates a program written
in a high-level language into machine language or Bytecode. 7. Machine code is the native
binary language that is directly executed by any particular computer. Bytecode is a standard
portable machine language that is executed by the Java Virtual Machine, but it is not directly
executed by the computer. 8. It translates the Bytecode instructions into operations that are
executed by the computer. 9. Sequence, selection, loop, subprogram, and asynchronous. 10.
The basic components of a computer are the memory unit, arithmetic/logic unit, control unit,
input and output devices, and auxiliary storage devices. 11. Hardware is the physical compo-
nents of the computer; software is the collection of programs that run on the computer. 12. Both
crimes deprive the owner of access to a resource. A physical object is taken in a car theft, whereas
time is the thing being stolen from the computer owner. 13. The divide-and-conquer approach
is a problem-solving technique that breaks a large problem into smaller, simpler subproblems.

Exam Preparation Exercises
1. Explain why the following series of steps is not an algorithm, then rewrite the

series so it is.

Shampooing

1. Rinse.
2. Lather.
3. Repeat.

2. Describe the input and output files used by a compiler.
3. In the following recipe for chocolate pound cake, identify the steps that are

branches (selection) and loops, and the steps that are references to subalgorithms
outside the algorithm.



Exam Preparation Exercises | 43

4. Put a check next to each item below that is a peripheral device.
______ a. Disk drive
______ b. Arithmetic/logic unit
______ c. Magnetic tape drive
______ d. Printer
______ e. CD-ROM drive
______ f. Memory
______ g. Auxiliary storage device
______ h. Control unit
______ i. LCD display
______ j. Mouse

Preheat the oven to 350 degrees
Line the bottom of a 9-inch tube pan with wax paper
Sift 2 3� 4 c flour, 3� 4 t cream of tartar, 1� 2 t baking soda, 1 1� 2 t salt, and 1 3� 4 c sugar into a large bowl
Add 1 c shortening to the bowl
If using butter, margarine, or lard, then

add 2/3 c milk to the bowl,
else

(for other shortenings) add 1 c minus 2 T of milk to the bowl
Add 1 t vanilla to the mixture in the bowl
If mixing with a spoon, then

see the instructions in the introduction to the chapter on cakes,
else

(for electric mixers) beat the contents of the bowl for 2 minutes at medium speed, scraping the
bowl and beaters as needed

Add 3 eggs plus 1 extra egg yolk to the bowl
Melt 3 squares of unsweetened chocolate and add to the mixture in the bowl
Beat the mixture for 1 minute at medium speed
Pour the batter into the tube pan
Put the pan into the oven and bake for 1 hour and 10 minutes
Perform the test for doneness described in the introduction to the chapter on cakes
Repeat the test once each minute until the cake is done
Remove the pan from the oven and allow the cake to cool for 2 hours
Follow the instructions for removing the cake from the pan, given in the introduction to the chapter

on cakes
Sprinkle powdered sugar over the cracks on top of the cake just before serving



44 | Chapter 1:  Overview of Programming and Problem Solving

5. Next to each item below, indicate whether it is hardware (H) or software (S).
______ a. Disk drive
______ b. Memory
______ c. Compiler
______ d. Arithmetic/logic unit
______ e. Editor
______ f. Operating system
______ g. Object program
______ h. Java Virtual Machine
______ i. Central processing unit

6. Means-ends analysis is a problem-solving strategy.
a. What are three things you must know in order to apply means-ends analysis

to a problem?
b. What is one way of combining this technique with the divide-and-conquer

strategy?
7. Show how you would use the divide-and-conquer approach to solve the problem

of finding a job.
8. Distinguish between information and data.

Programming Warm-Up Exercises
1. Write an algorithm for driving from where you live to the nearest airport that

has regularly scheduled flights. Restrict yourself to a vocabulary of 47 words
plus numbers and place names. You must select the appropriate set of words for
this task. An example of a vocabulary is given in Appendix A, the list of
reserved words (words with special meaning) in the Java programming language.
Notice that there are just 47 words in that list. The purpose of this exercise is to
give you practice writing simple, exact instructions with an equally small vocab-
ulary.

2. Write an algorithm for making a peanut butter and jelly sandwich, using a
vocabulary of just 47 words (you choose the words). Assume that all ingredients
are in the refrigerator and that the necessary tools are in a drawer under the
kitchen counter. The instructions must be very simple and exact because the per-
son making the sandwich has no knowledge of food preparation and takes every
word literally.

3. In Exercise 1 above, identify the sequential, conditional, repetitive, and subpro-
gram steps.

Case Study Follow-Up Exercises
1. Using Figure 1.16 as a guide, construct a divide-and-conquer diagram of the

Problem-Solving Case Study, A Company Payroll Program.
2. Use the following data set to test the payroll algorithm presented on page 36.

Follow each step of the algorithm just as it is written, as if you were a computer.
Then check your results by hand to be sure that the algorithm is correct.



Case Study Follow-Up Exercises | 45

ID Number Pay Rate Hours Worked

327 8.30 48
201 6.60 40
29 12.50 40

166 9.25 51
254 7.00 32

3. In the Company Payroll case study, we used means-ends analysis to develop the
subalgorithm for calculating pay. What are the ends in the analysis? That is,
what information did we start with and what information did we want to end up
with?

4. In the Payroll program, certain remarks are preceded by the symbols //. What
are these remarks called, and what does the compiler do with them? What is
their purpose?



TE
AM
FL
Y

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

Team-Fly® 



                

To be able to describe the composition of a Java pro-
gram.

To be able to read syntax templates in order to
understand the formal rules governing Java pro-
grams.

To be able to create and recognize legal Java identi-
fiers.

To be able to declare named constants and variables of
type char and class String.

To be able to distinguish reserved words in Java from
user-defined identifiers.

To be able to assign values to variables and objects.

To be able to construct simple string expressions made
up of constants, variables, and the concatenation
operator.

To be able to construct a code segment that displays a
message on the screen.

To be able to determine what is displayed by a given
code segment.

To be able to use comments to clarify your programs.

To be able to construct simple Java application programs.

To learn the steps involved in entering and running a
program.

Java Syntax and
Semantics, and the
Program Entry Process

G
oals



48 | Chapter 2:  Java Syntax and Semantics, and the Program Entry Process

Programmers develop solutions to problems using a programming language. In this
chapter, we start looking at the rules and symbols that make up the Java programming
language. We also review the steps required to create a program and make it work on a
computer.

2.1 Syntax and Symantics
A programming language is a set of rules, symbols, and special words used to construct
a program. There are rules for both syntax (grammar) and semantics (meaning).

Syntax is a formal set of rules that defines
exactly what combinations of letters, numbers, and
symbols can be used in a programming language.
There is no room for ambiguity in the syntax of a
programming language because the computer can’t
think; it doesn’t “know what we mean.” To avoid
ambiguity, syntax rules themselves must be written in
a very simple, very precise, formal language called a
metalanguage.

Learning to read a metalanguage is like learning
to read the rules of a sport. Once you understand the

notation, you can read the rule book. It’s true that many people learn a sport simply by
watching others play, but what they learn is usually just enough to allow them to take
part in casual games. You could learn Java by following the examples in this book, but
a serious programmer, like a serious athlete, must take the time to read and understand
the rules.

Syntax rules are the blueprints we use to “build” instructions in a program. They
allow us to take the elements of a programming language—the basic building blocks of
the language—and assemble them into constructs, syntactically correct structures. If our
program violates any of the rules of the language—by misspelling a crucial word or
leaving out an important comma, for instance—the program is said to have syntax errors
and cannot compile correctly until we fix them.

Syntax The formal rules governing how valid instruc-
tions are written in a programming language

Semantics The set of rules that determines the
meaning of instructions written in a programming lan-
guage

Metalanguage A language that is used to describe
the syntax rules for another language



2.1 Syntax and Symantics | 49

Theoretical Foundations
Metalanguages

Metalanguage is the word language with the prefix meta, which means “beyond” or “more
comprehensive.” A metalanguage is a language that goes beyond a normal language by allow-
ing us to speak precisely about that language. It is a language for talking about languages. It
is like an English grammar book describing the rules of English.

One of the oldest computer-oriented metalanguages is the Backus-Naur Form (BNF), which
is named for John Backus and Peter Naur, who developed it in 1960. BNF syntax definitions
are written out using letters, numbers, and special symbols. For example, an identifier (a name
for something) in Java must be at least one letter, underscore, or dollar sign, which may or
may not be followed by additional letters, underscores, dollar signs, or digits. The BNF defini-
tion of an identifier in Java is 

<identifier> ::= <letter> | <letter> <letter-digit-sequence>
<letter-digit-sequence > ::= <letter-or-digit> |  

<letter-or-digit> <letter-digit-sequence>
<letter-or-digit> ::= <letter> | <digit>
<letter> ::= _ | $ 

| A | B | C | D | E | F | G | H | I | J | K | L 
| M | N | O | P | Q | R | S | T | U | V | W | X | Y | Z
| a | b | c | d | e | f | g | h | i | j | k | l 
| m | n | o | p | q | r | s | t | u | v | w | x | y | z

<digit>  ::= 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9

where the symbol ::= is read “is defined as,” the symbol | means “or,” the symbols < and >
are used to enclose words called nonterminal symbols (symbols that still need to be defined),
and everything else is called a terminal symbol.

The first line of the definition reads: “An identifier is defined as a letter or a letter followed
by a letter-digit-sequence.” This line contains nonterminal symbols that must be defined. In
the second line, the nonterminal symbol <letter-digit-sequence> is defined as a
<letter-or-digit> or as a <letter-or-digit> followed by another <letter-
digit-sequence>. The self-reference in the definition is a roundabout way of saying that a
<letter-digit-sequence> can be a series of one or more letters or digits. In the fourth
line, a <letter-or-digit> is defined to be either a <letter> or a <digit>. In the fifth
and last lines, we finally encounter terminal symbols that define <letter> to be an under-
score, dollar sign, or any of the upper- or lowercase letters and <digit> as any one of the
numeric characters 0 through 9.

t
continued



50 | Chapter 2:  Java Syntax and Semantics, and the Program Entry Process

BNF is an extremely simple language, but that simplicity leads to syntax definitions that can be
long and difficult to read. An alternative metalanguage, the syntax diagram, is easier to follow. It
uses arrows to indicate how symbols can be combined. Here are the syntax diagrams that define an
identifier in Java:

0 1 2 3 4 5 6 7 8 9

digit

digit

letter

letter
identifier

a b c d e f g h i j k l m n o p q r s t u v w x y z

_ $ A B C D E F G H I J K L M N O P Q R S T U V W X Y Z

letter

Metalanguages

tcontinued



2.1 Syntax and Symantics | 51

Syntax Templates

In this book, we write the syntax rules for Java using a metalanguage called a syntax
template. A syntax template is a generic example of the Java construct being defined.
Graphic conventions show which portions are optional and which can be repeated. A
colored word or symbol is written in the Java construct just as it is in the template. A
noncolored word can be replaced by another template. A square bracket is used to indi-
cate a set of items from which one can be chosen.

Let’s look at an example. This template defines a Java identifier, which is Java’s
way of naming something in a program:

The shading indicates the part of the definition that is optional. The three dots (...)
mean that the preceding symbol or shaded block can be repeated. So an identifier in

Letter

Identifier

Letter


Digit
$

A
B
C
D
E
F
G
H
I
J
K
L
M
N
O
P
Q
R
S
T
U
V
W
X
Y
Z

0
1
2
3
4
5
6
7
8
9

a
b
c
d
e
f
g
h
i
j
k
l
m
n
o
p
q
r
s
t
u
v
w
x
y
z

Letter Digit

. . .

$

To read the diagrams, start at the left and follow the arrows. When you come to a branch, take
any one of the branch paths.

The first diagram shows that an identifier can consist of a letter and optionally any number of let-
ters or digits. The remaining diagram defines the nonterminal symbols letter and digit to be any one
of the alphabetic or numeric characters. Here, we have eliminated the BNF nonterminal symbols
<letter-digit-sequence> and <letter-or-digit> by using arrows in the first syntax dia-
gram to allow a sequence of consecutive letters or digits.

Syntax diagrams are easier to interpret than BNF definitions, but they still can be difficult to read.
In this text, we introduce another metalanguage, called a syntax template. Syntax templates show at
a glance the form a Java construct takes.

One final note: Metalanguages only show how to write instructions that the compiler can trans-
late. They do not define what those instructions do (their semantics). Formal languages for defining
the semantics of a programming language exist, but they are beyond the scope of this text. Through-
out this book, we describe the semantics of Java in English.

Metalanguages



52 | Chapter 2:  Java Syntax and Semantics, and the Program Entry Process

Java is a letter, an underscore, or dollar sign that may be optionally followed by one or
more letters, digits, underscores, or dollar signs.

Remember that a word not in color can be replaced with another template. These
are the templates for letter and digit:

In this template, the brackets again indicate lists of items from which any one can
be chosen. So a letter can be any one of the upper- or lowercase letters, and a digit can
be any of the numeric characters 0 through 9.

Naming Program Elements: Identifiers

As we noted in our discussion of metalanguages, an
identifier is used in Java to name something. For
example, an identifier could be the name of a class, a
subprogram (called a method, in Java), or a place in
the computer’s memory that holds data (called a field
in Java). Identifiers are made up of an indefinite
sequence of letters (A–Z, a–z), digits (0–9), the under-

Letter

Identifier

Letter


Digit
$

A
B
C
D
E
F
G
H
I
J
K
L
M
N
O
P
Q
R
S
T
U
V
W
X
Y
Z

0
1
2
3
4
5
6
7
8
9

a
b
c
d
e
f
g
h
i
j
k
l
m
n
o
p
q
r
s
t
u
v
w
x
y
z

Letter Digit

. . .

$

Identifier A name associated with a package, class,
method, or field and used to refer to them

Method A subprogram in Java

Field A named place in memory that holds a data
value or a reference to an object



2.1 Syntax and Symantics | 53

score character ( _ ), and the dollar sign ( $ ), but must begin with a letter, underscore,
or dollar sign.

Identifiers beginning with an underscore have special meaning in some Java sys-
tems, so it is best to begin an identifier with a letter. Similarly, the dollar sign has spe-
cial meaning in some Java systems, and should not be used at all in identifiers that you
write. We have included it in the syntax template so that you can recognize its use if
you encounter it in a Java program that someone else has written.

Here are some examples of valid identifiers:

sum_of_squares  J9  box_22A  getData  Bin3D4  count   Count

Note that the last two of these identifiers (count and Count) are completely different
names to the Java compiler. The uppercase and lowercase forms of a letter are two dis-
tinct characters to the computer. Here are some examples of invalid identifiers and the
reasons why they are invalid:

Invalid Identifier Explanation

40Hours Identifiers cannot begin with a digit.
Get Data Blanks are not allowed in identifiers.
box–22 The hyphen (-) is a math symbol (minus) in Java.
empty_? Special symbols such as ? are not allowed.
int The word int is predefined in the Java language.

The last identifier in the table, int, is an
example of a reserved word. Reserved words
are words that have specific uses in Java; you
cannot use them as programmer-defined
identifiers. Appendix A lists all of the
reserved words in Java.

In the following table we have listed some of the programmer-defined identifiers
used in the Payroll program in Chapter 1. Notice that we chose the names to convey
how the identifiers are used. You can also see that there is a wide range of program ele-
ments that Java allows us to name.

Identifier How It Is Used

MAX_HOURS Maximum normal work hours
total The sum of weekly wages for all employees (total company payroll)
payFile The output file (where the employee’s number, pay rate, hours, and

wages are written)
outputDisplay The name of an object representing a window on the screen
hours A real number representing hours worked
wages A variable that holds the result of calculating the wages for an

employee
calcPay A method for computing an employee’s wages
empNum A string of characters indicating the employee ID number

Reserved word A word that has special meaning in
Java; it cannot be used as a programmer-defined iden-
tifier.



54 | Chapter 2:  Java Syntax and Semantics, and the Program Entry Process

Now that we’ve seen how to write identifiers, we look at some of the things that
Java allows us to name.

2.2 Data Types
A computer program operates on data (stored internally in memory, stored externally on
disk or tape, or input from a keyboard, mouse, scanner, or electrical sensor) and pro-
duces output. As we said in Chapter 1, in Java each piece of data must be of a specific
data type. The data type determines how the data is represented in the computer and the

kinds of processing the computer can perform on it.
Some types of data are used so frequently that

Java provides them for us. Java defines several of
these standard (or built-in) types. You are already
familiar with three of them from everyday life: integer
numbers, real numbers, and characters. By the end of

Chapter 6 you’ll be equally familiar with a fourth type, Boolean.
Additionally, Java allows programmers to define their own data types—program-

mer-defined (or user-defined) types. In Java, each of these types is called a class. In this

Standard (built-in) type A data type that is auto-
matically available for use in every Java program

Matters of Style
Using Meaningful, Readable Identifiers

The names we use to refer to things in our programs are totally meaningless to the computer.
The computer behaves in the same way whether we call the value 3.14159265 pi or cake, as
long as we always call it the same thing. However, it is much easier for somebody to figure
out how a program works if the names we choose for elements actually tell something about
them. Whenever you have to make up a name for something in a program, try to pick one that
is meaningful to a person reading the program.

Java is a case-sensitive language. Uppercase letters are different from lowercase letters.
The identifiers

PRINTTOPPORTION pRiNtToPpOrTiOn printTopPortion PrintTopPortion

are four distinct names and are not interchangeable in any way. As you can see, the last two
of these forms are easier to read. In this book, we use combinations of uppercase letters, low-
ercase letters, and underscores in identifiers. Many Java programmers use different capitaliza-
tions of identifiers as a way to indicate what they represent. Later in this chapter we show you
the conventions that we, and many Java programmers, use.



2.2 Data Types | 55

Background Information
Data Storage

Where does a program get the data it needs to operate? Data is stored in the computer’s
memory. Remember that memory is divided into a large number of separate locations or cells,
each of which can hold a piece of data. Each memory location has a unique address we refer
to when we store or retrieve data. We can visualize memory as a set of post office boxes, with
the box numbers as the addresses used to designate particular locations.

Of course the actual address of each location in memory is a binary number in a machine
language code. In Java we use identifiers to name memory locations; then the compiler and
JVM translate them into binary for us. This is one of the advantages of a high-level program-
ming language: It frees us from having to keep track of the numeric addresses of the memory
locations in which our data and instructions are stored.

100 101 102 103 104 105 106 107 108 109

110 111 112 113 114 115 116 117 118 119

120 121 122 123 124 125 126 127 128 129

130 131 132 133 134 135 136 137 138 139

140 141 142 143 144 145 146 147 148 149

chapter, we focus on the char data type and the String class that enable us to work
with character data. In Chapter 4, we examine the numeric types (such as int, long,
float, and double) in detail.

The char Data Type The built-in type char describes data consisting of one
alphanumeric character—a letter, a digit, or a special symbol. Java uses a particular
character set, the set of alphanumeric characters it can represent. Java’s character set is
called Unicode, and includes characters for writing in many human languages. In this



56 | Chapter 2:  Java Syntax and Semantics, and the Program Entry Process

text we use a subset of Unicode that corresponds to an older character set called the
American Standard Code for Information Interchange (ASCII). ASCII consists of the
alphabet for the English language, plus numbers and symbols. Here are some example
values of type char.

'A'   'a'   '8'   '2'   '+'   '-'   '$'   '?'   '*'   ' '

Notice that each character is enclosed in single quotes (apostrophes). The Java compiler
needs the quotes to differentiate between the character data and other elements of Java.
For example, the quotes around the characters 'A' and '+' distinguish them from the
identifier A and the addition sign. Notice also that the blank, '  ', is a valid character.

How do we write the single quote itself as a character? If we write ''', Java com-
plains that this is a syntax error. The second quote indicates the end of the (empty)
character value, and the third quote starts a new character value. Java provides a special
case called an escape sequence that allows us to write a single quote as a character. The
sequence of two characters \', is treated by Java as a single character representing the
quote. When we want to write the quote as a character in Java, we thus write

'\"

Notice that we use the backwards slash, or backslash (\), as the escape character
rather than the regular slash (/). As we see in the next chapter, Java uses the regular
slash as a division sign, so it is important to recognize that they are different from each
other. A moment’s thought reveals that this scheme introduces a new problem: How do
we write the backslash as a character? The answer is that Java provides a second escape
sequence, \\, that allows us to write a backslash. Thus, we write the char value of
backslash in Java as follows.

'\\'

Java provides operations that allow us to compare data values of type char. The
Unicode character set has a collating sequence, a predefined ordering of all the charac-
ters. In Unicode, 'A' compares less than 'B', 'B' less than 'C', and so forth. And '1'
compares less than '2', '2' less than '3', and so on. None of the identifiers in the
Payroll program is of type char.

2.3 Classes and Objects
In Chapter 1 we outlined two phases of programming: the problem-solving phase and
the implementation phase. Often the same vocabulary is used in different ways in the
two phases. In the problem-solving phase, an object is an entity or some thing that
makes sense in the context of the problem being solved. A group of objects with similar

TE
AM
FL
Y

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

Team-Fly® 



2.3 Classes and Objects | 57

properties and behaviors is described by an
object class, or class for short. Object-oriented
problem solving involves isolating the objects
that make up the problem. Objects interact
with one another by sending messages.

In the implementation phase, a class is
a Java construct that allows the programmer
to describe one or more objects. A class
contains fields (data values) and methods
(subprograms) that define the behavior of the
object. Think of a class in the general sense
as a pattern for what an object looks like and
how it behaves and the Java class as the
construct that allows you to simulate the
object in code. If a class is a description of an
object, how do we get an object that fits the description? We use an operator called
new, which takes the class name and returns an object of the class type. The object that
is returned is an instance of the class. The act of creating an object from a class is
called instantiation. These definitions provide new meanings for the terms object and
class in addition to how we defined them in Chapter 1. Here is the syntax diagram for
a class.

A Java class may optionally begin with a series of import declarations. An object-
oriented language such as Java provides a very large library of classes that are available
for us to use in our programs. There are so many of these in Java’s library, in fact, that
they must be organized into smaller groups
called packages. Import declarations are state-
ments that tell the Java compiler which
library packages we are using in our class.
We do not use a Java package in this chapter,
so we postpone looking at the syntax for an
import statement until the next chapter.

ImportDeclaration;

Modifiers

ClassDeclaration

class Identifier

Class

{

}

Modifiers

. . .

. . .

. . .

private

public

:

Class (general sense) A description of the behavior
of a group of objects with similar properties and
behaviors

class (Java construct) A pattern for an object

Object (general sense) An entity or thing that is
relevant in the context of a problem

Object (Java) An instance of a class

Method A subprogram that defines one aspect of the
behavior of a class

Instantiation Creating an object, an instance of a
class

Package A named collection of program building
blocks or components in Java that can be imported by
a class



58 | Chapter 2:  Java Syntax and Semantics, and the Program Entry Process

The next line may optionally begin with a series of access modifiers, which are then
followed by the word class and an identifier. This line is called the heading of the
class. The heading gives the class a name (the identifier) and may optionally specify
some general properties of the class (the modifiers). Modifiers are Java keywords. We
have listed two of Java’s modifiers in the syntax diagram that are relevant here: public
and private. They are called access modifiers because they specify whether elements
outside of the class can use the class. What’s outside of the class? Any of the packages
that we list in import declarations are outside the class. In addition, every program
class actually resides within a package called java that is part of the JVM. Thus, if we
declare an identifier to be public, we are allowing the JVM and all imported packages
to make use of it. Because we want the JVM to be able to execute our program class, we
specify that its name is public.

After the heading you see an open brace, a series of class declarations, and a clos-
ing brace. These three elements make up the body of the class. The braces indicate where
the body begins and ends, and the class declarations contain all of the statements that
tell the computer what to do. The simplest Java class we can write would look like this

class DoNothing
{
}

and as its name implies, it does absolutely nothing. It is a completely empty shell of a
program. Our job as programmers is to add useful instructions to this empty shell.

The String Class Whereas a value of type char is limited to a single character, a
string (in the general sense) is a sequence of characters, such as a word, name, or
sentence, enclosed in double quotes. In Java, a string is an object, an instance of the
String class. For example, the following are strings in Java:

"Introduction to "    "Java"    " and Software Design "    "."

A string must be typed entirely on one line. For example, the string

"This string is invalid because it
is typed on more than one line."

is not valid because it is split across two lines before the closing double quote. In this
situation, the Java compiler issues an error message at the first line. The message may
say something like QUOTE EXPECTED, depending on the particular compiler.

The quotes are not considered to be part of the string but are simply there to distin-
guish the string from other parts of a Java program. For example, "amount" (in double
quotes) is the character string made up of the letters a, m, o, u, n, and t in that order.
On the other hand, amount (without the quotes) is an identifier, perhaps the name of a
place in memory. The symbols "12345" represent a string made up of the characters 1,
2, 3, 4, and 5 in that order. If we write 12345 without the quotes, it is an integer quan-
tity that can be used in calculations.



2.4 Defining Terms: Declarations | 59

A string containing no characters is called the empty string. We write the empty
string using two double quotes with nothing (not even spaces) between them.

""

The empty string is not equivalent to a string of spaces; it is a special string that con-
tains no characters.

To write a double quote within a string, we use another escape sequence, \". Here is
a string containing both quotation marks and the escape sequence for a backslash.

"She said, \"Don't forget that \\ is not the same as the / character.\""

The value of this string is

She said, "Don't forget that \ is not the same as the / character."

Notice that within a string we do not have to use the escape sequence \' to repre-
sent a single quote. Similarly, we can write the double quote as a value of type char
('"') without using an escape sequence. But we have to use \\ to write a backslash as a
char value or within a string.

Java provides operations for joining strings, comparing strings, copying portions of
strings, changing the case of letters in strings, converting numbers to strings, and convert-
ing strings to numbers. We look at some of these operations later in this chapter and
cover the remaining operations in subsequent chapters. In the Payroll program, the
identifier empNum is of class String, and string values are used directly in several places.

2.4 Defining Terms: Declarations
How do we tell the computer what an identifier represents? We use a declaration, a state-
ment that associates a name (an identifier) with a description of an element in a Java pro-
gram (just as a dictionary definition associates
a name with a description of the thing being
named). In a declaration, we name an identi-
fier and what it represents. For example, the
Payroll program uses the declaration

String empNum;

to announce that empNum is the name of a field whose contents are an instance of class
String. When we declare a field, the compiler picks a location in memory to be associ-
ated with the identifier. We don’t have to know the actual address of the memory loca-
tion because the computer automatically keeps track of it for us.

Fields and the actual instructions in a program are stored in various memory loca-
tions. We use identifiers to refer to fields. We have also seen that a method can be given
an identifier. In addition, a name can be associated with a programmer-defined class,
which is a collection of fields and methods.

Declaration A statement that associates an identifier
with a field, a method, a class, or a package so that the
programmer can refer to that item by name



60 | Chapter 2:  Java Syntax and Semantics, and the Program Entry Process

Variable identifier

Variable

Value

myChar
(memory location 1101010011)

5 ?
Data type

(char)

Figure 2.1 Variable

In Java you must declare every identifier before you use it. This allows the compiler
to verify that the use of the identifier is consistent with what it was declared to be. If
you declare an identifier to be a field that can hold a char value and later try to store a
number into the field, the compiler detects this inconsistency and issues an error mes-
sage.

A field can be either a constant or a variable. In other words, a field identifier can
be the name of a memory location whose contents are not allowed to change or it
can be the name of a memory location whose contents can change. There are different
forms of declaration statements for constants, variables, methods, and classes in Java.

Variables A program operates on data. Data is stored in memory. While a program is
executing, different values may be stored in the same memory location at different

times. This kind of memory location is called a
variable, and its contents are the variable value. The
symbolic name that we associate with a memory
location is the variable name or variable identifier. In
practice, we often refer to the variable name more
briefly as the variable.

Declaring a variable means specifying both its name and its data type or class. This
tells the compiler to associate a name with a memory location, and that the values to be
stored in that location are of a specific type or class (for example, char or String). The
following statement declares myChar to be a variable of type char:

char myChar;

Notice that the declaration does not specify what value is stored in myChar. It only
specifies that the name myChar can hold a value of type char. At this point, myChar
has been reserved as a place in memory but it contains no data. Shortly, we see how to
actually put a value into a variable. (See Figure 2.1.)

Variable A location in memory, referenced by an
identifier, that contains a data value that can be
changed



2.4 Defining Terms: Declarations | 61

Java is a strongly typed language. This means that a variable can contain a value
only of the type or class specified in its declaration. Because of the above declaration,
the variable myChar can contain only a char value. If the Java compiler comes across
an instruction that tries to store a value of the wrong type, it gives an error message,
usually something like “Cannot assign String to char.”

Here’s the syntax template for a variable declaration:

TypeName is the name of a type or class such as char or String. Notice that a declara-
tion always ends with a semicolon. Modifiers are Java reserved words. Different modi-
fiers have different meanings, and we introduce each one and explain its use as the
need arises throughout the next several chapters. Notice that the syntax template shows
that they are optional. We can declare variables without using any of the modifiers.

From the syntax template, you can also see that it is possible to declare several
variables in one statement:

char letter, middleInitial, ch;

Here, all three variables are declared to be char variables. Our preference, though, is to
declare each variable with a separate statement:

char letter;
char middleInitial;
char ch;

Declaring each variable with a separate statement allows you to attach comments to
the right of each declaration, for example:

String firstName;     // A person's first name
String lastName;       // A person's last name
String title;           // A person's title, for example Dr.
char middleInitial;     // A person's middle initial
char myChar;           // A place to store one letter

These declarations tell the compiler to reserve memory space for three String vari-
ables—firstName, lastName, and title—and two char variables, middleInitial,
and myChar. The comments explain to someone reading the program what each vari-
able represents.

In the syntax template for a class, we saw that it contains a set of class declara-
tions, and some of those declarations are variables. For example, here is a class with

VariableDeclaration

. . .Modifiers  TypeName Identifier, Identifier           ;



62 | Chapter 2:  Java Syntax and Semantics, and the Program Entry Process

two variable declarations, also showing how we might use a private modifier as part
of a declaration.

public class Sample          // The start of a class called Sample
{
private char myChar;      // A char type variable declared in class 

//  Sample
private String myString;  // A String variable declared in class Sample

}                            // The end of class Sample

Constants All single characters (enclosed in single quotes) and strings (enclosed in
double quotes) are constants.

'A'   '@'   "Howdy boys"   "Please enter an employee number:"

In Java, as in mathematics, a constant is something
whose value never changes. When we use the actual
value of a constant in a program, we are using a
literal value (or literal ).

An alternative to the literal constant is the named
constant (or symbolic constant ), which is introduced
in a declaration statement. A named constant is just
another way of representing a literal value. Instead of

using the literal value in an instruction, we give the literal value a name in a declara-
tion statement, then use that name in the instruction. For example, we can write an
instruction that prints the title of this book using the literal string "Introduction to
Java and Software Design". Or we can declare a named constant called
BOOK_TITLE that equals the same string and then use the constant name in the instruc-
tion. That is, we can use either

"Introduction to Java and Software Design"

or

BOOK_TITLE

in the instruction.
Using the literal value of a constant may seem easier than giving it a name and

then referring to it by that name. But, in fact, named constants make a program easier
to read because they make the meaning of literal constants clearer. And named con-
stants also make it easier to change a program later on.

Literal value Any constant value written in a pro-
gram

Named constant (symbolic constant) A location in
memory, referenced by an identifier, that contains a
data value that cannot be changed



2.4 Defining Terms: Declarations | 63

The syntax template for a constant declaration is similar to the template for a vari-
able declaration:

The only difference is that we must include the modifier final, a reserved word, and
we follow the identifier with an equal sign (=) and the value to be stored in the con-
stant. The final modifier tells the Java compiler that this value is the last and only
value we want this field to have.

The following are examples of constant declarations:

final String STARS = "********";
final char   BLANK = ' ';
final String BOOK_TITLE = "Introduction to Java and Software
Design";
final String MESSAGE = "Error condition";

As we have done above, many Java programmers capitalize the entire identifier of a
named constant and separate the English words with an underscore. The idea is to let
the reader quickly distinguish between variable names and constant names when they
appear in the middle of code.

It’s a good idea to add comments to constant declarations as well as variable decla-
rations. For example:

ConstantDeclaration

Modifiers  final  TypeName  Identifier = LiteralValue;

Matters of Style
Capitalization of Identifiers

Programmers often use capitalization as a quick, visual clue to what an identifier represents.
Different programmers adopt different conventions for using uppercase letters and lowercase
letters. Some people use only lowercase letters, separating the English words in an identifier
with the underscore character:

pay_rate   emp_num  pay_file

tcontinued



64 | Chapter 2:  Java Syntax and Semantics, and the Program Entry Process

final String STARS = "********"; // Row of stars to use as a separator
final char   BLANK = ' ';        // A single blank

2.5 Taking Action: Executable Statements
Up to this point, we’ve looked at ways of declaring
variables and constants in a program. Now we turn our
attention to ways of acting, or performing operations,
on data.

Assignment The value of a variable can be set or
changed through an assignment statement. For example,

The convention used by many Java programmers and the one we use in this book is the following:

• Variables and methods begin with a lowercase letter and capitalize each successive English word.

lengthInYards   middleInitial   hours

• Class names begin with an uppercase letter but are capitalized the same as variable names there-
after.

PayRollFrame   Sample   MyDataType   String

Capitalizing the first letter allows a person reading the program to tell at a glance that an identi-
fier represents a class name rather than a variable or method. Java reserved words use all lower-
case letters, so type char is lowercase. String is a class, so it begins with a capital letter.

• Identifiers representing named constants are all uppercase with underscores used to separate the
English words.

BOOK_TITLE   OVERTIME   MAX_LENGTH

These conventions are only that—conventions. Java does not require this particular style of capitaliz-
ing identifiers. You may wish to capitalize in a different fashion. But whatever you use, it is essential
that you use a consistent style throughout your program. A person reading your program will be con-
fused or misled if you use a random style of capitalization.

Capitalization of Identifiers

Assignment statement A statement that stores the
value of an expression into a variable



2.5 Taking Action: Executable Statements | 65

lastName = "Lincoln";

assigns the string value "Lincoln" to the variable lastName (that is, stores the
sequence of characters "Lincoln" into the memory associated with the variable named
lastName).

Here’s the syntax template for an assignment statement:

The assignment operator (=) means “is set equal to” or “gets”; the variable is set equal to
the value of the expression. Any previous value in the variable is destroyed and
replaced by the value of the expression.

Only one variable can be on the left-hand side of an assignment statement. An
assignment statement is not like a math equation (x + y = z + 4); the expression (what is
on the right-hand side of the assignment operator) is evaluated, and the resulting value
is stored into the single variable on the left of the assignment operator. A variable keeps
its assigned value until another statement stores a new value into it.

Because you are accustomed to reading from left to right, the way that the assign-
ment operator moves a value from right to left may at first seem awkward. Just remem-
ber to read the = as “is set equal to” or “gets” and it seems more natural.

The value assigned to a variable must be of the same type as the variable. Given the
declarations

AssignmentStatement

Variable = Expression;

Expression An arrangement of identifiers, literals,
and operators that can be evaluated to compute a
value of a given type

Evaluate To compute a new value by performing a
specified set of operations on given values



66 | Chapter 2:  Java Syntax and Semantics, and the Program Entry Process

Variable identifier

Variable

Value

myChar=
(memory location 1101010011)

5 B
Data type

char

Figure 2.2 Variable with value

String firstName;
String middleName;
String lastName;
String title;
char middleInitial;
char myChar;

the following assignment statements are valid:

firstName = "Abraham";
middleName = firstName;
middleName = "";
lastName = "Lincoln";
title = "President";
middleInitial = ' ';
myChar = 'B';

However, these assignments are not valid:

Invalid Assignment Statement Reason

middleInitial = "A."; middleInitial is of type char; "A." is a string.
letter = firstName; letter is of type char; firstName is of class String.
letter = " "; letter is of type char, " " is only one character but it

is a string because of the double quotes.
firstName = Thomas; Thomas is an undeclared identifier.
"Edison" = lastName; Only a variable can appear to the left of =.
lastName = ; The expression to the right of = is missing.

Figure 2.2 shows variable myChar with the letter B stored in it.

String Expressions Although we can’t perform arithmetic on strings, Java provides the
String class with a special string operation, called concatenation, that uses the +

TE
AM
FL
Y

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

Team-Fly® 



2.5 Taking Action: Executable Statements | 67

operator. The result of concatenating (joining) two strings is a new string containing the
characters from both strings. For example, given the statements

String bookTitle;
String phrase1;
String phrase2;

phrase1 = "Introduction to Java and ";
phrase2 = "Software Design";

we could write

bookTitle = phrase1 + phrase2;

which results in bookTitle being set equal to the character string

"Introduction to Java and Software Design"

The order of the strings in the expression determines how they appear in the result-
ing string. If we instead write

bookTitle = phrase2 + phrase1;

then bookTitle is set equal to the string

"Software DesignIntroduction to Java and "

Concatenation works with named String constants and literal strings as well as
String variables. For example, if we have declared the following constants:

final String WORD1 = "Introduction";
final String WORD3 = "Java";
final String WORD5 = "Design";

then we could write the following statement to assign the title of this book to the vari-
able bookTitle:

bookTitle = WORD1 + " to " + WORD3 + " and Software " + WORD5;

As a result, bookTitle is assigned the string

"Introduction to Java and Software Design"



68 | Chapter 2:  Java Syntax and Semantics, and the Program Entry Process

The preceding example demonstrates how we can combine identifiers and literal
strings in a concatenation expression. Of course, if we simply want to assign the com-
plete string to bookTitle, we can do so directly:

bookTitle = "Introduction to Java and Software Design";

But occasionally we need to assign a string literal that is too long to fit on one line and
then a concatenation expression is necessary, as in the following statement.

longSentence = "The Red-Wing Blackbird hovered precariously in the gusty " +
"breeze as he tried to display his brilliant red and yellow " +
"epaulets to his rival suitor. ";

Sometimes we may also encounter a situation in which we want to add some characters
to an existing string value. Suppose that bookTitle already contains "Introduction
to Java" and that we wish to complete the title. We could use a statement of the form

bookTitle = bookTitle + " and Software Design";

Such a statement retrieves the value of bookTitle from memory, concatenates the
string " and Software Design" to form a new string, and then assigns the new
string back to bookTitle. The new string replaces the old value of bookTitle (which
is destroyed).

Concatenation works only with values of type String. However, if we try to con-
catenate a value of one of Java’s built-in types with a string, Java automatically con-
verts the value into an equivalent string and performs the concatenation. For example,
the code segment:

String result;
result = "The square of 12 is " + 144;

assigns the string "The square of 12 is 144" to the variable result. Java converts
the integer literal 144 into the string "144" before performing the concatenation.

Fields The similarity in appearance between variable and constant declarations in Java
is not a coincidence. Java doesn’t actually distinguish between the declaration of named
constants and variables because they are just different kinds of fields. A named
constant is merely a field that is given an initial value, together with the modifier
final, which says that the value can never be changed. If we extend the template for a
variable declaration to include the syntax necessary to give the variable an initial value,
and add the keyword final to the list of modifiers, then we have a generic template for
a field declaration in Java. Now that we have defined expressions, we generalize the
initial value syntax to include expressions.



2.5 Taking Action: Executable Statements | 69

The following declarations are legal:

final String WORD1 = "Introduction";
final String WORD3 = "Java " + WORD1;
final String WORD5 = "Design " + WORD3;

and store "Design Java Introduction" as the value for constant WORD5.

Output Have you ever asked someone, “Do you know what time it is?” only to have
the person smile smugly, and say, “Yes, I do!”? This situation is like the one that
currently exists between you and the computer. You now know enough Java syntax to
tell the computer to assign values to variables and to concatenate strings, but the
computer won’t give you the results until you tell it to display them.

Early computers used printers to display their output. Older programming languages
thus had output statements, such as print or write that would type the contents of a
variable or a constant on the printer. As technology advanced, printers were replaced by
display screens, but output was still shown on the screen as if it was being typed by a
printer, line by line. In the 1970s, computer scientists at the Xerox Palo Alto Research
Center developed a new approach to output in which a program could display separate
panels on the screen and print or draw on each panel independently. The panels were
called windows, and opened a new era in the design of user interfaces for computer pro-
grams.

Today, virtually every computer operating system supports a graphical user inter-
face (GUI) based on windows. Such interfaces make it much easier for people to use pro-
grams; however, they require more work on the part of the programmer than did the
old-fashioned printer style of output. Because Java was developed after the GUI became
the standard mechanism for interactive input and output, it has built-in features to sim-
plify the programming of a user interface, which we cover in the next chapter. Here we
introduce a very simple way of writing messages on the screen.

Java provides an object that represents an output device, which is, by default, the
screen. We can send messages to this object asking it to print something on the screen.
The name of the object is System.out and the messages we can send (methods that we
can apply) are print and println. For example,

System.out.print("Susy" + "  " + "Sunshine");

prints

FieldDeclaration

Modifiers  TypeName  Identifier = Expression  , Identifier = Expression  ;



70 | Chapter 2:  Java Syntax and Semantics, and the Program Entry Process

Susy  Sunshine

in a window on the screen. There are several things to notice about this statement. The
method is invoked (message sent) by placing the method name next to the object with a
dot in between. The “something” that is to be printed is called a parameter and is placed
within the parentheses. What do you think the next code fragment prints?

System.out.print("Susy");
System.out.print("  ");
System.out.print("Sunshine");

If you said that the two code fragments print the same thing, you would be correct. Suc-
cessive messages sent via the print method print the strings next to each other on the
same line. If you want to go to the next line after the string is printed, you use the
println method. The code fragment,

System.out.println("Susy");
System.out.println("  ");
System.out.println("Sunshine");

prints

Susy

Sunshine

Note that the println method does not go to the next line until after the string is
printed. The second line contains two blanks, it is not the empty string. We can print
variables as well as literals.

String myName = "Susy  Sunshine";
System.out.println(myName);

prints exactly the same thing on the screen as the statement

System.out.print("Susy  Sunshine");

There is a difference, however. If this example is followed by another message to Sys-
tem.out, the next string would begin on the same line. If the previous example is fol-
lowed by another message to System.out, the next string would begin on the next
line.

Beyond Minimalism: Adding Comments to a Program



2.5 Taking Action: Executable Statements | 71

All you need to create a working program is the correct combination of declarations
and executable statements. The compiler ignores comments, but they are of enormous
help to anyone who must read the program. Comments can appear anywhere in a pro-
gram except in the middle of an identifier, a reserved word, or a literal constant.

Java comments come in two forms. The first is any sequence of characters enclosed
by the /*  */ pair. The compiler ignores anything within the pair no matter how many
lines are enclosed. Here’s an example:

String idNumber;  /* Identification number of the aircraft */

There is one special note about using this form of comment. When the first charac-
ter of the comment is an asterisk, the comment has a special meaning that indicates it is
to be used by an automatic documentation generation program called javadoc. For the
time being, since we do not discuss javadoc in this text, we recommend that you avoid
comments that start with /**.

The second, and more common, form begins with two slashes (//) and extends to
the end of that line of the program:

String idNumber;   // Identification number of the aircraft

The compiler ignores anything after the two slashes to the end of the line.
Writing fully commented programs is good programming style. A comment should

appear at the beginning of a program to explain what the program does:

// This program computes the weight and balance of a Beechcraft
// Starship–1 airplane, given the amount of fuel, number of
// passengers, and weight of luggage in fore and aft storage.
// It assumes that there are two pilots and a standard complement
// of equipment, and that passengers weigh 170 pounds each

Another good place for comments is in constant and variable declarations, where
the comments explain how each identifier is used. In addition, comments should intro-
duce each major step in a long program and should explain anything that is unusual or
difficult to read (for example, a lengthy formula).

It is important to make your comments concise and to arrange them in the program
so that they are easy to see and it is clear what they refer to. If comments are too long
or crowd the statements in the program, they make the program more difficult to read—
just the opposite of what you intended! In this text we use color to make the comments
stand out from the rest of the Java code in our examples.

Program Construction

We have looked at the basic elements of Java codes: identifiers, declarations, variables,
constants, expressions, assignment statements, method calls, and comments. Now let’s
see how to collect these elements into a program. A Java program, usually called an



72 | Chapter 2:  Java Syntax and Semantics, and the Program Entry Process

application, is a class containing class declarations: fields and methods. In order for the
class to be a Java application, one of the methods must be named main. The main
method is where execution of the Java program begins.

We have already shown the template for a field declaration; now let’s look at how
to declare a method. A method declaration consists of the method heading and its body,
which is delimited by left and right braces. The following syntax template represents the
declaration of a method.

Here’s an example of a program with just one method, the main method. Note that
the name of the program, the class that includes main, is up to the programmer; we
chose PrintName. Because a program is a class, we begin the name with an upper-
case P.

//******************************************************************
// PrintName program
// This program prints a name in two different formats
//******************************************************************
public class PrintName
{

public static void main(String[] args)
{
final String FIRST  = "Herman";    // Person's first name
final String LAST   = "Herrmann";  // Person's last name
final char   MIDDLE = 'G';        // Person's middle initial
String firstLast;                 // Name in first-last format
String lastFirst;                  // Name in last-first format

firstLast = FIRST + " " + LAST;
System.out.println("Name in first-last format is " + firstLast);
lastFirst = LAST + ", " + FIRST + ", ";
System.out.println("Name in last-first-initial format is " +

lastFirst + MIDDLE + ".");
}

}


Modifiers  void  Identifier  ( ParameterList )
{
        Statement
}

MethodDeclaration

. . .



2.5 Taking Action: Executable Statements | 73

The program begins with a comment that explains what the program does. Next
comes the class heading, which begins with the modifier public. In order to execute
the class, it must be public so that the JVM can find it. If you look a little further
down in the program, you see that the heading of the main method also begins with
public. The JVM must also be able to find main in order to start execution there. In
later chapters we see situations where we want to limit access to a field, method, or
class. We do this by using the modifier private. If we used the private modifier with
main, then the method would be invisible to the JVM and it wouldn’t know where to
start.

The class heading is followed by an open brace that begins the body of the class.
The class contains the method declaration for the main method. The first line is the
method heading. We are not going to explain the construction of main’s heading at
this point. For the time being, just memorize this heading, and use it in your programs.
It is not until the end of Chapter 11 that we can explain it completely. The body of the
method contains declarations of three String constants (FIRST, LAST, and MIDDLE)
and two String variables (firstLast and lastFirst) and a list of executable state-
ments. The compiler translates these executable statements into Bytecode instructions.
During the execution phase of the program, these are the instructions that are exe-
cuted.

Note that neither the public nor the private modifier precedes the variables
declared within main. The reason is that fields declared inside the body of a method are
said to be local to that method, which means that they are accessible only within the
method. Thus, there is no need to explicitly specify that they are private, and they
cannot be made public. In fact, the only modifier allowed in a local declaration is
final.

Notice how we use spacing in the PrintName program to make it easy for someone
to read. We use blank lines to separate statements into related groups, and we indent
the entire body of the class and the main method. The compiler doesn’t require us to
format the program this way; we do so only to make it more readable. We have more to
say in the next chapter about formatting a program.

Here is what the program displays on the screen when it executes:

Blocks



74 | Chapter 2:  Java Syntax and Semantics, and the Program Entry Process

The body of a method is an example of a block. This is the syntax template for a block:

A block is just a sequence of zero or more statements enclosed (delimited) by a {  }
pair. Now we can redefine a method declaration as a heading followed by a block:

In later chapters we define the syntax of Heading in greater detail. In the case of the
main method, Heading is simply public static void main(String[] args). Here
is the syntax template for a statement, limited to the Java statements discussed in this
chapter:

A statement can be empty (the null statement ). The null statement is just a semicolon
(;) and looks like this:

;

It does absolutely nothing at execution time; execution just proceeds to the next state-
ment. It is not used often.

As the syntax template shows, a statement also can be a local field declaration, an
executable statement, or even a block. The latter means that you can use an entire block
wherever a single statement is allowed. In later chapters where we introduce the syntax
for branching and looping structures, this fact is very important.

We use blocks often, especially as parts of other statements. Leaving out a {  }
pair can dramatically change the meaning as well as the execution of a program. This is


     NullStatement
     LocalFieldDeclaration
     AssignmentStatement
     MethodCall
     Block

Statement

Heading
Block

MethodDeclaration


{
        Statement
}

Block

. . .



2.6 Program Entry, Correction, and Execution | 75

why we always indent the statements inside a block—the indentation makes a block
easy to spot in a long, complicated program.

Notice in the syntax templates for the block and the statement that there is no men-
tion of semicolons. Yet the PrintName program contains many semicolons. If you look
back at the templates for class field declaration, local field declaration, assignment
statement, and method call, you can see that a semicolon is required at the end of each
kind of statement. However, the syntax template for the block shows no semicolon after
the right brace. The rule for using semicolons in Java, then, is quite simple: Terminate
each statement except a block with a semicolon.

One more thing about blocks and statements: According to the syntax template for
a statement, a field declaration is officially considered to be a statement. A declaration,
therefore, can appear wherever an executable statement can. In a block, we can mix
local declarations and executable statements if we wish. However, a declaration must
come before it is used.

{
char ch;                        // Declaration
ch = 'A';
System.out.println(ch);
String str;                      // Declaration
str = "Hello";
System.out.println(str);

}

In this book we group the declarations together because we think it is easier to read, and
is therefore better style.

{
// Declarations
char   ch;
String str;
// Executable statements
ch = 'A';
System.out.println(ch);
str = "Hello";
System.out.println(str);

}

2.6 Program Entry, Correction, andExecution
Once you have a program on paper, you must enter it on the keyboard. In this section,
we examine the program entry process in general. You should consult the manual for
your specific computer to learn the details.

File A named area in secondary storage that is used
to hold a collection of data; the collection of data itself



76 | Chapter 2:  Java Syntax and Semantics, and the Program Entry Process

Entering a Program

The first step in entering a program is to get the computer’s attention. With a personal
computer, this usually means turning it on. Workstations connected to a network are
usually left running all the time. You must log on to such a machine to get its attention.
This means entering a user name and a password. The password system protects infor-
mation that you’ve stored in the computer from being tampered with or destroyed by
someone else.

Once the computer is ready to accept your commands, you tell it that you want to
enter a program by running the editor. The editor is a program that allows you to create
and modify programs by entering information into an area of the computer’s secondary
storage called a file.

A file in a computer system is like a file folder in a filing cabinet. It is a collection
of data that has a name associated with it. You usually choose the name for the file
when you create it with the editor. From that point on, you refer to the file by the name
you’ve given it.

There are so many different types of editors, each with different features, that we can’t
begin to describe them all here. But we can describe some of their general characteristics.

The basic unit of information in an editor is a display screen full of characters. The
editor lets you change anything that you see on the screen.

Figure 2.3 Display screen for an editorTE
AM
FL
Y

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

Team-Fly® 



2.6 Program Entry, Correction, and Execution | 77

Enter program

Compile program

Compile-time errors?

Run program

Logic errors?

Success!

No

No

Yes

Yes

Figure out errors,
get back into editor,
and fix errors in
program.

Go back to algorithm
and fix design. Get
back into editor and 
fix errors in program.

Figure 2.4 Debugging process

When you create a new file, the editor clears the screen to show you that the file is
empty. Then you enter your program, using the mouse and keyboard to go back and make
corrections as necessary. Figure 2.3 shows an example of an editor’s display screen.

Compiling and Running a Program

Once your program is stored in a file, you compile it by issuing a command to run the
Java compiler. The compiler translates the program, then stores the Bytecode version
into a file. The compiler may display a window with messages indicating errors in the
program. Some systems let you click on an error message to automatically position the
cursor in the editor window at the point where the error was detected.

If the compiler finds errors in your program (syntax errors), you have to determine
their cause, go back to the editor and fix them, and then run the compiler again. Once
your program compiles without errors, you can run (execute) it.

Some systems automatically run a program when it compiles successfully. On other
systems, you have to issue a separate command to run the program. Whatever series of
commands your system uses, the result is the same: Your program is loaded into mem-
ory and executed by the JVM.

Even though a program runs, it still may have errors in its design. The computer
does exactly what you tell it to do, even if that’s not what you wanted it to do. If your



program doesn’t do what it should (a logic error), you have to go back to the algorithm
and fix it, and then go to the editor and fix the program. Finally, you compile and run
the program again. This debugging process is repeated until the program does what it is
supposed to do (see Figure 2.4).

Finishing Up

On a workstation, once you finish working on your program, you have to log off by typ-
ing a command. This frees up the workstation so that someone else can use it. It also
prevents someone from walking up after you leave and tampering with your files.

On a personal computer, when you’re done working, you save your files and quit
the editor. Turning off the power wipes out what’s in the computer’s memory, but your
files are stored safely on disk. It is a wise precaution to periodically make a copy of
your code files on a removable diskette. When a disk in a computer suffers a hardware
failure, it often makes it impossible to retrieve your files. Having a backup copy on a
diskette enables you to restore your files to the disk once it is repaired.

Be sure to read the manual for your particular system and editor before you enter
your first program. Don’t panic if you have trouble at first—almost everyone does. It
becomes much easier with practice. That’s why it’s a good idea to first go through the
process with a program such as PrintName, where mistakes don’t matter—unlike a class
programming assignment!

Problem-Solving Case Study
Display a Date in Multiple Formats

Problem You are beginning to work on a program that needs to output dates in several
formats. As a start, you decide to write a short Java application that takes a single date and
displays it in the different formats, so you can be certain that all of your string expressions are
correct.

Output A window showing the date in four formats:

Month day, year  (August 18, 2001)
day Month year  (18 August 2001)
mm/dd/yyyy  (8/18/2001)
dd/mm/yyyy  (18/8/2001)

Discussion You could easily just type the dates in the four formats as string literals in the
program, but the purpose of this exercise is to develop and test the string expressions you
need for the larger program.



Problem-Solving Case Study | 79

Because you plan to eventually use the same expressions in another program, you decide
that this preliminary program should start with a set of named string constants containing the
parts of a date. Then the program can use concatenation expressions to form string variables in
the different date formats. In that way, all the date strings can be created before the output
statements are executed.

A date consists of three parts, the month, day, and year, but you need to write the month
both by name and by number so there must be a total of four string constants. Here is the
algorithmic solution:

Define Constants

Create First Format

Create Second Format

Set first to MONTH_NAME + “ “ + DAY + “, “ + YEAR

MONTH_NAME = “August”
MONTH_NUMBER = “8”
DAY = “18”
YEAR = “2001”

Constants

Name Value Description

MONTH_NAME "August" The name of the month
MONTH_NUMBER "8" The number of the month
DAY "18" The day of the month
YEAR "2001" The four-digit year number



80 | Chapter 2:  Java Syntax and Semantics, and the Program Entry Process

Create Third Format

Create Fourth Format

Display the Dates

From the algorithm, we can create tables of constants and variables that help us write the
declarations in the program.

Now we’re ready to write the program. Let’s call it DateFormats. We can take the decla-
rations from the tables and create the executable statements from the algorithm. We also
include comments as necessary.

Here is the program:

//******************************************************************
// DateFormats program
// This program prints a date in four different formats by
// building strings up from the component parts of the date

Print first
Print second
Print third
Print fourth

Set fourth to DAY + “/” + MONTH_NUMBER + “/” + YEAR

Set third to MONTH_NUMBER + “/” + DAY + “/” + YEAR

Set second to DAY + “  “ + MONTH_NAME + “ “ + YEAR

Variables

Name Data Type Description

first String Date in Month day, year format
second String Date in day Month year format
third String Date in mm/dd/yyyy format
fourth String Date in dd/mm/yyyy format



Testing and Debugging | 81

// using string concatenation expressions
//******************************************************************

public class DateFormats
{
public static void main(String[] args)
{
final String MONTH_NAME = "August";  // The name of the month
final String MONTH_NUMBER = "8";     // The number of the month
final String DAY = "18";             // The day of the month
final String YEAR = "2001";        // The four-digit year number
String first;                        // Date in Month day, year format
String second;                    // Date in day Month year format
String third;                        // Date in mm/dd/yyyy format
String fourth;                       // Date in dd/mm/yyyy format

first = MONTH_NAME + " " + DAY + ", " + YEAR;   // Create Month day, 
//  year format

second = DAY + "  " + MONTH_NAME + " " + YEAR;  // Create day Month 
//  year format

third = MONTH_NUMBER + "/" + DAY + "/" + YEAR;  // Create mm/dd/yyyy 
//  format

fourth = DAY + "/" + MONTH_NUMBER + "/" + YEAR; // Create dd/mm/yyyy 
//  format

// Print the dates on the screen
System.out.println(first);
System.out.println(second);
System.out.println(third);
System.out.println(fourth);

}
}

The output from the program is



82 | Chapter 2:  Java Syntax and Semantics, and the Program Entry Process

Testing and Debugging

1. Every identifier that isn’t a Java reserved word must be declared. If you use a name
that hasn’t been declared, you get an error message.

2. If you try to declare an identifier that is the same as a reserved word in Java, you
get an error message from the compiler. See Appendix A for a list of reserved
words.

3. Java is a case-sensitive language. Two identifiers that are capitalized differently are
treated as two different identifiers. The word main and all Java reserved words use
only lowercase letters.

4. Check for mismatched quotes in char and string literals. Each char literal begins
and ends with an apostrophe (single quote). Each string literal begins and ends with
a double quote.

5. Be sure to use only the single quote (') to enclose char literals. There is also a
reverse apostrophe (') on most keyboards that is easily confused with the single
quote. If you use the reverse apostrophe, the compiler issues an error message.

6. To use a double quote within a literal string, use the two symbols \" in a row. If
you use just a double quote, it ends the string, and the compiler then sees the
remainder of the string as an error. Similarly, to write a single quote in a char lit-
eral, use the two symbols \' without any space between them (that is, '\" is the
char literal for a single quote).

7. In an assignment statement, be sure that the identifier to the left of = is a variable
and not a named constant.

8. In assigning a value to a String variable, the expression to the right of = must be
a String expression or a literal string.

9. In a concatenation expression, at least one of the two operands of + must be of
class String.

10. Make sure your statements end in semicolons (except compound statements, which
do not have a semicolon after the right brace).

11. On most Java systems, the filename that holds the program must be the same as the
name of the class, but with the extension .java. Thus, program DateFormats is
stored in a file called DateFormats.java. Using another name produces an error
message from the compiler.

12. Be careful when using the /*  */ pair to delimit comments. If you forget the */,
then everything that follows until the end of the next /*  */ comment (or the end

Package Name

Class Name Comments

java.lang Automatically imported to every Java 
program

String
System.out Instantiated automatically

Instance Methods: print(String)
println(String)



Quick Check | 83

Summary
The syntax (grammar) of the Java language is defined by a metalanguage. In this text,
we use a form of metalanguage called syntax templates. We describe the semantics
(meaning) of Java statements in English.

Identifiers are used in Java to name things. Some identifiers, called reserved words,
have predefined meanings in the language; others are created by the programmer. The
identifiers you invent are restricted to those not reserved by the Java language. Reserved
words are listed in Appendix A.

Identifiers are associated with memory locations by declarations. A declaration may
give a name to a location whose value does not change (a constant) or to one whose
value can change (a variable). Every constant and variable has an associated data type
or class. Java provides many predefined data types and classes. In this chapter we have
examined the type char and String class. A class contains fields and methods that
describe the behavior of an object. An object is an instance of the class that describes it.

The assignment operator is used to change the value of a variable by assigning it the
value of an expression. At execution time, the expression is evaluated and the result is
stored in the variable. With the String class, the plus sign (+) is an operator that con-
catenates two strings. A string expression can concatenate any number of strings to
form a new String value.

Simple output to the screen is accomplished by using the System.out object that is
provided in Java. There are two methods defined on this object: print and println.
System.out.print("A string") prints whatever is between the parentheses on the
screen. println behaves exactly the same as print, except that println goes to the
next line after it finishes the printing.

A Java application program is a class containing one or more class declarations,
which are fields and methods. One of the methods must be named main. Execution of a
program class always begins with the main method.

Quick Check
1. Every Java program consists of at least how many methods? (p. 72)
2. Use the following syntax template to decide whether your last name is a valid

Java identifier. (p. 50)

Letter

Identifier

Letter


Digit
$

A
B
C
D
E
F
G
H
I
J
K
L
M
N
O
P
Q
R
S
T
U
V
W
X
Y
Z

0
1
2
3
4
5
6
7
8
9

a
b
c
d
e
f
g
h
i
j
k
l
m
n
o
p
q
r
s
t
u
v
w
x
y
z

Letter Digit

. . .

$



84 | Chapter 2:  Java Syntax and Semantics, and the Program Entry Process

3. Write a Java constant declaration that gives the name ZED to the value 'Z'. (pp.
62–63)

4. Which of the following words are reserved words in Java? (Hint: Look in Appen-
dix A.)

public static final  pi  float  integer  sqrt

(p. 53)
5. Declare a char variable named letter and a String variable named street.

(pp. 60–61)
6. Assign the value "Elm" to the String variable street. (pp. 60–61)
7. Write an output statement that prints the title of this book (Introduction to Java

and Software Design) on the screen. (pp. 68–69)
8. What does the following code segment output on the screen?

String str;
str = "Abraham";
System.out.println("The answer is " + str + "Lincoln");

(pp. 68–70)
9. The following program code is incorrect. Rewrite it, using correct syntax for the

comment.

String address;   / Employee's street address,
/ including apartment

(pp. 70–71)
10. Fill in the blanks in this program.

__________ class QuickCheck
{
public static void _______(String args[])
____
final _____ TITLE = "Mr";   // First part of title
String guest1;              // First guest
String guest2;            // Second guest
guest1 ____ TITLE + ". " + "Jones";
guest2 ____ TITLE + "s. " + "Smith";
System._____.print("The guests in attendance were " ______;
System.out._____(guest1 _____ " and " + guest2);

____
}

(pp. 71–72)
11. Show precisely the output produced by running the program in Question 10

above. (pp. 71–72)



Quick Check | 85

Answers

1. A program must have at least one method—the main method.
2. Unless your last name is hyphenated, it probably is a valid Java identifier.
3. private final char ZED = 'Z';
4. public, static, final, float
5. private char letter;

private String street;
6. street = "Elm";
7. System.out.print("Introduction to Java and Software Design");
8. The answer is AbrahamLincoln
9. String address;   // Employee's street address,

// including apartment

or

String address;   /* Employee's street address,
including apartment        */

10.

public class QuickCheck
{

public static void main(String args[])

{

final String TITLE = "Mr";   // First part of title
String guest1;               // First guest
String guest2;               // Second guest

guest1 = TITLE + ". " + "Jones";
guest2 = TITLE + "s. " + "Smith";

System.out.print("The guests in attendance were " );
System.out.println(guest1 + " and " + guest2);

}
}

11. The guests in attendance were Mr. Jones and Mrs. Smith



86 | Chapter 2:  Java Syntax and Semantics, and the Program Entry Process

Exam Preparation Exercises
1. Mark the following identifiers either valid or invalid.

Valid Invalid
a. item#1 ______ _______
b. data ______ _______
c. y ______ _______
d. 3Set ______ _______
e. PAY_DAY ______ _______
f. bin–2 ______ _______
g. num5 ______ _______
h. Sq Ft ______ _______

2. Given these four syntax templates:

mark the following “Dwits” either valid or invalid.

Valid Invalid
a. XYZ ______ _______
b. 123 ______ _______
c. X1 ______ _______
d. 23Y ______ _______
e. XY12 ______ _______
f. Y2Y ______ _______
g. ZY2 ______ _______
h. XY23X1 ______ _______

3. Match each of the following terms with the correct definition (1 through 15)
given below. There is only one correct definition for each term.
_____ a. program _____ g. variable
_____ b. algorithm _____ h. constant
_____ c. compiler _____ i. memory
_____ d. identifier _____ j. syntax
_____ e. compilation phase _____ k. semantics
_____ f. execution phase _____ l. block
(1) A symbolic name made up of letters, digits, underscores, and dollar signs but

not beginning with a digit
(2) A place in memory where a data value that cannot be changed is stored
(3) A program that takes a program in a high-level language and translates it

into machine code or Bytecode
(4) An input device
(5) The time spent planning a program
(6) Grammar rules

X
Y
Z

Twit

Twit . . .  Nit . . .

Twitnit

Twitnit . . . 

Dwit

X
Y
Z

Nit

TE
AM
FL
Y

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

Team-Fly® 



Exam Preparation Exercises | 87

(7) A sequence of statements enclosed by braces
(8) Meaning
(9) A program that translates assembly language instructions into machine code
(10) When the compiled version of a program is being run
(11) A place in memory where a data value that can be changed is stored
(12) When a program in a high-level language is converted into machine code

or Bytecode
(13) A part of the computer that can hold both program and data
(14) Instructions for solving a problem in a finite amount of time with a finite

amount of data
(15) Data type specifications and instructions used by a computer to solve a

problem

4. Which of the following are reserved words and which are programmer-defined
identifiers?

Reserved Programmer-Defined
a. char ______ _______
b. sort ______ _______
c. INT ______ _______
d. new ______ _______
e. Public ______ _______

5. Reserved words can be used as variable names. (True or False?)
6. In a Java program containing just one method, that method can be named either

main or Main. (True or False?)
7. If s1 and s2 are String variables containing "blue" and "bird", respectively,

what does each of the following statements print?
a. System.out.println("s1 = " + s1 + "s2 = " + s2);
b. System.out.println("Result:" + s1 + s2);
c. System.out.println("Result:  " + s1 + s2);
d. System.out.println("Result:  " + s1 + ' ' + s2);

8. Show precisely what is output by the following statement.

System.out.println("A rolling" +
"stone" +
"gathers" +
"no" +
"moss");

9. How many characters can be stored into a variable of type char?
10. How many characters are in the empty string?
11. A variable of class String can be assigned to a variable of type char. (True or

False?)
12. A literal string can be assigned to a variable of class String. (True or False?)
13. What is the difference between the literal string "computer" and the identifier

computer?



88 | Chapter 2:  Java Syntax and Semantics, and the Program Entry Process

14. What is output by the following code segment? (All variables are of class
String.)

street = "Elm St.";
address = "1425B";
city = "Amaryllis";
state = "Iowa";
streetAddress = address + " " + street;
System.out.println(streetAddress);
System.out.println(city);
System.out.println(", " + state);

15. Correct the following program so that it displays "Martin Luther King Jr."

// This program is full of errors
class LotsOfErrors;
{
void main (string[] args);
{
constant String FIRST : Martin";
constant String MID : "Luther;
constant String LAST : King

String name;
character initial;
name = Martin + Luther + King;
initial = MID;
LAST = "King Jr.";
System.out.println('Name = ' + name));
System.out.println(mid

}

Programming Warm-Up Exercises
1. Write the output statement that prints your name.
2. Write three consecutive output statements that print the following three lines.

The moon
is
blue.

3. Write declaration statements to declare three variables of class String and two
variables of type char. The String variables should be named make, model,
and color. The char variables should be named plateType and classifi-
cation. 



Programming Warm-Up Exercises | 89

4. Write a series of output statements that display the values in the variables
declared in Exercise 3. Each value should be preceded by an identifying message.

5. Change the PrintName program (page 72) so that it also prints the name in the
format

First-name Middle-initial. Last-name

Make MIDDLE a String constant rather than a char constant. Define a new
String variable to hold the name in the new format. Use the existing named
constants, any literal strings that are needed for punctuation and spacing, and
concatenation operations to create the new string. Print the string, labeled
appropriately.

6. Print the following groups of text.

a. Four score
and seven years ago

b. Four score
and seven
years ago

c. Four score
and
seven
years ago

d. Four
score
and
seven
years
ago

7. Enter and run the following program. Be sure to type it exactly as it appears
here.

//*************************************************************
// HelloWorld program
// This program displays two simple messages
//*************************************************************
public class HelloWorld
{
public static void main(String[] args)
{
final String MSG1 = "Hello world.";
String msg2;



90 | Chapter 2:  Java Syntax and Semantics, and the Program Entry Process

System.out.println(MSG1);
msg2 = MSG1 + " " + MSG1 + " " + MSG1;
System.out.println(msg2);

}
}

Programming Problems
1. Write a Java application that displays a series of Haiku poems. A Haiku poem is

written in three phrases. The first phrase has five syllables, the second has seven
syllables, and the last phrase again has five syllables. For example:

Bright flash then silence
My expensive computer
Has gone to heaven

Your application should define string constants with four phrases of five sylla-
bles and two phrases of seven syllables. Use string concatenation expressions to
construct every possible 5–7–5 permutation of these phrases and display each
one. Do not use the same phrase twice in any poem. See if you can create
phrases that make sense together in every permutation. Be sure to include appro-
priate comments in your program, choose meaningful identifiers, and use inden-
tation as we do in the programs in this chapter.

2. Write an application that simulates the child’s game “My Grandmother’s Trunk.”
In this game, the players sit in a circle, and the first player names something that
goes in the trunk: “In my grandmother’s trunk, I packed a pencil.” The next
player restates the sentence and adds something new to the trunk: “In my grand-
mother’s trunk, I packed a pencil and a red ball.” Each player in turn adds some-
thing to the trunk, attempting to keep track of all the items that are already
there.

Your application should simulate just five turns in the game. Starting with
the empty string simulate each player’s turn by concatenating a new word or
phrase to the existing string, and print the result.

3. Write a program that prints its own grading form. The program should output
the name and number of the class, the name and number of the programming
assignment, your name and student number, and labeled spaces for scores
reflecting correctness, quality of style, late deduction, and overall score. An
example of such a form is the following:

CS–101 Introduction to Programming and Problem Solving

Programming Assignment 1

Sally A. Student   ID Number 431023877

Grade Summary:



Program Correctness:      Quality of Style:
Late Deduction:           Overall Score:
Comments:

Case Study Follow-Up Exercises
1. Change the DateFormats program so that the four formats are shown in the

opposite order on the screen.
2. In the DateFormats program, explain what takes place in the statement that

assigns a value to the string variable third.
3. Change the DateFormats program so that the third and fourth formats use

hyphens (-) instead of slashes (/).
4. Change the DateFormats program so that your birth date is displayed in the

four formats.

Case Study Follow-Up Exercises | 91





                 

To be able to construct a code segment that creates
a window on the screen.

To be able to construct a code segment that displays
a message in a window on the screen.

To be able to use a layout manager to organize mes-
sages in a window.

To be able to invoke a method.

To be able to use a constructor to instantiate an
object.

To be able to determine what is displayed by a given
code segment.

To be able to write an event listener for a window-
closing event.

Event-Driven Output
G

oals



94 | Chapter 3:  Event-Driven Output

In the last chapter, we looked at the components that make up a program: classes,
fields, and methods. We described the object that Java provides for writing simple infor-
mation on the screen (System.out). In this chapter we look at two fundamental capa-
bilities that Java provides. The first is the ability to create a window on the screen and
display information in the window, and the second is the ability to recognize and han-
dle an asynchronous event—the closing of a window.

3.1 Classes and Methods
In Chapter 1, we defined an interface as a connecting link at a shared boundary that
allows independent systems to meet and act on or communicate with each other. In this
chapter we use an interface: The independent systems are the computer and you the
programmer. The shared boundary is the screen, and the link is the set of capabilities
that Java provides for writing information on the screen.

Java supports many different classes of windows and interface components. In fact,
entire books have been written just to explain all of the features that Java supports for
output. In this text, we use a very simple subset of Java’s capabilities. Once you thor-
oughly understand the basics, you can easily learn about Java’s other interface features
on your own.

Frames

The type of window that we use in this text is called a frame. It has all of the basic fea-
tures that you are used to seeing in a window on a personal computer: the ability to
change size, to be closed, to be turned into an icon (a small pictorial representation of
the window), and so on. Our programs won’t support all of these features. When you try
to click on one of them, the window may simply do nothing in response. In later chap-
ters, we show you how to handle more of a frame’s features in your programs.

To use a frame for output in Java, your program must perform seven steps:

1. Import the package containing the Frame class from Java’s library.
2. Declare a variable of class Frame.
3. Ask Java to create an instance of class Frame (an object) and assign it to the variable.
4. Specify a layout manager for the Frame object.
5. Add output to the Frame object.
6. Pack the Frame object (adjust its size to fit the output it contains).
7. Show the Frame object on the screen.

In the remainder of this section we examine each of these steps in turn. Along the
way, we also review the syntax and semantics for calling a method in Java, and we
show you how to use additional types that Java defines for output.



3.1 Classes and Methods | 95

Packages In order to access the tools that you need to create and manipulate a
window, you must import some classes available in a Java package. Here is the syntax
diagram for a such declaration:

As the template shows, an import declaration begins with the keyword import, the
name of a package and a dot (period). Following the period you can either write the
name of a class in the package, or type an asterisk (*). The declaration ends with a
semicolon. If you know that we want to use exactly one class in a particular package,
then you can simply give its name (Class-name) in the import declaration. More often,
however, you’ll want to use more than one of the classes in a package, and the asterisk
is a shorthand notation to the compiler that says, “Import whatever classes from this
package that this program uses.”

Why would you ever want to use the first form, when the asterisk has the same effect
and is easier to type? The answer is that the first form documents the specific class that you
intend to use, and it causes the compiler to warn you if you mistakenly attempt to use
some additional class from the package. In this text the asterisk typically is used instead of
the Class-name, but a comment is used to document the class(es) being imported.

For example, the Frame class is contained in the Java package called awt (which
stands for abstract window toolkit). Many of Java’s library packages are contained in
the master package called java, which we mentioned previously. Java requires us to
indicate that awt is part of the java package; we do this by writing the two names
joined by a period in our import declaration:

import java.awt.*;   // Supplies Frame class for output display

Declaring and Instantiating a Frame Object Once you have imported the Frame class,
you can declare a variable of type Frame the same way that you declare a char or
String variable:

Frame outputDisplay;  // A variable of class Frame

Recall that an object is an instance of a class. This declaration says to set aside a
place in memory called outputDisplay that is to contain an object of class Frame.
Like any other variable, the variable called outputDisplay is empty until you assign it
a value. What sort of value is assigned to a Frame field? The answer to this question is
both trivial and deep: A Frame object is assigned. The answer is trivial because it seems
so obvious, like the answer to the question “Who is buried in Grant’s tomb?” In practice,

ImportDeclaration

import PackageName. ;

ClassName

*



96 | Chapter 3:  Event-Driven Output

it is really that simple. You can just write the following assignment statement using the
new operator:

outputDisplay = new Frame();

Java then instantiates a new object of class Frame and assigns it to outputDis-
play. The answer to our question is deep because the actual contents of a Frame object
are quite complex. You could read a biography of President Grant as one way of know-
ing who is buried in his tomb. Likewise, you could read all of the source code in the awt
package to learn how Frame objects work. Fortunately, Java makes it unnecessary for
you to do this through the principle of abstraction: You don’t have to understand what
makes Frame objects work in order to use them.

The Frame that is referenced by outputDisplay is an empty window that is
waiting to be filled and then shown on the screen. You fill it by adding display ele-
ments to it.

How does Java know where the elements should be placed within the window? You
can either tell it manually or let Java handle their layout automatically. Manual place-
ment of elements allows you to precisely control the appearance of output within the
window, but it requires that you compute the location of each element and specify it in
your program. We take the simpler approach of letting Java handle the layout auto-
matically.

Because Java provides several different styles of
automatic layout, you have to indicate which one to
use. The style of layout is determined by specifying
the name of a layout manager through a method asso-
ciated with the Frame object assigned to outputDis-
play. The method is called setLayout.

Method Invocation

Recall that methods are subprograms that are called upon to perform some predefined
set of actions. You can use the print and println methods to print strings on the
screen. Using object-oriented terminology, we say that we are sending messages to an

object called System.out. Technically, we say that
we are calling methods associated with the object.

A call to a method is another form of executable
statement in Java. You can write the call statement
simply by specifying the name of the method, fol-
lowed by a list of parameters enclosed in parentheses.
The parameters to print and println are the strings
to be printed. We say that the parameters are passed
to a method.

Layout manager A class that automatically manages
the placement of display elements within a window on
the screen

Call A statement that causes a method to be executed.
In Java, a method is called by writing its name, followed
by a list of parameters enclosed in parentheses.

Parameter An expression used for communicating
values to a method

TE
AM
FL
Y

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

Team-Fly® 



3.1 Classes and Methods | 97

In a call, the method name may or may not have to be appended to an object name
with a dot in between. (We explain these different forms of a call statement shortly.)

The effect of the call is to cause control of the computer to jump to the instructions
in the method, which make use of the values given to it as parameters. Control of the
computer returns to the statement following the call when the method has completed its
task.

Here is the syntax template for a call statement.

In Java, methods come in three flavors: instance methods, class methods, and
helper methods. Instance methods are associated with individual objects. Class methods
are associated with classes. Helper or auxiliary methods are subprograms within a class
that help other methods in the class. Instance methods are covered here.

When you create an object of a given class, it has a set of instance methods associ-
ated with it. Because there can be more than one object of a given class, you must also
identify the object when you call the method. In object-oriented terms, you must desig-
nate the object to which the message is being sent. The object name is appended in front
of the method name with a dot in between. In the following call

System.out.println("Good morning.");

System.out is the name of the object with which the println method is associated.
As you examine the template, you should note that the parameters in a call are

optional, but the parentheses are required. You sometimes write call statements of the
form

myObject.methodName();

in which there are no parameters.
After a method’s job is done, control passes to the next statement after the call. This

form of method call is used as a separate statement in the code. Methods that are used
in this way are called void methods. In the
next chapter we examine a different form of
method call that is written within an expres-
sion to compute a value as part of evaluating
the expression.

The setLayout method takes one
parameter, a layout manager object. A layout manager is another of Java’s classes that
you instantiate with the use of new, just as you did to create a new Frame object. Let’s

ObjectName.MethodName ( parameter , parameter           ) ;

Call

. . .

Void method A method that is called as a separate
statement. The method does not return a value.



98 | Chapter 3:  Event-Driven Output

use the simplest of Java’s layout managers, called FlowLayout. Thus, a call to the set-
Layout method associated with the Frame object outputDisplay is written as follows

outputDisplay.setLayout(new FlowLayout());

The FlowLayout manager’s responsibility is to automatically place elements that
you add to a frame in the order that you add them. The first element goes in the upper-
left corner of the window, and the next element goes to the right of it, on the same line.
When there is no more room left on a line, the manager moves to the next line in the
window and continues adding elements there.

Let’s review the steps covered so far.

import java.awt.*;             // Supplies Frame class for output display

:

Frame outputDisplay;           // Declare a variable of class Frame
outputDisplay = new Frame();  // Assign the variable a new Frame object
// Call the setLayout method associated with outputDisplay
// An object of class FlowLayout is passed as a parameter
outputDisplay.setLayout(new FlowLayout());

It is important to note that we can instantiate an object within a parameter list. The
parameter of setLayout is an object of type FlowLayout created by new.

Putting Elements in the Window We have now seen how to import the Frame class,
declare a Frame variable, instantiate a Frame object, and specify the layout manager

for the frame. A frame is called a container class
because you can add elements into it. The remaining
steps are to add elements to the frame, pack the frame,
and show it on the screen. All of these steps involve
additional instance method calls.

Initially, we just add elements called labels to our
frames. A label is a block of text that is placed into the frame. We can add the label to
the frame using the add instance method. Here is an example:

outputDisplay.add(new Label("This is the text in the label. "));

The add method places a new object into the frame.
We can also declare a variable to be of class Label, assign it a value, and pass the

variable as a parameter to the add method, as shown below.

Label someLabel;
someLabel = new Label("This is the text in the label. ");
outputDisplay.add(someLabel);

Container class A class into which you can add other
elements



3.1 Classes and Methods | 99

1A class method can have any name, but when its name is the same as the class containing it, then it is also a
constructor.

The first way of adding a label to a frame is simpler. But when you need a label
that can be added to a frame at multiple points in a program, it’s easier to declare and
instantiate it separately. Then, you can add it to the frame at any point in the program
simply by writing:

outputDisplay.add(someLabel);

Constructors In the example in the last section, you used the new operation to create
an object of class Label within the parameter list of the add method call:

outputDisplay.add(new Label("This is the text in the label. "));

Once again, because of Java’s use of abstraction, you don’t need to know the details
of what a Label object contains. You can simply accept that it has been properly
defined in the Java library and that the add method uses it appropriately.

You might notice that the portion of the parameter list following new looks very
similar to a method call: It is an identifier followed by a value within parentheses. That
is because it is really a call to a special
method, known as a constructor, that is part
of every class. The constructor for a given
class is called whenever a new object of that
class is created, and its purpose is to provide
the instructions the computer follows in
instantiating the object.

Constructors are class methods with the special feature that they have the same
name as the class.1 In the case of the constructor for the Label class, there is one
parameter, a string that specifies the text to appear in the label.

If you look back through this section, you should now recognize that we have used
two other constructors: Frame() and FlowLayout(). Both of these constructors have
empty parameter lists.

The capitalization of constructor names doesn’t follow our usual rule of starting a
method name with a lowercase letter. The reason is that the Java library uses the con-
vention that class names begin with an uppercase letter, and the constructor name must
be spelled exactly the same as the name of the class that contains it.

The call to the constructor method isn’t preceded by an object name. The reason is
that the constructor is a class method not an instance method; it is associated with the
class itself, rather than with an object. This makes sense if you stop to consider that the
constructor is used to create an object before it is assigned to a field. Thus, it can’t be
associated with a particular object name.

Constructor A method that has the same name as
the class containing it; this method is called whenever
an object of that class is instantiated



100 | Chapter 3:  Event-Driven Output

Only two steps remain to cause our frame to be displayed on the screen. You must
pack it by calling a method that adjusts its size to fit its contents. And you must call a
method to show it on the screen. These two method calls are quite simple:

outputDisplay.pack();
outputDisplay.show();

As you can see by the way that the calls are written, they are both void methods. Now
let’s put all the pieces together to show their relationship to each other. Our list of seven
steps is repeated here within the comments in the code.

import java.awt.*;   // Import the package containing the Frame class

public class FrameExample ...

private static Frame outputDisplay;  // Declare a field of class Frame

final String WORDS = "Java and Software Design";
...
// Create a new instance of class Frame and assign it to outputDisplay
outputDisplay = new Frame();  

// Specify a layout manager for the frame object
outputDisplay.setLayout(new FlowLayout());

// Add output to the frame object
outputDisplay.add(new Label("The title of this book is "));
outputDisplay.add(new Label("Introduction to " + WORDS));

// Specify a layout manager for the frame object
outputDisplay.pack(); // Pack the frame (adjust its size to fit the output)
outputDisplay.show(); // Show the frame on the screen
...

The ellipses (. . .) in this code segment indicate pieces of the Java program that are yet to
be filled in. Let’s now put all these steps together into a program. Let’s redo the program
that prints Mr. Herrmann’s name in two formats, but let’s use a window that the pro-
gram constructs rather than using System.out.

//******************************************************************
// PrintName program
// This program prints a name in two different formats
//******************************************************************
import java.awt.*;    // Contains Frame class
public class PrintName
{
public static void main(String[] args)



3.1 Classes and Methods | 101

{
final String FIRST  = "Herman";    // Person's first name
final String LAST   = "Herrmann";  // Person's last name
final char   MIDDLE = 'G';        // Person's middle initial
Frame outputDisplay;               // Declare frame object

String firstLast;                 // Name in first-last format
String lastFirst;                   // Name in last-first format

outputDisplay = new Frame();              // Create a Frame object
outputDisplay.setLayout(new FlowLayout()) // Specify layout manager

firstLast = FIRST + " " + LAST;
outputDisplay.add (new Label("Name in first-last format is "

+ firstLast));

lastFirst = LAST + ", " + FIRST + ", ";
outputDisplay.add(new Label("Name in last-first-initial format is "

+ lastFirst + MIDDLE + "."));

outputDisplay.pack();
outputDisplay.show();

}
} 

The output screen from this program is shown on page 105.

Background Information
The Origins of Java

If we were to chart the history of programming languages, we would find several distinct fam-
ilies of languages that have their origins in the early days of computing. When the idea of
high-level languages first arose, it seemed that everybody had their own notion of the ideal
form for a programming language. The result is known as the Tower of Babel period of pro-
gramming languages. As more programs were written, the cost of rewriting them to use the
features of a new language increased, and the computing world concentrated on a few lan-
guages. These included FORTRAN, Algol, COBOL, Basic, PL/1, Lisp, and BCPL.

As computers were used in more sophisticated ways, it was necessary to create more pow-
erful languages. In many cases, these new languages were just expanded versions of older lan-
guages. Expanding a language allows older programs to be used unchanged, but enables 

tcontinued



102 | Chapter 3:  Event-Driven Output

programmers to add to programs using the language’s new features. This strategy is known as
upward compatibility. A good example is the FORTRAN series that began with FORTRAN, then FOR-
TRAN II, FORTRAN IV, FORTRAN 77, FORTRAN 90, and now High Performance FORTRAN.

Sometimes, however, different extensions to a language result in excess complexity. The solution
is to redesign the language to eliminate conflicting features while preserving its desirable qualities.
For example, Pascal replaced the Algol language series and was itself superseded by the Modula
series of languages. Java is a redesign of languages derived from BCPL (Basic Combined Programming
Language).

In the 1960s, BCPL had a small but loyal following, primarily in Europe. From BCPL, another lan-
guage arose with its name abbreviated to B. In the early 1970s, Dennis Ritchie, working on a new
language at AT&T Bell Labs, adopted features from the B language and decided that the successor to
B naturally should be named C.

In 1985 Bjarne Stroustrup, also of Bell Labs, invented the C++ programming language. To the C
language he added features for object-oriented programming. Instead of naming the language D, the
Bell Labs group named it C++ in a humorous vein. As we see later, ++ signifies the increment opera-
tion in the C, C++, and Java languages. Given a variable x, the expression x++ means to increment
(add 1 to) the current value of x. Therefore, the name C++ suggests it is the successor of the C lan-
guage.

C includes many features that are close to the level of machine code, allowing programmers to
write detailed instructions for the computer. C++ adds features that enable programmers to write
instructions at a very powerful and abstract level that is far removed from machine language. If used
with care, this combination of features enables programmers to “shift gears” between easily pro-
gramming complex operations and writing instructions that are close to machine code. However,
many people find it difficult to keep the features separate and view the combination as fraught with
potential for introducing errors.

In the early 1990s, James Gosling, working at Sun Microsystems, needed a language for program-
ming microprocessors being used in consumer electronics (for example, digital cameras). Like Strous-
trop, he began with C but decided to eliminate features that would conflict with the structures that
he was adding. The Algol family of languages, as well as several experimental programming lan-
guages inspired some of the new features. He called his language Oak, and spent several years exper-
imenting with it and refining it. When the popularity of the Internet began to grow, Gosling worked
with a team of designers at Sun to adapt Oak for writing programs that could operate over the net-
work. The revised language was renamed Java and released to the public in May of 1996.

Java achieves many of the capabilities of C++ in a less complicated fashion. It supports program-
ming for the Internet and writing programs with graphical user interfaces that are now the standard
for interactive I/O. In addition, Java programs are highly portable. These features combined to cause
the popularity of Java to skyrocket in the first year after it was released. It is very rare for a new pro-
gramming language to appear and achieve popularity so quickly. Because Java is powerful yet simple,
it has also become popular as a language for teaching programming.

The Origins of Java



3.2 Formatting Output | 103

Named	 Numbered
August 18, 2001	 8/18/2001
18 August 2001	 18/8/2001

Figure 3.1 A grid layout with three rows and two columns

3.2 Formatting Output
To format a program’s output means to control how it appears visually on the screen or
on a printer. In the last section we used the layout manager called FlowLayout to
arrange our output on the screen. In this section, we introduce another layout manger,
called GridLayout, and examine how to align text within labels.

Using GridLayout for Tabular Output

We introduced FlowLayout as the simplest of Java’s layout managers. The advantage
of FlowLayout is that it entirely manages the placement of labels as we add them to a
frame. This simplicity is convenient, but it also prevents us from controlling the appear-
ance of output on the screen. For example, in the Case Study at the end of this chapter
we display a date in various formats. We do not have the option of telling FlowLayout
to place each date on a separate line. If we use the GridLayout manager, however, we
gain the ability to control the position of a label with respect to others in the frame.

GridLayout works much the same as FlowLayout in that we simply add labels to
the frame, and the layout manager places them consecutively into the available space.
The only difference is that GridLayout partitions the frame into a fixed number of
rows and columns—a rectangular grid. Starting with the top row and the leftmost col-
umn, GridLayout fills successive columns, moving to the next row when it has filled
every column on the row. Every column is the same size as every other column, and the
rows are also equal in size. Figure 3.1 shows a frame with a 3 3 2 grid.

To specify GridLayout as the manager for the frame, you must provide the con-
structor with a pair of integer parameters that determine the number of rows and
columns in the frame. If one of the parameters is zero, then that dimension isn’t speci-
fied and the grid grows as needed in that direction to accommodate the contents of the
frame. The first parameter is the number of rows and the second parameter is the num-
ber of columns.



104 | Chapter 3:  Event-Driven Output

For example, if we are printing dates in two columns as shown in Figure 3.1, the layout
is specified with a method call to setLayout as shown here.

dateWindow.setLayout(new GridLayout(3, 2));   // 3 rows and 2 columns

If you wanted the dateWindow frame to have two columns and an arbitrary num-
ber of rows, you would write the call with the first parameter to the GridLayout con-
structor being zero.

dateWindow.setLayout(new GridLayout(0, 2));  // Any # of rows of 2 columns

Using zero for the number of columns (the second parameter) would allow Grid-
Layout to partition the frame into any number of columns. The number it chooses
depends on the size of the largest label (since all columns are equal in size) and the
number of these labels that can fit horizontally on the screen. Because this could lead to
some rather strange column configurations, it is more common for the user to specify
the number of columns. The most common use of GridLayout is to display a table of
values, often with a text label at the top of each column (called a column heading) that
explains what is contained in the column. Figure 3.1 uses the column headings “Named”
and “Numbered.”

Alignment of Text within Labels

By default, the text within a label begins at the left edge of the label. Sometimes, how-
ever, you’ll want to center the text within the label or have it appear as far to the right
as possible within the label. Java allows you to do this by providing a second parameter
for use when calling the Label constructor. The parameter can be any of three prede-
fined constants that are imported with the Label class. The constants are Label.LEFT,
Label.CENTER, and Label.RIGHT. For example, if you want the column heading
“Named” in Figure 3.1 to be centered, you would write:

dateWindow.add(new Label("Named", Label.CENTER));

If instead you write

dateWindow.add(new Label("Named", Label.RIGHT));

then the text would be positioned as far to the right as possible within the label.
Because the usual position for text is toward the left, you rarely need to use
Label.LEFT. Figure 3.2 shows the result of centering the headings from the example in
Figure 3.1.



3.3 Handling Events | 105

	 Named		 Numbered
August 18, 2001	 8/18/2001
18 August 2001	 18/8/2001

Figure 3.2 A grid with centered headings in the first row

3.3 Handling Events
If you enter the PrintName program on page 100 into the computer and run it, the
result is a window like that shown here. Compare this window with the one from the
version of PrintName in Chapter 2.

If you run this application yourself, you discover that the window just stays there.
Nothing you do, short of using an operating system command to stop the program,
makes it go away. The situation that now exists between you and the computer is anal-
ogous to asking someone what time it is, only to have them hold their watch in front of
your face, refusing to take it away. We’re able to get the computer to tell us its results,
but it does so with rather poor manners.

Typically, a user would expect to make the window go away by closing it. On most
systems, closing a window is a matter of clicking on some symbol at the top of the win-
dow. However, this has no effect on your frame because your program doesn’t contain
any instructions that tell the computer what to do when the user clicks with the mouse.

Recall from Chapter 1 that one of the
control structures in a Java program is asyn-
chronous control. A mouse click is an action
that can trigger the program to perform a set
of instructions at any time during its execu-
tion. That is why it is called asynchronous,
which means not connected with a specific
moment in time. The program can be busily
working away performing some operation; you can choose that random moment to
click the mouse. The program has to stop what it is doing and transfer control to the

Asynchronous Not occurring at the same moment in
time as some specific operation of the computer. In
other words, not synchronized with the program’s
actions.



106 | Chapter 3:  Event-Driven Output

instructions that take care of the mouse click. Once it has responded to your action,
control returns to the program at the point at which it was interrupted. In Java, a user
action of this form is called an event, and responding to it is called event handling

Events are handled by special methods called event
handlers.

The event-handling process sounds very much
like calling a method, but there is a basic difference.
A method call is a statement in our program that calls
the method at a specific point in the program’s
execution. An event handler, on the other hand, can
implicitly be called at any time, and there is no corre-
sponding method call statement anywhere in the pro-
gram. How then is the event handler called?

The answer is that there are objects called event
listeners whose purpose is to watch for (i.e., listen for)
events to occur and respond to them. An object that
generates an event is called an event source. When an
event source generates an event, we say that the
source is firing the event. Every event source keeps a
list of the listeners that want to be notified when that
kind of event occurs. Letting an event source know
that a listener wants to be notified is called registering
the listener.

Each listener has one or more methods that are designed to respond to (handle)
events. These listeners are waiting in the background, watching diligently for events to
occur. When an event occurs, the appropriate listeners are notified and the appropriate
event handlers are invoked. When the event handler returns (method finishes execut-
ing), the program continues executing. Figure 3.3 illustrates the process. If there is no
listener that is interested or the interested listener doesn’t have an event handler for that
particular type of event, the event is ignored and the program continues uninterrupted.

Because program PrintName doesn’t have an event listener with an event-handling
method for the window-closing event, it just ignores our attempt to close the window
and continues to show us the frame. You need to add an event listener with a handler
method to the program so that it behaves with better manners.

3.4 Register an Event Listener
As we’ve already said, an event handler is a method of the listener object. But how do
you tell the event source that the listener wants to be notified when the event occurs?
The answer is that you have to register the listener with the event source object. To put
this in more familiar terms, let’s look at an analogy.

Suppose you are traveling and have told a friend to call you, and you give her the
phone number of your hotel. She calls the hotel and the hotel operator answers. Your
friend asks for you and the operator connects the call to your room phone. In this
analogy, your friend is an event source, the operator is the event listener, and your

Event An action, such as a mouse click, that takes
place asynchronously with respect to the execution of
the program

Event handling The process of responding to events
that can occur at any time during execution of the
program

Event handler A method that is part of an event lis-
tener and is invoked when the listener receives a corre-
sponding event

Event listener An object that is waiting for one or
more events to occur

Event source An object that generates an event

Firing an event An event source generating an event

Registering the listener Adding the listener to an
event source object’s list of interested listeners

TE
AM
FL
Y

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

Team-Fly® 



3.4 Register an Event Listener | 107

room phone is the event handler. By giving the number to your friend, you registered
the listener with the event source.

The hotel has multiple guests and takes many calls, with the operator directing
each call to the proper room. In the same way, a single event listener can have multiple
event-handler methods for different kinds of events. When the event listener is
invoked, it is passed an object of one of Java’s Event classes. The Event object
includes a method that the event listener can call to determine the specific type of
event that has occurred, and from that information the listener decides which of its
event handlers to call. Figure 3.4 illustrates this analogy.

Registering an event listener is accomplished by calling a method associated with
the event-source object. By convention, the method that registers a listener is add plus
the listener name. The listener for window events is WindowListener, so the method to
register the listener is addWindowListener. Registering the listener in program Print-
Name would be done as follows.

outputDisplay.addWindowListener(myListener);

Window
Closing
Opened


 
Mouse motion

Moved
Dragged


 
Key

Pressed
Released


Firing
an Event

Event HandlerEvent Listener

Event Source

Program on Hold

public void windowClosing ( )
{ ...}

public class PrintName ... 

public static void main ( ...  )
{



}

The point of execution when
the event occurred, and where
execution resumes when the
event handler returns

.
.
.

.
.
.

.
.
.

Figure 3.3 Event handling



108 | Chapter 3:  Event-Driven Output

Event Sources Event Handlers

#5551212

Event Listener

Registering Listener with Source

Figure 3.4 An analogy representing the event-listener registration and calling process

Notice that the parameter is an object of class WindowListener that is registered
with the event. This class defines the methods that handle the various window events.
Java recognizes seven different kinds of window events, so the WindowListener class
contains a handler (method) corresponding to each of these events. Each of the seven
methods has a specific name that the event source recognizes. Here you are just inter-
ested in the one that closes the window, called windowClosing. The addWindow-
Listener method registers the WindowListener object with the outputDisplay
Frame object. But you still must write the windowClosing event handler, which is a
method in the WindowListener class.

3.5 Event-Handler Methods
On the surface, writing a method called windowClosing sounds quite simple. Just as
you wrote a method named main that the JVM recognizes as the place to start execu-
tion, you can write a method with a special name that the event listener recognizes. The
problem is that the method has to be part of a user-defined class, and we won’t look at
how to write our own nonapplication classes until Chapter 7. Also, the class must
include methods for all seven types of window events. It’s inconvenient to have to write
seven methods when you just want to handle one specific event. Fortunately, Java pro-
vides a pair of shortcuts that solve these problems.

The first shortcut is a predefined class called WindowAdapter. An object of type
WindowAdapter can be used in place of an object of type WindowListener. A



3.5 Event-Handler Methods | 109

WindowAdapter object automatically supplies empty shells for all seven of the window
event-handler methods. For example, you can write:

outputDisplay.addWindowListener(new WindowAdapter());

If you pass a WindowAdapter object as a parameter when you register the listener,
the listener can call these seven empty methods. Calling an empty method has the same
effect as having no event handler at all, so the use of WindowAdapter would be point-
less if it wasn’t for the second shortcut that Java provides.

When you use new to create an object of class WindowAdapter, Java allows you to
follow the call to the constructor with a block containing declarations that are effec-
tively added to the object.

outputDisplay.addWindowListener(new WindowAdapter()
{declaration block});

If you write a method declaration in the block using the same name as one of the
methods supplied by WindowAdapter, then your method replaces it. The other empty
methods aren’t replaced, so the effect is that addWindowListener is passed a Win-
dowAdapter object that has all of the required methods. Six of those methods still do
nothing (because you aren’t explicitly handling those events), and the seventh contains
our code for responding to closing of the window.

Look carefully at the following code segment that illustrates how you write an
event handler. Notice that the declaration block is contained within the parameter list of
the call to addWindowListener, immediately following the call to the constructor for
WindowAdapter.

outputDisplay.addWindowListener(   // Within the parameter list
new WindowAdapter()  // Create object of type WindowAdapter

{ // Start a block of declarations to add to the WindowAdapter

// Here we write a method to replace WindowAdapter's
//  empty windowClosing method
public void windowClosing(WindowEvent event)
{
outputDisplay.dispose();  // Remove the window from the screen
System.exit(0);           // Stop the program

}                           // End of the method
// End of the declaration block and end of addWindowListener parameters
});                             

Figure 3.5 shows the relationship between the method written in the code, the Win-
dowAdapter object, the addWindowListener method, the WindowListener, and the
WindowEvent object. Once the modified WindowAdapter is received, the event listener
is able to call the method whenever a window closing event occurs.



110 | Chapter 3:  Event-Driven Output

{
public void windowClosing(WindowEvent event)
{
outputDisplay.dispose();
System.exit(0);

}
}

Our method replaces corresponding
method in WindowAdapter

Modified WindowAdapter is
passed to addWindowListener

addWindowListener
registers modified
WindowAdapter with
Event Source

Event
Source

Window
…

Mouse-
Motion
…

Key
…

addWindowListener(WindowListener)

WindowAdapter

void windowOpened()  {}

void windowClosing() {}

void windowClosed()  {}

void windowIconified()  {}

void windowDeiconified()  {}

void windowActivated()  {}

void windowDeactivated()  {}

Figure 3.5 An event handler is added to an event listener, and the event listener is registered with an event source.

The heading of the windowClosing method shows that it has to accept a parameter
of type WindowEvent that is passed to it by the event source. The value that the event
source assigns to the parameter includes the name of the window associated with the
event. Java makes it possible for programs to have multiple windows that are distin-
guished by different names, but because you are using just one window in the program,
you can ignore the value in the parameter at this point.

Notice also that the heading begins with the modifier public. It is being declared
within the WindowAdapter class, and so it must be public to be accessible outside of
that class. In the body of the method you can find two method calls. The first, dispose,
simply removes the window from the screen. The second, System.exit is a special
Java method that tells the JVM that the program is finished. Zero is passed to Sys-
tem.exit to indicate to the JVM that no problems were encountered. If any other value
is passed, the JVM displays a warning message that the program ended with an abnor-
mal condition.

Let’s see how the event handler fits into program PrintName. There is one other
detail that we need to take care of first, however. The classes for handling events are
contained in a separate package called java.awt.event. Thus, you must add a second
import declaration to the start of the program. Otherwise, it is just a matter of inserting
our event-handling code at the end of main.



3.5 Event-Handler Methods | 111

//******************************************************************
// PrintName program
// This program prints a name in two different formats
//******************************************************************
import java.awt.*;                          // Import Frame type, etc.
import java.awt.event.*;                    // Import event handling types

public class PrintName
{
private static Frame outputDisplay;          // Declare Frame variable
public static void main(String[] args)
{
final String FIRST  = "Herman";          // Person's first name
final String LAST   = "Herrmann";          // Person's last name
final char   MIDDLE = 'G';               // Person's middle initial

String firstLast;                         // Name in first-last format
String lastFirst;                         // Name in last-first format

outputDisplay = new Frame();               // Create new Frame object
outputDisplay.setLayout(new FlowLayout()); // Specify layout manager

firstLast = FIRST + " " + LAST;
outputDisplay.add(new Label("Name in first-last format is " +

firstLast));

lastFirst = LAST + ", " + FIRST + ", ";
outputDisplay.add(new Label("Name in last-first-initial format is " +

lastFirst + MIDDLE + "."));
outputDisplay.pack();                      // Pack the frame
outputDisplay.show();                     // Show the frame on the 

//  screen
// Event handler for window closing
outputDisplay.addWindowListener(new WindowAdapter()
{
public void windowClosing(WindowEvent event)  // Replacement method
{
outputDisplay.dispose();                  // Remove the window

//  from the screen
System.exit(0);                             // Stop the program

}
});

}
}



112 | Chapter 3:  Event-Driven Output

The output from this version of PrintName looks identical to the earlier version.
When we click on the icon for closing the window, however, it politely vanishes and the
program halts its execution.

Notice that a method, windowClosing, has been declared as part of creating a new
(nameless) object that is an instance of class WindowAdapter. The windowClosing
method is being added to the WindowAdapter class just for this specific object instanti-
ation. If you think of the class like the blueprint for building a house, and the new oper-
ator as being the actual construction of the house from the blueprint, then the
declaration of windowClosing is like customizing a standard blueprint for the con-
struction of a specific house.

Before we leave this example, there is one additional change that we made from the
prior version that requires some explanation. The declaration of the Frame variable has
been moved from within main to a point preceding main, and we’ve added the modi-
fiers private and static. The reason for this move is that windowClosing cannot
refer to variables declared within main, even though it appears inside of main itself.
What really happens is that the Java compiler discovers that windowClosing is being
added to the WindowAdapter class. Thus, windowClosing effectively becomes part of
WindowAdapter, which is outside of main. If we declare the Frame variable within
main, then it can be accessed only from within main. So we must declare it outside of
main to enable windowClosing to use it.

When it is declared outside of main, the Frame variable becomes one of the class
declarations, just like main. Also, as with main, we use the static modifier. Unlike
main, however, there is no reason for the JVM to access the Frame variable, so we
declare it private instead of public.

Problem-Solving Case Study
Display a Date in Multiple Formats

Problem You are beginning to work on a program that needs to output dates in several
formats. As a start, you decide to write a short Java application that takes a single date and
displays it in the different formats, so you can be certain that all of your string expressions are
correct. Does this sound familiar? It should, this is the beginning of the Case Study for Chapter
2. However, there are added constraints: There should be labels showing how the date is
written next to the example. The output should be in two columns, with the first column
labeled “Format” and the second labeled “Example.”



Problem-Solving Case Study | 113

Output A window showing the date in four formats:

Format Example

Month day, year August 18, 2001
day Month year 18 August 2001
mm/dd/yyyy 8/18/2001
dd/mm/yyyy 18/8/2001

Discussion To organize the screen as this problem requires means that we must use a Frame
object rather than System.out to create the output. The design we used in the original
problem can be used to create the date strings, but we must write the labels for each date. In
order to line them up in two columns, we should use GridLayout with five rows and two
columns. The first row is the label for each column. We must add a Frame variable to the list
of variables and instantiate the Frame object. Otherwise, the design remains the same until
we reach the Display the Dates algorithm.

Set Up FrameObject

Display the Labels

Display the Dates

Add label Month day, year
Add label first
Add label day Month year
Add label second
Add label mm/dd/yyyy
Add label third
Add label dd/mm/yyyy
Add label fourth

Add label “Format”
Add label “Example”

Frame outDisplay = new Frame();

outDisplay.setLayout(new GridLayout(5, 2)



114 | Chapter 3:  Event-Driven Output

In the first version, we were not using a frame, so we didn’t need to close the window. Here,
however, we do. We can use the code for addWindowListener directly from this chapter.

//******************************************************************
// DateFormats program
// This program prints a date in four different formats by
//  building strings up from the component parts of the date
//  using string concatenation expressions
//******************************************************************
import java.awt.*;
import java.awt.event.*;
public class DateFormats
{
public static Frame outDisplay;       // Declare a frame variable
public static void main(String[] args)
{
final String MONTH_NAME = "August"; // The name of the month
final String MONTH_NUMBER = "8";    // The number of the month
final String DAY = "18";             // The day of the month
final String YEAR = "2001";          // The four-digit year number
String first;                        // Date in Month day, year form
String second;                       // Date in day Month year format
String third;                        // Date in mm/dd/yyyy format
String fourth;                       // Date in dd/mm/yyyy format

outDisplay = new Frame();
outDisplay.setLayout(new GridLayout(5, 2));
// Set up headings
outDisplay.add(new Label("Format"));
outDisplay.add(new Label("Example"));

// Add information to the screen
outDisplay.add(new Label("Month day, year"));
first = MONTH_NAME + " " + DAY + ", " + YEAR;
outDisplay.add(new Label(first));

outDisplay.add(new Label("day Month year"));
second = DAY + "  " + MONTH_NAME + " " + YEAR;
outDisplay.add(new Label (second));

outDisplay.add(new Label("mm/dd/yyyy"));
third = MONTH_NUMBER + "/" + DAY + "/" + YEAR;
outDisplay.add(new Label(third));

outDisplay.add(new Label("dd/mm/yyyy"));
fourth = DAY + "/" + MONTH_NUMBER + "/" + YEAR;



Testing and Debugging | 115

outDisplay.add(new Label(fourth));
outDisplay.pack();
outDisplay.show();
outDisplay.addWindowListener(new WindowAdapter()
// Create a WindowAdapter
{
public void windowClosing(WindowEvent event)
// Method to replace the empty one
{
outDisplay.dispose();     // Remove the window from the screen
System.exit(0);           // Stop the program

}
});

}
}

The output from the program is

Testing and Debugging

1. Use new to instantiate an object of a class. Only objects can be assigned to class
variables.

2. When instantiating an object in a parameter list, be sure to include the new operator
before the class name.

3. Objects to which methods are being applied must have the method appended to the
object name with a dot in between.

4. If clicking the window does not remove it from the screen, you have probably for-
gotten to register the WindowListener with the event handler.

5. If your window does not appear on the screen, be sure you have included the show
method.



116 | Chapter 3:  Event-Driven Output

6. Don’t forget the closing parenthesis at the end of the parameter list of addWin-
dowListener. Because you are inserting a declaration block in the parameter list,
the parenthesis that closes the list appears far removed from the start of the list.

7. Remember that Java is case-sensitive: Gridlayout is not the same as GridLayout.
8. Be sure to include the awt and awt.event packages when using the Frame class.

Summary of Classes

Package Name

Class Name Comments

java.lang
System.exit(0) Proper exit from an application with

a Frame object
java.awt
FlowLayout

Constructor: FlowLayout()
GridLayout

Constructor: GridLayout(int, int) Used as a parameter to setLayout
method of class Frame

Frame
Constructor: Frame()
Instance Methods: add(Label)

addWindowListener(WindowListener)
dispose()
pack()
setLayout(FlowLayout)
setLayout(GridLayout)
show()

Label
Constructor: Label(String)

Java.awt.event
WindowListener

Constructor: WindowListener() Listener for Window events
WindowAdapter Can be substituted for 

WindowListener

Constructor: WindowAdapter()

TE
AM
FL
Y

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

Team-Fly® 



Quick Check | 117

Summary
Window output is accomplished by means of the Frame class, along with its add
method. Each add operation adds a display element to the frame. When the pack and
show methods are called, the frame is displayed on the screen containing whatever ele-
ments have been added to it.

In order to allow the user to close the window, we must provide an event handler
that can be called by the event source. An event handler is a method in a listener class.
Listeners are objects that are associated with events. When a listener is registered with
an event, the event can invoke a handler from the listener class when the event fires.
We modify the WindowAdapter class to include a method called windowClosing that
replaces its empty method of the same name, and then register the listener using the
addWindowListener method.

Quick Check
1. What type of window do we use in this text? (p. 94)
2. What is the Java reserved word that provides access to classes in a package?

(p. 95)
3. Write a statement that instantiates a Frame object called outDisplay. (pp.

95–96)
4. What is an expression used for communicating values to a method? (pp. 96–97)
5. What is the responsibility of a layout manager? (p. 98)
6. How many columns and how many rows will be in the frame that is formatted

according to the following statement? (p. 103)

out.setLayout(new GridLayout(4, 3));

7. Give an example of a method call to System.out. (p. 97)
8. Write a statement that adds the label “This is my answer” to outDisplay. (pp.

98–99)
9. What object is waiting for an event to occur? (pp. 105–106)

10. What is an event handler? (p. 106)
11. What is the method name that is used to register a window listener? (p. 107)

Answers

1. A frame 2. import 3. outDisplay = new Frame(); 4. A parameter 5. To auto-
matically place elements that we add to a frame in the order that we add them
6. 4 rows of 3 columns 7. System.out.print("Oh what a beautiful morn-
ing..."); or System.out.println("Oh what a beautiful morning...");
8. outDisplay.add(new Label("This is my answer")); 9. A listener object 10.
An event handler is a method in a listener class. 11. addWindowListener



118 | Chapter 3:  Event-Driven Output

Exam Preparation Exercises
1. Name two operations that can be applied to a Frame object.
2. How do we gain access to the Frame class?
3. How do you instantiate an object of a Frame class?
4. Describe the contents of a package.
5. Name three kinds of methods.
6. How do you invoke an instance method?
7. Name two instance methods associated with the System.out object.
8. What does the expression “sending a message to” mean?
9. Describe the role of a parameter list.

10. What is a class called that can contain other components?
11. What is the function of the add method of class Frame?
12. What is a synonym for a void method?
13. We have used the convention that method names begin with a lowercase letter.

Why does a constructor have to begin with an uppercase letter?
14. If your frame fails to appear on the screen, what might the error be?
15. a. What is the purpose of the setLayout method?

b. Name two layout managers. What is the difference between them?
16. The Label class has a second constructor that can take two parameters rather

than one. What is the second parameter?
17. What is the object whose role in life is to wait for an event to occur?
18. What is an event handler?
19. Where is an event handler defined?
20. What is an event source?
21. What does it mean to register an event listener?
22. What can be used in place of an object of class WindowListener?
23. Where is the code for the windowClosing method contained?
24. Why does the Frame variable have to be declared outside of main in the Case

Study program?
25. What is output by the following code segment? (All variables are of type

String. Assume that the frame variable out has been declared and given a
value.)

street = "Elm St.";
address = "1425B";
city = "Amaryllis";
state = "Iowa";
streetAddress = address + " " + street;
out.add(new Label(streetAddress));
out.add(new Label(city));
out.add(new Label(", " + state));
out.pack();
out.show();



Programming Warm-Up Exercises | 119

26. Correct the following program so that it displays “Martin Luther King Jr.”

// This program is full of errors
import Java.awt
class LotsOfErrors;
{
constant String FIRST : Martin";
constant String MID : "Luther;
constant String LAST : King
private static Frame : out;

void main (string[] args);
{
out = new Frame;
out.FlowLayout(new setLayout());
String name;
character initial;

name = Martin + Luther + King;
initial = MID;
LAST = "King Jr.";
out.add(new Label('Name = ' + name));
out.add(new Label(mid
out.pack
out.show();

}

Programming Warm-Up Exercises
1. Write the output statement that displays your name in a frame called display

(assume that display has already been set up properly and that display.pack
and display.show are called after your statement is executed).

2. Write three consecutive output statements that display the following three lines
of text as separate labels:

The moon
is
blue.

3. Write declaration statements to declare three variables of class String and two
variables of type char. The String variables should be named make, model, and
color. The char variables should be named plateType and classification.

4. Write a series of output statements that display the values in the variables
declared in Exercise 3 in a frame called auto. Each value should be preceded by
an identifying message.



120 | Chapter 3:  Event-Driven Output

5. Change the PrintName program (page 111) so that it also prints the name in the
format

First-name Middle-initial. Last-name

Make MIDDLE a String constant rather than a char constant. Define a new
String variable to hold the name in the new format and assign it the string
using the existing named constants, any literal strings that are needed for punc-
tuation and spacing, and concatenation operations. Display the string, labeled
appropriately.

6. Write Java output statements that declare and properly set up a frame called
address.

7. Display the following groups of text in the frame called address that was set up
in Exercise 6, with each line of text in a separate label.

a. Four score
and seven years ago

b. Four score
and seven
years ago

c. Four score
and
seven
years ago

d. Four
score
and
seven
years
ago

8. Enter and run the following program. Be sure to type it exactly as it appears
here.

//*************************************************************
// HelloWorld program
// This program displays two simple messages
//*************************************************************
import java.awt.*;
import java.awt.event.*;

public class HelloWorld
{
private static final String MSG1 = "Hello world.";
private static Frame out;



Programming Problems | 121

public static void main(String[] args)
{
String msg2;
out = new Frame();
out.setLayout(new FlowLayout());
out.add(new Label(MSG1));
msg2 = MSG1 + " " + MSG1 + " " + MSG1;
out.add(new Label(msg2));
out.pack();
out.show();
out.addWindowListener(new WindowAdapter()
{
public void windowClosing(WindowEvent event)
{
out.dispose();
System.exit(0);

}
});

}
}

a. Write a statement that assigns the GridLayout manager to Frame variable
outDisplay with two rows and three columns.

b. Write a statement that assigns the GridLayout manager to Frame variable
outDisplay with an unspecified number of rows and three columns.

c. Write a statement that adds a new label to Frame variable outDisplay that
centers the text in the label.

d. The following output appeared on the screen:

The dollar amount is 23dollarsand52cents.

Write the correct output using System.out.

Programming Problems
1. Problem 1 in Chapter 2 asked you to write a Java application that displayed a

series of Haiku poems. Recall that a Haiku poem is written in three phrases. The
first phrase has five syllables, the second has seven syllables and the last phrase
again has five syllables. For example:

Bright flash then silence
My expensive computer
Has gone to heaven



122 | Chapter 3:  Event-Driven Output

Your program was to define string constants with four phrases of five syllables
and two phrases of seven syllables. Use string concatenation expressions to con-
struct every possible 5–7–5 permutation of these phrases and display each one.
Rewrite this application using a Frame object rather than System.out.

2. Rewrite the solution to Chapter 2, Problem 2 that simulates the child’s game “My
Grandmother’s Trunk.” In this game, the players sit in a circle, and the first
player names something that goes in the trunk: “In my grandmother’s trunk, I
packed a pencil.” The next player restates the sentence and adds something new
to the trunk: “In my grandmother’s trunk, I packed a pencil and a red ball.” Each
player in turn adds something to the trunk, attempting to keep track of all the
items that are already there.

Your program should simulate just five turns in the game. Starting with the
null string, simulate each player’s turn by concatenating a new word or phrase
to the existing string, and add the result to a frame.

3. Write an application that uses the GridLayout manager to write your name
left-justified on the first line, your address centered on the next line, and your
phone number right-justified on the third line.

Case Study Follow-Up Exercises
1. Change the DateFormats program so that the four formats are shown in the

opposite order on the screen.
2. In the DateFormats program, explain what takes place in the statement that

assigns a value to the label that goes with string variable third.
3. Change the DateFormats program so that the third and fourth formats use

hyphens (-) instead of slashes (/).
4. Change the DateFormats program so that your birth date is displayed in the

four formats.



                 

To be able to declare named constants and variables
of type int and double.

To be able to construct simple arithmetic expres-
sions.

To be able to evaluate simple arithmetic expressions.

To be able to construct and evaluate expressions that
include multiple arithmetic operations.

To understand implicit type conversion and explicit
type casting.

To be able to use Java math methods in expressions.

To learn and be able to use additional operations asso-
ciated with the String type.

To be able to format the statements in a program in a
clear and readable fashion.

Numeric Types and
Expressions

G
oals



124 | Chapter 4:  Numeric Types and Expressions

integral

referenceprimitive

byte char short int

floating point

Java data types

float

array interface class

doublelong

boolean

Figure 4.1 Java data types

In Chapters 2 and 3, we examined enough Java syntax to be able to construct simple
programs using assignment and output. We focused on the char and String types and
saw how to construct expressions using the concatenation operator. In this chapter we
continue to write programs that use assignment and output, but we concentrate on
additional built-in data types: int, long, float, and double. These numeric types
include multiple operators that enable us to construct complex arithmetic expressions.
We show how to make expressions even more powerful by using calls to Java’s value-
returning math methods.

4.1 Overview of Java Data Types
The Java built-in data types are organized into primitive types and reference types (see
Figure 4.1).

You might have noticed that the String type isn’t listed in Figure 4.1. In Chapter 2
we noted that String is an example of a class, which is one of the reference types. In
fact, most of the types that we use in this text, other than the primitive types, are
classes. In Chapter 3 we used classes such as Frame, Label, and WindowAdapter.
Recall that our convention is to capitalize the first letter of all classes in this manner, to
help you identify them in programs.

The division of Java’s data types into primitive and reference types stems from the
way that Java stores values of each of the types in memory. Recall from Chapter 2 that
we said Java chooses an address in the computer’s memory where it stores each value
and keeps track of the address so that we don’t have to remember it. Each primitive type
takes up a fixed amount of space in memory, so Java stores each primitive value at the
memory address it chooses for it. When you assign a value to a variable of a primitive
type, Java copies the value into the address that has been chosen for the variable. This
action is possible because each primitive type takes a specified amount of space.

The reference types are more complex. Because they can contain different numbers
of fields, they take up different amounts of the computer’s memory. Most are too large
to fit into a single memory location, so Java can’t just assign the new object by copying



4.1 Overview of Java Data Types | 125

one memory location to another. Instead of storing the object at the chosen location,
Java stores the object in one or more additional locations in another part of memory. If
Java doesn’t put the object into the chosen location, then what does it put there? It
stores the address of the memory location where the object can be found. That is, the
chosen location contains a binary number that tells the computer where the object is
stored. When Java assigns an object to a variable, it copies this address into the vari-
able.

Let’s look at a pair of examples that demonstrate the difference between primitive
values and reference values.

char letter;
String title;
String bookName;
letter = 'J';
title = "Introduction to Java and Software Design";
bookName = title;

When you declare variables letter, title, and bookName, locations in memory are
chosen for these variables. When you assign the value 'J' to the char variable
letter, Java stores the value 'J' into it. When you assign the string "Introduction
to Java and Software Design" to the String variable title, Java chooses loca-
tions into which to store the string, and stores the address of the first location into
title. If you assign the value of title to the String variable called bookName, then
Java just copies the value stored in title (the address) to the place it chose for book-
Name. Figure 4.2 illustrates the difference between primitive and reference types.

Figure 4.2 also shows that a reference type has the advantage of saving memory
space when copying values that take up multiple locations in memory. The lengthy
value is stored just once, and the variables that are assigned the value each take up just
one location. If Java stored reference types the same way it stores primitive types, it
would have to store a copy of the whole value in each variable, which would take up
more space.

The term “reference,” by the way, comes from the fact that the contents of a refer-
ence variable refer to another place in memory. You can think of a reference type as
being analogous to the call number of a library book. If you have the call number, you
can go into the library and find the book. If a friend wants to find the same book, you
give a copy of the call number to him or her, which is much easier than making a copy
of the book.

Do not feel overwhelmed by the quantity of data types shown in Figure 4.1. Our
purpose is simply to give you an overall picture of what is available in Java. Except for
the String and output classes, this chapter works mainly with the primitive types.
Details of the reference types come later in the book. First we look at the primitive inte-
gral types (those used primarily to represent integers), and then we consider the floating
types (used to represent real numbers containing decimal points). We postpone talking
about the remaining primitive type, boolean, until Chapter 6.



126 | Chapter 4:  Numeric Types and Expressions

Primitive Type Reference Type

letter

After executing the assignment:   bookName = title;

J

title

01011010101

bookName

01011010101

01011010101

Introduction to Java and Software Design

Memory address number of
the start of the string value

Location 
containing
first part 
of string

Subsequent locations in memory

Figure 4.2 Primitive types and reference types

4.2 Numeric Data Types
You already are familiar with the basic concepts of integer and real numbers in mathe-
matics. However, as used on a computer, the corresponding data types have certain lim-
itations, which we now examine.

Integral Types

The data types byte, short, int, and long are known as integral types (or integer
types) because they refer to integer values—whole numbers with no fractional part. In
Java, the simplest form of integer value is a sequence of one or more digits:

22   16   1   498   0   4600

Commas are not allowed.
A minus sign preceding an integer value makes the integer negative:

–378  –912

The data types byte, short, int, and long are intended to represent different sizes
of integers, from smaller (fewer bits) to larger (more bits), as shown in Figure 4.3.

TE
AM
FL
Y

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

Team-Fly® 



4.2 Numeric Data Types | 127

8 bits

16 bits

32 bits

64 bits

byte

short

int

long

Figure 4.3 The integral types in Java

The Java language specifies the sizes of the integral types to be just as shown in the
figure. The more bits there are in the type, the larger the integer value that can be
stored.

The int type is by far the most common data type for manipulating integer data.
byte and short types are used far less frequently. In Java you nearly always use int
for manipulating integer values, but sometimes you may choose to use long if your
program requires values larger than the maximum int value. The range of int values
is from –2147483648 through +2147483647. As we noted in Chapter 1, numbers like
these remind us that the binary number system is working in the background.

A variable of type int can hold any value with up to nine decimal digits, such as a
social security number. But for values with more digits, such as a telephone number
with country and area codes, it isn’t large enough. Such numbers require the long type,
which can hold any integer up to 18 digits in length.

When you write a literal integer value, it is automatically assumed by Java to be of
type int. To write a literal of type long, you must follow the last digit of the number
with the letter “L”. You may also use the lowercase “l”, but it looks so much like the
digit “1” that it may be impossible for a person to recognize the literal as long when
reading your program. We use only the uppercase “L” in this text. Here are some exam-
ples of literals of type int and long.

Literal Type

0 int
0L long

2001 int
18005551212L long
18005551212 invalid (11 digits are too large for type int)

If your program tries to compute a value larger than a type’s maximum value, the
result is integer overflow. Some programming languages give you an error message
when overflow occurs, but Java doesn’t. If a computation in Java produces a value that
is too large for the type to represent, you simply get an erroneous result.



128 | Chapter 4:  Numeric Types and Expressions

One caution about integer literals in Java: A literal constant beginning with a zero
is taken to be an octal (base–8) number instead of a decimal (base–10) number. If you
write

015

the Java compiler takes this to mean the decimal number 13. If you aren’t familiar with
the octal number system, don’t worry about why an octal 15 is the same as a decimal
13. The important thing to remember is not to start a decimal integer literal with a zero
(unless you want the number 0, which is the same in both octal and decimal).

Floating-Point Types

Floating-point types (or floating types) are used to represent real numbers. Floating-
point numbers have an integer part and a fractional part, with a decimal point in
between. Either the integer part or the fractional part, but not both, may be missing.
Here are some examples:

18.0     127.54     0.57     4.     193145.8523     .8

Starting 0.57 with a 0 does not make it an octal number. It is only with integer values
that a leading 0 indicates an octal number.

Just as the integral types in Java come in different sizes (byte, short, int, and
long), so do the floating-point types. In increasing order of size, the floating-point
types are float and double (meaning double-precision). Type double gives us a wider
range of values and more precision (the number of significant digits in the number)
than type float, but at the expense of twice the memory space to hold the number. In
Java, int and float values take up the same amount of memory space (32 bits), and
both long and double take up 64 bits of memory space.

Floating-point values also can have an exponent, as in scientific notation. (In sci-
entific notation, a number is written as a value multiplied by 10 to some power.) Instead
of writing 3.504 3 1012, in Java we write 3.504E12. The E (you can also use e) means
exponent of base 10. The number preceding the letter E doesn’t need to include a deci-
mal point. Here are some examples of floating-point numbers in scientific notation:

1.74536E–12     3.652442E4     7E20      –8.01994E–23      –6e12

A float value can represent seven-digit decimal numbers with an exponent in the
range of 245 through 38. A double value can represent 15-digit decimal numbers with
an exponent ranging from 2324 to 308.

In Java, floating-point literals of the form we have shown are automatically
assumed by the compiler to be of type double. To write a literal of type float, you
must end the number with the letter F (or f). In the Payroll program, the identifiers



4.3 Declarations for Numeric Types | 129

MAX_HOURS, OVERTIME, payRate, hours, wages, and total are all of type double.
Here are some examples of floating-point literals.

Literal Type

0.0 double
0.0f float

2.001E3 double
2.001E3F float
1.8E225F invalid (exponent 225 too great for type float)

We talk more about floating-point numbers in Chapter 13. But there is one more
thing you should know about them now. Computers cannot always represent floating-
point numbers exactly. You learned in Chapter 1 that the computer stores all data in
binary (base–2) form. Many decimal floating-point values can only be approximated in
the binary number system. Don’t be surprised if your program prints out the number 4.8
as 4.7999998. In most cases, slight inaccuracies in the rightmost fractional digits are to
be expected and are not the result of programmer error.

4.3 Declarations for Numeric Types
Just as with the types char and String, we can declare named constants and variables
of type int, long, float, and double. Such declarations use the same syntax as
before, except that the literals and the names of the data types are different.

Named Constant Declarations

In the case of named constant declarations, the literal values in the declarations are
numeric instead of being characters in single or double quotes. For example, here are
some constant declarations that define values of type int and float. For comparison,
declarations of char and String values are included.

final double  PI = 3.14159;
final float   E = 2.71828F;
final long    MAX_TEMP = 1000000000L;
final int     MIN_TEMP = –273;
final char    LETTER = 'W';
final String  NAME = "Elizabeth";

Although character and string literals are put in quotes, literal integers and float-
ing-point numbers are not, because there is no chance of confusing them with identi-
fiers. Why? Because identifiers must start with a letter or underscore, and numbers must
start with a digit or sign.



130 | Chapter 4:  Numeric Types and Expressions

Variable Declarations

We declare numeric variables the same way in which we declare char and String vari-
ables, except that we use the names of numeric types. Here are some sample declara-
tions.

int     studentCount;   // Number of students
int     sumOfScores;   // Sum of their scores
long    sumOfSquares;   // Sum of squared scores
double  average;       // Average of the scores
float   deviation;    // Standard deviation of scores
char    grade;          // Student's letter grade
String  stuName;        // Student's name

Software Engineering Tip
Using Named Constants Instead of Literals

It’s a good idea to use named constants instead of literals. In addition to making your program
more readable, named constants can make your program easier to modify. Suppose you wrote
an application last year to compute taxes. In several places you used the literal 0.05, which
was the sales tax rate at the time. Now the rate has gone up to 0.06. To change your program,
you must locate every literal 0.05 and change it to 0.06. And if 0.05 is used for some other
reason—to compute deductions, for example—you need to look at each place where it is used,
figure out what it is used for, and then decide whether to change it.

The process is much simpler if you use a named constant. Instead of using a literal con-
stant, suppose you had declared a named constant, TAX_RATE, with a value of 0.05. To
change your program, you would simply change the declaration, setting TAX_RATE equal to
0.06. This one modification changes all of the tax rate computations without affecting the
other places where 0.05 is used.

Java allows us to declare constants with different names but the same value. If a value has
different meanings in different parts of an application, it makes sense to declare and use a
constant with an appropriate name for each meaning.

Named constants also are reliable; they protect us from mistakes. If you mistype the name
PI as PO, the Java compiler tells you that the name PO has not been declared. On the other
hand, even though we recognize that the number 3.14149 is a mistyped version of pi
(3.14159), the number is perfectly acceptable to the compiler. It won’t warn us that anything
is wrong.



4.4 Simple Arithmetic Expressions | 131

Given these declarations

int    num;
int    alpha;
double rate;
char   ch;

the following are appropriate assignment statements:

Variable Expression

alpha = 2856;
rate = 0.36;
ch = 'B';
num = alpha;

In each of these assignment statements, the data type of the expression matches the
data type of the variable to which it is assigned. Later in the chapter we see what hap-
pens if the data types do not match.

4.4 Simple Arithmetic Expressions
Now that we have looked at declaration and assignment, we consider how to calculate
with values of numeric types. Calculations are performed with expressions. We first look
at simple expressions that involve at most one operator so that we may examine each
operator in detail. Then, we move on to compound expressions that combine multiple
operations.

Arithmetic Operators

Expressions are made up of constants, variables, and operators. The following are all
valid expressions:

alpha + 2      rate – 6.0      4 – alpha      rate      alpha * num

The operators allowed in an expression depend on the data types of the constants
and variables in the expression. The arithmetic operators are

+ Unary plus
- Unary minus
+ Addition
- Subtraction
* Multiplication

/
Floating-point division (floating-point result){ Integer division (no fractional part)

% Modulus (remainder from division)



132 | Chapter 4:  Numeric Types and Expressions

The first two operators are unary operators—they
take just one operand. The remaining five are binary
operators, taking two operands. Unary plus and minus
are used as follows:

–54   +259.65   -rate

Programmers rarely use the unary plus. Without any
sign, a numeric constant is assumed to be positive anyway.

You may not be familiar with integer division and modulus (%). Let’s look at these
operations more closely. Note that % can be used with both integers and floating-point
numbers. When you divide one integer by another, you get an integer quotient and a
remainder. Integer division gives only the integer quotient, and % gives only the remainder.

In Java, the sign of the remainder is the same as the sign of the dividend. For example,

3 %  2 =  1
3 % –2 =  1
–3 %  2 = –1
–3 % –2 = –1

In contrast to integer division, floating-point division yields a floating-point result. The
expression

7.2 / 2.0

yields the value 3.6.
The floating-point remainder operation returns the remainder after dividing the div-

idend by the divisor a whole number of times. For example,

7.2 % 2.1

yields the value 0.9 because 2.1 goes into 7.2 exactly 3 times (3 * 2.1 = 6.3), with 0.9
remaining.

Here are some expressions using arithmetic operators and their values:

Expression Value

3 + 6 9
3.4 – 6.1 22.7
2 * 3 6
8 / 2 4
8.0 / 2.0 4.0
8 / 8 1

3
6
6
0

)2
6 / 2

6 % 2

3
7
6
1

)2
7 / 2

7 % 2

Unary operator An operator that has just one
operand

Binary operator An operator that has two operands



4.4 Simple Arithmetic Expressions | 133

Expression Value

8 / 9 0
8 / 7 1
8 % 8 0
8 % 9 8
8 % 7 1
0 % 7 0
5.0 % 2.3 0.4

Be careful with division and modulus. The expressions 7 / 0 and 7 % 0 produce
an error message. The computer cannot divide an integer by zero. With floating-point
values, however, the expressions 7.0 / 0.0 and 7.0 % 0.0 do not result in an error
message. The result of the expression 7.0 / 0.0 is a special value representing infinity.
The result of 7.0 % 0.0 is another special value called Not a Number (NaN).

Calculations involving these special values produce unusual results. For example,
the result of any arithmetic operation involving NaN is also NaN. If you encounter such
results, it is an indication that you need to carefully reexamine the expressions in your
program to be certain that the division operation and remainder do not have a zero
divisor.

Because variables are allowed in expressions, the following are valid assignments:

alpha = num + 6;
alpha = num / 2;
num = alpha * 2;
num = 6 % alpha;
alpha = alpha + 1;
num = num + alpha;

As we saw with assignment statements involving String expressions, the same
variable can appear on both sides of the assignment operator. In the case of

num = num + alpha;

the value in num and the value in alpha are added together, and then the sum of the
two values is stored back into num, replacing the previous value stored there. This
example shows the difference between mathematical equality and assignment. The
mathematical equality

num = num + alpha

is true only when alpha equals zero. The assignment statement

num = num + alpha;

is valid for any value of alpha.



134 | Chapter 4:  Numeric Types and Expressions

Here’s a simple program that uses arithmetic expressions:

//******************************************************************
// FreezeBoil program
// This program computes the midpoint between
// the freezing and boiling points of water
//******************************************************************

import java.awt.*;                    // Import Frame type, etc.
import java.awt.event.*;                // Import event handling types

public class FreezeBoil
{

private static Frame out;             // Declare a variable of type Frame
public static void main(String[]  args)
{ 
final double FREEZE_PT = 32.0;      // Freezing point of water
final double BOIL_PT = 212.0;       // Boiling point of water

double avgTemp;                     // Holds the result of averaging
//   FREEZE_PT and BOIL_PT

out = new Frame();                  // Create new value of type Frame
out.setLayout(new FlowLayout());    // Specify layout manager for frame
out.add(new Label("Water freezes at " + FREEZE_PT));
out.add(new Label("and boils at " + BOIL_PT + " degrees."));

avgTemp = FREEZE_PT + BOIL_PT;
avgTemp = avgTemp / 2.0;

out.add(new Label("Halfway between is " + avgTemp + " degrees."));
out.pack();                         // Pack the frame
out.show();                         // Show the frame on the screen
out.addWindowListener(new WindowAdapter()    
// Create a WindowClosing method to replace the empty one
public void windowClosing(WindowEvent event)
{
out.dispose();                 // Remove the frame from the screen



4.4 Simple Arithmetic Expressions | 135

System.exit(0);              // Stop the program
}

});
}

}

The program begins with a comment that explains what the program does. In the
class declaration section we declare the variable out of class Frame. The body of the
main method includes a definition of constants FREEZE_PT and BOIL_PT and the dec-
laration of the local variable avgTemp and then a sequence of executable statements.
These statements display labels, add FREEZE_PT and BOIL_PT, divide the sum by 2,
show the result, and finally set up handling of the window closing event. Here is the
output from the application:

Increment and Decrement Operators

In addition to the arithmetic operators, Java provides increment and decrement oper-
ators:

++ Increment
-- Decrement

These are unary operators that take a single variable name as an operand. For integer
and floating-point operands, the effect is to add 1 to (or subtract 1 from) the operand. If
num currently contains the value 8, the statement

num++;

causes num to contain 9. You can achieve the same effect by writing the assignment
statement

num = num + 1;

but Java programmers typically prefer using the increment operator.



136 | Chapter 4:  Numeric Types and Expressions

The ++ and -- operators can be either prefix operators

++num;

or postfix operators

num++;

Both of these statements behave in exactly the same way; they add 1 to whatever is in
num. The choice between these two is a matter of personal preference, although most
Java programmers favor the latter form.

Java allows the use of ++ and -- in the middle of a larger expression:

alpha = num++ * 3;

In this case, note that the postfix form of ++ gives a different result from the prefix
form. In Chapter 10, we explain the ++ and -- operators in more detail. In the mean-
time, you should use them only to increment or decrement a variable as a separate,
standalone statement:

4.5 Compound Arithmetic Expressions
The expressions we’ve used so far have contained at most a single arithmetic operator.
We also have been careful not to mix integer and floating-point values in the same
expression. Now we look at more complicated expressions—ones that are composed of
several operators and ones that contain mixed data types.

Precedence Rules

Arithmetic expressions can be made up of many constants, variables, operators, and
parentheses. In what order are the operations performed? For example, in the assign-
ment statement

avgTemp = FREEZE_PT + BOIL_PT / 2.0;

Variable ++ ;

++ Variable ;

IncrementStatement

Variable -- ;

-- Variable ;

DecrementStatementTE
AM
FL
Y

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

Team-Fly® 



4.5 Compound Arithmetic Expressions | 137

is FREEZE_PT + BOIL_PT calculated first or is BOIL_PT / 2.0 calculated first?
The five basic Java arithmetic operators (+ for addition, – for subtraction, * for

multiplication, / for division, and % for modulus) and parentheses are ordered the same
way mathematical operators are, according to precedence rules:

Highest precedence: ()
++ (postfix increment) -- (postfix decrement)
++ (prefix increment) -- (prefix decrement)
unary + unary -
* / %

Lowest precedence: + -

In the example above, we first divide BOIL_PT by 2.0 and then add FREEZE_PT to the
result.

You can change the order of evaluation by using parentheses. In the statement

avgTemp = (FREEZE_PT + BOIL_PT) / 2.0;

FREEZE_PT and BOIL_PT are added first, and then their sum is divided by 2.0. We
evaluate subexpressions in parentheses first and then follow the precedence of the oper-
ators.

When there are multiple arithmetic operators with the same precedence, their
grouping order (or associativity) is from left to right. The expression

int1 – int2 + int3

means (int1 2 int2) + int3, not int1 2 (int2 + int3). As another example, we
would use the expression

(double1 + double2) / double1 * 3.0

to evaluate the expression in parentheses first, then divide the sum by double1, and
then multiply the result by 3.0. Following are some more examples.

Expression Value

10 / 2 * 3 15
10 % 3 – 4 / 2 21
5.0 * 2.0 / 4.0 * 2.0 5.0
5.0 * 2.0 / (4.0 * 2.0) 1.25
5.0 + 2.0 / (4.0 * 2.0) 5.25



138 | Chapter 4:  Numeric Types and Expressions

Type Conversion and Type Casting

Integer values and floating-point values are stored differently inside a computer’s mem-
ory. The pattern of bits that represents the constant 2 does not look at all like the pat-
tern of bits representing the constant 2.0. (In Chapter 13, we examine why
floating-point numbers need a special representation inside the computer.) What hap-
pens if we mix integer and floating-point values together in an assignment statement or
an arithmetic expression? Let’s look first at assignment statements.

Assignment Statements If you make the declarations

int    someInt;
double someDouble;

then someInt can hold only integer values, and someDouble can hold only double-pre-
cision floating-point values. The assignment statement

someDouble = 12;

may seem to store the integer value 12 into someDouble, but this is not true. The com-
puter refuses to store anything other than a double value into someDouble. The com-
piler inserts extra Bytecode instructions that first convert 12 into 12.0 and then store

12.0 into someDouble. This implicit (automatic) con-
version of a value from one data type to another is
known in Java as type conversion.

The statement

someInt = 4.8;

also causes type conversion. When a floating-point value is assigned to an int vari-
able, the fractional part is truncated (cut off). As a result, someInt is assigned the
value 4.

With both of the assignment statements above, the program would be less confus-
ing for someone to read if we avoided mixing data types:

someDouble = 12.0;
someInt = 4;

More often, it is not just constants but entire expressions that are involved in type
conversion. Both of the assignments

someDouble = 3 * someInt + 2;
someInt = 5.2 / someDouble – anotherDouble;

Type conversion The implicit (automatic) conversion
of a value from one data type to another



4.5 Compound Arithmetic Expressions | 139

1In non-Java terminology, implicit conversions are called coercions and explicit conversions are casts.

lead to type conversion. Storing the result of an int expression into a double variable
doesn’t cause loss of information; a whole number such as 24 can be represented in
floating-point form as 24.0. In the Java language, a type conversion that does not result
in a loss of information is known as a widening conversion. Assigning int values to
long variables or a float values to double variables are additional examples of
widening conversions.1

However, storing the result of a floating-point expression into an int variable can
cause a loss of information because the fractional part is truncated. Java refers to such a
conversion as a narrowing conversion. It is easy to overlook the assignment of a float-
ing-point expression to an int variable, a double value to a float variable, or a long
value to an int variable when we try to dis-
cover why our program is producing the
wrong answers.

To make our programs as clear (and
error-free) as possible, we should use explicit
type casting. A Java cast operation consists of
a data type name within parentheses, then the
expression to be converted:

someDouble = (double)(3 * someInt + 2);
someInt = (int)(5.2 / someDouble –
anotherDouble);

Both of the statements

someFloat = someInt + 8;
someFloat = (float)(someInt + 8);

produce identical results. The only difference is in clarity. With the cast operation, it is
perfectly clear to the programmer and to others reading the program that the mixing of
types is intentional, not an oversight. Countless errors have resulted from unintentional
mixing of types.

Note that there is a nice way to round off rather than truncate a floating-point
value before storing it into an int variable. Here is the way to do it:

someInt = (int)(someDouble + 0.5);

With pencil and paper, see for yourself what gets stored into someInt when
someDouble contains 4.7. Now try it again, assuming someDouble contains 4.2.

Widening conversion A type conversion that does
not result in a loss of information1

Narrowing conversion A type conversion that may
result in a loss of some information, as in converting a
value of type double to type float
Type casting The explicit conversion of a value from
one data type to another; also called type conversion



140 | Chapter 4:  Numeric Types and Expressions

(This technique of rounding by adding 0.5 assumes that someDouble is a positive
number.)

Arithmetic Expressions So far we have been talking about mixing data types across
the assignment operator (=). It’s also possible to mix data types within an expression:

someInt * someDouble
4.8 + someInt – 3

Such expressions are called mixed type (or mixed
mode) expressions.

Whenever an integer value and a floating-point
value are joined by an operator, implicit type conver-
sion occurs as follows.

1. The integer value is temporarily converted to a floating-point value.
2. The operation is performed.
3. The result is a floating-point value.

Let’s examine how the machine evaluates the expression 4.8 + someInt – 3,
where someInt contains the value 2. First, the operands of the + operator have mixed
types, so the value of someInt is converted to 2.0. (This conversion is only temporary;
it does not affect the value that is stored in someInt.) The addition takes place, yielding
a value of 6.8. Next, the subtraction (-) operator joins a floating-point value (6.8) and
an integer value (3). The value 3 is converted to 3.0, the subtraction takes place, and the
result is the floating-point value 3.8.

Just as with assignment statements, you can use explicit type casts within expres-
sions to lessen the risk of errors. Writing expressions like

(double)someInt * someDouble
4.8 + (double)(someInt – 3)

makes it clear what your intentions are.
Not only are explicit type casts valuable for program clarity, in some cases they are

mandatory for correct programming. Given the declarations

int    sum;
int    count;
double average;

suppose that sum and count currently contain 60 and 80, respectively. If sum represents
the sum of a group of integer values and count represents the number of values, let’s
find the average value:

average = sum / count;     // Gives the wrong answer

Mixed type expression An expression that contains
operands of different data types; also called a mixed
mode expression



4.5 Compound Arithmetic Expressions | 141

Unfortunately, this statement stores the value 0.0 into average. Here’s why. The
expression to the right of the assignment operator is not a mixed type expression. Both
operands of the / operator are of type int, so integer division is performed. Dividing 60
by 80 yields the integer value 0. Next, the machine implicitly converts 0 to the value 0.0
before storing it into average. The way to find the average correctly, as well as clearly,
is this:

average = (double)sum / (double)count;

This statement gives us floating-point division instead of integer division. As a result,
the value 0.75 is stored into average.

As a final remark about type conversion and type casting, you may have noticed
that we have concentrated only on the int and double types. It is also possible to stir
byte, long, short, and float values into the pot. The results can be confusing and
unexpected. You should avoid unnecessarily mixing values of these types within an
expression. Whenever it is necessary to do so, you should use explicit type conversion
to clarify your intentions.

String Conversion Just as Java attempts to convert between numeric types when you
mix them in expressions, it also tries to convert numeric values to strings when
you mix them into expressions with the string concatenation operator. If you declare a
String object called answer, you can write an assignment expression of the following
form

answer = "The average is: " + average;

If average contains the value 27.65, then the outcome of this assignment is that
answer contains the string

"The average is: 27.65"

When one of the operands of the + operator is a string and the other operand is a
numeric type, the numeric type is converted to a string prior to concatenation. The +
operator has the same precedence whether it is adding numeric values or concatenating
strings. String conversion is a useful feature of Java for formatting output in which we
mix numeric values with text that explains their meaning. For example, you might use
the preceding expression in a label as follows:

out.add(new Label("The average is: " + average));

You can use a series of concatenation operators to create complex strings. For
example,

answer = "The results are: " + 27 + 18 + " and " + 9;



142 | Chapter 4:  Numeric Types and Expressions

produces the string

"The results are: 2718 and 9"

Notice, however that the values 27 and 18 were concatenated without any spaces
between them. String conversion of numeric values doesn’t add any space around the
digits of the number. You must explicitly include any spaces that you need as part of
the expression:

answer = "The results are: " + 27 + ", " + 18 + " and " + 9;

It is also important to note that the result of the original expression wasn’t

"The results are: 45 and 9"

Why doesn’t the subexpression 27 + 18 perform an integer addition? The answer is
found in the precedence rules. Let’s take a closer look at how this expression is evalu-
ated. All of the operators in the expression have the same precedence and are thus eval-
uated left to right. The first operand is a string, so the first + is a concatenation. The
second operand is converted to a string and concatenated, with a string

"The results are: 27"

as the result. This string becomes the first operand of the second + operator, so it too is
a concatenation. The number 18 is thus converted to a string and concatenated with the
result of the first operator to produce a new string

"The results are: 2718"

The third operator has two strings as its operands, so no conversion is necessary and it
produces

"The results are: 2718 and "

The last operator then has a string as its first operand and an integer as its second
operand. The integer is converted to a string and concatenated to form the final result,
which is assigned to answer.

As you can see from the preceding discussion, when an expression mixes strings
and numeric types, you must consider the entire expression in light of the precedence
rules. Take a look at the following expression and see if you can determine what its
result is.

answer = 27 + 18 + 9 + " are the results."



4.5 Compound Arithmetic Expressions | 143

If you think it is

"27189 are the results."

then you are forgetting the impact of the left-to-right evaluation precedence rule. Its
actual result is

"54 are the results."

The first two + operators are integer additions because neither of their operands are
strings. Only the last + sign is a concatenation, and its left operand is the sum of the
three numbers, which it converts into a string. If a chain of + operators begins with a
concatenation, then the succeeding operators are also concatenations. The following is
an invalid assignment:

answer = 27 + 18 + 9;           // Invalid; expression type is int

String conversion occurs only with the concatenation operator, not with assign-
ment. The result of this expression is an int value, which can’t be assigned to a string.
However, there is a trick that you can use to turn this expression into a series of string
concatenations. You can concatenate the values with the empty string.

answer = "" + 27 + 18 + 9;       // Valid; expression type is String

The value stored in answer is then "27189". But what if you want answer to con-
tain the string representing the sum of these integers? That is, how do you get Java to
first compute the integer sum before applying string conversion? You can do it the same
way that you change the order of evaluation of any expression: use parentheses.

answer = "" + (27 + 18 + 9);

Now the expression 27 + 18 + 9 is evaluated first, and because all of the
operands are integers, the + operators perform addition. Once the sum is computed, it is
converted to a string and concatenated with the null string. The assignment then stores
"54" into answer.

To summarize, string conversion is a useful feature of Java for formatting numeric
output. But keep in mind that it works only as part of string concatenation. And
remember that you must be careful to consider the precedence rules whenever you write
a complex expression in which you there are multiple numeric values.



144 | Chapter 4:  Numeric Types and Expressions

May We Introduce...
Blaise Pascal

One of the great historical figures in the world of computing was the French mathemati-
cian and religious philosopher Blaise Pascal (1623–1662), the inventor of one of the earliest
known mechanical calculators.

Pascal’s father, Etienne, was a noble in the French court, a tax collector, and a
mathematician. Pascal’s mother died when Pascal was three years old. Five years
later, the family moved to Paris and Etienne took over the education of the children.
Pascal quickly showed a talent for mathematics. When he was only 17, he pub-
lished a mathematical essay that earned the jealous envy of René Descartes, one of
the founders of modern geometry. (Pascal’s work actually had been completed
before he was 16.) It was based on a theorem, which he called the hexagrammum
mysticum, or mystic hexagram, that described the inscription of hexagons in conic
sections (parabolas, hyperbolas, and ellipses). In addition to the theorem (now

called Pascal’s theorem), his essay included over 400 corollaries.
When Pascal was about 20, he constructed a mechanical calculator that performed addition

and subtraction of eight-digit numbers. That calculator required the user to dial in the numbers
to be added or subtracted; then the sum or difference appeared in a set of windows. It is
believed that his motivation for building this machine was to aid his father in collecting taxes.
The earliest version of the machine does indeed split the numbers into six decimal digits and
two fractional digits, as would be used for calculating sums of money. The machine was hailed
by his contemporaries as a great advance in mathematics, and Pascal built several more in dif-
ferent forms. It achieved such popularity that many fake, nonfunctional copies were built by
others and displayed as novelties. Several of Pascal’s calculators still exist in various museums.

Pascal’s box, as it is called, was long believed to be the first mechanical calculator. How-
ever, in 1950, a letter from Wilhelm Shickard to Johannes Kepler written in 1624 was discov-
ered. This letter described an even more sophisticated calculator built by Shickard 20 years
prior to Pascal’s box. Unfortunately, the machine was destroyed in a fire and never rebuilt.

During his twenties, Pascal solved several difficult problems related to the cycloid curve,
indirectly contributing to the development of differential calculus. Working with Pierre de Fer-
mat, he laid the foundation of the calculus of probabilities and combinatorial analysis. One of
the results of this work came to be known as Pascal’s triangle, which simplifies the calculation
of the coefficients of the expansion of (x + y)n, where n is a positive integer.

Pascal also published a treatise on air pressure and conducted experiments that showed
that barometric pressure decreases with altitude, helping to confirm theories that had been
proposed by Galileo and Torricelli. His work on fluid dynamics forms a significant part of the
foundation of that field. Among the most famous of his contributions is Pascal’s law, which
states that pressure applied to a fluid in a closed vessel is transmitted uniformly throughout
the fluid.

tcontinued



4.6 Additional Mathematical Methods | 145

4.6 Additional Mathematical Methods
Certain computations, such as taking square roots or finding the absolute value of a
number, are very common in programs. It would be an enormous waste of time if every
programmer had to start from scratch and create methods to perform these tasks. To
help make the programmer’s life easier, the Math class provides a number useful meth-
ods. Note that the class name must precede each of these methods with a dot in
between the two names.

When Pascal was 23, his father became ill, and the family was visited by two disciples of
Jansenism, a reform movement in the Catholic Church that had begun six years earlier. The family
converted, and five years later one of his sisters entered a convent. Initially, Pascal was not so taken
with the new movement, but by the time he was 31, his sister had persuaded him to abandon the
world and devote himself to religion.

His religious works are considered no less brilliant than his mathematical and scientific writings.
Some consider Provincial Letters, his series of 18 essays on various aspects of religion, as the begin-
ning of modern French prose.

Pascal returned briefly to mathematics when he was 35, but a year later his health, which had
always been poor, took a turn for the worse. Unable to perform his usual work, he devoted himself to
helping the less fortunate. Three years later, he died while staying with his sister, having given his
own house to a poor family.

Blaise Pascal

Method Parameter Type(s) Result Type Result

Math.abs(x) int, long, float, same as parameter Absolute value of x
or double

Math.cos(x) double double Cosine of x (x is in radians)
Math.sin(x) double double Sine of x (x is in radians)
Math.log(x) double double Natural logarithm of x
Math.pow(x, y) double double x raised to the power y (if x = 0.0,

y must be positive; if x # 0.0, y
must be a whole number)

Math.min(x, y) int, long, float, same as parameter Smaller of x and y
or double

Math.max(x, y) int, long, float same as parameter Larger of x and y
or double

Math.sqrt(x) double double Square root of x (x $ 0.0)



146 | Chapter 4:  Numeric Types and Expressions

When you call a Frame class method like add as a separate statement, it simply
does some work and returns control to the next statement. But the calls to the Math
methods like those in this table are used in expressions within assignment statements or
in the parameter lists of other method calls. A method that is called as part of an
expression does some work for you, but it also returns a value that takes its place in the
expression. The statement

rootX = Math.sqrt(x);

calls the Math.sqrt method, which returns the
square root of x that is assigned to rootX. Methods
such as Math.sqrt, which return a value, are called
value-returning methods. The third column in the
preceding table tells you the type of the value that is
returned.

Notice that these arithmetic value-returning
methods (such as Math.abs and Math.sqrt) are

called without having to specify the name of an object. Recall from Chapter 3 that
methods can be instance methods or class methods. These methods are class methods
because they are associated with the class itself, rather than with a particular object. The
Math class belongs to the package java.lang, which is automatically imported into
every program by the Java compiler.

Value-returning method A method that is called
from within an expression. The method returns a value
that takes its place in the expression, allowing further
operations to be performed on the value; also called a
function.

Matters of Style
Program Formatting

As far as the compiler is concerned, Java statements are free format: They can appear anywhere on a line,
more than one can appear on a single line, and one statement can span several lines. The compiler needs
blanks (or comments or new lines) to separate important symbols, and it needs semicolons to terminate state-
ments. However, it is extremely important that your programs be readable, both for your sake and for the sake
of anyone else who has to examine them.

When you write an outline for an English paper, you follow certain rules of indentation to make it read-
able. These same kinds of rules can make your programs easier to read. It is much easier to spot a mistake in a
neatly formatted program than in a messy one. Thus you should keep your program neatly formatted while
you are working on it. If you’ve gotten lazy and let your program become messy while making a series of
changes, take the time to straighten it up. Often the source of an error becomes obvious during the process of
formatting the code.

tcontinued

TE
AM
FL
Y

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

Team-Fly® 



4.6 Additional Mathematical Methods | 147

Take a look at the following program for computing the cost per square foot of a house. Although it compiles
and runs correctly, it does not conform to any formatting standards.

// HouseCost program
// This program computes the cost per square foot of
// living space for a house, given the dimensions of
// the house, the number of stories, the size of the
// nonliving space, and the total cost less land
import java.awt.*; import java.awt.event.*; import java.text.*;
public class UglyHouseCost {private static Frame out;// Declare a variable of    

//  type Frame
public static void main(String[] args){
final double WIDTH = 30.0;
final double LENGTH = 40.0;// Length of the house
final double STORIES = 2.5;// Number of full stories
final double NON_LIVING_SPACE = 825.0;  // Garage, closets, etc.
final double PRICE = 150000.0;// Selling price less land
double grossFootage;// Total square footage
double livingFootage;// Living area
double costPerFoot;// Cost/foot of living area
out = new Frame(); out.setLayout(new FlowLayout());  // Specify layout manager 

//   for frame
grossFootage = LENGTH * WIDTH * STORIES;  // Compute gross footage

livingFootage = grossFootage – NON_LIVING_SPACE;  // Compute net footage
costPerFoot = PRICE / livingFootage; // Compute cost per usable foot
out.add(new Label("Cost per square foot is " + costPerFoot));

out.pack();   out.show();  // Show the frame on the screen
// Event handler for window closing

out.addWindowListener(new WindowAdapter(){
public void windowClosing(WindowEvent event){ out.dispose();

System.exit(0);}});}}

Now look at the same program with proper formatting:

//******************************************************************
// HouseCost program
// This program computes the cost per square foot of

Program Formatting

tcontinued



148 | Chapter 4:  Numeric Types and Expressions

// living space for a house, given the dimensions of
// the house, the number of stories, the size of the
// nonliving space, and the total cost less land
//******************************************************************
import java.awt.*;                               // Import Frame type, etc.
import java.awt.event.*;                        // Import event handling 

//   types

public class HouseCost
{
// Declare a variable of type Frame
private static Frame out;                        

public static void main(String[] args)
{
final double WIDTH = 30.0;                     // Width of the house
final double LENGTH = 40.0;                    // Length of the house
final double STORIES = 2.5;                   // Number of full stories
final double NON_LIVING_SPACE = 825.0;         // Garage, closets, etc.
final double PRICE = 150000.0;                 // Selling price less land

double grossFootage;                          // Total square footage
double livingFootage;                          // Living area
double costPerFoot;                           // Cost/foot of living area

out = new Frame();                            // Instantiate Frame object
out.setLayout(new FlowLayout());               // Specify layout manager 

//   for frame

grossFootage = LENGTH * WIDTH * STORIES;          // Compute gross footage
livingFootage = grossFootage – NON_LIVING_SPACE;  // Compute net footage
costPerFoot = PRICE / livingFootage;             // Compute cost per

//   usable foot

out.add(new Label("Cost per square foot is " +    // Add result to frame
costPerFoot));

Program Formatting

tcontinued



4.7 Additional String Operations | 149

4.7 Additional String Operations
Now that we have introduced numeric types and method calls, we can take advantage
of additional features of the String data type. Here we introduce three useful methods
that operate on strings: length, indexOf, and substring. The methods are value-
returning methods.

The length Method

The length method, when applied to a String object, returns an int value that equals
the number of characters in the string. If myName is a String object, a call to the
length method looks like this:

myName.length()

out.pack();                                      // Pack the frame
out.show();                                      // Show the frame on 

//  the screen
// Event handler for window closing
out.addWindowListener(new WindowAdapter()         // Create a 

//  WindowClosing method
{
public void windowClosing(WindowEvent event)  //  to replace the empty 

//   one
{
out.dispose();                             // Remove the frame from

//  the screen
System.exit(0);                           // Stop the program

}
});

}
}

Need we say more?
Appendix F talks about programming style. Use it as a guide when you are writing programs.

Program Formatting



150 | Chapter 4:  Numeric Types and Expressions

The length method requires no parameters to be passed to it, but you still must use
parentheses to signify an empty parameter list. Because length is a value-returning
method, the method call must appear within an expression:

String firstName;                    // Local declarations
String fullName;
int    len;

firstName = "Alexandra";
len = firstName.length();            // Assigns 9 to len
fullName = firstName + " Jones";
len = fullName.length();             // Assigns 15 to len

The indexOf Method

The indexOf method searches a string to find the first occurrence of a particular sub-
string and returns an int value giving the result of the search. The substring, passed as
a parameter to the method, can be a literal string or a String expression. If str1 and
str2 are of type String, the following are valid method calls with each returning an
integer:

str1.indexOf("the")     str1.indexOf(str2)     str1.indexOf(str2 + "abc")

In each case above, str1 is searched to see if the specified substring can be found
within it. If so, the method returns the position in str1 where the match begins. (Posi-
tions are numbered starting at 0, so the first character in a string is in position 0, the
second is in position 1, and so on.) For a successful search, the match must be exact,
including identical capitalization. If the substring could not be found, the method
returns the value 21.

Given the code segment

String phrase;
int position;
phrase = "The dog and the cat";

then the statement

position = phrase.indexOf("the");

assigns to position the value 12, whereas the statement

position = phrase.indexOf("rat");

assigns to position the value 21, because there was no match.



4.7 Additional String Operations | 151

The parameter to the indexOf method can also be a char value. In this case,
indexOf searches for the first occurrence of that character within the string and returns
its position (or 21, if the character was not found). For example, the code segment

String theString;

theString = "Abracadabra";
position = theString.indexOf('a');

assigns the value 3 to position, which is the position of the first occurrence of a low-
ercase a in theString. (Remember the first position is 0.)

Below are some more examples of calls to the indexOf method, assuming the fol-
lowing code segment has been executed:

String str1;
String str2;

str1 = "Programming and Problem Solving";
str2 = "gram";

Method Call Value Returned by Method

str1.indexOf("and") 12
str1.indexOf("Programming") 0
str2.indexOf("and") 21
str1.indexOf("Pro") 0
str1.indexOf("ro" + str2) 1
str1.indexOf("Pr" + str2) 21
str1.indexOf(' ') 11

Notice in the fourth example that there are two copies of the substring "Pro" in str1,
but indexOf returns only the position of the first copy. Also notice that the copies can
be either separate words or parts of words—indexOf merely tries to match the sequence
of characters given in the parameter list. The final example demonstrates that the
parameter can be as simple as a single character, even a single blank.

The substring Method

The substring method returns a particular substring of a string. Assuming myString
is of type String, here is a sample method call:

myString.substring(5, 20)



152 | Chapter 4:  Numeric Types and Expressions

The parameters are integers that specify positions within the string. The method returns
the piece of the string that starts with the position specified by the first parameter and
continues to the position given by the second parameter minus 1. Thus, the length of
the substring returned by the example call is 20 2 5 = 15 characters. Note that sub-
string doesn’t change myString; it returns a new String value that is a copy of a
portion of the string. Below are some examples, assuming the statement

myString = "Programming and Problem Solving";

has been executed.

Method Call String Contained in Value Returned by Method

myString.substring(0, 7) "Program"
myString.substring(7, 15) "ming and"
myString.substring(10, 10) ""
myString.substring(24, 31) "Solving"
myString.substring(24, 25) "S"

In the third example in the preceding list, specifying the second parameter to be the
same as the first produces the empty string as the result. The last example illustrates
how to obtain a single character from a given position in the string. If either of the
parameters specifies a position beyond the end of the string, or if the second parameter
is smaller than the first, the call to substring results in an error message. One way to
avoid such errors is to write the call to substring in the following form. Here, start
is an int variable containing the starting position, and len is another int variable
containing the length of the desired substring.

myString.substring(start, Math.min(start+len, myString.length()))

Recall from our discussion of Java’s math methods that Math.min returns the
smaller of its two parameters. If start+len is accidentally greater than the length of the
string, min returns the length of myString instead. We have thus ensured that the sec-
ond parameter in the call to substring can be no greater than the length of myString.
We are assuming start is less than the length of the string, but we can use the same
sort of formula as the first parameter if we aren’t certain that this assumption is valid.

Because substring returns a value of type String, you can use it with the con-
catenation operator (+) to copy pieces of strings and join them together to form new
strings. The indexOf and length methods can be useful in determining the location
and end of a piece of a string to be passed to substring as parameters.

Here is a code segment that uses several of the String operations:

fullName = "Jonathan Alexander Peterson";
startPos = fullName.indexOf("Peterson");
name = "Mr. " + fullName.substring(startPos, fullName.length());



4.8 Formatting Numeric Types | 153

This code assigns "Mr. Peterson" to name when it is executed. First, it stores a
string into the variable fullName, and then it uses indexOf to locate the start of the
name Peterson within the string. Next, it builds a new string by concatenating the lit-
eral "Mr. " with the characters Peterson, which are copied from the original string.
As we see in later chapters, string operations are an important aspect of many computer
programs.

4.8 Formatting Numeric Types
By default, consecutive integer and string values are output with no spaces between
them. If the variables i, j, and k contain the values 15, 2, and 6, respectively, the state-
ment

out.add(new Label("Results: " + i + j + k));

displays a label containing

Results: 1526

Without spacing between the numbers, this output is difficult to interpret. To separate
the output values, you could insert a single blank (as a char literal) between the num-
bers:

out.add(new Label("Results: " + i + ' ' + j + ' ' + k));

This statement produces the label contents

Results: 15 2 6

If you want even more spacing between items, you can use literal strings containing
blanks:

out.add(new Label("Results: " + i + "    " + j + "    " + k));

Here, the resulting label contains

Results: 15    2    6

What do you suppose happens if we reverse the order of the parameters in our first
example? That is, what does the following statement output?

out.add(new Label(i + j + k + " are the results."));



154 | Chapter 4:  Numeric Types and Expressions

You might think it would display

1526 are the results

But you’d be wrong. It actually displays

23 are the results

Remember that a chain of + operators is evaluated left to right, and a + performs
concatenation only if one of its operands is a string.

Software Engineering Tip
Understanding Before Changing

When you are in the middle of getting a program to run and you come across an error, it’s
tempting to start changing parts of the program to try to make it work. Don’t! You’ll nearly
always make things worse. It’s essential that you understand what is causing the error and
that you carefully think through the solution. The only thing you should try is running the pro-
gram with different data to determine the pattern of the unexpected behavior.

There is no magic trick—inserting an extra semicolon or right brace, for example—that can
automatically fix a program. If the compiler tells you that a semicolon or a right brace is miss-
ing, you need to examine the program in light of the syntax rules and determine precisely
what the problem is. Perhaps you accidentally typed a colon instead of a semicolon. Or maybe
there’s an extra left brace.

If the source of a problem isn’t immediately obvious, a good rule of thumb is to leave the
computer and go somewhere where you can quietly look over a printed copy of the program.
Studies show that people who do all of their debugging away from the computer actually get
their programs to work in less time and in the end produce better programs than those who
continue to work on the machine—more proof that there is still no mechanical substitute for
human thought.2

2Basili, V. R., Selby, R. W., “Comparing the Effectiveness of Software Testing Strategies,” IEEE Transactions on
Software Engineering, Vol. SE–13, No. 12, pp. 1278–1296, Dec. 1987.



Problem-Solving Case Study | 155

Problem-Solving Case Study
Map Measurements

Problem You’re spending a day in the city. You plan to visit the natural history museum, a
record store, a gallery, and a bookshop, and then go to a concert. You have a tourist map that
shows where these places are located. You want to determine how far apart they are and how
far you’ll walk during the entire day. Then you can decide when it would be better to take a
taxi. According to the map’s legend, one inch on the map equals one quarter of a mile on the
ground.

Output The distance between each of the places and the total distance, rounded to the
nearest tenth of a mile. The values on which the calculations are based also should be
displayed for verification purposes.

Discussion You can measure the distances between two points on the map with a ruler. The
program must output miles, so you need to multiply the number of inches by 0.25. You then
write down the figure, rounded to the nearest tenth of a mile. When you’ve done this for each
pair of places, you add the distances to get the total mileage.

What are the objects in our by-hand solution? Distances. We can represent each distance
as a floating-point number. The operations on the objects are the same as those that we did by
hand.

The only tricky part is how to round a value to the nearest tenth of a mile. This is easy to
do in our head; how do we calculate it in our program? In this chapter, we showed how to
round a floating-point value to the nearest integer by adding 0.5 and using a type cast to
truncate the result:

(int)((double)Value + 0.5))

To round to the nearest tenth, we first multiply the value by 10, round the result to the nearest
integer, and then divide by 10 again. For example, if doubleValue contains 5.162, then

(double)((int)(doubleValue * 10.0 + 0.5)) / 10.0

gives 5.2.
Let’s treat all of the quantities as named constants so that it is easier to change the pro-

gram later. From measuring the map, you know that the distance from the museum to the
record store is 1.5 inches, from the record store to the gallery is 2.3 inches, from the gallery to
the bookshop is 5.9 inches, and from the bookshop to the concert is 4.0 inches. Our distance
objects are represented by these constants.



156 | Chapter 4:  Numeric Types and Expressions

Define Constants

Initialize the Total Miles

Initialize the Frame

Compute Miles for Each Distance on the Map

Before we go on, let’s examine the Compute Miles algorithm again. There are four state-
ments that are alike except for the distance object being used in the calculation. Wouldn’t it
be nice if we could write that calculation equation only once but have it be applied four times
to four different values? Well, this is an example of the third kind of method, a helper method. 

Set miles to (double)((int)(DISTANCE1 * SCALE * 10.0 + 0.5)) / 10.0
Display DISTANCE1, miles to one decimal place
Add miles to totMiles
Set miles to (double)((int)(DISTANCE2 * SCALE * 10.0 + 0.5)) / 10.0
Display DISTANCE2, miles to one decimal place
Add miles to totMiles
Set miles to (double)((int)(DISTANCE3 * SCALE * 10.0 + 0.5)) / 10.0
Display DISTANCE3, miles to one decimal place
Add miles to totMiles
Set miles to (double)((int)(DISTANCE4 * SCALE * 10.0 + 0.5)) / 10.0
Display DISTANCE4, miles to one decimal place
Add miles to totMiles

Set the layout manager to GridLayout with one column and any number of rows

Set totMiles to 0.0

DISTANCE1 = 1.5
DISTANCE2 = 2.3
DISTANCE3 = 5.9
DISTANCE4 = 4.0
SCALE = 0.25

TE
AM
FL
Y

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

Team-Fly® 



Problem-Solving Case Study | 157

Display the Total Miles

Handle the Window-Closing Event

From the algorithms, we can create tables of constants and variables that help us write
the declarations in the program.

Register the WindowAdapter
Dispose of the frame
Exit the program

Display totMiles miles 
Pack and show the frame

Constants

Name Value Description

DISTANCE1 1.5 Measurement for first distance
DISTANCE2 2.3 Measurement for second distance
DISTANCE3 5.9 Measurement for third distance
DISTANCE4 4.0 Measurement for fourth distance
SCALE 0.25 Scale factor of map

Variables

Name Data Type Description

out Frame Frame for output display
totMiles double Total of rounded mileages
miles double An individual rounded mileage



158 | Chapter 4:  Numeric Types and Expressions

Now we’re ready to write the program. Let’s call it Walk. We take the declarations from
the tables and create the executable statements from the algorithm. We have labeled the out-
put with explanatory messages. We’ve also added comments where needed.

Here is the program:

//*************************************************************************
// Walk program
// This program computes the mileage (rounded to tenths of a mile) for each 
//  of four distances between points in a city, given the measurements on a 
//  map with a scale of one inch equal to one quarter of a mile
//*************************************************************************
import java.awt.*;                      // Import Frame type, etc.
import java.awt.event.*;                // Import event handling types

public class Walk
{
private static Frame out;             // Declare a variable of type Frame

public static void main(String args[])
{
final double DISTANCE1 = 1.5;       // Measurement for first distance
final double DISTANCE2 = 2.3;       // Measurement for second distance
final double DISTANCE3 = 5.9;       // Measurement for third distance
final double DISTANCE4 = 4.0;       // Measurement for fourth distance
final double SCALE = 0.25;          // Map scale

double totMiles;                    // Total of rounded mileages
double miles;                       // An individual rounded mileage

out = new Frame();                  // Instantiate Frame object
out.setLayout(new GridLayout(0,1)); // Specify layout manager for frame

totMiles = 0.0;
// Compute and display miles for each distance on the map
miles = (double)((int)(DISTANCE1 * SCALE * 10.0 + 0.5)) / 10.0;



Problem-Solving Case Study | 159

out.add(new Label("For a measurement of " + DISTANCE1 + " the first 
distance  is " + miles  + "mile(s) long."));

totMiles = totMiles + miles;

miles = (double)((int)(DISTANCE2 * SCALE * 10.0 + 0.5)) / 10.0;
out.add(new Label("For a measurement of " + DISTANCE2 + " the second 

distance  is " + miles + " mile(s) long."));
totMiles = totMiles + miles;

miles = (double)((int)(DISTANCE3 * SCALE * 10.0 + 0.5)) / 10.0;
out.add(new Label("For a measurement of " + DISTANCE3  + " the third 

distance  is " + miles + " mile(s) long."));
totMiles = totMiles + miles;

miles = (double)((int)(DISTANCE4 * SCALE * 10.0 + 0.5)) / 10.0;
out.add(new Label("For a measurement of " + DISTANCE4  + " the fourth 

distance  is " + miles + " mile(s) long."));

totMiles = totMiles + miles;
// Display the total miles and show the frame
out.add(new Label("Total mileage for the day is "

+ totMiles + " miles."));
out.pack();                       // Pack the frame
out.show();                        // Show the frame on the screen

// Event handler for window closing
out.addWindowListener(new WindowAdapter()    
// Create a WindowClosing method to replace the empty one
{
public void windowClosing(WindowEvent event)
{
out.dispose();               // Remove the frame from the screen7
System.exit(0);              // Stop the program

}
});

}
}



160 | Chapter 4:  Numeric Types and Expressions

The output from the program is

Testing and Debugging

1. An int literal other than 0 should not start with a zero. If it starts with zero, it is an
octal (base–8) number.

2. Watch out for integer division. The expression 47/100 yields 0, the integer quo-
tient. This error is one of the major sources of wrong output in Java programs.

3. When using the / and % operators, remember that division by zero is not allowed.
4. Double-check every expression according to the precedence rules to be sure that the

operations are performed in the desired order. This step is especially necessary for
expressions involving string conversion.

5. Avoid mixing integer and floating-point values in expressions. If you must mix
them, consider using explicit type casts to reduce the chance of mistakes.

6. For each assignment statement, check that the expression result has the same data
type as the variable to the left of the assignment operator (=). If not, consider using
an explicit type cast for clarity and safety. And remember that storing a floating-
point value into an int variable truncates the fractional part.

7. If a program is producing erroneous results and all of its expressions appear to be
correct, check to see if any of them can result in integer overflow. Also check to see
if they contain any unintentional conversions.

8. For every library package you use in your program, be sure to use an import dec-
laration.



Testing and Debugging | 161

Package Name

Class Name Comments

java.lang Automatically imported to every Java
program

Math

Value-Returning Class Methods:
abs(int) Returns int
abs(long) Returns long
abs(float) Returns float
abs(double) Returns double
cos(double) Returns double
log(double) Returns double
max(int, int) Returns int
max(long, long) Returns long
max(float, float) Returns float
max(double, double) Returns double
min(int, int) Returns int
min(long, long) Returns long
min(float, float) Returns float
min(double, double) Returns double
pow(double, double) Returns double
sin(double) Returns double
sqrt(double) Returns double

String

Value-Returning Instance Methods:
length() Returns int
indexOf(String) Returns int
indexOf(char) Returns int
substring(int, int) Returns String

9. Examine each method call to see that you have the correct number of parameters
and that the data types of the parameters are correct.

10. If the cause of an error in a program is not obvious, leave the computer and study a
printed listing. Change your program only after you understand the source of the
error.

Summary of Classes

In this chapter we introduced value-returning methods, so we add this form of method
to our table that summarizes the classes discussed in the chapter.



162 | Chapter 4:  Numeric Types and Expressions

Summary
Java provides several built-in numeric data types, of which the most commonly used
are int and double. The integral types are based on the mathematical integers, but the
computer limits the range of integer values that can be represented. The floating-point
types are based on the mathematical notion of real numbers. As with integers, the com-
puter limits the range of floating-point numbers that can be represented. In addition, it
limits the number of digits of precision in floating-point values. We can write literals of
type double in several forms, including scientific (E) notation. Java provides the stan-
dard mathematical operations to go with these data types: addition (+), subtraction (-),
multiplcation (*), division (/), and remainder (%). Java also provides an increment oper-
ation (++) and a decrement operation (--).

Mixing values of the integer and floating-point types in an expression results in
automatic type conversion to achieve compatibility between the operands of all of the
operators. If you aren’t careful, these automatic conversions can have unanticipated
results. It is best to explicitly use type cast operations whenever you need to mix types
within expressions.

Much of the computation of a program is performed in arithmetic expressions.
Expressions can contain more than one operator. The order in which the operations are
performed is determined by precedence rules. In arithmetic expressions, the unary oper-
ators (such as negation) are performed first, then type casts, then multiplication, divi-
sion, and modulus are performed, and lastly addition and subtraction. Multiple
arithmetic operations of the same precedence are grouped from left to right. You can
use parentheses to override the precedence rules.

Not only should the output produced by a program be easy to read, but the format of
the program itself should be clear and readable. Java is a free-format language. A con-
sistent style that uses indentation, blank lines, and spaces within lines helps you (and
other programmers) understand and work with your programs.

Quick Check
1. Write a local Java constant declaration that gives the name PI to the value

3.14159. (p. 129)
2. Declare an int variable named count and a double variable named sum. (pp.

130–131)
3. You want to divide 9 by 5.

a. How do you write the expression if you want the result to be the floating-
point value 1.8? (pp. 138–139)

b. How do you write it if you want only the integer quotient?  (pp. 138–139)
4. What is the value of the following Java expression?

5 % 2

(pp. 131–133)



Quick Check | 163

5. What is the result of evaluating the expression

(1 + 2 * 2) / 2 + 1

(p. 137)
6. How would you write the following formula as a Java expression that produces

a floating-point value as a result? (pp. 138–139)

7. Add type casts to the following statements to make the type conversions clear
and explicit. Your answers should produce the same results as the original state-
ments. (pp. 138–139)
a. someDouble = 5 + someInt;
b. someInt = 2.5 * someInt / someDouble;

8. You want to compute the square roots and absolute values of some floating-
point numbers. Which Java methods would you use? (pp. 145–146)

9. If the String variable str contains the string “Now is the time”, what is the
result of the following expression? (pp. 149–153)

str.length() + ' ' + str.substring(1, 3)

10. Reformat the following program to make it clear and readable. (pp. 146–149)

//*************************************************************
// SumProd program

// This program computes the sum and product of two integers
//*************************************************************
import java.awt.*; public class SumProd {
private static Frame out;
public static void main(String[] args){

final int INT2=8;
out = new Frame();
out.setLayout (new FlowLayout());

final int INT1=20; out.add(new Label(
"The sum of " + INT1 + " and "
+ INT2 + " is " + INT1+INT2)); out.add(new Label (
"Their product is " + (INT1*INT2))); out.pack(); out.show(); }
}

11. What should you do if a program fails to run correctly and the reason for the
error is not immediately obvious? (p. 154)

9
5

32c +



164 | Chapter 4:  Numeric Types and Expressions

Answers

1. final double PI = 3.14159;
2. int   count;

float sum;
3. a. 9.0 / 5.0 or (double) 9 / (double) 5 b. 9 / 5
4. The value is 1.
5. The result is 3.
6. 9.0 / 5.0 * c + 32.0
7. a. someDouble = (double)(5 + someInt);

b. someInt = (int)(2.5 * (double)(someInt) / someDouble);
8. math.sqrt and math.abs 9. 15 ow

10.
//*************************************************************
// SumProd program
// This program computes the sum and product of two integers
//*************************************************************
import java.awt.*;

public class SumProd
{
private static Frame out;
public static void main(String[] args)
{
final int INT1 = 20;
final int INT2 = 8;

out = new Frame();
out.setLayout(new FlowLayout());
out.add(new Label("The sum of " + INT1 + " and "
+ INT2 + " is " + INT1+INT2));
out.add(new Label ("Their product is " + (INT1*INT2)));
out.pack();
out.show();
}

}

11. Print out the program, leave the computer, and study the program until you
understand the cause of the problem. Then correct the algorithm and the pro-
gram as necessary before you go back to the computer and make any changes in
the program file.

Exam Preparation Exercises
1. Mark the following constructs either valid or invalid. Assume all variables are of

type int.



Exam Preparation Exercises | 165

Valid Invalid

a. x * y = c; ______ _______
b. y = con; ______ _______
c. private static final int x : 10; ______ _______
d. int x; ______ _______
e. a = b % c; ______ _______

2. If alpha and beta are int variables with alpha = 4 and beta = 9, what value
is stored into alpha in each of the following? Answer each part independently
of the others.
a. alpha = 3 * beta;
b. alpha = alpha + beta;
c. alpha++;
d. alpha = alpha / beta;
e. alpha--;
f. alpha = alpha + alpha;
g. alpha = beta % 6;

3. Compute the value of each legal expression. Indicate whether the value is an
integer or a floating-point value. If the expression is not legal, explain why.

Integer Floating Point

a. 10.0 / 3.0 + 5 * 2 ______ _______
b. 10 % 3 + 5 % 2 ______ _______
c. 10 / 3 + 5 / 2 ______ _______
d. 12.5 + (2.5 / (6.2 / 3.1)) ______ _______
e. –4 * (–5 + 6) ______ _______
f. 13 % 5 / 3 ______ _______
g. (10.0 / 3.0 % 2) / 3 ______ _______

4. What value is stored into the int variable result in each of the following?
a. result = 15 % 4;
b. result = 7 / 3 + 2;
c. result = 2 + 7 * 5;
d. result = 45 / 8 * 4 + 2;
e. result = 17 + (21 % 6) * 2;
f. result = (int)(4.5 + 2.6 * 0.5);

5. If a and b are int variables with a = 5 and b = 2, what output does each of the
following statements produce?
a. out.add(new Label("a = " + a + "b = " + b));
b. out.add(new Label("Sum:" + a + b));
c. out.add(new Label("Sum:  " + a + b));
d. out.add(new Label(a / b + " feet"));



166 | Chapter 4:  Numeric Types and Expressions

6. What does the following program print?

import java.awt.*
public class ExamPrep
{
private static Frame out;
public static void main(String[] args)
{
final int LBS = 10;
int  price;
int  cost;
char ch;
out = new Frame();
out.setLayout(new GridLayout(0,1));
price = 30;
cost = price * LBS;
ch = 'A';
out.add(new Label("Cost is "));
out.add(new Label(cost));
out.add(new Label("Price is " + price + "Cost is " + cost));
out.add(new Label("Grade " + ch + " costs "));
out.add(new Label(cost));
out.pack();
out.show();

}
}

7. Translate the following Java code into algebraic notation. (All variables are dou-
ble variables.)

y = -b + sqrt(b * b – 4.0 * a * c);

8. Given the following program fragment:

int    i;
int    j;
double z;

i = 4;
j = 17;
z = 2.6;

determine the value of each expression below. If the result is a floating-point
value, include a decimal point in your answer.
a. i / (double)j
b. 1.0 / i + 2
c. z * j

TE
AM
FL
Y

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

Team-Fly® 



Exam Preparation Exercises | 167

d. i + j % i
e. (1 / 2) * i
f. 2 * i + j – i
g. j / 2
h. 2 * 3 – 1 % 3
i. i % j / i
j. (int)(z + 0.5)

9. To use each of the following statements, a Java program must import which
package(s)?
a. out.add(new Label(x));
b. new WindowAdapter();
c. out.setLayout(new GridLayout(0, 2));
d. out.pack();

10. Evaluate the following expressions. If the result is a floating-point number,
include a decimal point in your answer.
a. Math.abs(–9.1)
b. Math.sqrt(49.0)
c. 3 * (int)7.8 + 3
d. Math.pow(4.0, 2.0)
e. Math.sqrt((double)(3 * 3 + 4 * 4))
f. Math.sqrt(abs(–4.0) + Math.sqrt(25.0))

11. Given the statements

String heading;
String str;
heading = "Exam Preparation Exercises";

what is the output of each code segment below?
a. out.add(new Label(heading.length()));
b. out.add(new Label(heading.substring(6, 16)));
c. out.add(new Label(heading.indexOf("Ex")));
d. str = heading.substring(2, 26);

out.add(new Label(str.indexOf("Ex")));
e. str = heading.substring(heading.IndexOf("Ex") + 

2, heading.length());
out.add(new Label(str.indexOf("Ex")));

12. Formatting a program incorrectly causes an error. (True or False?)



168 | Chapter 4:  Numeric Types and Expressions

Programming Warm-Up Exercises
1. Change the program in Exam Preparation Exercise 6 so that it prints the cost for

15 pounds.
2. Write an assignment statement to calculate the sum of the numbers from 1

through n using Gauss’s formula:

Store the result into the int variable sum.
3. Given the declarations

int    i;
int    j;
double x;
double y;

write a valid Java expression for each of the following algebraic expressions.

a. e. (the floating-point result)

b. (x + y)(x 2 y) f. (the integer quotient)

c. g.

d.

4. Given the declarations

int    i;
long   n;
double x;
double y;

write a valid Java expression for each of the following algebraic expressions.
Use calls to math methods wherever they are useful.

  

1
x

y+

  

x y x y

x

+
−

−
3 5

4  

1
x y+

 

i
j

 

i
j  

x
y

− 3

  
Sum =

+( )n n 1
2



Programming Warm-Up Exercises | 169

a. (absolute value) e.

b. |n| f.

c. |x + y| g.

d. |x| + |y|

5. Write expressions to compute both solutions for the quadratic formula. The for-
mula is

The 6 means “plus or minus” and indicates that there are two solutions to the
equation, one in which the result of the square root is added to 2b and one in
which the result is subtracted from 2b. Assume all variables are float variables.

6. Enter the following program into your computer and run it. In the initial com-
ments, replace the items within parentheses with your own information. (Omit
the parentheses.)

//***********************************
// Programming Assignment One
// (your name)
// (date program was run)
// (description of the problem)
//***********************************
import java.awt.*;

class WarmUp
{
public static void main(String[] args)
{
private static Frame out;      // Frame for output
final double DEBT = 300.0;    // Original value owed
final double PMT = 22.4;       // Payment
final double INT_RATE = 0.02;  // Interest rate

  

− ± −b b ac
a

2 4
2

  
x y+( )7

  x y
6 5+

  

X
x y

3

+
i



170 | Chapter 4:  Numeric Types and Expressions

double charge;     // Interest times debt
double reduc;      // Amount debt is reduced
double remaining;   // Remaining balance

out = new Frame();
out.setLayout(new FlowLayout());
charge = INT_RATE * DEBT;
reduc = PMT – charge;
remaining = DEBT – reduc;
out.add(new Label("Payment: " + PMT + " Charge: " + charge

+ " Balance owed: " + remaining));
out.pack();
out.show();

}
}

7. Enter the following program into your computer and run it. Add comments,
using the pattern shown in Exercise 6 above. (Notice how hard it is to tell what
the program does without the comments.)

import java.awt.*;
class WarmUp2
{
private static Frame out;
public static void main(String[] args)
{
final int TOT_COST = 1376;
final int POUNDS = 10;
final int OUNCES = 12;

int    totOz;
double uCost;

out = new Frame();
out.setLayout(new FlowLayout());
totOz = 16 * POUNDS;
totOz = totOz + OUNCES;
uCost = TOT_COST / totOz;
out.add(new Label("Cost per unit: " + uCost));
out.pack();
out.show();

}
}



Programming Problems | 171

8. Complete the following Java program. The program should find and output the
perimeter and area of a rectangle, given the length and the width. Be sure to
label the output, and don’t forget to use comments.

//***********************************************
// Rectangle program
// This program finds the perimeter and the area
// of a rectangle, given the length and width
//***********************************************
import java.awt.*;
class Rectangle
{
private static Frame out;      // Frame for output
public static void main(String[] args)
{

double length;               // Length of the rectangle
double width;                // Width of the rectangle
double perimeter;            // Perimeter of the rectangle
double area;                // Area of the rectangle

length = 10.7;
width = 5.2;

9. Write an expression whose result is the position of the first occurrence of the
characters "res" in a String variable named sentence. If the variable con-
tains the first sentence of this question, then what is the result? (Look at the sen-
tence carefully!)

10. Write a sequence of Java statements to output the positions of the second and
third occurrences of the characters “res” in the String variable named sen-
tence. You may assume that there are always at least three occurrences in the
variable. (Hint: Use the substring method to create a new string whose con-
tents are the portion of sentence following an occurrence of “res”.)

Programming Problems
1. Java systems provide a set of classes that duplicate the names of primitive

types except that the first letter of the type name is capitalized (for example,
Double and Long instead of double and long). The two exceptions are that
the class corresponding to int is called Integer and the class corresponding
to char is called Character. Each of these types contains declarations of con-
stants related to the corresponding primitive type. Two of these constants are
Integer.MAX_VALUE and Integer.MIN_VALUE, the largest and smallest int



172 | Chapter 4:  Numeric Types and Expressions

values that Java allows. Write an application to display the values of Inte-
ger.MAX_VALUE and Integer.MIN_VALUE. The output should identify which
value is Integer.MAX_VALUE and which value is Integer.MIN_VALUE. Be
sure to include appropriate comments in your program, and use indentation as
we do in the programs in this chapter. Each of these types defines similar con-
stants, so you may want to extend your program to display Long.MIN_VALUE,
and so on, just to learn what the actual maximum and minimum numbers are
for each of the primitive types.

2. Write an application that outputs three labels, displayed on separate lines as fol-
lows:

7 / 4 using integer division equals <result>
7 / 4 using floating point division equals <result>
7 modulo 4 equals <result>

where <result> stands for the result computed by your program. Use named con-
stants for 7 and 4 everywhere in your program (including the output statements)
to make the program easy to modify. Be sure to include appropriate comments in
your program, choose meaningful identifiers, and use indentation as we do in
the programs in this chapter.

3. Write a Java application that converts a Celsius temperature to its Fahrenheit
equivalent. The formula is

Make the Celsius temperature a named constant so that its value can be changed
easily. The program should print both the value of the Celsius temperature and
its Fahrenheit equivalent, with appropriate identifying messages. Be sure to
include appropriate comments in your program, choose meaningful identifiers,
and use indentation as we do in the programs in this chapter.

4. Write an application to calculate the diameter, the circumference, and the area of
a circle with a radius of 6.75. Assign the radius to a float variable, and then
output the radius with an appropriate message. Declare a named constant PI
with the value 3.14159. The program should output the diameter, the circumfer-
ence, and the area, each on a separate line, with identifying labels. Be sure to
include appropriate comments in your program, choose meaningful identifiers,
and use indentation as we do in the programs in this chapter.

5. You have bought a car, taking out a loan with an annual interest rate of 9%.
You expect to make 36 monthly payments of $165.25 each. You want to keep

 
Fahrenheit Celsius= +9

5
32



Case Study Follow-Up Exercises | 173

track of the remaining balance you owe after each monthly payment. The for-
mula for the remaining balance is

where

Balk = balance remaining after the kth payment
k = payment number (1, 2, 3, ...)

pmt = amount of the monthly payment
i = interest rate per month (annual rate ÷ 12)
n = total number of payments to be made

Write an application to calculate and display the balance remaining after the
first, second, and third monthly car payments. Before showing these three
results, the program should output the values on which the calculations are
based (monthly payment, interest rate, and total number of payments). Display
an identifying message with each numerical result. Be sure to include appropri-
ate comments in your program, choose meaningful identifiers, and use indenta-
tion as we do in the programs in this chapter.

Case Study Follow-Up Exercises
1. What is the advantage of using named constants instead of literal constants in

the Walk program?
2. Modify the Walk program to include a round-off factor so that the rounding of

miles can be modified easily. Currently, the program uses a literal constant
(10.0) in several places to round miles to the nearest tenth, requiring us to make
multiple changes if we want a different round-off factor.

3. Should the round-off factor in Question 2 be a constant or a variable? Explain.
4. In the Walk program, a particular pattern of statements is repeated four times

with small variations. Identify the repeating pattern. Next, circle those parts of
the statements that vary with each repetition. Having done this, now modify the
Walk program to work with a fifth distance measurement.

Bal pmtk

k ni

i
=

− +( )








−1 1





                 

To be able to construct statements to display a data
entry field on the screen.

To be able to display a button on the screen and reg-
ister it as an event source.

To be able to write statements to read values from a
data entry field into a program when a button is
pressed.

To be able to write an event handler for a button event
and register it as a listener.

To know how to convert strings containing numbers
into numeric types.

To be able to write appropriate prompting labels for
interactive programs.

To be able to describe the basic principles of object-
oriented design and functional decomposition.

To be able to apply the object-oriented design strategy
to solve a simple problem.

To be able to apply the functional decomposition strat-
egy to solve a simple problem.

To be able to take a design for a software solution and
code it in Java, using self-documenting code.

Event-Driven Input
and Software Design
Strategies

G
oals



176 | Chapter 5:  Event-Driven Input and Software Design Strategies

Input

Output
Output

Data set
1

PROGRAM 2

Result set
1

Input

Output

Data set
2

PROGRAM 2

Result set
2

PROGRAM 1

Results

This program must
be changed to work
with different data
values.

This program inputs its data
from outside, so it can work
with different data sets without
being changed.

Data as
constants

Figure 5.1 Separating the data from the program

A program needs data on which to operate. We have been writing all of the data values
in the program itself, in literal and named constants. If this were the only way we could
enter data, we would have to rewrite a program each time we wanted to apply it to a
different set of values. In this chapter, we look at ways of entering data into a program
while it is running.

Once we know how to input data, process the data, and output the results, we can
begin to think about designing more complicated programs. We have talked about gen-
eral problem-solving strategies and writing simple programs. For a simple problem, it’s
easy to choose a strategy, write the algorithm, and code the program. But as problems
become more complex, we have to use a more organized approach. In the second part of
this chapter, we look at two general strategies for developing software: object-oriented
design and functional decomposition.

5.1 Getting Data into Programs
One of the biggest advantages of computers is that a program can be used with many
different sets of data. To do so, we must keep the data separate from the program until
the program is executed. Then instructions in the program copy values from the data set
into variables in the program. After storing these values into the variables, the program
can perform calculations with them (see Figure 5.1).

The process of placing values from an outside data set into variables in a program
is called input. In widely used terminology, the computer is said to read outside data
into the variables. The data for the program can come from an input device (such as a
keyboard or mouse) or from a file on an auxiliary storage device. We look at file input
in Chapter 9; here we consider data entered from the keyboard.

TE
AM
FL
Y

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

Team-Fly® 



5.2 Entering Data Using Fields in a Frame | 177

Figure 5.2 Possible data entry frame for the Payroll program

5.2 Entering Data Using Fields in a Frame
If the Payroll program in Chapter 1 had used interactive input, the frame in Figure 5.2
would have been appropriate.

This frame contains three labels and a
button (Done) in the left column of its grid.
The right column has three data entry fields.

It’s important to note that a data entry
field and a Java field (a declaration in a class)
are not the same. One is an area on the screen
and the other is a name representing a con-
stant or variable. This is a case where the Java
designers use the same word to mean two dif-
ferent things. When discussing fields, we must clearly indicate which kind we are refer-
ring to. Syntactically, Java doesn’t confuse them because a data entry field is a type of
object and a class field is part of a class declaration.

The user clicks within a data entry field to position the cursor there and then types
a value into the field using the keyboard. As shown in Figure 5.2, the program displays
each field with an initial value that the user can delete before entering a value. Such an
initial value is called a default value. A program can also be written to display a field
without a default value. Including a default value is one way to show the user how to
type data within the field.

The user can enter the data into the fields in any order and can go back to any field
and correct a mistyped value. None of the user’s actions are seen by the program until the
button is clicked. Of course, the computer is responding to the user’s keystrokes and mouse
clicks, so some program must be handling these actions. What is it? The JVM, working
together with the operating system, handles the individual keystrokes and mouse actions.

There is a separate variable in the program that corresponds to each field object in
the frame. The operating system keeps a copy of each field’s contents in objects
assigned to these variables. Meanwhile, the program is doing nothing because it has
turned control over to the JVM. You can picture a program covering its eyes while the
user makes changes to its field variables via the operating system and JVM.

Button A component of a frame that fires an event
(called a button event) when the user clicks on it with
the mouse

Field A component of a frame in which the user can
type a value. The user must first place the cursor in the
field by clicking inside the field.



178 | Chapter 5:  Event-Driven Input and Software Design Strategies

Event Handler

Process data
Reset values in fields
Return to Java

Payroll

•

•

hoursField;
payRateField;
empNumField;

Create and display frame

Turn control over to Java

Clicking the Done button fires
an event that causes the
corresponding Event Listener to
call the Event Handler. The Event 
Handler processes the values in 
the field variables and resets the 
values in the fields.

User enters values in fields. JVM copies
values into corresponding variables in
the program.

Figure 5.3 Data entry process

When the user clicks on the button, the button event is fired and the appropriate
handler within the button listener is invoked. The event handler springs into action (the
program uncovers its eyes) and processes the values that are currently stored in the
variables associated with the fields. The event handler then restores the values in the
fields to their default values and returns control to the JVM. Seeing the fields return to
their default values is a signal to the user that he or she can enter another set of values.
This process is shown in Figure 5.3.



5.3 Creating a Data Entry Field | 179

Entering data in the manner that we have
just described is typical of modern programs,
and is called a dialog. In a theatrical play, a
dialog is an exchange between two charac-
ters. In the case of the computer, a dialog is
an exchange between the user and a program.
The program initiates the dialog by displaying
a frame, the user replies by entering data into
the fields of the frame and clicking a button,
the program processes the data and responds by updating the frame.

If the program needs to have a series of values entered, it can again display the
frame in its initial form and the user replies again. This data entry cycle is called an
event loop. The event loop continues until the user indicates that there is no more data
to enter, perhaps by entering a special data value or clicking another button.

Later we consider the finer points of designing a dialog so that it is easy to use.
Such considerations are especially important when a dialog involves entering data into
multiple fields in a frame. Until then, we focus our attention on a simple dialog using a
frame that contains a single field, a label for the field, and a button.

5.3 Creating a Data Entry Field
Creating a data entry field in Java is very similar to creating a label. The essential steps
are the same, with only minor differences. Those steps are:

1. Declare a variable of the appropriate field class
2. Instantiate an object of the class
3. Add the object to the frame using the add method

We saw in Chapter 3 that a label is simply an object of type Label. A data entry
field is an object of type TextField. For example, you can declare a variable called
inputField as follows:

TextField inputField;      // Declare a field for data entry

When you create a Label object with new, you pass a string to the Label construc-
tor that tells it what text to display in the label. For example, here is a statement that
creates and assigns a Label object containing the string "Enter data here:" to a
Label variable called fieldLabel.

fieldLabel = new Label("Enter data here:");

When creating an object of type TextField, you provide the constructor with the size
of the field. Here is an example of creating and assigning a TextField object to the
variable inputField.

inputField = new TextField(6);

Dialog A style of user interface in which the user
enters data and then performs a separate action (such
as clicking a button) when the entered values are ready
to be processed by the program

Event loop The repetitive calling of an event handler
to respond to a series of events, until some condition
causes the program to exit the cycle.



180 | Chapter 5:  Event-Driven Input and Software Design Strategies

In this example, the object assigned to inputField is specified to have space for
typing six characters within it. You can give the field a default value by including a
string as the first parameter to the constructor. For example,

inputField = new TextField("Replace Me", 10);

would cause the TextField object to be created with space for 10 characters, and ini-
tially the words "Replace Me" would appear within the field.

The last step in creating a field is to add it to a frame. Just as with a label, you can
use the frame’s add method. If you have a frame called dataEntryFrame, then you
would write:

dataEntryFrame.add(inputField);

When you call dataEntryFrame.show(), the frame appears on the screen with a field
for entering data. As you can see, creating a field really is just as simple as creating a
label. There is one very important difference between a Label field and a TextField
field: The user cannot change the text written in a Label but can change the text in the
TextField. 

In some of our examples, we’ve instantiated labels directly within the parameter list
of add. Java lets us do the same thing with a TextField, but we should never do so.
The reason is that objects instantiated in this manner aren’t assigned to a variable, so
there is no name that we can use to access them. These are called anonymous objects.
Sometimes we add a Label to a Frame and then never access it again; in that case it’s
OK for it to be anonymous. But the reason for adding a TextField is to later access its
contents for input data. So a TextField object must be assigned to a variable to be
useful. 

Now let’s look at how to get the data from the field in which it has been entered.

5.4 Extracting a Value from a Field
Just as a Frame object has methods such as add, pack, and show associated with it,
a TextField object also comes with a set of methods. One of those methods, called
getText, enables us to get the current value in the field as it appears on the screen. The
getText method returns a value of type String that holds a copy of the contents of
the field. For example, if you declare a String variable called fieldContents, you
can write

fieldContents = inputField.getText();

to store the characters currently contained in inputField into fieldContents.
Note that we have not yet said anything about when or where to call the getText

method. We have considered the steps of creating the field and taking data from it in



5.4 Extracting a Value from a Field | 181

Figure 5.4 A Frame with one TextField

isolation from the rest of the program. In the following sections, we examine how these
steps are related to handling a button event that tells the program when the user is
ready to have it look at the data. Before that, however, there is one more TextField
method that we would like to introduce.

You saw in the last section how a field can be given a default value by its construc-
tor. Once a field has been created and shown on the screen, it is often useful to be able
to change its contents. For example, after the program has processed the contents of the
field, it may replace them with the default value so that the user knows that he or she
can enter a new value. The setText method replaces the current contents of a field
with a string that is passed to it. Here is an example of calling setText:

inputField.setText("Replace Me");

Notice that setText is a void method. It does not return a value, and it is called as a
separate statement. If you want to clear the field so that it appears empty, you simply
call setText with an empty string:

inputField.setText("");

A call to setText immediately changes the contents of the field on the screen. You do
not call the frame’s show method again to update the field. Figure 5.4 shows a window
with one TextField object.

You might notice another similarity between a Label object and a TextField
object; a Label object also has a setText method that allows you to change its con-
tents after it has been displayed on the screen. For example, you can write

fieldLabel.setText("Enter more data:");

which changes the text in fieldLabel to the string, "Enter more data:".



182 | Chapter 5:  Event-Driven Input and Software Design Strategies

Given all of their similarities, it is important to remember the major distinction
between a Label object and a TextField object: The user cannot change what is dis-
played in a Label, but he or she can change the contents of a TextField.

5.5 Creating a Button
Before you can handle a button event, you have to put a button into the frame and reg-
ister a listener with the button object. First, let’s consider how to add a button to a
frame. The process is very much like adding a label or a field.

1. Declare a variable of the appropriate button class
2. Instantiate an object of the class
3. Add the object to the frame using the add method

In the case of a button, the appropriate class is called Button. An example declara-
tion is:

Button done;          // Declare a Button variable called done

The call to its constructor includes the string that should appear inside of the button.
For example,

done = new Button("Done");         // Create a Button object

The call to the add method for a frame called dataEntryField is written:

dataEntryFrame.add(done);

When the show method for the frame is called, a button is included in the frame with
the word "Done" appearing inside of it. Note that we are using our convention of start-
ing a variable identifier with a lowercase letter, but the string that appears in the button
is capitalized. Java may not use proper English capitalization, but our user interface
should! The identifier done with a lowercase d is the name of a button object; "Done"
with an uppercase D is the string that appears on the button on the screen. Now let’s
examine the button registration process.

Each event listener must be registered with the appropriate event source. When the
event fires, the object that generated it calls the appropriate method within the listener
to process the event. Each Java application has its own set of possible events and corre-
sponding event listeners. Registration is a two-part process: giving a name to the event
and registering a corresponding listener. In the case of closing the window, however,
you didn’t have to give a name to the event. Because Java predefines all of the events
that a window can generate, it automatically names them when you create a frame.

Java doesn’t know in advance what buttons are added to a frame or what they are
called. There could be dozens of buttons on the screen at once and all of them could



5.5 Creating a Button | 183

have the same listener. So each event must have a name that distinguishes it from the
others. Giving the event a name is simply a matter of calling a method associated with
its Button object. The method is called setActionCommand and it takes one parameter,
a string that names the event. Here is an example:

done.setActionCommand("done");

The example call tells the Button object called done that when it generates an
event it should supply the string "done" to any listener that responds to the event. Note
that the string doesn’t have to be the same as the name of the object. It can be any
string of our choosing. However, it’s easier to remember a single name for both, so that
is the style we follow in this text. Keep in mind that there are two strings associated
with a button, the one that is displayed on the screen and the one that names the event
that the button generates.

If a user interface has multiple buttons, when the event handler is called, it does-
n’t automatically know which one was clicked. To tell them apart, it looks at the event
name string associated with the event. Because we use frames with just one button in
this chapter, we needn’t be concerned with using the name in our event handler
method. Even so, we still give the button event a name as a matter of good program-
ming practice. In Chapter 6, we use the event name to handle events from multiple
buttons.

Let’s put together all of the elements we’ve seen in this chapter to show how to
create the example frame.

Frame dataEntryFrame;                       // Declare a frame
Label fieldLabel;                            // Declare a label
TextField inputField;                        // Declare a field
Button done;                                 // Declare a button
;

dataEntryFrame = new Frame();                 // Give the frame a value
fieldLabel = new Label("Enter data here:");   // Give the label a value
inputField = new TextField("Replace me", 10); // Give the field a value
done = new Button("Done");                 // Give the button a value
done.setActionCommand("done");               // Name the button event

dataEntryFrame.setLayout(new FlowLayout());   // Set the layout manager
dataEntryFrame.add(fieldLabel);               // Add the label to frame
dataEntryFrame.add(inputField);               // Add the field to frame
dataEntryFrame.add(done);                     // Add the button to frame
dataEntryFrame.pack();                       // Pack the frame
dataEntryFrame.show();                       // Show the frame

The above code segments result in a frame with the following appearance.



184 | Chapter 5:  Event-Driven Input and Software Design Strategies

Of course, when the user clicks on the Done button, nothing appears to happen. In fact,
something does happen: An event is fired, but we have not registered the listener with
the button. Since the button doesn’t know what to do, it simply ignores the event. Now
let’s look at how to create such a handler.

5.6 Creating and Registering a Button Event Listener
In Chapter 3 we were able to handle a windowClosing event by adding a method to a
WindowAdapter as its constructor was creating it. For example, our PrintName pro-
gram had the following code segment:

// Event handler for window closing
out.addWindowListener(new WindowAdapter()      
// Create WindowClosing method
{                                            //  to replace the empty one
public void windowClosing(WindowEvent event)
{
out.dispose();                           // Remove frame from screen
System.exit(0);                          // Stop the program

}
});

Recall that when we first discussed the addWindowListener method in Chapter 3,
we said that it must be passed a parameter of type WindowListener. We then intro-
duced the WindowAdapter type as a shortcut to save us from having to define the
WindowListener type.

Button event listeners are registered with the event source through a similar method
call. The corresponding method to register the event listener is called addActionLis-
tener, which takes as a parameter an object of the listener class. Thus far, registering a
button listener is basically the same as registering a window event listener. Unfortu-
nately, here is where the similarity breaks down: Java was able to provide the Win-
dowAdapter shortcut for the window listener class because it predefines all of the
window events that can happen. However, button events aren’t predefined, so there is
no ActionAdapter in Java. We have to define a new listener class that meets the spec-
ifications in ActionListener in order to handle button events.

Defining classes in Java is a straightforward process. However, there are many
optional aspects to defining a new class that could easily divert our attention from



5.6 Creating and Registering a Button Event Listener | 185

the essential task at hand. Fortunately, in the case of a button listener class, Java
gives us a precise model to follow. We don’t have to consider any of the options
until we get to Chapter 7. The model that
Java provides for us is called an interface.
Previously, we defined an interface in the
general sense. In Java, however, an interface
is part of the language; it is a way of speci-
fying the fields and methods that must be
present in a class that is an implementation
of the interface. Likewise, we said in Chapter
1 that implementation is the stage in the
software development life cycle in which an algorithm is translated into a program-
ming language. But in Java, an implementation is a specific part of the language.
The Java designers have used these general terms in a very specific way to define
part of the language.

The ActionListener interface specifies that you need to write a class that has one
method called actionPerformed, which takes the event source object as a parameter.
You’ve already seen how to write a class (each of our programs is a class), and you’ve
seen how to write a method (that’s what main is). The following example should thus
look somewhat familiar to you.

private static class ButtonHandler implements ActionListener
{
public void actionPerformed(ActionEvent event) // Event handler method
{
// Body of button event handler method goes here

}
}                                                // End of ButtonHandler

The only major differences are that:

1. The class that implements ActionListener is contained within our program class
as a declaration.

2. Instead of having a main method, the new class has a method called actionPer-
formed.

There are some other minor differences that are summarized in the following table.

Interface (In Java) A model for a class that specifies
the fields and methods that must be present in a class
that implements the interface

Implementation (In Java) A class containing the defi-
nitions of the methods specified in an interface

Type of Class Program Class Class Implementing ActionListener

Class modifiers public private static
Extra class clauses none implements ActionListener
Method heading public static void main public void actionPerformed
Method parameter (String[] args) (ActionEvent event)



186 | Chapter 5:  Event-Driven Input and Software Design Strategies

As the table shows, the class that implements ActionListener is modified by
private and static instead of public. These modifiers are consistent with the other
declarations that are internal to our application. Class ButtonHandler is used only
within the application to declare an object of that class, and is not used outside of the
application. Thus, there is no need to make it public. Just as we get to choose the
name of our application class, we also get to choose the name (ButtonHandler) of the
class that implements ActionListener.

The name of the class is followed by the keyword implements and the name of the
interface (ActionListener). The fact that our new class implements the ActionLis-
tener interface means that we can pass a ButtonHandler object to a method that
expects a parameter of class ActionListener (such as addActionListener).

With respect to the methods main and actionPerformed, the table indicates that
main is modified by public and static, while actionPerformed has only public as
a modifier. There are deeper reasons for this difference that we consider in a later chap-
ter, but for now we simply note that the designer of ActionListener chose to use only
the public modifier, and we have to precisely match the interface in our implementa-
tion. Similarly, the interface specifies that actionPerformed takes one parameter of
class ActionEvent (a predefined class that represents a source event). We can choose
any name that we wish for the parameter, but here we simply call it event.

Let’s look at how this class definition is written within a program. Here is a skeleton
of a program that includes just the essential parts of the two classes.

public class ButtonDemo                        // Our program class
{
// As part of the declarations for the program, we define another class
//  called ButtonHandler that implements Java's ActionListener interface
private static class ButtonHandler implements ActionListener
{
public void actionPerformed(ActionEvent event) // Event handler method
{
// Body of button event handler method goes here

}
}                                           // End of ButtonHandler class

// More declarations for the program (ButtonDemo)

public static void main(String[] args)      // main, just as usual
{
// Body of main goes here

}
}

As you can see from this skeleton, it is an application just like previous ones,
except that it contains another class with one method inside of it. It looks basically like
a application within an application. The inner "application" however, defines a new

TE
AM
FL
Y

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

Team-Fly® 



5.6 Creating and Registering a Button Event Listener | 187

class called ButtonHandler. Although we use the identifier "ButtonHandler" for the
class, it is actually a listener class. Because the listener contains the method that handles
the event, we use the linguistic shortcut of calling it a button handler rather than call-
ing it “the listener that contains the method that handles the button event.” All we have
to do to complete the type definition is fill in the body of the actionPerformed
method with statements to be executed when the button event fires. Those statements
might be, for example,

fieldContents = inputField.getText();
inputField.setText("Replace me");

We return to the discussion of processing within a button event handler in the next sec-
tion. Before we turn to that topic, there are three steps we need to take to register the
listener with the event source.

1. Declare a variable of class ButtonHandler.
2. Instantiate an object of class ButtonHandler.
3. Call the addActionListener method associated with the button and pass it the

object of class ButtonHandler.

When you define a new class, you specify a blueprint for Java to use in creating an
object of that class. You still must declare a variable to hold such an object. The situa-
tion here is no different than for any other class in Java. For example, the existence of
the String class doesn’t create any String variables—you have to declare them. You
now have a class called ButtonHandler, and you can use it to declare variables of that
class. Here’s an example:

ButtonHandler buttonEventHandler;

This statement declares a variable called buttonEventHandler to handle button
events. Having declared such a variable, you can assign it an object that you create with
new:

buttonEventHandler = new ButtonHandler();

and then pass it to addActionListener to register the listener with the event source:

done.addActionListener(buttonEventHandler);

Because addActionListener is an instance method associated with done, this
particular event listener is registered with the event that is generated by the button.

You have seen how to create fields and buttons, how to name a button event and
register its listener, and how to extract data from a field when the button is pressed.
You now have all of the syntax that you need to program a user interface dialog that
inputs data. There are still some algorithmic and style issues that must be considered in
writing the body of our event handler, and we examine these in the next section.



188 | Chapter 5:  Event-Driven Input and Software Design Strategies

5.7 Handling a Button Event
Once a button’s event handler has been registered, the user can click on the button and
the result is that the event transfers control to the first statement in the event handler.
But what should the event handler do? In this case, the event is a signal from the user
that some data has been typed into a field and is now ready for processing. Because we
have just been exploring the mechanics of getting to this point in the program, rather
than solving an actual problem, we don’t know just yet what the data represents or
what should be done with it.

Our discussion up to this point has put the cart before the horse. In solving a real
problem, we begin by identifying the input data and what should be done with it. Then
we design the user interface to enable the user to enter the data and generate the events
that cause the program to process it.

Let’s look at a trivial problem that we can use to illustrate the design process for
building an event handler. Suppose we want the user to be able to enter a string and
have it appear in a label in the same frame when he or she is done typing. Here is a for-
mal definition of the problem.

Input: A string that the user enters.
Output: The input string, displayed in a label.
Processing: Copy the input string from the data entry field to the label.

When does the program copy the input string to the label? We need an event to sig-
nal when the user is done typing. Let’s use a button called "Copy" to generate the
event. What happens after the program copies the string? The problem statement doesn’t
answer this question. We could end the program, but then the frame disappears before
the user has a chance to see the output. We need a second event to indicate when the
user has finished looking at the output. Such an event could be generated by a second
button, but we’re not quite ready to handle events from multiple buttons. Instead, we
can do what we’ve done in prior programs and let the user close the window to end the
program. We thus have to write two event handlers.

The event handler for the button simply copies the data from the input field to the
output label. For example,

fieldContents = inputField.getText();
outputLabel.setText(fieldContents);

We can even shorten these two lines to just one and eliminate the string variable
fieldContents as follows:

outputLabel.setText(inputField.getText());

This single line of code carries out the main action that we want to perform on the
data. The button event handler that contains it is written just as before, except that we
insert this line into the body of the method.



5.7 Handling a Button Event | 189

private static class ButtonHandler implements ActionListener
{
public void actionPerformed(ActionEvent event)  // Event handler method
{
outputLabel.setText(inputField.getText());

}
}                                               // End of ButtonHandler

After this method executes, it returns control to the JVM. If the user then closes the
window, the window closing event calls the window-closing event handler. The code for
this event handler is basically the same as in our other programs. Let’s call the frame
dataFrame.

// Event handler for window closing
out.addWindowListener(new WindowAdapter()      
// Create WindowClosing method to replace the empty one
{                                            
public void windowClosing(WindowEvent event)
{
dataFrame.dispose();                    // Remove frame from screen
System.exit(0);                         // Stop the program

}
});

All that remains is to declare the appropriate variables, assign them objects, add them to
the frame, and then show the frame on the screen. We saw in Chapter 3 that the Frame
object had to be declared outside of the main method and needed the modifier static.
Do any of the other declarations here need to be declared outside of main with a
static modifier? Yes. Recall that we declared the Frame object outside of main
because Java views the extension of the WindowAdapter class as also being declared
outside of main, and its method refers to the Frame. Similarly, the method inside of
class ButtonHandler refers directly to outputLabel and inputField, so they must
also be declared outside of main. The other variables can remain local to main. Here is
the complete program, which we call CopyString.

import java.awt.*;                                // User interface classes
import java.awt.event.*;                          // Event handling classes

public class CopyString
// This program displays a frame with a data entry field and copies its
//  contents to a label when the user clicks a button marked "Copy"
{
// Define a button listener
private static class ButtonHandler implements ActionListener
{



190 | Chapter 5:  Event-Driven Input and Software Design Strategies

public void actionPerformed(ActionEvent event) // Event handler method
{
outputLabel.setText(inputField.getText());

}
}                                                // End of ButtonHandler

// Declare pieces of the user interface shared by main and CopyString
private static Frame dataFrame;                  // User interface frame
private static Label outputLabel;                // Label for output
private static TextField inputField; // Input field

public static void main(String[] args)
{ // Declare pieces of the user interface accessed only by main
Label entryLabel;                             // Label for input field
Button copy;                                  // Copy button
ButtonHandler copyAction;                     // Action handler

// Instantiate the pieces of the interface
dataFrame = new Frame();
entryLabel = new Label("Enter a string:");
outputLabel = new Label("");
inputField = new TextField("", 30);
copy = new Button("Copy");
copy.setActionCommand("copy");              // Give button event a name
copyAction = new ButtonHandler();           // Instantiate listener
copy.addActionListener(copyAction);       // Register listener

// Make the frame and put interface parts in it
dataFrame.setLayout(new GridLayout(2,2));
dataFrame.add(entryLabel);
dataFrame.add(inputField);
dataFrame.add(copy);
dataFrame.add(outputLabel);
dataFrame.pack();
dataFrame.show();

// Register window closing event handler
dataFrame.addWindowListener(new WindowAdapter()
{
public void windowClosing(WindowEvent event)
{
dataFrame.dispose();                  // Close the frame
System.exit(0);                       // Quit the program

}
});

}
}



5.8 Interactive Input/Output | 191

The program initially displays a frame that looks like this:

After the user enters a string and clicks the copy button, the frame appears as follows:

When the user closes the window, the program removes the frame from the screen
and quits. But what happens if the user doesn’t close the window? What if the user
types some more data and clicks the button again? The button sends another event to
the event manager, which dutifully calls the event handler again, and the output label is
updated with the new input value. The user can keep entering new data values until he
or she closes the window. In future programs we see that this pattern is useful as a way
to enter a series of data values. For this problem, however, our intent was to allow the
user to enter just one value.

How can we prevent the user from entering another value? We can have the event
handler remove the button from the frame so that it can’t be clicked a second time.
Every Frame object supports a remove method that allows us to delete items that we’ve
previously inserted with add. We can thus write a second line in our event handler that
calls this method for dataFrame, passing it the button copy.

dataFrame.remove(copy);

Now, as soon as the user clicks on the Copy button, the button disappears. At the
same time the input string appears in the output label. The only event that the user can
then generate is closing the window.

5.8 Interactive Input/Output
In Chapter 1 we defined an interactive program as one in which the user communicates
directly with the computer. Many of the programs that we write are interactive. There is
a certain “etiquette” involved in writing interactive programs that has to do with
instructions for the user to follow.

To get data into an interactive program, we begin with input prompts, labels that
explain what the user should enter into an adjacent field. Without these messages, the



192 | Chapter 5:  Event-Driven Input and Software Design Strategies

user has no idea what data values to type. In many cases, a program also should display
the data values typed in so that the user can verify that they were entered correctly. Dis-
playing input values is called echo printing.

The amount of information you put into your prompts depends on who is going to
be using a program. If you are writing a program for people who are not familiar with
computers, the prompts should be more detailed. For example, “Type a four-digit part
number, then click the button marked Enter.” If the program is going to be used fre-
quently by the same people, you might shorten the prompt to “Enter PN.”

Whether a program echo prints its input or not also depends on how experienced
the users are and on the task it is to perform. If the users are experienced and the
prompts are clear, then echo printing is probably not required. If the users are novices
or multiple values can be input at once, echo printing should be used. If the program
inputs a large quantity of data and the users are experienced, rather than echo print the
data, it may be stored in a separate file that can be checked after all of the data is input.
We’ll see how to store data into a file in a later chapter.

When data is not entered in the correct form, a message that indicates the problem
should be displayed. For users who haven’t worked much with computers, it’s important
that these messages be informative and friendly. The message

ILLEGAL DATA VALUES!!!!!!!

is likely to upset even an experienced user. Moreover, it doesn’t offer any constructive
information. A much better message would be

That is not a valid part number.
Part numbers must be no more than four digits long.
Please reenter the number in its proper form:

In Chapter 10, we introduce statements that allow us to catch and handle erroneous
data.

5.9 Converting Strings to Numeric Values
Many of the problems solved with computers involve the entry of numerical data; val-
ues of the types int, long, float, and double. A TextField object enables you to
enter a String. How then do you input a number? The answer is that you can’t—at
least not directly. Java provides only for the input of strings. You have to enter a num-
ber as a string and then convert the string into one of the numeric types using methods
from Java’s library.

As noted previously, Java’s standard library includes a set of classes that corre-
spond to the built-in numeric types. These classes provide methods and constants that
are useful in working with the numeric types. The following table lists these predefined
classes and the built-in type that each one corresponds to.



5.9 Converting Strings to Numeric Values | 193

As you can see, the general rule is that the class name is the same as the name of
the built-in type except that its first letter is capitalized. The two exceptions are that the
class corresponding to int is called Integer and the class corresponding to char is
Character. (Although we do not consider a character a numeric type, Java inherits this
view from C.)

Among the methods associated with each of these classes is one called valueOf,
which takes a string as its parameter and returns a value of the object type. For exam-
ple, you can write

Double someDouble;
someDouble = Double.valueOf("37.89");

with the result that the string "37.89" is converted to a value of class Double and a refer-
ence to it is stored in someDouble. There are two very important new concepts that are rep-
resented in this one statement. The first is to realize that valueOf doesn’t create a value of
type double—its result is an object of class Double. One of the fields within the class is
indeed a value of type double that represents the number 37.89, but you need a second
conversion from class Double to type double to use that value as an ordinary number.

The second important concept is revealed if you look closely at the method call and
realize that it is not associated with the name of an object of type Double, but with the
name of the type itself. Other than our calls to constructors and the value-returning
math methods we saw in Chapter 4, all of our calls have been associated with a specific
object. For example, you know that we must write inputFrame.show() rather than
writing Frame.show() because that’s how
you indicate to which Frame object the
method applies. We informally introduced the
terms instance method and class method.
We’ve now reached the point that we can
define them formally.

A method that is called in the familiar
way is known as an instance method because
an object is an instance of its class. But Java
also provides methods that are associated with
the class itself that are called class methods.

Instance method A method that is associated with
an object of a given type. It is called by writing the
name of the object followed by a period and then the
name of the method and its parameter list.

Class method A method that is associated with a
class but not with a specific object. It is called by writ-
ing the name of the class followed by a period and
then the name of the method and its parameter list.

Built-in Type Object Type

int Integer
long Long
float Float
double Double
char Character



194 | Chapter 5:  Event-Driven Input and Software Design Strategies

A class method is called by writing the name of the class, followed by a period, and
then the name of the method and its parameter list. Class methods give us a way to per-
form operations related to a class that are not specific to a particular object of that type.

Each Double object has an instance method that returns the double value that it
contains. If you declare number to be a variable of type double, then you can write

number = someDouble.doubleValue();

to convert someDouble into a value of type double and store it in number. You can
cut out the use of the intermediate object, someDouble, by appending the call to dou-
bleValue onto the end of the call to valueOf:

number = Double.valueOf("37.89").doubleValue();

This odd-looking piece of syntax works because the call to valueOf returns an
object (an instance) of class Double. Even though the returned object doesn’t have a
name (and is thus said to be anonymous), Java recognizes it as an object with which the
doubleValue method is associated. Java treats the call as being equivalent to writing
the name of a declared variable, and allows you to follow it with a period and then the
instance method name and its parameter list. You thus have a single statement contain-
ing both a call to a class method and a call to an instance method. Look closely at this
statement and be certain you know which call is which.

The preceding statement is a roundabout way of assigning the value 37.89 to the
variable number. Of course, what you really want to be able to do is convert a value in
a text field into a number. You can replace the string "37.89" in the preceding state-
ment with a call to the getText method associated with the field:

number = Double.valueOf(inputField.getText()).doubleValue();

Let’s look at an example of getting an integer value from a text field:

int intNumber;
intNumber = Integer.valueOf(inputField.getText()).intValue();

number = Double.valueOf("37.89").doubleValue();

class name class method call instance method call

anonymous object of class Double



5.11 Software Design Strategies | 195

Notice that the class method valueOf is preceded by the name of the class, but the
instance method intValue is preceded by an instance of the class.

You now have a single statement that reads a numerical value from a data entry
field on the screen. What if the user types something other than a number in the field?
At this point in our knowledge of Java, the result is that the program halts and displays
a message such as “Number Format Error.” In Chapter 10, we see how a program can
catch such an error (called an exception) and respond to it without stopping.

5.10 Noninteractive Input/Output
Although we tend to use examples of interactive I/O in this text, many programs are
written using noninteractive I/O. A common example of noninteractive I/O on large
computer systems is batch processing. Remember that in batch processing (Chapter 1),
the user and the computer do not interact while the program is running. This method is
most effective when a program is going to input or output large amounts of data. An
example of batch processing is a program that inputs a file containing semester grades
for thousands of students and prints grade reports to be mailed out.

When a program must read in many data values, the usual practice is to prepare
them ahead of time, storing them into a disk file. This allows the user to go back and
make changes or corrections to the data as necessary before running the program. When
a program is designed to print lots of data, the output can be sent directly to a high-
speed printer or another disk file. After the program has been run, the user can examine
the data at leisure.

Most Java programs are written for interactive use. But the flexibility of the lan-
guage allows you to write noninteractive programs as well. The biggest difference is in
the input/output requirements. Noninteractive programs are generally more rigid about
the organization and format of the input and output data.

Programs can also combine interactive input and output with file input and output.
In Chapter 9, we discuss input and output with disk files.

5.11 Software Design Strategies
Over the last four chapters and the first part of this one, we have introduced elements of
the Java language that let us input data, perform calculations, and output results. The
programs we wrote were short and straightforward because the problems to be solved
were simple. We are ready to write programs for more complicated problems, but first
we need to step back and look at the overall process of programming.

As we have stressed several times, the programming process consists of a problem-
solving phase and an implementation phase. The problem-solving phase includes analy-
sis (analyzing and understanding the problem to be solved) and design (designing a
solution to the problem). Given a complex problem—one that results in a 10,000-line
program, for example—it’s simply not reasonable to skip the design process and go



196 | Chapter 5:  Event-Driven Input and Software Design Strategies

directly to writing Java code. What we need is a systematic way of designing a solution
to a problem, no matter how complicated the problem is.

In the remainder of this chapter, we describe a methodical way of designing solu-
tions to more complex problems: object-oriented
design (OOD). This methodology helps you create
solutions that can be easily implemented as Java pro-
grams. The resulting programs are readable, under-
standable, and easy to debug and modify. Java was
developed in part to facilitate the use of the OOD
methodology. In the next two sections, we present the
essential concepts of OOD, and we expand our treat-
ment of the approach throughout the rest of the book.
At times OOD is used in conjunction with a second,
older methodology, which we also discuss in this
chapter, functional decomposition.

OOD focuses on the entities (objects) in a prob-
lem. In OOD we solve a problem by identifying the components that make up a solution
and how those components interact with each other. The result is a design for a set of
objects that cooperate to solve a problem.

In contrast, functional decomposition views the solution to a problem as a task to
be accomplished. It focuses on the sequence of operations that are required to complete
the task. When the problem requires a sequence of steps that is long or complex, we
divide it into subproblems that are easier to solve. Functional decomposition is the
method that we have been using to break our simple problems into sequences of steps
that the computer can follow. This strategy also can be used to develop algorithms for
an object’s methods.

In most large problems we naturally find entities that we wish to represent in an
application. For example, in designing an application that manages a checking account,
you might identify checks, deposits, an account balance, and account statements as
entities. These entities interact with each other through messages. For example, a check
could send a message to the balance entity that tells it to deduct an amount from itself.
We didn’t list the amount in our initial set of objects, but it may be another entity that
we need to represent.

Our example illustrates a common approach to OOD. You begin by identifying a set
of objects that you think are important in a problem. Then you consider some scenarios
in which the objects interact to accomplish a task. In the process of envisioning how a
scenario happens, you identify additional objects and messages. You keep trying new
scenarios until you find that the set of objects and messages is sufficient to accomplish
any task that the problem requires.

5.12 What Are Objects and Classes?
Let’s review what we have said about objects and see how they work in the context of
programming. Then we can more effectively explore how to solve a problem with OOD.
We have defined an object three ways: as a collection of data together with associated

Object-oriented design A technique for developing
software in which the solution is expressed in terms of
objects—self-contained entities composed of data and
operations on that data that interact by sending mes-
sages to one another

Functional decomposition A technique for develop-
ing software in which the problem is divided into more
easily handled subproblems, the solutions of which cre-
ate a solution to the overall problem

TE
AM
FL
Y

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

Team-Fly® 



5.12 What Are Objects and Classes? | 197

operations, an entity or thing that is relevant in the context of a problem, and as an
instance of a class. What is a class? We have also defined a class three ways: as a
description of an object that specifies the types of data values that it can hold and the
operations that it can perform, as a description of the behavior of a group of objects
with similar properties, and as a pattern for an object.

Although varied, these definitions are complementary rather than contradictory. In
the problem-solving phase we look for objects (things) that are relevant to the problem
we are solving. We analyze these objects and how they interact with each other. We
abstract the common properties and behaviors from these real objects and define classes
that describe this behavior. In the implementation phase, we then take these descriptions
(classes) and use the syntax of our programming language to define classes (in the Java
sense) that describe the data values an object can have and the operations it can per-
form. Our program instantiates these classes to give us objects that interact to solve the
original problem.

Several programming languages, called object-oriented programming languages,
have been created specifically to support OOD. Examples are Java, Smalltalk, CLOS, Eif-
fel, and Object-Pascal. In these languages, a class is the construct used to define the
pattern that is used when instantiating an object. Let’s look first at this construct a little
deeper; in the next section we outline a strategy for finding objects and classes in the
problem-solving phase.

A class isn’t an object, but it specifies a pattern to use in creating a specific kind of
object. For example, earlier in this chapter we defined a ButtonHandler class. Once we
define the class, we are able to declare a variable of class ButtonHandler, such as
copyAction, and instantiate it with new. Here we repeat those segments of the code:

// Define a button listener class
private static class ButtonHandler implements ActionListener
{
public void actionPerformed(ActionEvent event)
{
outputLabel.setText(inputField.getText());

}
} // End of ButtonHandler class definition
.
.
.
// Now that we have defined the class, we can declare a variable of
//  class ButtonHandler
private static ButtonHandler copyAction;
.
.
.
// Then we can instantiate an object of class ButtonHandler with new,
//  and assign it to the variable
copyAction = new ButtonHandler();



198 | Chapter 5:  Event-Driven Input and Software Design Strategies

Class definition Variable declaration

Assigning the new object to the variableInstantiating the object

Put it
there.

Figure 5.5 An analogy illustrating the relationships among a class, a variable, and an object

Think of a class definition as analogous to a set of blueprints. A blueprint isn’t a
house, but it tells you how to construct a house. A class isn’t an object, but it tells the
computer how to construct an object. Declaring a variable of a class type is like buying
the land on which to build the house. You still haven’t built the house, but you have a
place where you can build it.

The new operator invokes the constructor method for the class; it is like calling in a
construction crew to interpret the blueprints and actually build the house. In Java, this
is like having the house built in a factory (using new), and then delivered to the lot
(assigned to the variable). Figure 5.5 illustrates this analogy.

We saw in Chapter 2 that a class declaration is a collection of field and method dec-
larations. The declarations in a class are called the
members of the class. As we have also seen, members
can be public or private, and they can also be
static (or not static) and final (or not final).
The public members of a class combine to specify its
public interface. Here we use interface in the general
sense of the word, in contrast to the Java interface

Member A field or method declaration within a class

Public interface The members of a class that can be
accessed outside of the class, together with the modes
of access that are specified by other modifiers



5.12 What Are Objects and Classes? | 199

construct. When a programmer wishes to employ a predefined class in writing an appli-
cation, he or she looks up its interface to see what fields and methods it makes available
for use.

What do we mean by “modes of access” in our definition of interface? Recall our
earlier discussion of instance methods and class methods. We said that we invoke a
class method by writing the class name, a period, and then the method name. We
invoke an instance method by writing the object name, a period, and then the method
name. In a class declaration, the two types of methods look exactly the same except
that class method declarations include the static modifier. In other words, the
static modifier specifies this aspect of how to access the method. Consider this
statement:

valueOf is a class method and is prefaced by the name of the class Integer. It takes a
string and converts it into an instance of class Integer. intValue is an instance
method and is prefaced by an instance of class Integer.

The public and private modifiers determine whether a member can be accessed
outside of a class. The final modifier specifies whether a member can be changed.
There are eight combinations of these modifiers, each of which effectively defines a
mode of access. However, only the public members are part of the public interface.
From code that is outside of the class definition, we cannot access members that are
private.

For example, the public interface for the class Double includes some final fields
such as the maximum and minimum double values. It provides a set of class (static)
methods that includes valueOf, and a set of instance methods that includes double-
Value. All of these members are public. We can also surmise that the definition of
Double includes a private field of type double that is used to store a numerical
value. In Chapters 7 and 8, where we look at the details of how to write new class defi-
nitions, we introduce additional access modifiers.

In Figure 5.6, we picture a Double object as having a private part and a public part.
The private part includes fields and methods that the user cannot access and doesn’t
need to know about in order to use the object. The public part, shown as ovals in the
side of the object, represent its public interface: values and operations that are available
to programmers wishing to use the object.

Instance of Class
Integer

Class
Name

Class
method

Instance
Method

intNumber = Integer.valueOf(inputField.getText()).intvalue();



200 | Chapter 5:  Event-Driven Input and Software Design Strategies

5 Private data and methods
MAX_VALUE

MIN_VALUE

valueOf

doubleValue

Public Interface

someNumber
(an object of class Double)

1Originally published in: Kent Beck and Ward Cunningham, “A Laboratory for Teaching Object-Oriented
Thinking,” OOPSLA ‘89 Proceedings, SIGPLAN Notices 24(10): 1–6, October, 1989.

5.13 Object-Oriented Design
Now we turn to the process of developing a problem solution using OOD. Our goal is to
develop a design that captures the information needed to program a solution to the
problem. But our design should not be at the level of detail of an actual program. That
is, we want a way to write out a solution without getting distracted by programming
language syntax. As we have said before, it is important to think first and code later. In
this section we introduce an informal technique for developing object-oriented designs,
known as CRC cards.1

The first step in OOD is to identify the major objects in the problem. We identify the
abstract properties of each object, and use these to define classes that we need. Each
class specifies a set of responsibilities, which are the actions that its objects support.
Objects collaborate with each other by sending messages. A message is a request for an
object to carry out one of its responsibilities. The collection of Classes, Responsibilities,
and Collaborations (CRC) combine to solve a problem.

OOD leads to programs that are collections of objects. Each object is responsible for
one part of the entire solution, and the objects send messages by accessing each other’s
members. There are many libraries of prewritten classes, including the standard Java
library. In many cases, it is possible to browse through a library, choose classes you
need for a problem, and assemble them to form a substantial portion of your program.
Putting existing pieces together in this fashion is an excellent example of the building-
block approach we discussed in Chapter 1.

Figure 5.6 An object and its public interface



5.13 Object-Oriented Design | 201

When there isn’t a suitable class available in a library, it is necessary to define a
new class. We see how this is done in Chapters 7 and 8. Here we introduce CRC cards
for solving problems in an object-oriented manner that leads to an OOD. The resulting
design may or may not require the definition of new classes. We use CRC cards in the
case studies of this chapter and the next to produce designs that do not require new
classes. That way you can gain some experience in using them prior to learning the
syntax for defining new classes.

In the discussion that follows, however, we won’t be concerned with coding. So we
use some examples that would result in new classes. This is meant to illustrate the full
range of how CRC cards are used, and to give you a foretaste of how we approach OOD
once we have the syntax to implement new classes. Let’s briefly return to the more gen-
eral topic of problem solving before we introduce the CRC cards.

Object-Oriented Problem Solving

As we discuss OOD, keep in mind that there are many different correct solutions to most
problems. The techniques we use may seem imprecise, especially in contrast with the
precision that is demanded by the computer. But the computer merely demands that we
express (code) a particular solution precisely. The process of deciding which particular
solution to use is far less precise. It is our human ability to make choices without having
complete information that enables us to solve problems. Different choices naturally lead
to different solutions to a problem.

For example, in developing a simulation of an air traffic control system, you might
decide that airplanes and control towers are objects that communicate with each other.
Or you might decide that pilots and controllers are the objects that communicate. This
choice affects how you subsequently view the problem and the responsibilities that you
assign to the objects. Either choice can lead to a working application. You may simply
prefer the one with which you are most familiar (recall the Look for Things That Are
Familiar strategy from Chapter 1).

Some of your choices lead to designs that are more or less efficient than others. For
example, keeping a list of names in alphabetical rather than random order makes it pos-
sible for the computer to find a particular name much faster. However, choosing to
leave the list randomly ordered still produces a valid (but slower) solution.

Other choices affect the amount of work that is required to develop the remainder
of a problem solution. In creating a program for choreographing ballet movements, you
might begin by recognizing the dancers as the important object and then create a class
for each dancer. But in doing so, you might then discover that all of the dancers have
certain common responsibilities. Rather than repeat the definition of those responsibili-
ties for each class of dancer, you can change your initial choice and define a class for a
generic dancer that includes all the common responsibilities and then develop sub-
classes (the subject of Chapter 8) that add responsibilities specific to each individual.

The point is, don’t hesitate to begin solving a problem because you are waiting for
some flash of genius that leads you to the perfect solution. There is no such thing. It is
better to jump in and try something, step back and see if you like the result, and then
either proceed or make changes. The CRC card technique that we look at next is a way
to easily explore different design choices and keep track of them.



202 | Chapter 5:  Event-Driven Input and Software Design Strategies

Class Name: Superclass: Subclassess:

Responsibilities Collaborations

Figure 5.7 A blank CRC card

Identifying the Classes

The first step in solving a problem with OOD is to identify the classes of objects that are
found in the problem. There is no foolproof technique for doing this; just start brain-
storming ideas and see where they lead. A large program is typically written by a team
of programmers, so the brainstorming process often occurs in a team setting. Team
members identify whatever objects they see in the problem and then propose classes to
represent them. The proposed classes are all written on a board. None of the ideas for
classes are discussed or rejected in this first stage.

After the brainstorming, the team goes through a process of filtering the classes.
First they eliminate duplicates. Then they discuss whether each class really represents an
object in the problem (it’s easy to get carried away and include classes, such as “the
user,” that are beyond the scope of the problem). The team then looks for classes that
seem to be related. Perhaps they aren’t duplicates, but they have much in common, and
so they are grouped together on the board. At the same time, the discussion may reveal
some classes that were overlooked.

For each class that survives the filtering stage, a CRC card is created. The CRC card
is just an index card with a line drawn vertically down the middle. The name of the
class is written at the top and the two columns have the headings, Responsibilities and
Collaborations. Figure 5.7 shows a blank CRC card.

We have added spaces at the top of the CRC card for naming the superclass and
subclasses of the class. As an example, the different kinds of dancers would be the
subclasses of the generic dancer class. Each specific dancer class would have the generic



5.13 Object-Oriented Design | 203

dancer class listed as its superclass. Filling in these spaces helps us to keep track of
these relationships between our classes.

Let’s say we want to write an address book application. We take a look at a physical
address book and then brainstorm that our application has the following potential objects:

Then we enter the filtering stage. Our application doesn’t need to represent the
physical parts of an address book, so we can delete Cover and Pages. However, we need
something analogous to a page that holds all the same sort of information. Let’s call it
an Entry. The different telephone numbers can all be represented by the same kind of
object. So we can combine Home, Work, Fax, Pager, and Cell-phone into a Phone num-
ber class. In consultation with the customer, we find that the electronic address book
doesn’t need the special pages that are often found in a printed address book, so we
delete Calendar, Time zone map, Owner information, and emergency numbers.

Further thought reveals that the User isn’t part of the application, although this does
point to the need for a User Interface that we did not originally list. A Work address is a

Cover
Pages
Address
Name
Home phone number
Work phone number
E-mail
Fax number
Pager number
Cell phone number
Birthday
Company name
Work address
Calendar
Time zone map
Owner information
Emergency number
User



204 | Chapter 5:  Event-Driven Input and Software Design Strategies

specific kind of address that has additional fields, so we can make it a subclass of
Address. Company names are just strings, so there is no need to distinguish them, but
Names have a first, last, and middle part. Our filtered list of classes now looks like this.

For each of these classes we create a CRC card. In the case of Work Address, we list
Address as its Superclass and on the Address card we list Work Address in its Subclasses
space.

In doing coursework, you may be asked to work individually rather than in a col-
laborative team. You can still do your own brainstorming and filtering using a scrap of
paper rather than a blackboard. However, we recommend that you take a break after the
brainstorming and do the filtering after you have let your initial ideas rest for a while.
An idea that seems brilliant in the middle of brainstorming may lose some of its attrac-
tion after a day or even a few hours.

Initial Responsibilities

Once you (or your team) have identified the classes and created CRC cards for them, go
over each card and write down any responsibilities that are obvious. For example, a
Name class has a responsibility to know its first name, its middle name, and its last
name. You can list these three responsibilities in the left column of its card as shown in
Figure 5.8. In an implementation, they become methods that return the corresponding
part of the name. For many classes, the initial responsibilities include knowing some
value or set of values.

A First Scenario Walk-Through

To further expand the responsibilities of the classes and see how they collaborate, we
must pretend to carry out various processing scenarios by hand. This kind of role-play-
ing is known as a walk-through. We ask a question such as, “What happens when the
user wants to find an address that’s in the book?” Then we answer the question by
telling how each object is involved in accomplishing this task. In a team setting, the
cards are distributed among the team members. When an object of a class is doing
something, its card is held in the air to visually signify that it is active.

Entry
Name
Address
Work address
Phone number
E-mail
Birthday
User interface



5.13 Object-Oriented Design | 205

Class Name: Name Superclass: Subclassess:

Responsibilities Collaborations

Know first

Know middle

Know last

Figure 5.8 A CRC card with initial responsibilities

With this particular question, we might pick up the User Interface card and say, “I
have a responsibility to get the person’s name from the user.” That responsibility gets
written down on the card. Once the name is input, the User Interface must collaborate
with other objects to look up the name and get the corresponding address. What object
should it collaborate with?

We’ve found a hole in our list of classes! The Entry objects should be organized into
a Book object. We quickly write out a Book CRC card. The User Interface card-holder
then says. “I’m going to collaborate with the book class to get the address.” The collabo-
ration is written in the right column of the card, and it remains in the air. The owner of
the Book card holds it up, saying, “I have a responsibility to find an address in the list
of Entry objects that I keep, given a name.” That responsibility gets written on the Book
card. Then the owner says, “I have to collaborate with each Entry to compare its name
with the name sent to me by the User Interface.” Figure 5.9 shows a team in the middle
of a walk-through.

Now comes a decision. What are the responsibilities of Book and Entry for carrying
out the comparison? Should Book get the name from Entry and do the comparison, or
should it send the name to Entry and receive an answer that indicates whether they are
equal? The team decides that Book should do the comparing, so the Entry card is held in
the air, and its owner says, “I have a responsibility to provide the full name as a string.
To do that I must collaborate with Name.” The responsibility and collaboration are
recorded and the Name card is raised.

Name says, “I have the responsibilities to know my first, middle, and last names.
These are already on my card, so I’m done.” And the Name card is lowered. Entry says,
“I concatenate the three names into a string with spaces between them, and return the
result to Book, so I’m done.” The Entry card is lowered.

Book says, “I keep collaborating with Entry until I find the matching name. Then I
must collaborate with Entry again to get the address.” This collaboration is placed on its
card and the Entry card is held up again, saying, “I have a responsibility to provide an
address. I’m not going to collaborate with Address, but am just going to return the



206 | Chapter 5:  Event-Driven Input and Software Design Strategies

Class Name: Entry Superclass: Subclassess:

Responsibilities Collaborations

Provide name as a string

Provide Address None

Get first from Name

Get middle from Name

Get last from Name

Figure 5.10 The CRC card for Entry

Figure 5.9 A scenario walk-through in progress

object to Book.” The Entry card has this responsibility added and then goes back on the
table. Its CRC card is shown in Figure 5.10.

Now Book can say, “I have the Address, and I return it to User Interface, so I’m
done.” The Book card is lowered. Figure 5.11 shows its CRC card. Then the holder of
User Interface (whose arm is getting very tired) says, “I need to collaborate with Address
to get each line of the address as a string that I can place in a pair of labels.” Address is
raised, saying, “I have responsibilities to know my street, city, state, and zip code, and
those are already on my list.” User Interface says, “I can concatenate the last three to

TE
AM
FL
Y

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

Team-Fly® 



5.13 Object-Oriented Design | 207

Class Name: Book Superclass: Subclassess:

Responsibilities Collaborations

Find address, given a name Get name string from Entry

Get address from Entry

Figure 5.11 The CRC card for Book

form the second line, so that satisfies the collaboration.” The collaboration is recorded,
and User Interface says, “Now I display the labels and provide buttons to either quit or
get another address, and I’m done.” The last card is lowered and the scenario ends.

Reading about the scenario makes it seem longer and more complex than it really
is. Once you get used to role playing, the scenarios move quickly and the walk-through
becomes more like a game. However, to keep things moving, it is important to avoid
becoming bogged-down with implementation details. Book should not be concerned
with how the Entry objects are organized on the list. Address doesn’t need to think
about whether the zip code is stored as an int or a String. Explore each responsibility
only as far as you need to decide whether a further collaboration is needed or whether it
can be solved with the available information.

Subsequent Scenarios

We began the first scenario with a “What happens when...” question for the most obvi-
ous case. The next step is to brainstorm some additional questions that produce new
scenarios. For example, here is list of some further scenarios.

We walk through each of the scenarios, adding responsibilities and collaborations
to the CRC cards as necessary. After several scenarios have been tried, the number of
additions decreases. When one or more scenarios take place without adding to any of
the cards, then we brainstorm further to see if we can come up with new scenarios that

What happens when the user
     asks for a name that‘s not in the book?
     wants to add an entry to the book?
     deletes an entry?
     tries to delete an entry that isn‘t in the book?
     wants a phone number?
     wants a business address?
     wants a list of upcoming birthdays?



208 | Chapter 5:  Event-Driven Input and Software Design Strategies

may not be covered. When all of the scenarios that we can envision seem to be doable
with the existing classes, responsibilities, and collaborations, then the design is done.

The next step is to implement the responsibilities for each class. The implementa-
tion may reveal details of a collaboration that weren’t obvious in the walk-through. But
knowing the collaborating classes makes it easy to change their corresponding responsi-
bilities. The implementation phase should also include a search of available class
libraries to see if any existing classes can be used. For example, the java.util.Cal-
endar class represents a date that can be used directly to implement Birthday.

Inheritance

In walking through the scenario in which the user requests a business address, we
should notice that the Work Address class is nearly identical with the Address class,
except that it also provides a Business Name and a Second Address Line. Rather than
copy all of the responsibilities and collaborations from the Address card to this one, we
can list Address as the superclass of Work Address.

Because Work Address is a subclass of Address, it inherits all of the responsibilities
that are in Address. A subclass is automatically able to use the responsibilities of its super-
class and also add its own. In addition, a subclass can replace an inherited responsibility
with a new definition of the responsibility. The new definition is a way of retaining the

same form of interface but customizing its implementa-
tion to reflect the differences between the superclass
and the subclass. In OOD this concept is called
inheritance, and it allows you to adapt an existing class
to satisfy additional responsibilities.

We used inheritance to write our windowClos-
ing event handler. Recall from Chapter 3 that the

WindowAdapter class provides empty methods for all of the different events that a
window can generate, and we supply a replacement for its windowClosing method.
When we do this we are actually defining a new class that inherits all of the other
empty methods from the WindowAdapter class. Java calls this an anonymous inner
class—a fancy name that simply means we are using some syntax shortcuts to define
the new class without giving it a name and as part of instantiating the object. In terms
of our house building analogy, you can think of an anonymous inner class as giving
the construction crew some last minute changes in the design without bothering to
redraw the blueprints. Figure 5.12 illustrates the use of inheritance in defining a win-
dowClosing event handler.

Enhancing CRC Cards with Additional Information

The CRC card design is informal. There are many ways that the card can be enhanced.
For example, when a responsibility has obvious steps, we can write them below its
name. Each step may have specific collaborations, and we write these beside the steps in
the right column. We often recognize that certain data must be sent as part of the mes-
sage that activates a responsibility, and we can record this in parentheses beside the
calling collaboration and the responding responsibility. Figure 5.13 shows a CRC card

Inheritance A mechanism that enables us to define a
new class by adapting the definition of an existing
class



5.13 Object-Oriented Design | 209

Private 
data and 
methods

Anonymous inner class
inheriting methods from

WindowAdapter

windowActivated

windowClosed

windowOpened

windowClosing windowClosing

Class WindowAdapter

Figure 5.12 A windowClosing event handler defines a new class that inherits all but 
one of the methods from Class WindowAdapter

Class Name: Entry Superclass: Subclassess:

Responsibilities

Provide name as a string

Get first name

Get middle name

Get last name

Name

Name

Name

Change Name (name string)

Break name into first, middle, last

Update first name

Update middle name
Update last name

String

Name, changeFirst(first)

Name, changeMiddle(middle)
Name, changeLast(last)

Provide Address None

Collaborations

Figure 5.13 A CRC card that is enhanced with additional information



210 | Chapter 5:  Event-Driven Input and Software Design Strategies

that includes design information in addition to the basic responsibilities and colla-
borations.

To summarize the CRC card process, first brainstorm the objects in a problem and
then abstract them into classes. Then filter the list of classes to eliminate duplicates. For
each class, create a CRC card and list any obvious responsibilities that it should support.
Then walk through a common scenario, recording responsibilities and collaborations as
they are discovered. After that, walk through additional scenarios, moving from com-
mon cases to special and exceptional cases. When it appears that all of the scenarios
have been covered, brainstorm additional scenarios that may need more responsibilities
and collaborations. When all ideas for scenarios are exhausted and all the scenarios are
covered by the existing CRC cards, the design is done.

In this section, we have presented only an introduction to OOD. A more complete
discussion requires knowledge of topics that we explore in Chapters 6 through 8: flow
of control, programmer-written methods, class definitions, and interface design. Until
then, our programs are relatively small, and we consider problems that can be solved
with object-based programming. Keep in mind that a CRC card design doesn’t have to
lead to the design of new classes.

5.14 Functional Decomposition
The second design technique we use is functional decomposition (also called structured
design, top-down design, stepwise refinement, and modular programming). It allows us
to use the divide-and-conquer approach, which we talked about in Chapter 1.

When a responsibility clearly involves a series of major steps, you can break it
down (decompose it) into pieces. In the process, you move to a lower level of abstrac-
tion—that is, some of the implementation details (but not too many) are now specified.
Each of the major steps becomes an independent subproblem that you can work on sep-
arately. The process continues until each subproblem cannot be divided further or has
an obvious solution.

By subdividing the problem, you create a hierarchical structure called a tree struc-
ture. Each level of the tree is a complete solution to the problem that is less abstract

(more detailed) than the level above it. Figure 5.14
shows a generic solution tree for a problem. Steps that
are shown in black type have enough implementation
details to be translated directly into Java statements.
These are concrete steps. Those in colored type are
abstract steps; they reappear as subproblems in the
next level down. Each box in the figure represents a
module. Modules are the basic building blocks in a
functional decomposition. The diagram in Figure 5.14
is also called a module structure chart.

Concrete step A step for which the implementation
details are fully specified

Abstract step A step for which some implementation
details remain unspecified

Module A self-contained collection of steps that
solves a problem or subproblem; can contain both con-
crete and abstract steps



5.14 Functional Decomposition | 211

Step I
Step II
Step III

Step A
Step B

Step 7
Step 8

Step 4
Step 5
Step 6

Step a
Step b
Step c

Step 1

Subproblem 2

Subproblem B Subproblem C Subproblem FSubproblem A

Subproblem I Subproblem II Subproblem III

Level 3

Level 2

Level 0
AbstractTop

ConcreteBottom

Level 1

Solve the problem

Hierarchical Solution Tree

Step 2
Step 3

Step C
Step D

Step E
Step F

Figure 5.14 Hierarchical solution tree

Writing Modules

Here’s one approach to writing modules:

1. Think about how you would solve the subproblem by hand.
2. Begin writing down the major steps.
3. If a step is simple enough so that you can see how to implement it directly in Java,

it is at the concrete level; it doesn’t need any further refinement.

4. If you have to think about implementing a step as a series of smaller steps or as
several Java statements, it is still at an abstract level.

5. If you are trying to write a series of steps and start to feel overwhelmed by details,
you probably are bypassing one or more levels of abstraction. Stand back and look
for pieces that you can write as more abstract steps.



212 | Chapter 5:  Event-Driven Input and Software Design Strategies

We could call this the “procrastinator’s technique.” If a step is cumbersome or diffi-
cult, put it off to a lower level; don’t think about it today, think about it tomorrow. Of
course, tomorrow does come, but the whole process can be applied again to the sub-
problem. A trouble spot often seems much simpler when you can focus on it. And even-
tually the whole problem is broken up into manageable units.

As you work your way down the solution tree, you make a series of design deci-
sions. If a decision proves awkward or wrong (and many times it does!), you can back-
track (go back up the tree to a higher-level module) and try something else. You don’t
have to scrap your whole design—only the small part you are working on. There may be
many intermediate steps and trial solutions before you reach a final design.

Before OOD was developed, functional decomposition was used to solve entire
problems. However, by itself, it results in designs that lack flexibility. Applications
developed entirely this way are hierarchical in nature, and often at the bottom of the
hierarchy you are implementing multiple versions of the same responsibility. With OOD,
you can define a superclass and a set of subclasses to organize these responsibilities and
save yourself programming effort. But functional decomposition doesn’t allow for this
kind of organization.

Today, we typically use functional decomposition as a way to design the algorithm
for a complex responsibility. For example, in a class that supports image processing, a
morphing responsibility that distorts part of an image might have no need of any other
collaboration. Yet there may be many mathematically sophisticated steps in the algo-
rithm that transforms the image data. Functional decomposition provides a way to
break such a problem down into simpler pieces that are easier to solve.

Pseudocode

You’ll find it easier to implement a design if you write the steps in pseudocode.
Pseudocode is a mixture of English statements and Java-like control structures that can
be translated easily into Java. (We’ve already been using pseudocode in the algorithms
in the Problem-Solving Case Studies.) When a concrete step is written in pseudocode, it
should be possible to rewrite it directly as a Java statement in a program.

Remember that the problem-solving phase of the programming process takes time.
If you spend the bulk of your time analyzing and designing a solution, coding (imple-
menting) the program takes relatively little time.

Software Engineering Tip
Documentation

As you create your functional decomposition or object-oriented design, you are developing
documentation for your program. Documentation includes the written problem specifications,
design, development history, and actual code of a program.

tcontinued



Problem-Solving Case Study | 213

Good documentation helps other programmers read and understand a program and is invaluable
when software is being debugged and modified (maintained). If you haven’t looked at your program
for six months and need to change it, you’ll be happy that you documented it well. Of course, if
someone else has to use and modify your program, documentation is indispensable.

Documentation is both external and internal to the program. External documentation includes the
specifications, the development history, and the
design documents. Internal documentation includes
the program format and self-documenting code—
meaningful identifiers and comments. You can use
the pseudocode from your design as comments in
your programs.

This kind of documentation may be sufficient for
someone reading or maintaining your programs. However, if a program is going to be used by people
who are not programmers, you must provide a user’s manual as well.

Be sure to keep documentation up-to-date. Indicate any changes you make in a program in all of
the pertinent documentation. Use self-documenting code to make your programs more readable.

Documentation

Self-documenting code Program code containing
meaningful identifiers as well as judiciously used clari-
fying comments

2Grady Booch, “What Is and Isn’t Object-Oriented Design.” American Programmer, Special Issue on Object Orientation,
Vol. 2, no. 7–8, Summer 1989.

Now let’s look at a case study that demonstrates the design process.

Problem-Solving Case Study
Averaging Rainfall Amounts

Problem You are working for a scientific research project that is keeping track of the average
rainfall in your area. Observers from different locations call you to report how much rain has
fallen at the end of a storm. You need to enter the numbers as they come in and print the
running average.

Brainstorming Because this is such a small project, you are the “team.” Therefore, you must
do a solitary brainstorm. Grady Booch suggested that underlining nouns in a problem
statement is a good way to begin.2 So you begin your brainstorming by looking at the nouns in
the problem statement: you, project, average, rainfall, observers, and storm. So, here is your
first pass at the classes in the problem.



214 | Chapter 5:  Event-Driven Input and Software Design Strategies

Filtering Project and storm are not really objects; they just give information about the
context of the problem. Average and rainfall are numeric values, so we don’t need classes for
them. What are observers? They are the people who provide the rainfall values, so they are not a
class in our problem solution. However, this reminds us that we must have a window object to
input the rainfall values. What does you represent? It represents the processing that must be
done. Since you cannot actually do the processing within the machine, you is represented as the
application class. Let’s call the application class RainFall. Here is the filtered list of classes.

Scenarios The main class (RainFall) is responsible for seeing that the values are input and
the running average is calculated and printed. Some of the tasks should be done in the main
method and some in the button handlers for the input. We can use the built-in classes Frame,
Button, Label, String, and TextField to implement the window. Because the classes we
need for the window are built in, we don’t need to set up CRC cards for them, but we do for
class Rainfall.

Responsibility Algorithms At this point, let’s switch to a functional decomposition to write
the algorithms for implementing the responsibilities. Preparing the window for input (more
generally called preparing the user interface) requires us to declare each of the components of
the interface, to instantiate each component, and to add each component to the frame. These

Class Name: RainFall Superclass: Subclassess:

Responsibilities

Prepare the window for input

Handle input events (using buttons)

Handle window closing

TextField, Label, String, Buttons

Buttons

Frame

Collaborations

RainFall
Window object

you
project
average
rainfall
observers
storm



Problem-Solving Case Study | 215

are abstract steps because they each involve a series of actions. We defer a closer examination
of them until later. After the frame has been built, we pack and show it. We also need to
register its window-closing event handler. These steps can all be translated into individual Java
statements, so they are concrete.

Prepare Window for Input Level 1

Declaring the interface objects is essentially making a list of the components of our user inter-
face. We need a frame to hold everything, two labels (one for input and one for output), a field
for entering data, and a button for the user to click when a value is ready for input.

Declare the Interface Variables Level 2

Each declared object variable should also be assigned an instantiated object.

Instantiate Each Interface Object

We have added one more abstract step, which we can now expand. Registering an event lis-
tener for a button involves four steps. We declare a variable of the listener class that imple-
ments interface ActionListener, set the action command for the button, instantiate the
object, and then add the object to the button. Let’s call the listener ActionHandler. These
four steps are all concrete, as shown in the following module.

Set inputFrame to new Frame
Set entryLabel to new Label, “Enter amount here:”
Set outputLabel to new Label
Set inputField to new TextField, empty with 10 spaces
Set enter to new Button, “Enter”
Register the event listener for the Enter button

Declare a Frame, inputFrame
Declare a Label, entryLabel
Declare a Label, outputLabel
Declare a TextField, inputField
Declare a Button, enter

Declare the interface variables
Instantiate each interface object
Add each interface object to the frame
Pack the frame
Show the frame
Handle window closing



216 | Chapter 5:  Event-Driven Input and Software Design Strategies

Register the Event Listener for the Enter Button Level 3

Next, we must assemble the user interface components into a frame. We start by specifying a
layout manager for the frame. Let’s use a 2 by 2 grid for this interface to keep it compact. Now
we simply add each of the components to the frame: the two labels, the input field, and the
button.

Add Each Interface Object to the Frame Level 2

Handling the input events is where the real work of the program is accomplished. When the
user clicks the Enter button, we need to get the value from the input field and convert it to a
numerical value. Because we have input a new data value, we need to add 1 to the count of
the entries. We also add the input value to the total rainfall. The updated total and count can
then be used to compute the average, which we display for the user to see. Lastly, we should
clear out the input field so that the user can enter a new value. Each of these steps is concrete,
as shown in the following module.

Handle Input Events Level 1

Get the entry string from the input field
Set rainfall to numerical value (double) of entry string
Add 1 to the number of entries
Add rainfall to total
Set average to total divided by number of entries
Display average
Clear input field

Set layout manager for inputFrame to 2 3 2 grid
Add entryLabel to inputFrame
Add outputLabel to inputFrame
Add inputField to inputFrame
Add enter button to inputFrame

Declare action of class ActionHandler
setActionCommand for button enter to “enter”
Instantiate action
Add action as listener for button

TE
AM
FL
Y

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

Team-Fly® 



Problem-Solving Case Study | 217

This module must be implemented as a method called actionPerformed in a class that
implements ActionListener, the interface that all button handlers must implement. We
have called the class ActionHandler.

The last responsibility is to handle the window closing. When the user closes the window,
it is time to quit the program. What should we do if there is a value in the input field? Let’s
ignore it, on the assumption that it is only valid if the user clicks the Enter button. There are
two housekeeping steps to be done in quitting the program. We should clear the frame from
the screen and then exit the program. Each of these is a concrete step.

Handle Window Closing Level 1

We used OOD to determine the objects and their responsibilities. We then used functional
decomposition to write the algorithms to implement the responsibilities. Each abstract step in
each algorithm has been expanded into concrete steps that are functionally equivalent. All
that remains is for us to gather together the concrete steps in the proper order to give a com-
plete algorithm consisting of concrete steps. To perform the gathering process, we begin at the
lowest level, substituting the concrete steps of each module for the corresponding abstract
step in the level above it. That is, we replace each line of colored type with the corresponding
lines of black type.

For example, the four lines in the Level 3 module would be substituted for the colored line
at the end of the Level 2 module called “Instantiate Each Interface Object.” That module then
consists entirely of concrete steps that can replace the abstract step by the same name in the
Level 1 module called “Prepare Window for Input.”

Once all of the substitutions are complete, we have an algorithmic solution consisting
entirely of concrete steps. Because each concrete step can be directly translated into a Java
statement, writing the program is simply a matter of converting each line of the algorithm into
a corresponding line of code. The resulting algorithm and program are known as a flat or inline
implementation because our series of substitutions produces a solution with just a single level.
We are flattening the two-dimensional, hierarchical structure of the solution by writing all of
the steps as one long sequence. This kind of implementation is adequate when the implemen-
tation of a responsibility is short.

From our design we collect a list of all of the variables that our program uses, to help in
writing their declarations. The variables referenced outside of main must be declared out-
side of main and have the modifier static. To remind us, we mark these variables with an
asterisk.

Dispose of the frame
Exit the program



218 | Chapter 5:  Event-Driven Input and Software Design Strategies

At this stage we should look over this list of variables and ask ourselves if there are any that
we have forgotten to initialize. total keeps the running total of the rainfall so far, so it should
be initialized to zero. numberEntries is a counter that tells how many values have been read,
so it should also be set to zero. We must set these values in main where they are declared. We
have marked the identifiers used outside of main; we need to make them private static
class declarations.

Here is the complete program. We have used the steps in the design as the basis for its
comments.

import java.awt.*;                                // User interface classes
import java.awt.event.*;                         // Event handling classes
public class Rainfall
{
// Define a button listener
private static class ActionHandler implements ActionListener
{
public void actionPerformed(ActionEvent event)
// Handles events from the Enter button in inputFrame
{
double amount;                               // Holds input value
double average;                              // Holds computed average
// Convert string in inputField to a double value
amount = Double.valueOf(inputField.getText()).doubleValue();
numberEntries++;                            // Increment entries
total = total + amount;                      // Add value to sum
average = total / numberEntries;             // Compute average 
outputLabel.setText("" + average);          // Display average
inputField.setText("");                   // Clear input field

}
}

Variables

Name Data Type Description

inputFrame* Frame A frame
entryLabel Label Label for input
outputLabel* Label Label for output
inputField* TextField Input field
enter Button Enter button
total* double Keeps running total
numberEntries* double Keeps count of entries
action ActionHandler Action handler
amount double Holds input value
average double Holds computed average



Problem-Solving Case Study | 219

private static Frame inputFrame;                // User interface frame
private static Label outputLabel;               // Label for output
private static TextField inputField;            // Input field
private static double total;                    // Keeps running total
private static double numberEntries;           // Keeps count of entries

public static void main(String[] args)
{ 
{  // Declare local variables
Label entryLabel;                             // Label for input field
Button enter;                               // Enter button
ActionHandler action;                         // Declare listener
// Initialize/instantiate variables
total = 0.0;
numberEntries = 0.0;
inputFrame = new Frame();
entryLabel = new Label("Enter amount here:");
outputLabel = new Label("0.0", Label.RIGHT);
inputField = new TextField("", 10);
enter = new Button("Enter");
enter.setActionCommand("enter");              // Name the button event
action = new ActionHandler();                 // Instantiate listener
enter.addActionListener(action);              // Register the listener
// Add components to frame
inputFrame.setLayout(new GridLayout(2,2));
inputFrame.add(entryLabel);
inputFrame.add(inputField);
inputFrame.add(enter);
inputFrame.add(outputLabel);
inputFrame.pack();                            // Pack the frame
inputFrame.show();                            // Show the frame
inputFrame.addWindowListener(new WindowAdapter()  
// Declare window closing event handler
{
public void windowClosing(WindowEvent event)
{
inputFrame.dispose();                   // Close the frame
System.exit(0);                          // Quit the program

}
});

}
}



220 | Chapter 5:  Event-Driven Input and Software Design Strategies

When the program executes, the frame shown below is displayed. The contents shown in
the frame are the result of entering the following series of values, with the frame appearing as
it does just before Enter is clicked to cause the last value to be processed.

1.300
0.800
1.200
2.000
0.950
1.410

Background Information
Programming at Many Scales

To help you put the topics in this book into context, we describe in broad terms the way pro-
gramming in its many forms is done in “the real world.” Obviously, we can’t cover every possi-
bility, but we’ll try to give you a flavor of the state of the art.

Programming projects range in size from the small scale, in which a student or computer
hobbyist writes a short program to try out something new, to large-scale multicompany pro-
gramming projects involving hundreds of people. Between these two extremes are efforts of
many other sizes. There are people who use programming in their professions, even though it
isn’t their primary job. For example, a scientist might write a special-purpose program to ana-
lyze data from a particular experiment.

Even among professional programmers there are many specialized programming areas. An
individual might have a specialty in business data processing, in writing compilers or develop-
ing word processors (a specialty known as “tool making”), in research and development sup-
port, in graphical display development, in writing entertainment software, or in one of many
other areas. However, one person can produce only fairly small programs (a few tens of thou-
sands of lines of code at best). Work of this kind is called programming in the small.

A larger application, such as the development of a new operating system, might require
hundreds of thousands or even millions of lines of code. Such large-scale projects require
teams of programmers, many of them specialists, who must be organized in some manner or
they waste valuable time just trying to communicate with one another.

Usually, a hierarchical organization is set up. One person, the chief architect or project
director, determines the basic structure of the program and then delegates the responsibility
of implementing the major components. The components may be implemented by teams or by
individual programmers. This sort of organization is called programming in the large.

Programming languages and software tools can help a great deal in supporting program-
ming in the large. For example, if a programming language lets programmers develop, compile, 

continued t



Testing and Debugging | 221

Testing and Debugging

An important part of implementing a program is testing it (checking the results). By
now you should realize that there is nothing magical about the computer. It is infallible
only if the person writing the instructions and entering the data is infallible. Don’t trust
it to give you the correct answers until you’ve verified enough of them by hand to con-
vince yourself that the program is working.

From here on, these Testing and Debugging sections offer tips on how to test your
programs. We offer suggestions for what to do if a program doesn’t work as expected.
It’s much easier to prevent bugs than to fix them.

With programs that input data from fields, the most common error is to try to
assign the field contents directly to an int or double variable. Remember that Java

and test parts of a program independently before they are put together, then it enables several peo-
ple to work on the program simultaneously. Of course, it is hard to appreciate the complexity of pro-
gramming in the large when you are writing a small program for a class assignment. However, the
experience you gain in this course will be valuable as you begin to develop larger programs.

The following is a classic example of what happens when a large program is developed without
careful organization and proper language support. In the 1960s, IBM developed a major new operat-
ing system called OS/360, which was one of the first true examples of programming in the large.
After the operating system was written, more than 1,000 significant errors were found. Despite years
of trying to fix these errors, the programmers never did get the number of errors below 1,000, and
sometimes the “fixes” produced far more errors than they eliminated.

What led to this situation? Hindsight analysis showed that the code was badly organized and that
different pieces were so interrelated that nobody could keep it all straight. A seemingly simple
change in one part of the code caused several other parts of the system to fail. Eventually, at great
expense, an entirely new system was created using better organization and tools.

In those early days of computing, everyone expected occasional errors to occur, and it was still
possible to get useful work done with a faulty operating system. Today, however, computers are used
more and more in critical applications such as medical equipment and aircraft control systems where
errors can prove fatal. Many of these applications depend on large-scale programming. If you were
stepping onto a modern jetliner right now, you might well pause and wonder, “Just what sort of lan-
guage and tools did they use when they wrote the programs for this thing?” Fortunately, most large,
life-critical, software development efforts today use a combination of good methodology, appropriate
language, and extensive organizational tools—an approach known as software engineering.

Programming at Many Scales



222 | Chapter 5:  Event-Driven Input and Software Design Strategies

only inputs String values and that you must convert the input to any other type.
Another problem that often occurs is that the user enters a number that causes integer
overflow. When you want a field to input an integer value, limit its size (through the
constructor call) to nine characters. As we noted before, we are not yet ready to handle
errors in which the user enters nonnumeric data into such a field. Your program will
simply crash with an error message if this happens.

In testing programs that perform numeric calculations, be sure to test whether input
values can result in overflow or division by zero. In Chapter 6 we see how to catch these
errors before the calculation takes place. Until then you should document the limitations
of your program with comments.

By giving you a framework that can help you organize and keep track of the details
involved in designing and implementing a program, OOD and functional decomposition
should help you avoid errors in the first place.

Testing and Debugging Hints

1. Remember to label each input field with a prompting message.
2. Be certain that every field, label, or button follows the three basic steps: declare it,

instantiate it, and add it to the frame.

3. Remember to specify a layout manager for a frame.
4. The value in a field is a string. If you need to input a number, you must use get-

Text to input the string, and then convert the string to a number, using methods
such as valueOf and doubleValue or valueOf and intValue. Applying these
methods to a nonnumeric value causes the program to halt with an error message
such as Number Format Error.

5. Call setActionCommand for each button to name it.
6. A button event listener declaration must follow exactly the pattern of headings

specified by the ActionListener interface. You can choose the name of the
class, but the rest of the class and method headings must appear exactly as shown
on page 185.

7. Once the button event listener class is declared, there are three steps that must be
performed to register the event listener: declare an object of the same type as the
class, instantiate the object, and call the button’s addActionListener method
with the object as its parameter.

8. Use the design methodologies presented in this chapter to carefully design a com-
plete algorithmic solution to a problem before you start writing Java code. The
design should be sufficiently detailed that converting it to Java is almost a mechan-
ical process.



Summary of Classes | 223

Summary of Classes

Package Name

Class Name Comments

java.lang Automatically imported to every Java program

Double
Class Constants: MAX_VALUE Highest double value

MIN_VALUE Lowest double value
Constructor: Double(double)
Value-Returning Class Method:

valueOf(String) Returns Double
Value-Returning Instance Method:

doubleValue() Returns double

Float
Class Constants: MAX_VALUE Highest float value

MIN_VALUE Lowest float value
Constructor: Float(float)
Value-Returning Class Method:

valueOf(String) Returns Float
Value-Returning Instance Method:

floatValue() Returns float

Integer
Class Constants: MAX_VALUE Highest int value

MIN_VALUE Lowest int value
Constructor: Integer(int)
Value-Returning Class Method:

valueOf(String) Returns Integer
Value-Returning Instance Method:

intValue() Returns int

Long
Class Constants: MAX_VALUE Highest long value

MIN_VALUE Lowest long value
Constructor: Long(long)
Value-Returning Class Method:

valueOf(String) Returns Long
Value-Returning Instance Method:

longValue() Returns long



224 | Chapter 5:  Event-Driven Input and Software Design Strategies

Package Name

Class Name Comments

java.awt
ActionEvent Passed to event handler
ActionListener An interface
Button

Constructor: Button(String)
Void Instance Methods:

setActionCommand(String)
addActionListener(implementation of ActionListener)

Frame

Void Instance Methods:
add(Button)
add(TextField)
remove(Button)
remove(Label)
remove(TextField)

TextField

Constructors: TextField(int)
TextField(String, int)

Value-Returning Instance Method:
getText() Returns String

Void Instance Method:
setText(String)

Summary
Programs operate on data. If data and programs are kept separate, the data is available to
use with other programs, and the same program can be run with different sets of input data.

The TextField class enables us to input data from the keyboard, storing the data into
the variable specified in a call to its getText method. The getText method inputs the
contents of the field as a string. We must use additional methods such as valueOf and
doubleValue to convert an input string to a numeric value. Reading of the text in a
field is usually triggered by a user event such as closing a window or clicking a button.

We must register an event listener with its button to activate the button. The button
is named with a call to setActionCommand, and the event listener is registered with a



Quick Check | 225

call to addActionListener. The event handler itself is a method in a class definition
that follows the specification of the ActionListener interface.

Interactive programs prompt the user for each data entry and directly inform the user
of results and errors. Designing an interactive dialogue is an exercise in the art of com-
munication. Noninteractive input/output allows data to be prepared before a program is
run and allows the program to run again with the same data in the event that a problem
crops up during processing.

Object-oriented design (OOD) and functional decomposition are methods for tackling
nontrivial programming problems. The two methodologies are often used in combina-
tion, and experienced programmers often switch between them in solving a problem.
We use OOD to design the overall solution to a complex problem, and then apply func-
tional decomposition to aid in writing the algorithm for the individual responsibilities of
each object.

Object-oriented design produces a problem solution by focusing on objects and
their associated operations. The first step is to brainstorm the major objects in the
problem and create classes that are abstract descriptions of them. We filter the initial
classes, eliminating duplicate and inappropriate classes. We then walk through a
series of scenarios, working from common cases to exceptional cases to determine the
responsibilities and collaborations of the classes. The use of CRC cards helps us to
keep track of this information as we explore the scenarios. The result of the design
process is a program consisting of self-contained objects that have responsibilities for
managing their own data and collaborating with other objects by invoking each
other’s methods.

Functional decomposition begins with an abstract solution that then is divided into
major steps. Each step becomes a subproblem that is analyzed and subdivided further. A
concrete step is one that can be translated directly into Java; those steps that need more
refining are abstract steps. A module is a collection of concrete and abstract steps that
solves a subproblem. 

Careful attention to program design, program formatting, and documentation pro-
duces highly structured and readable programs.

Quick Check
1. What is one of the biggest advantages of computers? (p. 176)
2. Where is an event sent when a user clicks on a button with a mouse? (p. 178)
3. What happens when a user clicks a button? (p. 178)
4. Who or what participates in a computer dialog? (p. 179)
5. Declare a TextField called dataField. (p. 179–180)
6. Assign a value to dataField with a fieldwidth of 10. (pp. 179–180)
7. Assign a default value “Replace me” to dataField. (p. 180)
8. Add dataField to Frame object dataFrame. (p. 180)
9. Write the statement that stores the values entered in field dataField into the

String variable dataValue. (pp. 180–181)
10. Write the statement that converts the dataValue into doubleValue of type

double. (pp. 192–194)



226 | Chapter 5:  Event-Driven Input and Software Design Strategies

11. Write a statement that declares a Button variable press. (p. 182)
12. Write the statement that gives the name “Press” to press. (pp. 182–183)
13. Write a statement that declares an object of listener class ButtonListener. (pp.

184–187)
14. Write the statement to register the button listener. (p. 187)
15. Object-oriented design produces a collection of _________. (objects, tasks)

(p. 200)
16. Functional design produces a hierarchy of ________. (objects, tasks) (p. 210)

Answers

1. A program can be run with many different data sets. 2. Event handler within an event lis-
tener. 3. The JVM recognizes the button event and calls the event handler within the appropri-
ate event listener. 4. A computer dialog is an exchange between the program and a user.
5. private static TextField dataField
6. dataField = new TextField(10);
7. dataField = new TextField("Replace me", 10);
8. dataFrame.add(dataField);
9. dataValue = dataField.getText();

10. someDouble = Double.valueOf(dataValue).doubleValue();
11. Button press;
12. press.setActionCommand("Press");
13. ButtonListener buttonHear;
14. press.addActionListener(ButtonHear);
15. objects 16. tasks

Exam Preparation Exercises
1. Name three objects that can be contained in a Frame object.
2. What are the steps in adding a data entry field to a Frame object?
3. When instantiating a Label object, what is passed to the constructor?
4. When instantiating a TextField object, what is passed to the constructor?
5. What happens if you forget to include the statement dataFrame.show()?
6. What are the three steps needed to add a Button object to a frame?
7. What are the steps necessary in creating a Button object?
8. What are the steps necessary in creating a Button listener?
9. What happens when a user clicks a button but there is no listener registered for

the event?
10. What is an interface in Java?
11. What is an interface implementation in Java?
12. How are application classes and classes that implement the ActionListener

interface different?
13. actionPerformed takes one parameter of a predefined Java type. What is the

name of the type?

TE
AM
FL
Y

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

Team-Fly® 



Programming Warm-Up Exercises | 227

14. What three steps are necessary to register an event listener?
15. Why do you not have to write an implementation of WindowListener to handle

the window-closing event?
16. What determines the amount of information in a prompt?
17. Java provides input only for strings. How can we enter numeric values into our

programs?
18. What are the object types that correspond with the built-in numeric types?
19. Distinguish between instance methods and class methods.
20. If it is natural to think of the solution to a problem in terms of a collection of

component parts, which design technique is more appropriate?
21. If it is natural to think of the solution to a problem in terms of a series of steps,

which design technique is more appropriate?
22. If a method is modified by static, is it a class method or an instance method?
23. Distinguish between an abstract step and a concrete step.
24. List the steps in performing an object-oriented design.
25. At which point in an object-oriented design is functional decomposition useful?

Programming Warm-Up Exercises
1. a. Write the statement that declares a Label field named textLabel.

b. Write the statement that instantiates textLabel with the string "Enter
data".

c. Write the statement that declares a TextField named dataField.
d. Write the statement that stores the values entered in field dataField into

String variable dataValue.
e. Write the statement that converts dataValue to an integer value and stores

it in intValue.
f. Write a statement to replace the current contents of dataField with "Next

Value".
2. a. Declare a Button variable called stop.

b. Instantiate the Button object, calling it "Stop".
c. Name the Button object "stop".
d. Declare and instantiate a Button listener object.
e. Register the Button listener.
f. Add the button to frame dataFrame.

3. a. Write the statements to create a frame (exampleFrame) with one label
(exampleLabel), one field (exampleField), and one button (example-
Button).

b. Write the statements that define a class (ExampleClass) that is an imple-
mentation of ActionListener. When the exampleButton is clicked, the
contents of exampleField are stored in exampleValue and removed from
exampleField.

c. Write the statements that declare and instantiate example_EventHandler of
class ExampleClass.



228 | Chapter 5:  Event-Driven Input and Software Design Strategies

d. Write the statements that name exampleButton and register its associated
event listener exampleEventHandler.

4. a. What is the type of the following expression Integer.valueOf("1999")?
b. Is valueOf an instance method or a class method?
c. If Integer.valueOf("1999") returns a value of type Integer, how can

you convert it to type int?
5. Write the statements that store the number 2,000 into variable data of type int.
6. Write the statement that takes the string representing an integer number in

exampleField and stores it into data.
7. You are to read the three coefficients of a quadratic polynomial and write the

two floating-point solutions. Assume that the discriminant (the portion of the
formula inside the square root) is nonnegative. You may use the standard
method Math.sqrt. The quadratic formula is

a. Use object-oriented design to determine the objects in the problem. Discuss
the problem in the following phases: brainstorming, filtering, scenarios, CRC
cards, and responsibility algorithms.

b. Use functional decomposition to write an algorithm for the problem.
c. Compare your object-oriented design and your functional design.

Programming Problems
1. Design and code a Java application to read an invoice number, quantity ordered,

and unit price (all integers) and compute the total price. The application should
write out the invoice number, quantity, unit price, and total price on the screen
with identifying phrases. Format your program with consistent indentation; use
appropriate comments and meaningful identifiers. The data is prompted for and
read from the screen. Use buttons where appropriate.

2. How tall is a rainbow? Because of the way in which light is refracted by water
droplets, the angle between the level of your eye and the top of a rainbow is
always the same (the so-called magic angle). If you know the distance to the
rainbow, you can multiply it by the tangent of that angle to find the height of
the rainbow. The magic angle is 42.3333333 degrees. The Java standard library
works in radians, however, so you have to convert the angle to radians with this
formula:

where p equals 3.14159265.

 
radians degrees= × π

180

  

− ± −b b ac
a

2 4
2



Case Study Follow-Up Exercises | 229

Math.tan is a value-returning method that takes a floating-point parameter
and returns a floating-point result:

x = Math.tan(someAngle);

If you multiply the tangent by the distance to the rainbow, you get the height of
the rainbow.

Design and code a Java application to read a single floating-point value—the
distance to the rainbow—from the screen and compute the height of the rainbow.
The program should print the distance to the rainbow and its height with phrases
that identify which number is which. Format your program with consistent
indentation, and use appropriate comments and meaningful identifiers.

3. Sometimes you can see a second, fainter rainbow outside a bright rainbow. This
second rainbow has a magic angle of 52.25 degrees. Modify the program in
Exercise 2 so that it prints the height of the main rainbow, the height of the sec-
ondary rainbow, and the distance to the main rainbow, with a phrase identifying
each of the numbers.

Case Study Follow-Up Exercises
1. Does RainFall crash if the window is closed before the user enters any values?

Explain.
2. Outline a testing strategy for application RainFall.
3. Rainfall stops when the user closes the window. What other ways could the

program allow the user to quit? Explain.
4. What happens when a negative value is input?





                 

To be able to construct a simple logical (Boolean)
expression to evaluate a given condition.

To be able to construct a complex Boolean expres-
sion to evaluate a given condition.

To be able to construct an if-else statement to per-
form a specific task.

To be able to construct an if statement to perform a
specific task.

To be able to construct a set of nested if statements to
perform a specific task.

To be able to describe an algorithm walk-through and
tell how it is used.

To be able to explain the purpose of tracing the execu-
tion of Java code.

To be able to test and debug a Java program.

Conditions, Logical
Expressions, and
Selection Control
Structures

G
oals



232 | Chapter 6:  Conditions, Logical Expressions, and Selection Control Structures

So far, the statements in our programs have been executed in the same order that we
write them, except when an event occurs. The first statement is executed, then the sec-
ond, and so on. The method call and the event handler, which execute a separate
sequence of statements, provide variations of this ordering. But what if we want the
computer to execute the statements in an order other than sequentially? Suppose we
want to check the validity of input data and then perform a calculation or display an
error message, not both. To do so, we must be able to ask a question and then, based on
the answer, choose one or another course of action.

The if statement allows us to execute statements in an order that is different from
their physical order. We can ask a question with it and do one thing if the answer is yes
(true) or another if the answer is no (false). In the first part of this chapter, we deal with
asking questions; in the second part, we deal with the if statement itself.

6.1 Flow of Control
The order in which statements are executed in a program is called the flow of control.
In a sense, the computer is under the control of one statement at a time. When a

statement has been executed, control is turned over
to the next statement (like a baton being passed in a
relay race).

Flow of control is normally sequential (see Figure
6.1). That is, when one statement is finished execut-
ing, control passes to the next statement in the pro-
gram. If you want the flow of control to be
nonsequential, you can use control structures, special

statements that transfer control to a statement other than the one that physically comes
next. You have already seen that method calls, especially event handlers, are control

statement 1

statement 2

statement 3

statement 4

Flow of
control

Figure 6.1 Sequential control

Flow of control The order in which the computer
executes statements in a program

Control structure A statement used to alter the nor-
mally sequential flow of control



6.1 Flow of Control | 233

structures that alter the flow of control so that a separate sequence of statements can be
executed.

Selection

You can use a selection (or branching) control structure when you want the computer to
choose between alternative actions. You make an assertion, a claim that is either true or
false. If the assertion is true, the computer executes one statement. If it is false, it exe-
cutes another (see Figure 6.2). The computer’s ability to solve practical problems is a
product of its ability to make decisions and execute different sequences of instructions.

The Payroll program in Chapter 1 shows the selection process at work. The com-
puter must decide whether or not a worker has earned overtime pay. It does this by test-
ing the assertion that the person has worked more than 40 hours. If the assertion is true,
the computer follows the instructions for computing overtime pay. If the assertion is
false, the computer simply computes the regular pay. Before examining selection control
structures in Java, let’s look closely at how we get the computer to make decisions.

Assertion

statement 1A statement 1B

true false

Figure 6.2 Selection (branching) control structure



234 | Chapter 6:  Conditions, Logical Expressions, and Selection Control Structures

1The name boolean is a tribute to George Boole, a nineteenth-century English mathematician who
described a system of logic using variables with just two values, True and False. (See the Background Informa-
tion box on page 242.)

6.2 Conditions and Logical Expressions
To ask a question in Java, we don’t phrase it as a question; we state it as an assertion. If
the assertion we make is true, the answer to the question is yes. If the statement is not
true, the answer to the question is no. For example, if we want to ask, “Are we having
spinach for dinner tonight?” we would say, “We are having spinach for dinner tonight.”
If the assertion is true, the answer to the question is yes. If not, the answer is no.

So, asking questions in Java means making an assertion that is either true or false.
The computer evaluates the assertion, checking it against some internal condition (the
values stored in certain variables, for instance) to see whether it is true or false.

The boolean Data Type

The boolean data type consists of just two values, the constants true and false. The
reserved word boolean is pronounced bool-e-un.1 Boolean data is used for testing con-
ditions in a program so that the computer can make decisions (as in a selection control
structure).

We declare variables of type boolean the same as we declare variables of other
standard types, by writing the name of the data type and then an identifier:

boolean dataOK;    // True if the input data is valid
boolean done;      // True if the process is done
boolean taxable;   // True if the item has sales tax

Each variable of type boolean can contain one of two values: true or false. It’s
important to understand right from the beginning that true and false are not variable
names and they are not strings. They are special constants in Java and, in fact, are
reserved words.

Logical Expressions

In programming languages, assertions take the form of logical expressions (also called
Boolean expressions). Just as an arithmetic expression is made up of numeric values and
operations, a logical expression is made up of logical values and operations. Every logi-
cal expression has one of the two boolean values: true or false.

Here are some examples of logical expressions:

• A boolean variable or constant
• An arithmetic expression followed by a relational operator followed by an arith-

metic expression
• A logical expression followed by a logical operator followed by a logical expression



6.2 Conditions and Logical Expressions | 235

Let’s look at each of these in detail.

Boolean Variables and Constants As we have seen, a boolean variable is a variable
declared to be of type boolean, and it can contain either the value true or the value
false. For example, if dataOK is a boolean variable, then

dataOK = true;

is a valid assignment statement.

Relational Operators Another way of assigning a value to a boolean variable is to set
it equal to the result of comparing two expressions with a relational operator. Relational
operators test a relationship between two values.

Let’s look at an example. In the following program fragment, lessThan is a
boolean variable and i and j are int variables:

lessThan = (i < j); // Compare i and j with the "less than" relational
//  operator, and assign the value to lessThan

By comparing two values, we assert that a relationship (such as “less than”) exists
between them. If the relationship does exist, the assertion is true; if not, it is false. These
are the relationships we can test for in Java:

Operator Relationship Tested

== Equal to
!= Not equal to
> Greater than
< Less than
>= Greater than or equal to
<= Less than or equal to

An expression followed by a relational operator followed by an expression is called
a relational expression. The result of a relational expression is of type boolean. For
example, if x is 5 and y is 10, the following expressions all have the value true:

x != y
y > x
x < y
y >= x
x <= y

If x is the character 'M' and y is 'R', the values of the expressions are still true
because the relational operator <, used with letters, means “comes before in the alpha-
bet,” or, more properly, “comes before in the collating sequence of the character set.”
For example, in the ASCII subset of the Unicode character set, all of the uppercase



236 | Chapter 6:  Conditions, Logical Expressions, and Selection Control Structures

letters are in alphabetical order, as are the lowercase letters, but all of the uppercase let-
ters come before the lowercase letters. So

'M' < 'R'

and

'm' < 'r'

have the value true, but

'm' < 'R'

has the value false.
Of course, we have to be careful about the data types of things we compare. The

safest approach is always to compare identical types: int with int, double with dou-
ble, char with char, and so on. If you mix data types in a comparison, implicit type
conversion takes place just as in arithmetic expressions. If an int value and a double
value are compared, the computer temporarily converts the int value to its double
equivalent before making the comparison. As with arithmetic expressions, it’s wise to
use explicit type casting to make your intentions known:

someDouble >= (double)someInt

If you try to compare a boolean value with a numeric value (probably by mistake),
the compiler gives you an error message. Values of type boolean cannot be converted
to any type other than String. When a boolean variable is concatenated with a string,
its value is automatically converted to either "true" or "false". No type can be con-
verted to boolean.

Be careful to compare char values only with other char values. For example, the
comparisons

'0' < '9'

and

0 < 9

are appropriate, but comparing a digit in quotes (a character) and a digit such as

'0' < 9

generates an implicit type conversion and a result that probably isn’t what you expect.
The character for the digit 'O' is converted to its Unicode int value, which is 79, and
the comparison returns false because 79 is greater than 9.

You can use relational operators not only to compare variables or constants, but
also to compare the values of arithmetic expressions. The following table shows the

TE
AM
FL
Y

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

Team-Fly® 



6.2 Conditions and Logical Expressions | 237

results of using the relational operators to compare expressions made up of adding 3 to
x and multiplying y by 10 for different values of x and y:

Value of x Value of y Expression Result

12 2 x + 3 <= y * 10 true
20 2 x + 3 <= y * 10 false
7 1 x + 3 != y * 10 false
17 2 x + 3 == y * 10 true
100 5 x + 3 > y * 10 true

Caution: It’s easy to confuse the assignment operator (=) and the == relational opera-
tor. These two operators have very different effects in a program. Some people pronounce
the relational operator as “equals-equals” to remind themselves of the difference.

Comparing Strings You cannot compare strings using the relational operators.
Syntactically, Java lets you write the comparisons for equality (==) and inequality (!=)
between values of class String, but the comparison that this represents is not what you
typically want. Recall from Chapter 3 that String is a reference type. That is, the
content of a String variable is the memory address number for the beginning of the
string. When you assign one string to another, Java just copies this address. Similarly,
when you compare two strings, Java checks to see that they have the same address. It
does not check to see if they contain the same sequence of characters.

Forgetting that Java applies comparison to strings in this manner, and mistakenly
using == or != can produce some insidious errors. The comparison sometimes seems to
work and sometimes it fails. The reason is that most Java compilers are quite clever
about how they store String literals. If you type the same literal in two different places
in your program, the compiler recognizes their equality and stores the character
sequence just once, and then uses the same address in the Bytecode. Thus, comparing a
String literal to a variable that has been assigned an identical literal elsewhere in the
program is likely to work (if the Java compiler is well designed).

On the other hand, if you get a string from a TextField object and compare it to a
String literal, the two will always compare as unequal, even when they contain the
exact same sequence of characters. The string from the TextField object and the
String literal are stored in different places in memory, which means that their
addresses compare as unequal.

Rather than using the relational operators, we compare strings with a set of value-
returning instance methods that Java supplies as part of the String class. Because they
are instance methods, the method name is written following a String object, separated
by a dot. The string that the method name is appended to is one of the strings in the
comparison, and the string in the parameter list is the other. Because there are times we
want to compare strings ignoring capitalization, the String class provides methods
called toLowerCase and toUpperCase that convert all the characters of a string to
lowercase or uppercase, respectively. The two most useful comparison methods are sum-
marized in the following table, along with toLowerCase and toUpperCase.



238 | Chapter 6:  Conditions, Logical Expressions, and Selection Control Structures

Method Name Parameter Type Returns Operation Performed

equals String boolean Tests for equality of string
contents.

compareTo String int Returns 0 if equal, a positive
integer if the string in the
parameter comes before the
string associated with the
method, and a negative integer if
the parameter comes after it.

toLowerCase String Returns a new identical string,
except the characters are all low-
ercase.

toUpperCase String Returns a new identical string,
except the characters are all low-
ercase.

For example, if lastName is a String variable, you can write

lastName.equals("Olson") // Tests whether lastName equals "Olson"

Because every String literal is also a String object, Java lets you append the method
call to a literal, if you so choose.

"Olson".equals(lastName) // Tests whether lastName equals "Olson"

As another example, you might write

0 > lastName.compareTo("Olson") // Tests if lastName comes before "Olson"

Comparison of strings follows the collating sequence of the Unicode character set.
When the computer tests a relationship between two strings, it begins with the first
character of each, compares them according to the collating sequence, and if they are
the same, repeats the comparison with the next character in each string. The charac-
ter-by-character test proceeds until a mismatch is found, the final characters have
been compared and are equal, or one string runs out of characters. If all their charac-
ters are equal, then the two strings are equal. If a mismatch is found, then the string
with the character that comes before the other is the “lesser” string. If their characters
are equal throughout the shorter string, the shorter string comes before the longer
string.

For example, given the statements

String word1;
String word2;

word1 = "Tremendous";
word2 = "Small";



6.2 Conditions and Logical Expressions | 239

the following relational expressions have the values shown.

Expression Value Reason

word1.equals(word2) false They are unequal in the first char-
acter.

0 < word1.compareTo(word2) true ‘T’ comes after ‘S’ in the collating
sequence.

0 < word1.compareTo("small") false ‘T’ comes before ‘s' in the collating
sequence.

0 > word1.compareTo("Tremble") false Fifth characters don’t match, and
‘b’ comes before ‘e’.

word2.equals("Small") true They are equal.
0 == "cat".compareTo("dog") false They are unequal.

In most cases, the ordering of strings corresponds to alphabetical ordering. But
when strings have mixed case letters, you can get nonalphabetical results. For example,
in a phone book we expect to see Macauley before MacPherson, but the Unicode collat-
ing sequence places all English uppercase letters before the lowercase letters, so the
string “MacPherson” compares as less than “Macauley”. To compare strings for strict
alphabetical ordering, all the characters must be in the same case. Here we see examples
in which toLowerCase and toUpperCase are used to perform the comparison cor-
rectly.

lowerCaseString = myString.toLowerCase();
upperCaseString = myString.toUpperCase();

You can use these methods directly in a comparison expression. For example, the
following expressions convert word1 and word2 to the same case before comparing
them. It doesn’t matter whether the strings are both converted to uppercase or both are
converted to lowercase, as long as they are the same.

0 > word1.toLowerCase().compareTo(word2.toLowerCase())
0 > word1.toUpperCase().compareTo(word2.toUpperCase())

If two strings with different lengths are compared and the comparison is equal up
to the end of the shorter string, then the shorter string compares as less than the longer
string. For example, if word2 contains "Small", the expression

0 > word2.compareTo("Smaller")

yields true because the strings are equal up to their fifth character position (the end of
the string on the left) and the string on the right is longer.

Logical Operators In mathematics, the logical (or Boolean) operators AND, OR, and
NOT take logical expressions as operands. Java uses special symbols for the logical



240 | Chapter 6:  Conditions, Logical Expressions, and Selection Control Structures

2In Boolean algebra, the pattern is formalized by a theorem called DeMorgan’s law.

operators: && (for AND), || (for OR), and ! (for NOT). By combining relational operators
with logical operators, you can make more complex assertions. For example, suppose
you want to determine whether a final score is greater than 90 and a midterm score is
greater than 70. In Java, you would write the expression this way:

finalScore > 90 && midtermScore > 70

The AND operation (&&) requires both relationships to be true in order for the overall
result to be true. If either or both of the relationships are false, the entire result is
false.

The OR operation (||) takes two logical expressions and combines them. If either or
both are true, the result is true. Both values must be false for the result to be false.
Now you can determine whether the midterm grade is an A or the final grade is an A. If
either the midterm grade or the final grade equals A, the assertion is true. In Java, you
can write the expression like this:

midtermGrade == 'A' || finalGrade == 'A'

The && and || operators always appear between two expressions; they are binary
(two-operand) operators. The NOT operator (!) is a unary (one-operand) operator. It pre-
cedes a single logical expression and gives its opposite as the result. If (grade ==
'A') is false, then !(grade == 'A') is true. NOT gives a convenient way of reversing
the meaning of an assertion. For example,

!(hours > 40)

is the equivalent of

hours <= 40

In some contexts, the first form is clearer; in others, the second makes more sense.
The following pairs of expressions are equivalent:

Expression Equivalent Expression

!(a == b) a != b
!(a == b || a == c) a != b && a != c
!(a == b && c > d) a != b || c <= d

Take a close look at these expressions to be sure you understand why they are equiva-
lent. Try evaluating them with some values for a, b, c, and d. Notice the pattern: The
expression on the left is just the one to its right with ! added and the relational and
logical operators reversed (for example, == instead of != and || instead of &&). Remem-
ber this pattern. It allows you to rewrite expressions in the simplest form.2



6.2 Conditions and Logical Expressions | 241

Logical operators can be applied to the results of comparisons. They also can be
applied directly to variables of type boolean. For example, instead of writing

isElector = (age >= 18 && district == 23);

to assign a value to the boolean variable isElector, you could use two intermediate
boolean variables, isVoter and isConstituent:

isVoter = (age >= 18);
isConstituent = (district == 23);
isElector = isVoter && isConstituent;

The two tables below summarize the results of applying && and || to a pair of logi-
cal expressions (represented here by boolean variables x and y).

Value of x Value of y Value of (x &&
y)

true true true
true false false
false true false
false false false

Value of x Value of y Value of (x ||
y)

true true true
true false true
false true true
false false false

The following table summarizes the results of applying the ! operator to a logical
expression (represented by Boolean variable x).

Value of x Value of !x

true false
false true

Short-Circuit Evaluation Consider the logical expression

i == 1 && j > 2



242 | Chapter 6:  Conditions, Logical Expressions, and Selection Control Structures

Some programming languages use full evaluation of
logical expressions. With full evaluation, the computer
first evaluates both subexpressions (both i == 1 and
j > 2) before applying the && operator to produce the
final result.

In contrast, Java uses short-circuit (or condi-
tional) evaluation of logical expressions. Evaluation

proceeds from left to right, and the computer stops evaluating subexpressions as soon as
possible—that is, as soon as it knows the Boolean value of the entire expression. How
can the computer know if a lengthy logical expression yields true or false if it does-
n’t examine all the subexpressions? Let’s look first at the AND operation.

An AND operation yields the value true only if both of its operands are true. In
the previous expression, suppose that the value of i happens to be 95. The first subex-
pression yields false, so it isn’t necessary even to look at the second subexpression.
The computer stops evaluation and produces the final result of false.

With the OR operation, the left-to-right evaluation stops as soon as a subexpression
yielding true is found. Remember that an OR produces a result of true if either one or
both of its operands are true. Given this expression:

c <= d || e == f

if the first subexpression is true, evaluation stops and the entire result is true. The
computer doesn’t waste time evaluating the second subexpression.

Java provides a second set of logical operators that result in full evaluation of
Boolean expressions. The single & and | perform logical AND and OR operations,
respectively, with full evaluation. We don’t recommend their use at this stage in your

Short-circuit (conditional) evaluation Evaluation of
a logical expression in left-to-right order with evalua-
tion stopping as soon as the final Boolean value can be
determined

Background Information
George Boole

Boolean algebra is named for its inventor, English mathematician George Boole, born in 1815.
His father, a tradesman, began teaching him mathematics at an early age. But Boole
initially was more interested in classical literature, languages, and religion—interests
he maintained throughout his life. By the time he was 20, he had taught himself
French, German, and Italian. He was well versed in the writings of Aristotle, Spinoza,
Cicero, and Dante, and wrote several philosophical papers himself.

At 16, to help support his family, he took a position as a teaching assistant in a
private school. His work there and a second teaching job left him little time to study.
A few years later, he opened a school and began to learn higher mathematics on his
own. In spite of his lack of formal training, his first scholarly paper was published in

the Cambridge Mathematical Journal when he was just 24. Boole went on to publish over 50
papers and several major works before he died in 1864, at the peak of his career.

tcontinued



6.2 Conditions and Logical Expressions | 243

experience with programming. In Java these operators have another meaning with vari-
ables or constants of types byte, short, int, and long, which can lead to errors that
are hard to find.

Boole’s The Mathematical Analysis of Logic was published in 1847. It would eventually form the
basis for the development of digital computers. In the book, Boole set forth the formal axioms of
logic (much like the axioms of geometry) on which the field of symbolic logic is built.

Boole drew on the symbols and operations of algebra in creating his system of logic. He associated
the value 1 with the universal set (the set representing everything in the universe) and the value 0
with the empty set, and restricted his system to these two quantities. He then defined operations
that are analogous to subtraction, addition, and multiplication. Variables in the system have symbolic
values. For example, if a Boolean variable P represents the set of all plants, then the expression 1 2 P
refers to the set of all things that are not plants. We can simplify the expression by using 2P to
mean “not plants.” (0 2 P is simply 0 because we can’t remove elements from the empty set.) The
subtraction operator in Boole’s system corresponds to the ! (NOT) operator in Java. In a Java pro-
gram, we might set the value of the Boolean variable plant to true when the name of a plant is
entered, and !plant is true when the name of anything else is input.

The expression 0 + P is the same as P. However, 0 + P + F, where F is the set of all foods, is the set
of all things that are either plants or foods. So the addition operator in Boole’s algebra is the same as
the Java || (OR) operator.

The analogy can be carried to multiplication: 0 3 P is 0, and 1 3 P is P. But what is P 3 F? It is
the set of things that are both plants and foods. In Boole’s system, the multiplication operator is the
same as the && (AND) operator.

In 1854, Boole published An Investigation of the Laws of Thought, on Which Are Founded the
Mathematical Theories of Logic and Probabilities. In the book, he described theorems built on his
axioms of logic and extended the algebra to show how probabilities could be computed in a logical
system. Five years later, Boole published Treatise on Differential Equations, then Treatise on the Cal-
culus of Finite Differences. The latter is one of the cornerstones of numerical analysis, which deals
with the accuracy of computations. (In Chapter 13, we examine the important role numerical analysis
plays in computer programming.)

Boole received little recognition and few honors for his work. Given the importance of Boolean
algebra in modern technology, it is hard to believe that his system of logic was not taken seriously
until the early twentieth century. George Boole was truly one of the founders of computer science.

George Boole



244 | Chapter 6:  Conditions, Logical Expressions, and Selection Control Structures

Precedence of Operators

In Chapter 4, we discussed the rules of precedence, the rules that govern the evaluation
of complex arithmetic expressions. Java’s rules of precedence also govern relational and
logical operators. Here’s a list showing the order of precedence for the arithmetic, rela-
tional, and logical operators (with the assignment operator thrown in as well):

() Highest precedence
! unary  -  unary +  ++  -- (post)
++  --  (pre)
*   /   %
+   -
<   <=   >   >=
==   !=
&&
||
= Lowest precedence

Operators on the same line in the list have the same precedence. If an expression con-
tains several operators with the same precedence, most of the operators group (or asso-
ciate) from left to right. For example, the expression

a / b * c

means (a / b) * c, not a / (b * c). However, the ! operator groups from right to left.
Although you’d never have occasion to use this expression:

!!badData

the meaning of it is !(!badData) rather than the meaningless (!!)badData. Appen-
dix B, Operator Precedence, lists the order of precedence for all operators in Java. In
skimming the appendix, you can see that a few of the operators associate from right to
left (for the same reason we just described for the ! operator).

Parentheses are used to override the order of evaluation in an expression. If you’re
not sure whether parentheses are necessary, use them anyway. The compiler disregards
unnecessary parentheses. So if they clarify an expression, use them. Some programmers
like to include extra parentheses when assigning a relational expression to a boolean
variable:

dataInvalid = (inputVal == 0);

The parentheses are not needed; the assignment operator has the lowest precedence of
all the operators we’ve just listed. So we could write the statement as

dataInvalid = inputVal == 0;



6.2 Conditions and Logical Expressions | 245

but the parenthesized version is more readable.
One final comment about parentheses: Java, like other programming languages,

requires that parentheses always be used in pairs. Whenever you write a complicated
expression, take a minute to go through and pair up all of the opening parentheses with
their closing counterparts.

Software Engineering Tip
Changing English Statements into Logical Expressions

In most cases, you can write a logical expression directly from an English statement or mathe-
matical term in an algorithm. But you have to watch out for some tricky situations. Remember
our sample logical expression:

midtermGrade == 'A' || finalGrade == 'A'

In English, you would be tempted to write this expression: “Midterm grade or final grade
equals A.” In Java, you can’t write the expression as you would in English. That is,

midtermGrade || finalGrade == 'A'

won’t work because the || operator is connecting a char value (midtermGrade) and a logi-
cal expression (finalGrade == 'A'). The two operands of || must be logical expressions.
This example generates a syntax error message.

A variation of this mistake is to express the English assertion “i equals either 3 or 4” as

i == 3 || 4

But the syntax is incorrect. In the second subexpression, 4 is an int rather than a boolean
value. The || operator (and the && operator) can only connect two boolean expressions.
Here’s what we want:

i == 3 || i == 4

In math books, you might see a notation like this:

12 < y < 24

t

PEANUTS reprinted by permission of United Features Syndicate, Inc.

continued



246 | Chapter 6:  Conditions, Logical Expressions, and Selection Control Structures

Relational Operators with Floating-Point Types

So far, we’ve talked only about comparing int, char, and String values. Here we look
at float and double values.

Do not compare floating-point numbers for equality. Because small errors in the
rightmost decimal places are likely to arise when calculations are performed on float-
ing-point numbers, two float or double values rarely are exactly equal. For example,
consider the following code that uses two double variables named oneThird and x:

oneThird = 1.0 / 3.0;
x = oneThird + oneThird + oneThird;

We would expect x to contain the value 1.0, but it probably doesn’t. The first assign-
ment statement stores an approximation of 1/3 into oneThird, perhaps 0.333333. The
second statement stores a value like 0.999999 into x. If we now ask the computer to
compare x with 1.0, the comparison yields false.

Instead of testing floating-point numbers for equality, we test for near equality. To
do so, we compute the difference between the two numbers and test to see if the result

which means “y is between 12 and 24.” This expression is illegal in Java. First, the relation 12 < y is
evaluated, giving a boolean result. The computer then tries to compare it with the number 24.
Because a boolean value cannot be converted to any type other than String, the expression is
invalid. To write this expression correctly in Java, you must use the && operator as follows:

12 < y && y < 24

Changing English Statements into Logical Expressions

TE
AM
FL
Y

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

Team-Fly® 



6.3 The if Statement | 247

is less than some maximum allowable difference. For example, we often use compar-
isons like this:

Math.abs(r – s) < 0.00001

where Math.abs is the absolute value method from the Java library. The expression
Math.abs(r – s) computes the absolute value of the difference between two variables
r and s. If the difference is less than 0.00001, the two numbers are close enough to call
them equal. We discuss this problem with floating-point accuracy in more detail in
Chapter 13.

6.3 The if Statement
Now that we’ve seen how to write logical expressions, let’s use them to alter the normal
flow of control in a program. The if statement is the fundamental control structure that
allows branches in the flow of control. With it, we can ask a question and choose a
course of action: if a certain condition exists (the assertion is true), perform one action,
else perform a different action.

The computer performs just one of the two actions under any given set of circum-
stances. Yet we must write both actions into the program. Why? Because, depending on
the circumstances, the computer can choose to execute either of them. The if statement
gives us a way of including both actions in a program and gives the computer a way of
deciding which action to take.

The if-else Form

In Java, the if statement comes in two forms: the if-else form and the if form. Let’s look
first at the if-else. Here is its syntax template:

00141/Dale
Figure 5.169

if  
	 Statement1A
else
	 Statement1B

IfStatement (the if-else form)

( Expression )




248 | Chapter 6:  Conditions, Logical Expressions, and Selection Control Structures

Statement1A

Statement1B

if ( Expression )

false true

else

Statement2

Figure 6.3 if-else flow of control

The expression in parentheses must produce a boolean result. At run time, the
computer evaluates the expression. If the value is true, the computer executes State-
ment1A. If the value of the expression is false, Statement1B is executed. Statement1A
often is often called the then-clause; Statement1B, the else-clause. Figure 6.3 illustrates
the flow of control of the if-else. In the figure, Statement2 is the next statement in the
program after the entire if statement.

Notice that a Java if statement uses the reserved words if and else but the then-
clause does not include the word then. The code fragment below shows how to write an
if statement in a program. Observe the indentation of the then-clause and the else-
clause, which makes the statement easier to read. And notice the placement of the state-
ment following the if statement.

if (hours <= 40.0)
pay = rate * hours;

else
pay = rate * (40.0 + (hours – 40.0) * 1.5);

out.add(new Label("Pay is " + pay));

In terms of instructions to the computer, the above code fragment says, “If hours is less
than or equal to 40.0, compute the regular pay and then go on to execute the output
statement. But if hours is greater than 40, compute the regular pay and the overtime
pay, and then go on to execute the output statement.” Figure 6.4 shows the flow of con-
trol of this if statement.

If-else statements are often used to check the validity of input. For example, before
we ask the computer to divide by a data value, we should be sure that the value is not



6.3 The if Statement | 249

pay = rate*hours;

pay = rate*(40.0+(hours-40.0)*1.5

if ( hours <= 40.0 )

false true

else

out.add(new Label("Pay is " - pay));

Figure 6.4 Flow of control for calculating pay

zero. (Even computers can’t divide something by zero. If you try it with int values, the
computer halts the execution of your program. With floating-point types, you get the
special infinity value.) If the divisor is zero, our program should thus display an error
message. Here’s an example that adds an error message label to a frame called out.

Label errorMsg;
errorMsg = new Label("Division by zero is not allowed. " +

" Enter a new value for divisor and press Done button." );
if (divisor != 0)
result = dividend / divisor;

else
out.add(errorMsg);

If this code fragment is within the handler for a button controlling screen input, the
program waits until another event occurs, either the pressing of the button or the clos-
ing of the input window.

Before we look any further at if statements, take another look at the syntax tem-
plate for the if-else. According to the template, there is no semicolon at the end of an if
statement. In both of the program fragments above—the worker’s pay and the division-
by-zero examples—there seems to be a semicolon at the end of each if statement. How-
ever, the semicolons belong to the statements in the then-clause and the else-clause in
those examples; assignment statements end in semicolons, as do method calls. The if
statement doesn’t have its own semicolon at the end.



250 | Chapter 6:  Conditions, Logical Expressions, and Selection Control Structures

Blocks (Compound Statements)

In our division-by-zero example, suppose that when the divisor is equal to zero we want
to do two things: add the error message to the frame and set the variable named result
equal to a special value like Integer.MAX_VALUE. We would need two statements in
the same branch, but the syntax template seems to limit us to one.

What we really want to do is turn the else-clause into a sequence of statements.
This is easy. Remember from Chapter 2 that the compiler treats the block (compound
statement)

{
.
.
.

}

like a single statement. If you put a { } pair around the sequence of statements you
want in a branch of the if statement, the sequence of statements becomes a single block.
For example:

if (divisor != 0)
result = dividend / divisor;

else
{
out.add(errorMsg);
result = Integer.MAX_VALUE;

}

If the value of divisor is zero, the computer both prints the error message and sets the
value of result to Integer.MAX_VALUE before continuing with whatever statement
follows the if statement.

Blocks can be used in both branches of an if-else statement. For example:

private static Label errorMsg;
private static Label oKMsg;
errorMsg = new Label("Division by zero is not allowed.");
oKMsg = new Label("Division performed.");
if (divisor != 0)
{



6.3 The if Statement | 251

Matters of Style
Braces and Blocks

Java programmers use different styles when it comes to locating the left brace of a block. The
style we use puts the left and right braces directly below the words if and else, each brace
on its own line:

if (n >= 2)
{
alpha = 5;
beta = 8;

}
else
{
alpha = 23;
beta = 12;

}

Another popular style is to place the statements following if and else on the same line as
the left brace; the right braces still line up directly below the left braces.

if (n >= 2)
{ alpha = 5;
beta = 8;

}
else
{ alpha = 23;
beta = 12;

}

It makes no difference to the Java compiler which style you use (and there are other styles
as well, such as placing the left braces at the ends of the lines containing if and else.). It’s a
matter of personal preference. Whichever style you use, though, you should always use the
same style throughout a program. Inconsistency can confuse a person reading your program
and give the impression of carelessness.



252 | Chapter 6:  Conditions, Logical Expressions, and Selection Control Structures

result = dividend / divisor;
out.add(oKMsg);

}
else
{
out.add(errorMsg);
result = Integer.MAX_VALUE;

}

When you use blocks in an if statement, there’s a rule of Java syntax to remember:
Never use a semicolon after the right brace of a block. Semicolons are used only to ter-
minate simple statements such as assignment statements and method calls. If you look
at the examples above, you won’t see a semicolon after the right brace that signals the
end of each block.

The if Form

Sometimes you run into a situation where you want to say, “If a certain condition
exists, perform some action; otherwise, don’t do anything.” In other words, you want
the computer to skip a sequence of instructions if a certain condition isn’t met. You
could do this by leaving the else branch empty, using only the null statement:

if (a <= b)
c = 20;

else
;

Better yet, you could simply leave off the else part. The resulting statement is the if
form of the if statement. This is its syntax template:

Here’s an example of an if form. Notice the indentation and the placement of the
statement that follows the if.

if (age < 18)
out.add(new Label("Not an eligible "));

out.add(new Label("voter."));

00141/Dale
Figure 5.172

if	 ( Expression )
	    Statement

IfStatement (the if form)



6.3 The if Statement | 253

Statement1

if ( Expression )

false true

Statement2

Figure 6.5 if flow of control

This statement means that if age is less than 18, first add the label "Not an eligible "
to Frame out and then add the label "voter.". If age is not less than 18, skip the first
statement and go directly to adding the label "voter.". Figure 6.5 shows the flow of
control for an if form.

Like the two branches in an if-else form, the one branch in an if can be a block. For
example, let’s say you are writing a program to compute income taxes. One of the lines
on the tax form says, “Subtract line 23 from line 17 and enter result on line 24; if result
is less than zero, enter zero and check box 24A.” You can use an if statement to do this
in Java:

Label checkMsg;
checkMsg = new Label("Check box 24A");
result = line17 – line23;
if (result < 0.0)
{
out.add(checkMsg);
result = 0.0;

}
line24 = result;

This code does exactly what the tax form says it should. It computes the result of sub-
tracting line 23 from line 17. Then it looks to see if result is less than zero. If it is, the
fragment displays a message telling the user to check box 24A and then sets result to
zero. Finally, the calculated result (or zero, if the result is less than zero) is stored into a
variable named line24.

What happens if you leave out the left and right braces in the code fragment
above? Let’s look at it:



254 | Chapter 6:  Conditions, Logical Expressions, and Selection Control Structures

Label checkMsg;                       // Incorrect version
checkMsg = new Label("Check box 24A");
result = line17 – line23;
if (result < 0.0)
out.add(checkMsg);
result = 0.0;

line24 = result;

Despite the way the code is indented, the compiler takes the first clause to be a single
statement—the output statement. If result is less than zero, the computer executes the
output statement, then sets result to zero, and then stores result into line24. So
far, so good. But if result is initially greater than or equal to zero, the computer skips
the first clause and proceeds to the statement following the if statement—the assignment
statement that sets result to zero. The unhappy outcome is that result ends up as
zero no matter what its initial value was! The moral here is not to rely on indentation
alone; you can’t fool the compiler. If you want a compound statement for either clause,
you must include the left and right braces.

6.4 Nested if Statements
There are no restrictions on what the statements in an if form can be. Therefore, an if
within an if is okay. In fact, an if within an if within an if is legal. The only limitation
here is that people cannot follow a structure that is too involved. And readability is one
of the marks of a good program.

When we place an if within an if, we are creating a nested control structure. Control
structures nest much like mixing bowls do, with smaller ones tucked inside larger ones.
Here’s an example, written in pseudocode:

if today is Saturday or Sunday

if it is raining

Outer If

Inner (nested) If
Sleep Late

else
Get up and go outside

else
Go to work



6.4 Nested if Statements | 255

In general, any problem that involves a multiway branch (more than two alternative
courses of action) can be coded using nested if statements. For example, to store the
name of a month into a string variable, given its number, we could use a sequence of if
statements (unnested):

if (month == 1)
monthName = "January";

if (month == 2)
monthName = "February";

if (month == 3)
monthName = "March";
:

if (month == 12)
monthName = "December";

But the equivalent nested if structure,

if (month == 1)
monthName = "January";

else
if (month == 2)              // Nested if
monthName = "February";

else
if (month == 3)                // Nested if
monthName = "March";

else
if (month == 4)                 // Nested if

:

is more efficient because it makes fewer comparisons. The first version—the sequence of
independent if statements—always tests every condition (all 12 of them), even if the first
one is satisfied. In contrast, the nested if solution skips all remaining comparisons after
one alternative has been selected. As fast as modern computers are, many applications
require so much computation that an inefficient algorithm can waste hours of computer
time. Always be on the lookout for ways to make your programs more efficient, as long
as doing so doesn’t make them difficult for other programmers to understand. It’s usu-
ally better to sacrifice a little efficiency for the sake of readability.

In the last example, notice how the indentation of the then- and else-clauses causes
the statements to move continually to the right. Instead, we can use a special indenta-
tion style with deeply nested if-else statements to indicate that the complex structure is
just choosing one of a set of alternatives. This general multiway branch is known as an
if-else-if control structure:



256 | Chapter 6:  Conditions, Logical Expressions, and Selection Control Structures

if (month == 1)
monthName = "January";

else if (month == 2)        // Nested if
monthName = "February";

else if (month == 3)         // Nested if
monthName = "March";

else if (month == 4)          // Nested if
:

else
monthName = "December";

This style prevents the indentation from marching continuously to the right. But, more
importantly, it visually conveys the idea that we are using a 12-way branch based on
the variable month.

It’s important to note one difference between the sequence of if statements and the
nested if: More than one alternative can be taken by the sequence of ifs, but the nested
if can select only one. To see why this is important, consider the analogy of filling out a
questionnaire. Some questions are like a sequence of if statements, asking you to check
all the items in a list that apply to you (such as all your hobbies). Other questions ask
you to check only one item in a list (your age group, for example) and are thus like a
nested if structure. Both kinds of questions occur in programming problems. Being able
to recognize which type of question is being asked permits you to immediately select
the appropriate control structure.

Another particularly helpful use of the nested if is when you want to select from a
series of consecutive ranges of values. For example, suppose that you want to display a
message indicating an appropriate activity for the outdoor temperature, given the fol-
lowing table.

Activity Temperature

Swimming Temperature > 85
Tennis 70 < temperature # 85
Golf 32 < temperature # 70
Skiing 0 < temperature # 32
Dancing Temperature # 0

At first glance, you may be tempted to write a separate if statement for each range of
temperatures. On closer examination, however, it is clear that these conditions are inter-
dependent. That is, if one of the statements is executed, none of the others should be
executed. We really are selecting one alternative from a set of possibilities—just the sort
of situation in which we can use a nested if structure as a multiway branch. The only
difference between this problem and our earlier example of printing the month name
from its number is that we must check ranges of numbers in the if expressions of the
branches.

When the ranges are consecutive, we can take advantage of that fact to make our
code more efficient. We arrange the branches in consecutive order by range. Then, if a

TE
AM
FL
Y

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

Team-Fly® 



6.4 Nested if Statements | 257

particular branch has been reached, we know that the preceding ranges have been elim-
inated from consideration. Thus, the if expressions must compare the temperature to
only the lowest value of each range.

message = "The recommended activity is ";
if (temperature > 85)
message = message + "swimming.";

else if (temperature > 70)
message = message + "tennis.";

else if (temperature > 32)
message = message + "golf.";

else if (temperature > 0)
message = message + "skiing.";

else
message = message + "dancing.";

out.add(new Label(message));

To see how this if-else-if structure works, consider the branch that tests for tem-
perature greater than 70. If it has been reached, you know that temperature must
be less than or equal to 85 because that condition causes this particular else branch to
be taken. Thus, you need to test only whether temperature is above the bottom of
this range (> 70). If that test fails, then you enter the next else-clause knowing that
temperature must be less than or equal to 70. Each successive branch checks the bot-
tom of its range until you reach the final else, which takes care of all the remaining
possibilities.

Note that if the ranges aren’t consecutive, then you must test the data value against
both the highest and lowest value of each range. You still use an if-else-if structure
because that is best for selecting a single branch from multiple possibilities, and you
can arrange the ranges in consecutive order to make them easier for a human reader to
follow. But there is no way to reduce the number of comparisons when there are gaps
between the ranges.

The Dangling else 

When if statements are nested, you may find yourself confused about the if-else pair-
ings. That is, to which if does an else belong? For example, suppose that if a student’s
average is below 60, you want to display “Failing”; if it is at least 60 but less than 70,
you want to display “Passing but marginal”; and if it is 70 or greater, you don’t want to
display anything.

You can code this information with an if-else structure nested within an if:

Label failing;
Label passing;
failing = new Label("Failing");
passing = new Label("Passing but marginal");
if (average < 70.0)



258 | Chapter 6:  Conditions, Logical Expressions, and Selection Control Structures

if (average < 60.0)
out.add(failing);

else
out.add(passing);

How do you know to which if the else belongs? Here is the rule that the Java com-
piler follows: In the absence of braces, an else is always paired with the closest preced-
ing if that doesn’t already have an else paired with it. The code is indented to reflect this
pairing.

Suppose you write the fragment like this (assuming the declarations of the labels
are the same):

if (average >= 60.0)         // Incorrect version
if (average < 70.0)
out.add(passing);

else
out.add(failing);

Here you want the else branch attached to the outer if statement, not the inner, so the
code is indented as you see it. But indentation does not affect the execution of the code.
Even though the else aligns with the first if, the compiler pairs it with the second if. An
else that follows a nested if is called a dangling else. It doesn’t logically belong with the
nested if but is attached to it by the compiler.

To attach the else to the first if, not the second, you can turn the outer then-clause
into a block:

if (average >= 60.0)          // Correct version
{
if (average < 70.0)
out.add(passing);

}
else
out.add(failing);

The { } pair indicates that the first if statement has a compound first clause that con-
tains an if statement (with no else clause), so the else must belong to the outer if.

6.5 Handling Multiple Button Events



6.5 Handling Multiple Button Events | 259

When we first discussed the handling of button events in a frame, we restricted our user
interface to a single button. The reason for our restriction was that all button events for
a frame can be sent to the same listener method (actionPerformed) and we had not
yet seen the if statement, which is what we use to distinguish among events from multi-
ple buttons. Now we have the ability to respond to each event differently. In this section
we consider the handling of events from multiple buttons, which also nicely illustrates
the use of branching.

Immediately after we instantiate a button with new, we call setActionCommand
with a String parameter that identifies the button. (This is not the string that appears
on the button, though they may be the same string.) If we do not call setActionCom-
mand, the listener assumes that the name of the button is the same as the string used
when instantiating the Button object. We then call addActionListener to tell the
event, “Here’s a button listener to be called when this button fires.” 

For example, suppose we provide a user interface with two buttons, Copy and Done,
as follows: We create one ButtonHandler listener object, and we register it with both
buttons as follows.

buttonAction = new ButtonHandler();   
// Instantiate a ButtonHandler object, and assign it to the variable 
//  buttonAction
copy = new Button("Copy");            
// Instantiate a Button object that is displayed with the word "Copy"
//  assign it to the variable copy
copy.setActionCommand("copy");        
// Give button a string to identify it
copy.addActionListener(buttonAction); 
// Register button listener using the ButtonHandler assigned to 
//  buttonAction
done = new Button("Done");            
// Instantiate a second Button thatdisplays the word "Done" inside it
//  and assign it to the variable done
done.setActionCommand("done");        
// Give button a string to identify it
done.addActionListener(buttonAction); 
// Register button listener using the ButtonHandler stored in buttonAction

Figure 6.6 Frame with two buttons



260 | Chapter 6:  Conditions, Logical Expressions, and Selection Control Structures

private static class ButtonHandler implements ActionListener
{
public void actionPerformed(ActionEvent buttonEvent) // Event handler method
{
String command;                                    // String to hold button name
command = buttonEvent.getActionCommand();         // Get the button’s name
if (command.equals("copy")) // When the name is "copy"
outputLabel.setText(inputField.getText());       //  copy the field

else if (command.equals("done"))                   // When the name is "done"
{
dataFrame.dispose();                             // close the frame and
System.exit(0);                                  // quit the program

}
else                                               // Otherwise, it’s an error
outputLabel.setText("An unexpected event occurred.");

}
}

Figure 6.6 shows a frame with these buttons in it.
When either one of these buttons is pressed, actionPerformed is called by its

source event, just as we saw in Chapter 5. How does actionPerformed decide which

button was pressed? Recall that when we write the heading for the actionPerformed
method, we include a parameter of type ActionEvent. The source event passes an
object to the method through that parameter. That object has a field containing the
name of the button, which is either the default string from the constructor or the string
in the call to setActionCommand. We access the name string by calling the value
returning method getActionCommand that is associated with the parameter object.

For example, if the heading for actionPerformed is written this way:

public void actionPerformed(ActionEvent buttonEvent)

Then we obtain the string that names the pressed button using the following statement.

command = buttonEvent.getActionCommand();

Within our declaration of the method, we use string comparisons and branches to
perform the necessary action for the particular button. For example, we might extend
the event handler in our CopyString class from Chapter 5 as follows.

When the event source calls actionPerformed, the method gets the button’s name
using getActionCommand. If setActionCommand has been called to name the button,
its parameter string is returned. If not, the parameter string used in the button’s instan-
tiation is returned. Why do we bother to explicitly name the button? There may be
times when a different internal name is more meaningful than the string used to label
the button in the window. For example, if you are writing an application to be used in



6.5 Handling Multiple Button Events | 261

France, you might want the button to have a meaningful English name, but the label
would be in French.

The eventhandler then uses an if-else-if structure to decide which button was
pressed and execute the appropriate statements. Although getActionCommand should
never return a name other than "copy" or "done", you can provide a branch for other
names just to be safe. Some time in the future the program could be changed to add
another button. If you forget to add a corresponding branch to handle that event, the
program displays an error message instead of crashing.

There is another way that you can handle multiple button events. For each button
you can declare a separate listener class. For example, instead of one class called But-
tonHandler, you could declare two classes called CopyHandler and DoneHandler,
each of which has its own actionPerformed method. You would then write

copyAction = new CopyHandler();     // Instantiate copyAction
copy = new Button("Copy");          // Instantiate copy, labeled "Copy"
copy.setActionCommand("copy");      // Give copy button a string to 

//  identify it
copy.addActionListener(copyAction); // Register the button listener using

//  the CopyHandler assigned to 
//  copyAction

done = new Button("Done");          // Instantiate done, labeled "Done"
doneAction = new DoneHandler();     // Instantiate the handler
done.setActionCommand("done");      // Name the button
done.addActionListener(doneAction); // Register the button listener using 

//  the DoneHandler assigned to 
//  doneAction

This code registers a different event listener for each button. The source event calls the
actionPerformed method within the appropriate listener. With this approach you
avoid writing a branch to decide which button has been pressed, but you must declare a
new class for each button. Look back at Figure 6.6. The buttons generated from this
code fragment are identical to those in Figure 6.6; how the buttons are handled when
they are pressed, however, is different.

When a user interface contains buttons that perform simple or related tasks, it
makes sense to combine the handling of their events into a single method. If pressing a
button causes complex processing that is unrelated to other buttons, then it is more sen-
sible to use a separate event handler. For example, when a button press results in a
branch to a different part of the program where the user interface is replaced by a new
set of fields and buttons, then the code belongs in a separate event listener.

The following code segment shows the declaration of the CopyHandler and Done-
Handler classes, along with the subsequent declaration of variables of those types. The
same names are used as in the preceding code segment.

private static class CopyHandler implements ActionListener
{
public void actionPerformed(ActionEvent event)  
// Copy event handler method



262 | Chapter 6:  Conditions, Logical Expressions, and Selection Control Structures

{
outputLabel.setText(inputField.getText());   // Copy the field

}
}

private static class DoneHandler implements ActionListener
{
public void actionPerformed(ActionEvent event)  
// Done event handler method
{
dataFrame.dispose();                         // Close the frame
System.exit(0);                              // Quit the program

}
}

CopyHandler copyAction;  // CopyHandler variable
DoneHandler doneAction;                          // DoneHandler variable

Problem-Solving Case Study
A Simple Calculator

Problem It’s useful to have a calculator that you can display on your computer screen when
you look around and can’t find your handheld one. Let’s write a Java application that simulates
a simple calculator. Once we have the basic design it is easy to extend it to provide other
functions.

Brainstorming You pick up your pocket calculator. After all, this problem is one of simulating
the pocket calculator. What are the objects that you see? A register on the top that shows
what you are entering and displays the answer, an ON button, buttons for each of the ten
decimal digits, buttons for each of the four basic operations, a CLEAR button, and a button
marked with an equal sign. There are buttons for percent and square root, but you do not use
them often enough to add them to the simulation. So the first list of proposed classes is as
follows:



Problem-Solving Case Study | 263

Filtering We certainly need a register to show the output. Do we need an ON button? No,
running the program is equivalent to the ON button. However, we do need some way of
quitting the program. We could have a quit button or we could let the window closing end the
program. We need an object to represent the calculator itself; that is, we need a window to
hold all the other objects. What about the buttons for each digit? No, we can let the user
input a number into a text field rather than pushing individual buttons. This means that we
need a label for the text field. Do we need an enter button? No, we can let the button for the
operation signal that the value is ready to be read. We do need buttons for each operation. We
certainly need a CLEAR button to set the register value to zero. What about the equal button?
On the calculator it signals that we want to see the results so far in the register. Instead of
entering an equal button, let’s just display the result of each operation in the register as we go
along.

We know from our experience with the Case Study in Chapter 5 that we need a class that
contains main to organize the window and a class that implements ActionListener. This
class becomes the application. Let’s call it Calculator. Here, then, is our second pass at the
classes for our application:

Scenarios The register is simply a label that displays what is put into it, so it actually has no
further responsibility. The window object is a container into which labels, text fields, and
buttons are placed, so it collaborates with each of these. The text field for the input has no

a register
window
text field for number input
label for input text field
four buttons for the operations
clear button

register
on button
buttons for each digit
buttons for four operations
clear button
equal button



264 | Chapter 6:  Conditions, Logical Expressions, and Selection Control Structures

responsibilities; it just collaborates with the appropriate button handler. The label for the text
field has only one responsitility: to display the input prompt. What happens when the
operation buttons are pressed? The four operator buttons are event sources; they have no
responsibility, but their handlers do. When one is pressed, the JVM calles the appropriate
button handler, which collaborates with the text field to input a value, performs a calculation,
and sends the value to the register. The clear button is different in function from the others
but its only responsibility is to be an event source. However, its event handler must collaborate
with the register to set it to zero. It makes sense to use one button handler for the four
arithmetic buttons, but a separate one for the CLEAR button.

The application has responsibility for setting up the window, handling the button events
through the inclusions of the two listener classes, and handling the window-closing event.

CRC cards All of the objects are instances of classes provided in the Java window and event-
handling packages. So the only CRC card is for class Calculator.

Responsibility Algorithms Do you remember in Chapter 1, after the long first program, that
we said that much of the code dealt with input and output, which would soon become second
nature to you? Well the first responsibility should sound comfortingly familiar. It is exactly the
same as the first responsibility for Chapter 5’s Case Study. Does this mean that we can just cut
and paste the algorithms? No, the objects in the window are not the same, but the steps used
to create them are the same, so we can reuse the top-level module.

Prepare Window for Input Level 1

Declaring the interface variables requires us to make a list of the components in the window.
We need a frame to hold everything, two labels (one for input and one for the register), a field
for entering a data value, four buttons for the user to click to indicate the operation when a
value is ready for input, and a button for the user to click to clear the register.

Declare the interface variables
Instantiate each interface object
Add each interface object to the frame
Pack the frame
Show the frame

Class Name: Calculator Superclass: Subclasses:

Responsibilities

Prepare the window for input
Handle numeric button events
Handle clear button event
Handle window closing

TextField, Label, String, Buttons
Buttons, register (text field)
Buttons, register (text field)
Frame

Collaborations



Problem-Solving Case Study | 265

Before we go on, let’s simplify the problem somewhat. Let’s first create a calculator with
only plus and minus functions. After we verify this simplified version of the program, we can
come back and add division and multiplication. (See Case Study Follow-Up Question 1.)

Declare Interface Variables Level 2

Instantiate Each Interface Object

We have added two more
abstract steps, which we can now expand. Registering an event listener for a button involves
four steps that: declare a variable of the listener class, set the action command for the button,
instantiate the listener class, and then add the listener object to the button. Let’s call the lis-
tener for the numeric operations NumericHandler. These four steps are all concrete as
shown in the following module.

Register the Event Listener for the Numeric Buttons Level 3

Let’s call the listener for the clear operation ClearHandler.

Register the Event Listener for the Clear Button

Declare a NumericHandler, operation
setActionCommand for button add to “add”
setActionCommand for button subtract to “subtract”
Instantiate operation
Add operation as listener for numeric button

Set calcFrame to new Frame, as a four-row, two-column grid
Set resultLabel to new Label, “Result:”
Set register to new Label, “0.0”
Set entryLabel to new Label, "Enter #:"
Set inputField to new TextField, empty with 10 spaces
Set add to new Button, “+”
Set subtract to new Button, “-”
Set clear to new Button, “Clear”
Register the event listener for the numeric buttons
Register the event listener for the clear button

Declare a Frame, calcFrame
Declare a Label, resultLabel
Declare a Label, register
Declare a Label, entryLabel for prompting
Declare a TextField, inputField for input
Declare a Button, add
Declare a Button, subtract
Declare a Button, clear



266 | Chapter 6:  Conditions, Logical Expressions, and Selection Control Structures

Add Each Interface Object to the Frame Level 2

We have now completed the first responsibility for class Calculator. The second responsibil-
ity is to handle the numeric buttons; that is, write the listener for the numeric buttons. We
have said that the listener class is called NumericHandler. What should the action-
Performed method do when an add or subtract button is pushed? First, it should get the
value to be used in the calculation from the input field and convert it to a real number. If the
user enters a string that does not represent a legitimate real number, a NumberFormatEx-
ception may be thrown. In Chapter 10 we show you how to handle this exception; here we
assume correct input.

The next step is to determine which operation is to be applied to the number, addition or
subtraction. Wait a minute: Addition and subtraction are binary operations. We have one
value; where is the other one? Actually, the value just input is the second operand. The first
operand is the value in the register. Rather than extract it from the window each time, we
should keep a copy in numeric form. (We must be sure to set that value to zero originally.)
Back to the question of determining which button was pushed: We can use the parameter to
the actionPerformed method to tell us.

Handle Numeric Button Events Level 1

Add resultLabel to calcFrame
Add register to calcFrame
Add entryLabel to calcFrame
Add inputField to calcFrame
Add add to calcFrame
Add subtract to calcFrame
Add clear to calcFrame

Declare a ClearHandler, clearOperation
setActionCommand for button clear to “Clear”
Instantiate clearOperation
Add clearOperation as listener for clear button

TE
AM
FL
Y

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

Team-Fly® 



Problem-Solving Case Study | 267

The third responsibility is even simpler; all we have to do is set the register and input field to
zero as well as the variable that contains the same value. These actions are performed in the
actionPerformed method of class ClearHandler.

Handle Clear Button Event Level 1

Set result to zero
Display result in register
Clear inputField

Get the entry string from the input field
Set secondOperand to numerical value (double) of entry string
Set whichButton to source event
if whichButton is “add”

Set result to result + secondOperand
else

Set result to result 2 secondOperand
Display result in register
Clear inputField

Objects and Variables

Name Type Description

In main:
calcFrame* Frame Frame to display on screen
resultLabel Label Indicates output area
register* Label Label to show output
entryLabel Label Label indicating input field
inputField* TextField Field for user input
add Button Add button
subtract Button Subtract button
clear Button Clear button
result* double Keeps current value
operation NumericHandler Listener for numeric buttons
clearOperation ClearHandler Listener for clear button

In NumericHandler.actionPerformed:
secondOperand double Holds input value
whichButton String Holds button’s name



268 | Chapter 6:  Conditions, Logical Expressions, and Selection Control Structures

The fourth responsibility is one that you should see in all of your applications that use win-
dows: Handle window closing.

Handle Window Closing Level 1

The coding of the program into Java is now easy—tedious but straightforward. Here is the
result.

import java.awt.*;                               // User interface classes
import java.awt.event.*;                        // Event handling classes

public class Calculator
{
// Define action listener for numeric buttons
private static  class NumericHandler implements ActionListener
{
public void actionPerformed(ActionEvent event)
// Handles events from the numeric buttons in calcFrame
{
double secondOperand;                      // Holds input value
String whichButton;                        // Holds the button's name
// Get the operand
secondOperand = Double.valueOf(inputField.getText()).doubleValue();
whichButton = event.getActionCommand();  // Get the button's name

if (whichButton.equals("add"))             // When the name is "add"
result = result + secondOperand;         //  add the operand

else                                       // Otherwise
result = result – secondOperand;          //  subtract the operand

register.setText("" + result);             // Display result
inputField.setText("");                    // Clear input

}
}

private static class ClearHandler implements ActionListener
{
public void actionPerformed(ActionEvent event)
// Handles events from the Clear button in calcFrame
{
result = 0.0; // Set result back to zero

Dispose of the frame
Exit the program



Problem-Solving Case Study | 269

register.setText("0.0");                   // Reset register
inputField.setText("");                  // Clear input

}
}

private static TextField inputField;         // Data field
private static Label register;                 // Result shown on screen
private static Frame calcFrame;                // Declare a frame
private static double result;                  // Keeps current value

public static void main(String[] args)
{
// Declare numeric listener
NumericHandler operation;                    
ClearHandler clearOperation;                 // Declare clear listener
Label resultLabel;                           // Indicates output area
Label entryLabel;                         // Label for input field
Button add;                                  // Add button
Button subtract;                             // Subtract button
Button clear;                           // Clear button

operation = new NumericHandler();            // Instantiate operation
// Instantiate clearOperation
clearOperation = new ClearHandler();         
result = 0.0;                                // Initialize result

// Instantiate labels and initialize input field
calcFrame = new Frame();                    // Give the frame a value
calcFrame.setLayout(new GridLayout(4,2));    // Set the layout manager
resultLabel = new Label("Result:");
register = new Label("0.0", Label.RIGHT);
entryLabel = new Label("Enter #:");
inputField = new TextField("", 10);

// Instantiate button objects
add = new Button("+");
subtract = new Button("-");
clear = new Button("Clear");

// Name the button events
add.setActionCommand("add");
subtract.setActionCommand("subtract");
clear.setActionCommand("clear");



270 | Chapter 6:  Conditions, Logical Expressions, and Selection Control Structures

// Register the button listeners
add.addActionListener(operation);
subtract.addActionListener(operation);
clear.addActionListener(clearOperation);

// Add interface elements to calcFrame
calcFrame.add(resultLabel);
calcFrame.add(register);
calcFrame.add(entryLabel);
calcFrame.add(inputField);
calcFrame.add(add);
calcFrame.add(subtract);
calcFrame.add(clear);
calcFrame.pack();                                  // Pack the frame
calcFrame.show();                                  // Show the frame
calcFrame.addWindowListener(new WindowAdapter()      
// Define window-closing event handler
{                                                 
public void windowClosing(WindowEvent event)
{
calcFrame.dispose();                         // Close the frame
System.exit(0);                              // Quit the program

}
});

}
}

When we run the program, it displays a window like the one shown below.

Desk checking Tracing an execution of a design or
program on paper



Testing and Debugging | 271

Testing and Debugging

In Chapter 1, we discussed the problem-solv-
ing and implementation phases of computer
programming. Testing is an integral part of
both phases. Testing in the problem-solving phase is done after the solution is devel-
oped but before it is implemented. In the implementation phase, we test after the algo-

Walk-through A verification method in which a
team performs a manual simulation of the program or
design

Inspection A verification method in which one mem-
ber of a team reads the program or design line by line
and the others point out errors

Execution trace The process of going through the
program with actual values recording the state of the
variables



272 | Chapter 6:  Conditions, Logical Expressions, and Selection Control Structures

rithm is translated into a program, and again after the program has compiled success-
fully. The compilation itself constitutes another stage of testing that is performed auto-
matically.

Testing Strategies

When an individual programmer is designing and implementing a program, he or she
can find many software errors with pencil and paper. Desk checking the design solution
is a very common method of manually verifying a design or program. The programmer
writes down essential data (variables, input values, parameters of subprograms, and so
on) and walks through the design, manually simulating the actions of the computer and
recording changes in the data on the paper. Portions of the design or code that are com-
plex or that are a source of concern should be double-checked.

Deskchecking can be done by an individual, but most sizable computer programs
are developed by teams of programmers. Two extensions of desk checking that are used
effectively by programming teams are design or code walk-throughs and inspections.
These are formal team activities, the intention of which is to move the responsibility for
uncovering bugs from the individual programmer to the group. Because testing is time-
consuming and errors cost more the later they are discovered, the goal is to identify
errors before testing begins.

In a walk-through the team performs a manual simulation of the design or program
with sample test inputs, keeping track of the program’s data by hand. Unlike thorough
program testing, the walk-through is not intended to simulate all possible test cases.
Instead, its purpose is to stimulate discussion about the way the programmer chose to
design or implement the program’s requirements.

At an inspection, a reader (not necessarily the program’s author) goes through the
design or code line by line. Inspection participants point out errors, which are recorded
on an inspection report. Some errors are uncovered just by the process of reading aloud.
Others may have been noted by team members during their preinspection preparation.
As with the walk-through, the chief benefit of the team meeting is the discussion that
takes place among team members. This interaction among programmers, testers, and
other team members can uncover many program errors long before the testing stage
begins.

At the high-level design stage, the design should be compared to the application
requirements to make sure that all required responsibilities have been included and that
this application or class correctly interfaces with other software in the system. At the
low-level design stage, when the design has been filled out with more details, it should
be reinspected before it is implemented.

After the code is written, you should go over it line by line to be sure that you’ve
faithfully reproduced the algorithm—a process known as a code walk-through. In a team
programming situation, you ask other team members to walk through the algorithm and
code with you, to double-check the design and code.



Testing and Debugging | 273

You also should take some actual values and hand-calculate what the output should
be by doing an execution trace (or hand trace). When the program is executed, you can
use these same values as input and then check the results. The computer is a very literal
device—it does exactly what we tell it to do, which may or may not be what we want it
to do. We try to make sure that a program does what we want by tracing the execution
of the statements.

When a program contains branches, it’s a good idea to retrace its execution with
different input data so that each branch is traced at least once. In the next section, we
describe how to develop data sets that test each of a program’s branches.

To test an application with methods, we need to execute each method. If a method
contains branches, we need to execute each branch at least once and verify the results.
For example, there are two actionPerformed methods, one of which contains an if
statement. Therefore, we need at least three data sets to test the methods and the differ-
ent branches. For example, the following combination of buttons and input values
cause all of the methods and branches to be executed:

Button Value

Set 1 + 12.5
Set 2 - 2.5
Set 3 Clear

Every branch in the program is executed at least once through this series of test
runs. Eliminating any of the test data sets would leave at least one branch untested. This
series of data sets provides what is called minimum complete coverage of the program’s
branching structure. Whenever you test a program with branches in it, you should
design a series of tests that covers all of the branches. Because an action in one branch
of a program often affects processing in a
later branch, it is critical to test as many com-
binations of branches, or paths, through a
program as possible. By doing so, you can be
sure that there are no interdependencies that
could cause problems. Should you try all pos-
sible paths? Yes, in theory you should. How-
ever, the number of paths in even a small
program can be very large.

The approach to testing that we’ve used here is called code coverage because the test
data is designed by looking at the code of the program. Code coverage is also called
white-box (or clear-box) testing because you are allowed to see the program code while
designing the tests. Another approach to testing, data coverage, attempts to test as many
allowable data values as possible without regard to the program code. Because you need
not see the code in this form of testing, it is also called black-box testing—the same set
of tests would be used even if the code were hidden in a black box. Complete data cov-
erage is as impractical as complete code coverage for many programs. For example, the

Test plan A document that specifies how a program
is to be tested

Test plan implementation Using the test cases speci-
fied in a test plan to verify that a program outputs the
predicted results



274 | Chapter 6:  Conditions, Logical Expressions, and Selection Control Structures

Figure 6.7 When you test a program without a plan, you never know what you might be missing

NumericHandler.actionPerformed method reads one double value and thus has an
immense number of possible input values.

Often, testing is a combination of these two strategies. Instead of trying every pos-
sible data value (data coverage), the idea is to examine the code (code coverage) and
look for ranges of values for which processing is identical. Then test the values at the
boundaries and, sometimes, a value in the middle of each range. For example, a simple
condition such as

alpha < 0

divides the integers into two ranges:

Test Plan for the Calculator Application

Reason for Test Case Input Values Expected Output Observed Output

Test add command 12.5, + 12.500
Test subtract command 2.5, - 10.000
Test clear command none, Clear 0.000
Test window closing none window disappears



Testing and Debugging | 275

Problem solving Algorithm Algorithm 
walk-through

Semantic

Phase Result Testing Technique Type of Error

Implementation Coded program Code walk-through, 
Trace

Syntax
Semantic

Compilation Object program Compiler-generated
error messages

Syntax

Execution Output Implement
test plan

Typographical semantic
Algorithm semantic

Figure 6.8 Testing process

1. Integer.MIN_VALUE through –1
2. 0 through Integer.MAX_VALUE

Thus, you should test the four values Integer.MIN_VALUE, 21, 0, and
Integer.MAX_VALUE. A compound condition such as

alpha >= 0 && alpha <= 100

divides the integers into three ranges:

1. Integer.MIN_VALUE through –1
2. 0 through 100
3. 101 through Integer.MAX_VALUE

Thus, you have six values to test. In addition, to verify that the relational operators are
correct, you should test for values of 1 (> 0) and 99 (< 100).

Conditional branches are only one factor in developing a testing strategy. We con-
sider more of these factors in later chapters.

The Test Plan

We’ve discussed strategies and techniques for testing programs, but how do you
approach the testing of a specific program? You do it by designing and implementing a



276 | Chapter 6:  Conditions, Logical Expressions, and Selection Control Structures

test plan—a document that specifies the test cases that should be tried, the reason for
each test case, and the expected output. Test plan implementation involves running the
program using the data specified by the test cases in the plan and checking and record-
ing the results.

The test plan should be developed together with the design. The following table
shows a partial test plan for the Calculator application. The first test case assumes
that the calculator has an initial value of 0.0. Successive test cases use the preceding
result as one of the two operands for a calculation. To be more thorough, we should
check that the program properly handles closing of the window, and we should include
some negative as well as positive values.

Implementing a test plan does not guarantee that a program is completely correct. It
means only that a careful, systematic test of the program has not demonstrated any
bugs. The situation shown in Figure 6.7 is analogous to trying to test a program without
a plan—depending only on luck, you may completely miss the fact that a program con-
tains numerous errors. Developing and implementing a written test plan, on the other
hand, casts a wide net that is much more likely to find errors.

Tests Performed Automatically During Compilation and Execution

Once a program is coded and test data has been prepared, it is ready for compiling. The
compiler has two responsibilities: to report any errors and (if there are no errors) to
translate the program into object code or Bytecode.

Errors can be syntactic or semantic. The compiler finds syntactic errors. For exam-
ple, the compiler warns you when reserved words are misspelled, identifiers are unde-
clared, semicolons are missing, and operand types are mismatched. But it won’t find all
of your typing errors. If you type > instead of <, you won’t get an error message;
instead, you get erroneous results when you test the program. It’s up to you to design a
test plan and carefully check the code to detect errors of this type.

Semantic errors (also called logic errors) are mistakes that give you the wrong
answer. They are more difficult to locate than syntactic errors and usually surface when
a program is executing. Java detects only the most obvious semantic errors—those that
result in an invalid operation (dividing by zero, for example). Although typing errors
sometimes cause semantic errors, they are more often a product of a faulty algorithm
design.

By walking through the algorithm and the code, tracing the execution of the pro-
gram, and developing a thorough test strategy, you should be able to avoid, or at least
quickly locate, semantic errors in your programs.

Figure 6.8 illustrates the testing process we’ve been discussing. The figure shows
where syntax and semantic errors occur and in which phase they can be corrected.

Testing and Debugging Hints

1. Java has three pairs of operators that are similar in appearance but different in
effect: == and =, && and &, and || and |. Double-check all of your logical expres-
sions to be sure you’re using the “equals-equals,” “and-and,” and “or-or” operators.

TE
AM
FL
Y

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

Team-Fly® 



Summary of Classes | 277

Then check them again to make certain that you didn’t double type the < or > oper-
ators.

2. If you use extra parentheses for clarity, be sure that the opening and closing
parentheses match up. To verify that parentheses are properly paired, start with the
innermost pair and draw a line connecting them. Do the same for the others, work-
ing your way out to the outermost pair. For example,

3. Here is a quick way to tell whether you have an equal number of opening and clos-
ing parentheses. The scheme uses a single number (the “magic number”), whose
value initially is 0. Scan the expression from left to right. At each opening paren-
thesis, add 1 to the magic number; at each closing parenthesis, subtract 1. At the
final closing parenthesis, the magic number should be 0. In the following example
the digits indicate the total number so far, working from left to right.

if (((total/scores) > 50) && ((total/(scores – 1)) < 100))
0  123           2      1    23      4          32      10

4. Don’t use =< to mean “less than or equal to”; only the symbol <= works. Likewise,
=> is invalid for “greater than or equal to”; you must use >= for this operation.

if( ( ( (total/(scores - 1) ) < 100) )&&(total/scores) > 50)



278 | Chapter 6:  Conditions, Logical Expressions, and Selection Control Structures

Summary
Using logical expressions is a way of asking questions while a program is running. The
program evaluates each logical expression, producing the value true if the expression
is true or the value false if the expression is not true.

The if statement allows you to take different paths through a program based on the
value of a logical expression. The if-else statement is used to choose between two
courses of action; the if statement is used to choose whether or not to take a particular
course of action. The branches of an if or if-else can be any statement, simple or com-
pound. They can even be another if statement.

When a user interface includes multiple buttons, we can use the action command
string associated with each button to determine which one was pressed. The event han-
dler is passed an ActionEvent value as a parameter, and we call its associated value-
returning instance method, getActionCommand, to retrieve the string given to the
button.

The algorithm walk-through is a manual simulation of the algorithm at the design
phase. By testing our design in the problem-solving phase, we can eliminate errors that
can be more difficult to detect in the implementation phase.

An execution trace is a way of finding program errors once we’ve entered the imple-
mentation phase. It’s a good idea to trace a program before you run it, so that you have
some sample results against which to check the program’s output. A written test plan is
an essential part of any program development effort.

Quick Check
1. Write a Java expression that compares the variable letter to the constant 'Z'

and yields true if letter is less than 'Z'. (pp. 237–238)
2. Write a Java expression that yields true if letter is between 'A' and 'Z'

inclusive. (pp. 237–239)
3. What form of the if statement would you use to make a Java program print out

“Is an uppercase letter” if the value in letter is between 'A' and 'Z' inclusive,
and print out “Is not an uppercase letter” if the value in letter is outside that
range? (pp. 247–249)

4. What form of the if statement would you use to make a Java program print out
“Is a digit” only if the value in the variable someChar is between '0' and '9'
inclusive? (pp. 252–253)

5. On a telephone, each of the digits 2 through 9 has a segment of the alphabet
associated with it. What kind of control structure would you use to decide which
segment a given letter falls into and to print out the corresponding digit? (pp.
254–257)

6. If operands of a relational expression are characters rather than numeric values,
what do the relational operators measure?

7. What is the handler method to which all button events for a frame are sent? (pp.
258–261)



Exam Preparation Exercises | 279

Expression Meaning in English

one == two
one != two
one > two
one < two
one >= two
one <= two

8. In what phase of the program development process should you carry out an exe-
cution trace? (pp. 270–272)

9. You’ve written an application that displays the corresponding digit on a phone,
given a letter of the alphabet. Everything seems to work right except that you
can’t get the digit '5' to display; you keep getting the digit '6'. What steps
would you take to find and fix this bug? (pp. 274–275)

Answers
1. letter < 'Z' 2. letter >= 'A' && letter <= 'Z' 3. The if-else form
4. The if form 5. A nested if statement 6. The relative position of the characters within the
collating sequence of the character set 7. actionPerformed 8. The implementation phase
9. Carefully review the section of code that should print out '5'. Check the branching condition
and the output statement there. Try some sample values by hand.

Exam Preparation Exercises
1. What is the purpose of a control structure?
2. What is a logical expression?
3. Given the following relational expressions, state in English what they say.

4. Given these values for the Boolean variables x, y, and z:

x = true, y = false, z = true

evaluate the following logical expressions. In the blank next to each expression,
write a T if the result is true or an F if the result is false.
_____ a. x && y || x && z
_____ b. (x || !y) && (!x || z)
_____ c. x || y && z
_____ d. !(x || y) && z

5. Given these values for variables i, j, p, and q:

i = 10, j = 19, p = true, q = false



280 | Chapter 6:  Conditions, Logical Expressions, and Selection Control Structures

add parentheses (if necessary) to the expressions below so that they evaluate to
true.
a. i == j || p
b. i >= j || i <= j && p
c. !p || p
d. !q && q

6. Given these values for the int variables i, j, m, and n:

i = 6, j = 7, m = 11, n = 11

what is the output of the following code?

out.add(new Label("Madam"));
if (i < j)
if (m != n)
out.add(new Label("How"));

else
out.add(new Label("Now"));

out.add(new Label("I’m"));
if (i >= m)
out.add(new Label("Cow"));

else
out.add(new Label("Adam"));

7. Given the int variables x, y, and z, where x contains 3, y contains 7, and z
contains 6, what is the output from each of the following code fragments?

a. if (x <= 3)
out.add(new Label('x' + 'y'));

out.add('x' + 'y');
b. if (x != –1)

out.add(new Label("The value of x is " + x));
else
out.add(new Label("The value of y is " + y));

c. if (x != –1)
{
out.add(new Label("" + x));
out.add(new Label("" + y));
out.add(new Label("" + z));

}
else
out.add(new Label("y"));
out.add(new Label("z"));



Exam Preparation Exercises | 281

8. Given this code fragment:

if (height >= minHeight)
if (weight >= minWeight)
out.add(new Label("Eligible to serve."));

else
out.add(new Label("Too light to serve."));

else
if (weight >= minWeight)
out.add(new Label("Too short to serve."));

else
out.add(new Label("Too short and too light to serve."));

a. What is the output when height exceeds minHeight and weight exceeds
minWeight?

b. What is the output when height is less than minHeight and weight is less
than minWeight?

9. Match each logical expression in the left column with the logical expression in
the right column that tests for the same condition.
_____ a. x < y && y < z (1) !(x != y) && y == z
_____ b. x > y && y >= z (2) !(x <= y || y < z)
_____ c. x != y || y == z (3) (y < z || y == z) || x == y
_____ d. x == y || y <= z (4) !(x >= y) && !(y >= z)
_____ e. x == y && y == z (5) !(x == y && y != z)

10. The following expressions make sense but are invalid according to Java’s rules
of syntax. Rewrite them so that they are valid logical expressions. (All the vari-
ables are of type int.)
a. x < y <= z
b. x, y, and z are greater than 0
c. x is equal to neither y nor z
d. x is equal to y and z

11. Given these values for the Boolean variables x, y, and z,

x = true, y = true, z = false

indicate whether each expression is true (T) or false (F).
_____ a. !(y || z) || x
_____ b. z && x && y
_____ c. ! y || (z || !x)
_____ d. z || (x && (y || z))
_____ e. x || x && z

12. For each of the following problems, decide which is more appropriate, an if-else
or an if-(then). Explain your answers.
a. Students who are candidates for admission to a college submit their SAT

scores. If a student’s score is equal to or above a certain value, print a letter
of acceptance for the student. Otherwise, print a rejection notice.



282 | Chapter 6:  Conditions, Logical Expressions, and Selection Control Structures

b. For employees who work more than 40 hours a week, calculate overtime pay
and add it to their regular pay.

c. In solving a quadratic equation, whenever the value of the discriminant (the
quantity under the square root sign) is negative, print out a message noting
that the roots are complex (imaginary) numbers.

d. In a computer-controlled sawmill, if a cross section of a log is greater than
certain dimensions, adjust the saw to cut four-inch by eight-inch beams; oth-
erwise, adjust the saw to cut two-inch by four-inch studs.

13. What causes the error message “UNEXPECTED ELSE” when this code fragment is
compiled?

if (mileage < 24.0)
{
out.add(new Label("Gas "));
out.add(new Label("guzzler."));

};
else
out.add(new Label("Fuel efficient."));

14. The following code fragment is supposed to print “Type AB" when Boolean
variables typeA and typeB are both true, and print “Type O" when both vari-
ables are false. Instead, it prints “Type O" whenever just one of the variables
is false. Insert a { } pair to make the code segment work the way it should.

if (typeA || typeB)
if (typeA && typeB)
out.add(new Label("Type AB"));

else
out.add(new Label("Type O"));

15. The nested if structure below has five possible branches depending on the values
read into char variables ch1, ch2, and ch3. To test the structure, you need five
sets of data, each set using a different branch. Create the five test data sets.

if (ch1 == ch2)
if (ch2 == ch3)
out.add(new Label("All initials are the same."));

else
out.add(new Label("First two are the same."));

else if (ch2 == ch3)
out.add(new Label("Last two are the same."));

else if (ch1 == ch3)
out.add(new Label("First and last are the same."));

else
out.add(new Label("All initials are different."));



Programming Warm-Up Exercises | 283

Method Name Parameter Returns English Description

equals
compareTo
toUpperCase
toLowerCase

a. Test data set 1: ch1 = _____  ch2 = _____  ch3 = _____
b. Test data set 2: ch1 = _____  ch2 = _____  ch3 = _____
c. Test data set 3: ch1 = _____  ch2 = _____  ch3 = _____
d. Test data set 4: ch1 = _____  ch2 = _____  ch3 = _____
e. Test data set 5: ch1 = _____  ch2 = _____  ch3 = _____

16. If x and y are Boolean variables, do the following two expressions test the same
condition?

x != y
(x || y) && !(x && y)

17. The following if condition is made up of three relational expressions:

if (i >= 10 && i <= 20 && i != 16)
j = 4;

If i contains the value 25 when this if statement is executed, which relational
expression(s) does the computer evaluate? (Remember that Java uses short-cir-
cuit evaluation.)

18. a. If strings cannot be compared using the relational operators in Java, how can
you compare two strings?

b. Fill in the following table that describes methods that can be applied to string
objects.

19. How do you associate a string with a button event?
20. Why are there two strings associated with each button event? Explain.
21. What happens if you do not call the setActionCommand to name the button?
22. Describe the two ways that multiple buttons can be distinguished.

Programming Warm-Up Exercises
1. Declare eligible to be a Boolean variable, and assign it the value true.
2. Write a statement that sets the Boolean variable available to true if num-

berOrdered is less than or equal to numberOnHand minus numberReserved.
3. Write a statement containing a logical expression that assigns true to the

Boolean variable isCandidate if satScore is greater than or equal to 1100,
gpa is not less than 2.5, and age is greater than 15. Otherwise, isCandidate
should be false.



284 | Chapter 6:  Conditions, Logical Expressions, and Selection Control Structures

4. Given the declarations

boolean leftPage;
int  pageNumber:

write a statement that sets leftPage to true if pageNumber is even. (Hint:
Consider what the remainders are when you divide different integers by two.)

5. Write an if statement (or a series of if statements) that assigns to the variable
biggest the greatest value contained in variables i, j, and k. Assume the three
values are distinct.

6. Rewrite the following sequence of if-(then) as a single if-else statement.

if (year % 4 == 0)
out.add(new Label(year + " is a leap year."));

if (year % 4 != 0)
{
year = year + 4 – year % 4;
out.add(new Label(year + " is the next leap year."));

}

7. Simplify the following program segment, taking out unnecessary comparisons.
Assume that age is an int variable.

if (age > 64)
out.add(new Label("Senior voter"));

if (age < 18)
out.add(new Label("Under age"));

if (age >= 18 && age < 65)
out.add(new Label("Regular voter"));

8. The following program fragment is supposed to print out the values 25, 60, and
8, in that order. Instead, it prints out 50, 60, and 4. Why?

length = 25;
width = 60;
if (length == 50)
height = 4;

else
height = 8;

out.add(new Label("" + length + ' ' + width + ' ' + height));

9. The following Java program segment is almost unreadable because of the incon-
sistent indentation and the random placement of left and right braces. Fix the
indentation and align the braces properly.

// This is a nonsense program segment
if (a > 0)
if (a < 20)

{
out.add(new Label("A is in range."));



Programming Warm-Up Exercises | 285

b = 5;
}

else
{

out.add(new Label("A is too large."));
b = 3;

}
else

out.add(new Label("A is too small."));
out.add(new Label("All done.")

10. Given the float variables x1, x2, y1, y2, and m, write a program segment to
find the slope of a line through the two points (x1, y1) and (x2, y2). Use the for-
mula

to determine the slope of the line. If x1 equals x2, the line is vertical and the
slope is undefined. The segment should write the slope with an appropriate label.
If the slope is undefined, it should write the message “Slope undefined.”

11. Given the float variables a, b, c, root1, root2, and discriminant, write a
program segment to determine whether the roots of a quadratic polynomial are
real or complex (imaginary). If the roots are real, find them and assign them to
root1 and root2. If they are complex, write the message “No real roots.”

The formula for the solution to the quadratic equation is

The 6 means “plus or minus” and indicates that there are two solutions to the
equation: one in which the result of the square root is added to 2b and one in
which the result is subtracted from 2b. The roots are real if the discriminant (the
quantity under the square root sign) is not negative.

12. Provide a user interface with two buttons, Enter and Quit.
a. Write the statements that declare the buttons and a single listener

(ButtonHandler).
b. Write the statements that instantiate the buttons and the listener.
c. Write the statements that name the buttons.
d. Write the statements that add the buttons to the frame.
e. Write the statements that register the listener.
f. Write the statement that access a button’s name from within an event han-

dler.
g. Code the ButtonHandler class. When each button is pushed, write its name

on the screen.

− ± −b b ac
a

2 4
2

m
y y
x x

= −
−

1 2

1 2



286 | Chapter 6:  Conditions, Logical Expressions, and Selection Control Structures

13. Provide a user interface with two buttons, Enter and Quit.
a. Write the statements that declare the buttons and two listeners.
b. Write the statements that instantiate the buttons and the listeners.
c. Write the statements that name the buttons.
d. Write the statements that add the buttons to the frame.
e. Write the statements that register the listeners.
f. Code a class that implements ActionListener for each button. When each

button is pushed, write its name on the screen.

Programming Problems
1. Design and write a Java application that inputs a single letter and prints out the

corresponding digit on the telephone. The letters and digits on a telephone are
grouped this way:

2 = ABC 4 = GHI 6 = MNO 8 = TUV
3 = DEF 5 = JKL 7 = PRS 9 = WXY

No digit corresponds to either Q or Z. For these two letters, your application
should print a message indicating that they are not used on a telephone.

The application should have two buttons, one to enter input and one to quit.
The screen dialog might look like this:

Enter a single letter, and I will tell you what the 
corresponding digit is on the telephone.
R

The digit 7 corresponds to the letter R on the telephone.

Here’s another example:

Enter a single letter, and I will tell you what the 
corresponding digit is on the telephone.
Q

There is no digit on the telephone that corresponds to Q.

Your program should print a message indicating that there is no matching digit
for any nonalphabetic character the user enters. Also, the program should recog-
nize only uppercase letters. Include the lowercase letters with the invalid charac-
ters. Prompt the user with an informative message for the input value, as shown
above.

Use proper indentation, appropriate comments, and meaningful identifiers
throughout the program.

2. People who deal with historical dates use a number called the Julian day to cal-
culate the number of days between two events. The Julian day is the number of
days that have elapsed since January 1, 4713 B.C. For example, the Julian day

TE
AM
FL
Y

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

Team-Fly® 



Programming Problems | 287

3Notice that this formula can give a date in April.

for October 16, 1956, is 2,435,763. There are formulas for computing the Julian
Day from a given date and vice versa.

One very simple formula computes the day of the week from a given Julian
day:

Day of the week = (Julian day + 1) % 7

where % is the Java modulus operator. This formula gives a result of 0 for Sun-
day, 1 for Monday, and so on up to 6 for Saturday. For Julian day 2,435,763, the
result is 2 (a Tuesday). Your job is to write a Java application that requests and
inputs a Julian day, computes the day of the week using the formula, and then
prints out the name of the day that corresponds to that number. Use two but-
tons, Done and Quit. The application continues until the Quit button is pushed.

Your screen dialog might look like this:

Enter a Julian day number and press Done. Press Quit to quit.
2451545
Julian day number 2451545 is a Saturday.
2451547
Julian day number 2451547 is a Monday.

3. You can compute the date for any Easter Sunday from 1982 to 2048 as follows
(all variables are of type int):

a is year % 19
b is year % 4
c is year % 7
d is (19 * a + 24) % 30
e is (2 * b + 4 * c + 6 * d + 5) % 7

Easter Sunday is March (22 + d + e)3

For example Easter Sunday in 1985 is April 7.
Write an application that inputs the year and outputs the date (month and

day) of Easter Sunday for that year. Use two buttons.
4. The algorithm for computing the date of Easter can be extended easily to work

with any year from 1900 to 2099. There are four years—1954, 1981, 2049, and
2076—for which the algorithm gives a date that is seven days later than it should
be. Modify the application for Exercise 3 to check for these years and subtract 7
from the day of the month. This correction does not cause the month to change.
Be sure to change the documentation for the program to reflect its broadened
capabilities.

5. Write a Java application that calculates and prints the diameter, the circumfer-
ence, or the area of a circle, given the radius. The application should have three
buttons, one for diameter, one for circumference, and one for area. The user



288 | Chapter 6:  Conditions, Logical Expressions, and Selection Control Structures

should be prompted to enter the radius in floating-point form and press the
appropriate button. The output should be labeled appropriately. For example, if
the input is 6.75 and the area button is pressed, your program should print
something like this:

The area of a circle with radius 6.75 is 143.14.

Here are the formulas you need:

Diameter = 2r
Circumference = 2pr
Area of a circle = pr 2

where r is the radius. Use 3.14159265 for p.
6. The factorial of a number n is n * (n 2 1) * (n 2 2) * . . . * 2 * 1. Stirling’s formula

approximates the factorial for large values of n:

where p = 3.14159265 and e = 2.718282.
Write a Java program that inputs an integer value (but stores it into a dou-

ble variable n), calculates the factorial of n using Stirling’s formula, assigns the
(rounded) result to a long integer variable, and then prints the result appropri-
ately labeled.

Depending on the value of n, you should obtain one of these results:
A numerical result.

• If n equals 0, the factorial is defined to be 1.
• If n is less than 0, the factorial is undefined.
• If n is too large, the result exceeds Long.MAX_VALUE.

Because Stirling’s formula is used to calculate the factorial of very large num-
bers, the factorial approaches Long.MAX_VALUE quickly. If the factorial exceeds
Long.MAX_VALUE, it causes an arithmetic overflow in the computer, in which
case the program continues with a strange-looking integer result, perhaps nega-
tive. Before you write the program, then, you first must write a small program
that lets you determine, by trial and error, the largest value of n for which you
can compute a factorial using Stirling’s formula. After you’ve determined this
value, you can write the program using nested ifs that print different messages
depending on the value of n. If n is within the acceptable range for your com-
puter system, output the number and the result with an appropriate message. If n
is 0, write the message, “The number is 0. The factorial is 1.”. If the number is
less than 0, write: “The number is less than 0. The factorial is undefined.”. If the
number is greater than the largest value of n for which your computer system
can compute a factorial, write: “The number is too large.”.

Factorial of n
n n

e

n

n
= 2π



Case Study Follow-Up Exercises | 289

Suggestion: Don’t compute Stirling’s formula directly. The values of nn and en

can be huge, even in floating-point form. Take the natural logarithm of the for-
mula and manipulate it algebraically to work with more reasonable floating-
point values. If r is the result of these intermediate calculations, the final result is
er. Make use of the standard library methods Math.log and Math.exp, available
through the java.lang.Math class. These methods compute the natural loga-
rithm and natural exponentiation, respectively.

Case Study Follow-Up Exercises
1. Most of the code in the Calculator program involves input/output. The pro-

gram is long, but the concepts are simple. Examine this program and mark the
statements associated with creating the frame as F, the statements associated
with creating and handling buttons as B, and the statements that relate the but-
tons to the frame as FB. Notice that all the comments have been removed; you
have to read and understand the actual code to answer this question and the
next.

import java.awt.*;
import java.awt.event.*;

public class Calculator
{
private static class NumericHandler implements ActionListener
{
public void actionPerformed(ActionEvent event)
{
double secondOperand;
String whichButton;
secondOperand =    
Double.valueOf(inputField.getText()).doubleValue();

whichButton = event.getActionCommand();
if (whichButton.equals("add"))
result = result + secondOperand;

else
result = result – secondOperand;

register.setText("" + result);
inputField.setText("");

}
}

private static class ClearHandler implements ActionListener
{
public void actionPerformed(ActionEvent event)
{



290 | Chapter 6:  Conditions, Logical Expressions, and Selection Control Structures

result = 0.0;
register.setText("0.0");
inputField.setText("");

}
}

private static TextField inputField;
private static Label register;
private static Frame calcFrame;
private static double result;

public static void main(String[] args)
{
NumericHandler operation;
ClearHandler clearOperation;
Label resultLabel;
Label entryLabel;
Button add;
Button subtract;
Button clear;
operation = new NumericHandler();
clearOperation = new ClearHandler();
result = 0.0;
resultLabel = new Label("Result:");
register = new Label("0.0", Label.RIGHT);
entryLabel = new Label("Enter #:");
inputField = new TextField("", 10);
add = new Button("+");
subtract = new Button("-");
clear = new Button("Clear");
add.setActionCommand("add");
subtract.setActionCommand("subtract");
clear.setActionCommand("clear");
add.addActionListener(operation);
subtract.addActionListener(operation);
clear.addActionListener(clearOperation);
calcFrame = new Frame();

calcFrame.setLayout(new GridLayout(4,2));
calcFrame.add(resultLabel);
calcFrame.add(register);
calcFrame.add(entryLabel);
calcFrame.add(inputField);
calcFrame.add(add);



Case Study Follow-Up Exercises | 291

calcFrame.add(subtract);
calcFrame.add(clear);
calcFrame.pack();
calcFrame.show();
calcFrame.addWindowListener(new WindowAdapter()
{
public void windowClosing(WindowEvent event)
{
calcFrame.dispose();
System.exit(0);

}
});

}
}

2. List the statements that relate to the Clear button, describing in English what
each one does.

3. Complete the original Calculator project by adding buttons for multiplication
and division.

4. Write a test plan to test the final project and implement the test plan.





              

To be able to apply the concepts of abstraction and
encapsulation in object-oriented design.

To be able to design the public interface for a class.

To be able to implement a class responsibility as a
method.

To be able to design and implement a constructor for
a class.

To be able to distinguish between immutable and
mutable objects.

To be able to implement a new class.

To be able to determine the lifetime of an object or a
class field.

To be able to recognize the conditions under which an
object is garbage collected.

To be able to collect a set of classes together in a
package.

To be able to test classes in a package.

Classes and Methods
G

oals



294 | Chapter 7:  Classes and Methods

Prior to this chapter we have written Java application classes in which we have occa-
sionally nested other class definitions. These classes have followed specific patterns that
enabled us to write them without learning all the rules and options that Java provides
for implementing a class. As we have seen from our use of CRC cards, however, it is
common to create new classes that don’t follow an existing formula.

In this chapter we consider the principles that result in a well-designed class imple-
mentation. Primary among these is the concept of encapsulation. We’ll also see how to
bundle one or more classes into a package that can be imported by applications.

Up to this point we’ve also been writing just a few specific methods such as main. It’s
time to see how to write methods that can implement an arbitrary class responsibility.

7.1 Encapsulation
The dictionary provides several definitions of the word capsule. For example, it can be a
sealed gelatin case that holds a dose of medication. Early spacecraft were called cap-
sules because they were sealed containers that carried passengers through space. A cap-
sule protects its contents from outside contaminants or harsh conditions. To encapsulate
something is to place it into a capsule.

What does encapsulation have to do with classes
and object-oriented programming? One goal in
designing a class is to protect its contents from being
damaged by the actions of external code. If the con-
tents of a class can be changed only through a well-
defined interface, then it is much easier to use the
class and to debug errors in an application.

Why is it important to encapsulate a class?
Encapsulation is the basis for abstraction in program-

ming. Recall, for example, that it is abstraction that lets us use a Frame without having
to know the details of its implementation.

We simplify the design of a large program through abstraction: We design classes
that can be described in simple terms. There are implementation details of each class
that are irrelevant to using it. Those details are hidden by encapsulation. The program-
mer who implements the class doesn’t have to understand how the larger application

uses it, and the programmer who uses the class doesn’t
have to think about how it is implemented.

Even when you are the programmer in both cases,
abstraction simplifies your job because it allows you to
focus on different parts of the program in isolation
from each other. What seems like a huge programming
problem at first is much more manageable when you
break it into little pieces that you can solve separately
(the divide-and-conquer strategy from Chapter 1).

Separating a class into a logical description (an
interface) and an encapsulated implementation has
two additional benefits: modifiability and reuse.

Encapsulation Designing a class so that its imple-
mentation is protected from the actions of external
code except through the formal interface

Abstraction The separation of the logical properties
of an object from its implementation

Modifiability The property of an encapsulated class
definition that allows the implementation to be
changed without having an effect on code that uses it
(except in terms of speed or memory space)

Reuse The ability to import a class into any program
without additional modification to either the class or
the program; the ability to extend the definition of a
class



7.1 Encapsulation | 295

Encapsulation enables us to modify the implementation of a class after its initial
development. Perhaps we are rushing to meet a deadline, so we create a simple but inef-
ficient implementation. Later, we can replace the implementation with one that is more
efficient. The modification is undetectable by users of the class with the exception that
their programs run faster and/or require less memory.

If we write a class in a manner that exposes implementation details, user code may
try to exploit some of those details. If we later change the implementation, the user code
would stop working. Figure 7.1 illustrates an encapsulated implementation versus one
that is exposed to external code.

Encapsulation also allows us to use a class in other applications. An encapsulated
class is self-sufficient so that it doesn’t depend on declarations in the application. It can
thus be imported into different applications without requiring changes to either the class
or the application. Our event listener classes have directly accessed variables that are
also directly accessed by main, and therefore are not encapsulated.

As we see in Chapter 8, reuse also means that an encapsulated class can be easily
extended to form new related classes. For example, suppose you are working for a util-
ity company developing software to manage their fleet of vehicles. As shown in Figure
7.2, an encapsulated class that describes a vehicle could be used in the applications that
schedule its use and keep track of maintenance as well as the tax accounting applica-
tion that computes its operating cost and depreciation. Each of those applications could
add extensions to the vehicle class to suit its particular requirements.

Reuse is a way to save programming effort and also ensures that objects have the
same behavior every place that they are used. Consistent behavior helps us to avoid and
detect programming errors.

External code

Can be
changed
without
affecting
external

code

Changes
can affect
external

code

Encapsulated
implementation

Exposed
implementation

Figure 7.1 Encapsulated versus exposed implementation



296 | Chapter 7:  Classes and Methods

Vehicle Class

Vehicle
Maintenance
Scheduling
Program

Vehicle
Use

Scheduling
Program

Vehicle
Tax

Accounting
Program

Figure 7.2 Reuse

It is important to understand that encapsulation isn’t a Java language construct. We
achieve encapsulation by carefully designing the class interface. Once that’s done, we
take advantage of Java features that simplify implementation of an encapsulated class.

Abstraction

How do we design a class with an encapsulated implementation? We begin with the
abstraction for the object, as written on our CRC card. That way, we focus on the class
interface independently of how we may implement it. Then the implementation is auto-
matically separated from the interface.

We thus begin with a discussion of abstraction in programming, then turn to class
interface design, and finally look at implementation. Along the way we’ll take a short
detour to look at method implementation in Java.

Data and Control Abstraction Creation of a new class begins when there is a need for
a new object type. At the conclusion of the brainstorming and filtering steps in a
design, if we find a CRC card that isn’t in the Java library, we create a new class from
the responsibilities on the card. Some responsibilities require us to supply data to the
class (for example, constructors), while others provide data (such as Know First Name).
Each responsibility has a control component (what it does) and a data component (the
information it needs or returns). Encapsulation allows us to create an abstraction of
either or both of these components.

Data abstraction is the separation of the external
representation of an object’s values from their internal
implementation. For example, the external representa-
tion of a date might be integer values for the day and
year, and a string that specifies the name of the
month. But we might implement the date within the

class using a standard value that calendar makers call the Julian day, which is the num-
ber of days since January 1, 4713 B.C.

The advantage of using the Julian day is that it simplifies arithmetic on dates, such
as computing the number of days between dates. All of the complexity of dealing with

Data abstraction The separation of the logical repre-
sentation of an object’s range of values from their
implementation

TE
AM
FL
Y

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

Team-Fly® 



7.1 Encapsulation | 297

1The Java library includes a Date class, java.util.Date. However, the familiar properties of dates make
them a natural example to use in explaining the concepts of class interface design. So we ignore the existence
of the library class in the discussion that follows, as if we must design our own Date class. In writing real
programs, however, you would probably use the Calendar library class that replaced Date in Java 1.1.

leap years and the different number of days in the months is captured in formulas that
convert between the conventional representation of a date and the Julian day. From the
user’s perspective, however, the responsibilities of a Date object receive and return a
date as two integers and a string.1

In many cases, the external representation and the implementation of the values are
identical. However, we won’t tell that to the user, in case we decide to change the
implementation in the future.

Control abstraction is the separation of
the logical properties of the actions of a
responsibility from their implementation. For
example, the documentation for the Date
class says that it takes into account all of the
special leap-year rules. In the implementa-
tion, only the conversion formulas handle those rules, and the other responsibilities
merely perform simple arithmetic on the Julian day number.

A user can simply imagine that every Date responsibility is separately computing
leap years. But control abstraction lets us program a more efficient implementation and
hide that complexity from the user.

Object State Any object that stores infor-
mation is said to have state. The object’s state
is the current set of values that it contains.
Some of those values may be represented in
the data abstraction and some may be hidden.
An object’s state can also contribute to its control abstraction. For example, an object
that simulates a traffic light may only return its current color, but internally it keeps
track of the time so that it knows when to change color.

The state of an object, its data and control abstractions, and its collaborations com-
bine to precisely determine its behavior.

An object is instantiated with an initial
state. If any of its methods can subsequently
change its state, then the object is said to be
mutable. A Frame is an example of a mutable
object; its add method changes its state. If an
object doesn’t have any methods that can
change its state, it is immutable. A String is
an immutable object; we can only retrieve its
contents.

Control abstraction The separation of the logical
properties of the operations on an object from their
implementation

State The current values contained within an object

Mutable An object whose state can be changed after
it is created

Immutable An object whose state cannot be changed
once it is created



298 | Chapter 7:  Classes and Methods

For example, examine the following class shell that represents a traffic light.

public class TrafficLight
{
// Instance variables
String currentColor;
int timeRemaining;
// Constructor
public TrafficLight()
{
}
// Observer methods
public String knowCurrentColor()
{
}

Theoretical Foundations
Categories of Instance Responsibilities

Class instance responsibilities generally fall into three categories: constructors, transformers,
and observers.

A constructor is an operation that creates a new instance of a class. Operators that modify
the state of an object are transformers. For example, an operation that changes the year of a
Date object is a transformer. Observers are operations that allow us to observe the state of an
object. The knowFirstName method of a Name class is an example of an observer.

Some operations are combinations of observers and constructors. An operation that takes a
Date object and an integer value and returns a new Date object that is the original date plus

that number of days is an example of an observer (of
the original Date object) and a constructor (of the
new Date object). This particular case is an example
of a copy constructor.

In addition to the three basic categories of respon-
sibility, there is a fourth category that is less common:
iterators.

In later chapters we examine classes that are made
up of multiple values all of the same type. An iterator
allows us to observe each of these components one at
a time. For example, given a class representing a list
of names, an iterator would enable us to go through
the list, observing or transforming each of the names
one by one.

Constructor An operation that creates a new
instance of a class

Transformer An operation that changes the internal
state of an object

Observer An operation that allows us to observe the
state of an object without changing it

Copy constructor An operation that creates a new
instance of a class by copying an existing instance,
possibly altering some or all of its state in the process

Iterator An operation that allows us to process—one
at a time—all the components in an object



7.2 Class Interface Design | 299

public int knowTimeRemaining()
{
}
// Transformers
public void changeColor()
{
}
public void decrementTimeRemaining()
{
}

}

The values stored in currentColor and timeRemaining are the state of the
object. We know that any object of class TrafficLight is a mutable object because
transformer methods are defined.

7.2 Class Interface Design
Let’s begin our discussion of designing the class interface by looking at the CRC card for
a new class, Name, with three fields, First, Middle, and Last.

Class Name: Name Superclass: Subclasses:

Responsibilities Collaborations

Create itself (First, Middle, Last)

Know its first name

return String

Know its middle name

return String

Know its last name

return String

Name in firstMidLast form

return String

Name in lastFirstMid form

return String

Are two names equal?
return boolean

Compare two names

 return int 



None

None

None

None

String

String

String

String



300 | Chapter 7:  Classes and Methods

As you can see, a Name has eight responsibilities. As we discussed in Chapter 5, we
have extended the basic CRC card to include notes about the data that a responsibility
needs and that it returns. This additional information arises naturally in the scenario
discussions as we play out the collaborations, and we simply write it on the CRC card to
remember it.

From the preceding discussion we can classify the eight responsibilities as follows:

Responsibility Classification

Create itself Constructor
Know its first name Observer
Know its middle name Observer
Know its last name Observer
Name in firstMidLast form Observer
Name in lastFirstMid form Observer
Is this name equal to (anotherName)? Observer
Compare this name to (anotherName) Observer

We know that the first responsibility (Create itself) must be a constructor that uses new
to instantiate itself. The remaining responsibilities all return information about a name, so
they are observers. There are no transformers among the responsibilities. Thus an instance
of this class is an immutable object; once it is created it doesn’t change. None of the respon-
sibilities are iterators. This information can be added to the CRC card for future reference.

Now let’s look at how we turn this CRC card into a design for a class. Note that at
this stage, we begin to convert the responsibilities from phrases or sentences to names
that represent the responsibility.

Public Interface Design

There are two ways that the data abstraction of an object can be provided to the user,
the fields that it makes publicly accessible and the parameters of its methods. We briefly
consider public field values, and then look at methods and parameters.

Public Field Values One way to implement the Name class would be to keep each part
of the name in a String declared as a field:

String first;
String middle;
String last;

The Know first, Know middle, and Know last responsibilities return these values, so
we might consider simply declaring the corresponding fields public and letting the
user access them directly. However, this defeats the encapsulation of the class by reveal-
ing its internal representation to the user.

We can achieve encapsulation by making each of these responsibilities a method. If
we later change the internal representation, the methods can be rewritten to convert the
new internal representation into the existing external form.



7.2 Class Interface Design | 301

Would we ever want to declare a public field in a class? Yes. Sometimes it’s useful to
provide constants that a collaborator can pass to responsibilities. For example, the names of
the primary colors for a Spectrum object could be represented by public constants.

The constant RED could be an int with a value of 1 or a String with a value of
"RED". The collaborator doesn’t know how the class represents the constant. It merely
passes the class-supplied constant as a parameter to a method, as in this example:

colorObject.mixWith(Spectrum.RED);

In Java, such constants are declared static; that is, they belong to the class rather
than to an instance. We want every object of a given class to use the same set of con-
stants, so they should be kept centrally located in the class.

The Name class doesn’t have any such constants on its CRC card. Normally, they
would be identified during the scenario phase, and it would be noted that responsibili-
ties receive one value from among a small set. Here’s part of the CRC card for Spectrum
that illustrates the need for constants.

Responsibilities as Methods Each responsibility on the CRC card can be implemented
by a method in the class. If we know the information that is needed and returned by
each one, then the design is straightforward.

An observer naturally returns a value, so we implement it as a Java value-returning
method. Constructors have a special syntax in Java that we review later in this chapter.
A transformer is typically a void method. Iterators may be either value-returning or
void, but we won’t consider them until we work with arrays in Chapter 12.

If a responsibility implicitly refers to an object, then it should be implemented as an
instance method. Constructors, observers, transformers, and iterators are always
instance methods. They implicitly take their associated object as a parameter and have
access to its fields. In addition they can receive values through the parameter list, as
noted on the CRC card.

Class methods are used to implement responsibilities that are not associated with a
particular object, such as the Math.abs method. Class methods may also affect all the
instances of a class. For example, setting the maximum score for all TestScore objects
so that they can be checked for errors. None of the responsibilities of the Name class are
appropriate for a class method implementation.

Class Name: Spectrum Superclass:  Subclasses:

Responsibilities Collaborations

mixWith (a color, one of red, orange, 
yellow, green, blue, indigo, or violet)




None

.
.
.



302 | Chapter 7:  Classes and Methods

Let’s add this information to the CRC card for the class. We abbreviate value-
returning as V-R on the card.

7.3 Internal Data Representation
The first implementation step for a class is to decide on the internal representation of
data. Then we can use the means-ends analysis technique from Chapter 1 to design the
algorithms for translating between the abstract and internal representations. These algo-
rithms form the basis for the constructor and observer methods, and parts of some
transformer and iterator methods.

As we saw with our example of a Date object, the internal representation (Julian
day) and the abstract representation (month, day, year) can be quite different. In other
cases, such as class Name, the internal representation may be exactly the same as the
abstract form of the data. We choose the internal form to be useful for the programmer
rather than the user.

Our goal in selecting an internal representation should be to simplify our task and
to make the object efficient in terms of storage space and execution time. These goals
are sometimes in conflict, and we must balance simplicity against efficiency.

Class Name: Name Superclass: Subclasses:

Responsibilities Collaborations

Create itself (first, middle, last), Constructor

Know its first name, Observer, V-R instance
 return String

Know its middle name, Observer, V-R instance
 return String

Know its last name, Observer, V-R instance

return String

Name in firstMidLast form, Observer, V-R instance

return String

Name in lastFirstMid form, Observer, V-R instance

return String

Are two names equal?, Observer, V-R instance
return boolean

Compare two names, Observer, V-R instance 

 return int 



None

None

None

None

String

String

String

String



7.3 Internal Data Representation | 303

class
Date Julian Day Formula


intRes1 = 2-year/100+year/400
intRes2 = (int) (365.25*year)
intRes3 = (int) (30.6001*(month+1))
julianDay = intRes1+intRes2+intRes3+day+1720994.5

Astronomy
Text

Figure 7.3 Who would use similar data?

Two problem-solving strategies that are valuable in designing the internal data rep-
resentation are looking for things that are familiar and solving by analogy. In the case
of the Date class, you can go to the library and research calendars. For the Name class,
you already know how to write down a name.

It’s rare that you have to invent an entirely new data representation. Most programs
are written to solve problems that people have dealt with in the past. Consider who
would normally use such data, and consult with those people or look in texts that they
would use (Figure 7.3). For example, astronomers use dates in computing the positions
of planets over many years. You can find the formulas for computing the Julian day in
some astronomy texts.

As another example, a geography professor gave an assignment to draw a map
showing nearby airports with their elevations and the lengths of their runways. Most
students spent hours poring through almanacs and topographic maps to gather the data.
Even so, their maps were inaccurate. One student, however, got a perfect grade because
she stopped to consider who would use such data. She went to a pilot supply shop and
bought a precise map of nearby airports.

While there, she noticed a book that lists information for airports using an espe-
cially efficient representation. If she ever had to develop a computerized version of the
map, she would start with that representation.

From the preceding discussion it should be clear that we can’t give you a set of
rules that lead you to an internal data representation for a class. Each situation you
encounter is different. Be prepared to give this part of your design some careful
thought, to go to a library and do some research, to consult with other people, and to
trade off issues of efficiency and complexity.

In some cases you may discover that there is no one representation that is always
best. Or there may not be enough information to choose among several options. In those
cases, you simply have to pick a representation and use it. In the end, it may not turn
out to be the best choice. But remember that the beauty of encapsulation is that you can
go back later and change to a better internal representation!



304 | Chapter 7:  Classes and Methods

Data Lifetime

There are three categories of data that we use in implementing a class, instance data,
class data, and local data. We tend to focus more on the instance data because it is the

internal representation of a given object. However, the
other two categories are also important. Class data
provides information common to all objects of a class.
Local data is specific to a given call of a method.

Storage space for data in a Java application is
automatically supplied by the JVM for as long as the
data is needed. Depending on the category of the data,
it is needed at different stages in the execution of the
application. The period during which storage space is
assigned to data is called its lifetime.

As you implement the internal representation for a class, you need to choose one of
the categories for each variable, constant, or object, and that choice largely depends
upon the desired lifetime of the data. Let’s look at each of the three categories in turn.

Instance Data Each class instance contains data that distinguishes it from other
instances. For example, a Name object contains three strings that hold the first, middle,
and last names.

We’ve said many times that the JVM instantiates
an object when we use new. To instantiate an object,
the JVM must provide memory space for it. The JVM
manages an area of memory called the free pool or
heap for storing objects.

When an object is instantiated we say that new
allocates memory space from the free pool to the
object. An object is destroyed when the JVM detects
that no variable refers to it. If no variable contains the
address of the object, there is no longer any way to
access its contents.

For example, consider the following code seg-
ment.

labelVar = new Label("Instance data for one object.");
labelVar = new Label("Instance data for another object.");

In the first statement new instantiates a Label, allocating space for it. The assign-
ment causes labelVar to refer to this object. The second statement also instantiates a

Label and assigns it to labelVar. After the second
statement, labelVar no longer refers to the first
object, nor does any other variable. There is no way to
refer to that first object, and we say that the object is
unreachable.

Instance data Data that is associated with a specific
object

Class data Data that is associated with a class and
accessible by all objects of that class

Local data Data that is associated with a specific call
to a method

Lifetime For a variable, constant, or object, the por-
tion of an application’s execution time during which it
is assigned storage space in the computer’s memory

Allocate To assign memory space at run time for use
by an object

Free pool (heap) An area of memory, managed by
the JVM, that is used to provide storage space for
objects

Unreachable A condition of an object such that there
is no way to refer to it



7.3 Internal Data Representation | 305

When an object is unreachable, the JVM
marks it as garbage. Periodically, the JVM
performs an operation known as garbage col-
lection, in which it finds all of the unreach-
able objects and deallocates their storage
space, making it once again available in the
free pool for the creation of new objects.2

This approach, of creating and destroying
objects at different points in the application by
allocating and deallocating space in the free
pool is called dynamic memory management.
Without it, the computer would be much more
likely to run out of storage space for data.

The point of the preceding discussion is
to impress upon you that the lifetime of instance data is shorter than the execution time
of the application and is the same as the lifetime of its object. It is thus a way of storing
object-specific information between method calls.

Instance data thus records the object’s state for as long as the object exists. We
implement a field for an instance value by omitting the static modifier in its declara-
tion. It is often helpful to gather together the instance variables into one section of the
class declaration for easy reference—for example,

// Private instance variables
private String first;
private String middle;
private String last;

To identify the parts of the internal representation that are instance data, answer
this question:

Which parts of the internal representation does each object of this class need to
store independently for its lifetime?

Class Data Fields declared as static belong to the class rather than to a specific
instance. Space for class data is allocated at the start of the application and exists until
it is finished. That is, its lifetime is the whole time that the application is running. It
provides a way for us to record information about a class that survives across the
creation and destruction of objects.

A common use for class data is to provide constants that are available to all
instances of the class. For example, a Measurement class might declare constants for
conversion between metric and English units.

Garbage The set of currently unreachable objects

Garbage collection The process of finding all
unreachable objects and destroying them by deallocat-
ing their storage space

Deallocate To return the storage space for an object
to the pool of free memory so that it can be reallo-
cated to new objects

Dynamic memory management The allocation and
deallocation of storage space as needed while an appli-
cation is executing

2The term garbage collection dates back to programming languages of the 1960s. If the technique had been
invented more recently, it would probably be called recyclable collection.



306 | Chapter 7:  Classes and Methods

public class Measurement
{
// Class constants
static final double INCHES_TO_CENTIMETERS = 2.54;
static final double METERS_TO_YARDS = 1.1;
.
.
.

As you can see from these examples, class data has many uses. It is a way of stor-
ing information that is separate from any particular object. In implementing the class,
ask yourself:

What information needs to be kept that is independent of any instance or that must
remain throughout the execution of the application?

Local Data Local data exists only within a method call. As we have seen with main
and our event handler methods, we can declare local constants and variables within the
body of a method that are accessible only to statements within the method.

public void actionPerformed(ActionEvent event)
{ // Local variable declarations
double secondOperand;
String whichButton;

.

.

.

The JVM allocates space for this data when the method is called and deallocates it as
soon as the method returns. Local data has the most limited lifetime of the three categories.

We use local data whenever we need to store information that is specific to a par-
ticular method. For example, computing the Julian day number requires intermediate
values to be computed and then combined in a final formula. The method needs local
variables in which to keep these values. The values aren’t needed by any other methods,
so they do not have to be kept in instance variables.

As you develop the algorithm for each method, keep a list of the values that are
needed. Those that are not parameters, instance values, or class values are probably
local. To be certain, for each value ask yourself:

Is this information needed anywhere outside of the method?

If the answer is no, then you know the value is local. The following table summarizes
the lifetime of each category of data.

Category Lifetime

Class Execution of application program
Instance From creation to destruction of its object
Local From method call until return

TE
AM
FL
Y

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

Team-Fly® 



7.4 Class Syntax | 307

Internal Representation Example

Our Name class needs to represent a first, middle, and last name for each of its instances.
Clearly, these are instance variables because they are distinct values for each object.
What other information does Name need to carry out its responsibilities?

The lastFirstMid responsibility must provide punctuation to separate the names.
We could write this punctuation directly in the necessary string expression, or we could
declare a named constant with the punctuation string. The constant could be associated—
either with the instance or with the class. Because the same punctuation characters are
used in every instance, let’s make it a class constant.

Here is the Java code that declares the internal representation for Name.

static final String PUNCT = ", ";  // Class constant
// Instance variables
private String first;
private String middle;
private String last;

Notice that we use static to indicate that the constant belongs to the class, and
omitting this modifier from the variable declarations associates them with instances of
the class. When the following expression is executed:

new Name("Martha", "Bette", "Casey")

the JVM allocates space to the three string variables in the new Name object. For each
additional Name object that we instantiate, the JVM allocates space for three more
strings. But there is just one copy of PUNCT, and it exists for the lifetime of the appli-
cation.

7.4 Class Syntax
The syntax for writing a new class is exactly like that of our application class. Here we
show a syntax template for a class. It consists of a heading, followed by a block con-
taining class declarations:

ClassModifier class   Identifier

ClassDeclaration

{


}

. . .

. . .

Class



308 | Chapter 7:  Classes and Methods

The following template for a ClassDeclaration shows that it can be either a field
declaration (such as a variable, constant, or object), or a method declaration:

Here’s an example class declaration.

public class Name
{
static final String PUNCT = ", ";  // Class constant
// Instance variables
private String first;
private String middle;
private String last;
// Declare methods that implement responsibilities of Name

}

We already know how to declare fields in a class from our experience with writing
fields in the application class. However, we have not examined the process of declaring
methods. The mechanics of writing a method are quite simple: We just write its heading
and then follow it with the block of code that does the work. In the next section we see
how to write a method declaration, and we focus extensively on its heading and espe-
cially its parameters.

7.5 Declaring Methods
Up to now, we’ve restricted our method declarations to a small set of precise recipes. We
know how to declare main, windowClosing, and actionPerformed, all of which have
their headings predefined for us. In this section we look at how to write headings for
arbitrary methods. Here we repeat the syntax templates from Chapter 2 that show the
form of a method declaration.

FieldDeclaration

MethodDeclaration

ClassDeclaration



7.5 Declaring Methods | 309

In Chapter 2 we left Heading undefined. Now we can provide the syntax template
that defines it.

From this template we see that a method heading can optionally begin with modi-
fiers such as public, private, final, abstract, and static. Next in the heading is
the result type (void if no value is returned, or the name of a type or class if the
method returns a value). After the result type comes the name that we are giving to the
method. Then, enclosed in parentheses is an optional list of the parameters accepted by
the method, with commas separating them. Each parameter declaration consists of a
type (or class) name and an identifier. Notice that the parentheses are required. Here are
some examples of method headings.

Heading

Modifiers      ResultType     Identifier ( TypeName    Identifier , TypeName    Identifier     . . .       )     



     {

           Statement        . . .  

     }



Block




Heading

Block

MethodDeclaration



310 | Chapter 7:  Classes and Methods

void doNothing()                              // The simplest heading
public void skipValue()                       // Example with a modifier
int trimax(int num1, int num2, int num3)      // Shows multiple parameters
private static int square(int number)         // One parameter, returns int
public static double cube(double number)         // A public class method
public abstract void readname(FileReader inFile) // An abstract method

The first example is the simplest form of instance method heading, and illustrates that
the parentheses are required even when there are no parameters. When we omit any access
modifiers from the heading, it is said to have package accessibility. We explain package
accessibility later in this chapter when we look at how to create packages. The second
example shows a similar heading with the addition of the public access modifier. The
third example shows a heading for a value-returning instance method that has three
parameters, all of type int.

The fourth case shows a heading for a private value-returning class (static)
method that takes one parameter of type int. A private class method can only be called
from other methods within the class (either class or instance methods). The fifth example
is a public value-returning class method that can be called by users of the class.

The last example shows the heading for an
abstract method. We discuss abstract methods in
Chapter 12. At this point there is no need for you to
write abstract methods, so you should avoid using
this modifier in method headings.

The parameter list in the method heading provides
one mechanism by which the method call and the
method exchange information. Identifiers declared in
the method heading are called parameters and expres-

sions in the method call are arguments.
Arguments are matched to parameters by their relative position within the two lists.

Here is an example that illustrates the matching between the lists in a method heading
and a call.

When the JVM executes a call to a method, it first
copies the values of the arguments into their corre-
sponding parameters. We refer to this step as
parameter passing. Then it transfers control to the first
statement in the method’s block. As soon as the last
statement in the block has been executed, the values

in the parameters are destroyed and control returns to the point following the call.

public void someMethod (int param1, double param2, String param3)



                 someMethod (argumentA*2, argumentB, argumentC) 

Parameter An identifier declared between the paren-
theses in a method heading

Argument An expression listed in the call to a
method

Parameter passing The transfer of data between the
arguments and parameters in a method call



7.5 Declaring Methods | 311

The parameters are just like local variables declared within the method’s block. The
only difference is that they are automatically given initial values when the method is
called, because the values of the arguments are copied into the parameters. If the
method is called again with different arguments, then the method starts executing with
these new values in its parameters.

Parameters

When a method is executed, it uses the values of the arguments passed to it in the call.
But because of the distinction between simple and reference types, the effect of passing
different types of arguments varies.

With simple types, such as int, double, and boolean, the parameter receives a
copy of the value of the argument. The method can use and change the value in the
parameter. Keep in mind that the argument can be any expression that computes a value
of the appropriate type. Frequently, however, our arguments are just individual variables.

When we pass a variable as an argument to a parameter, it is easy to think that the
two identifiers are connected in some way, as if the parameter becomes a synonym for
the argument. But their only connection is at the moment when the value of the argu-
ment is copied to the parameter. Otherwise, they are independent of each other. That is,
operations on the parameter do not affect the argument.

When the method returns, whatever value is in a parameter is discarded. It is not
copied back into a variable in the argument. Thus, values of simple types may be passed
into methods, but changes to those values aren’t returned. Figure 7.4 illustrates the
passing of simple types as parameters.

321.89

double arg1

321.89

double param1

Call

During Method Execution paraml = 91773.112;

Argument Parameter

321.89

double arg1

91773.112

double param1

Return

321.89

double arg1 double param1

Figure 7.4 Passing a simple type as a parameter



312 | Chapter 7:  Classes and Methods

321.89

double arg1

321.89

double param1

Simple Type

Reference Type paraml = 91773.112;

Argument Parameter

Addr 317401

String arg2

Addr 317401

String param2

Memory Address
317401 "Java"

Figure 7.5 Passing simple and reference types

With reference types such as String and other classes, a variable contains the
address of where an object’s fields are stored in memory. This address is the value copied
from the argument to the parameter. There is only one copy of the object’s fields, which is
used by both the calling code and the method. If the method changes the values in those
locations, then the calling code sees those changes when the method returns.

Therefore, you must be careful when using reference type parameters because
changes made to their fields affect the value of the argument. Figure 7.5 illustrates the
difference between passing simple and reference types to a method.

Each argument must have the same type or class as the parameter in the same posi-
tion. You sometimes see Java code that seems to violate this rule, for example, in pass-
ing an int argument to a float parameter. But in this case, Java automatically inserts
a widening conversion that forces the argument to have the same type as the parameter.
Proper programming style would use an explicit conversion of the argument. There
must also be the same number of arguments in a call as there are parameters in the
method heading, or a compiler error message results.

When a method has several parameters of the same type, be careful that the argu-
ments are in the correct order. For example, given the following heading for a method
that computes the amount of water resulting from snow melting during one day at a
specified temperature,

public double meltEstimate(int temperature, int snowDepth)

the following call is syntactically correct, but the arguments are clearly reversed and
produce a meaningless result.

runOff = meltEstimate(237, –12);



7.5 Declaring Methods | 313

This example also demonstrates that we can pass a literal constant as an argument.
Changes to the parameter do not affect the literal constant argument when a simple

type is being used. But what about literals of type String, which is a reference type?
Wouldn’t a change to the parameter change the argument? For many reference types
the answer would be yes, but String is an immutable class.

There is no way to change a string object. We can only assign a new value to a
String variable. Because each string value occupies a different place in memory, the
effect of assigning a new value to a String variable is to store a different address in it.
A parameter of type String is initially given a copy of the address of the string literal,
and when we assign it a new value, the address is replaced by the address of the new
value. The argument is left unchanged. Figure 7.6 illustrates what happens when we
change the value of a parameter of type String.

In contrast to the simple types and immutable classes like String, there are classes
that provide methods for directly changing instance fields. For example, Java allows us
to write a method that takes a Frame as a parameter, and adds a label containing the

Address 7394

String arg1

Address 7394

String param1

Call

During execution param1 = "Some other string";

Argument Parameter

Address 7394

String arg1

Address 7511

String param1

Return

Address 7394

String arg1 String param1

Memory

7394

Address

7511

Contents

"Argument string"

"Some other string"

Figure 7.6 The effect of assigning a new value to a reference type parameter



314 | Chapter 7:  Classes and Methods

Address 2015

Frame arg1

Address 2015

Frame param1

Call

During execution

Argument Parameter

Address 2015

Frame arg1

Address 2015

Frame param1

Return

Address 2015

Frame arg1 Frame param1

2015

Address

label1
field1
button1

Contents
Memory before call

2015

Address

label1
field1
button1
label2

Contents
Memory after call

label2 = new Label("Java");
param1.add(label2);

Figure 7.7 The effect of changing the fields of a reference type parameter

string "Java" to the frame. The method’s parameter receives the address where the
Frame is stored. Calling add with the parameter directly changes the same Frame that
the argument refers to.

Figure 7.7 shows this process, and you should carefully compare it to Figure 7.6 to
be sure that you understand the difference. Assigning a new value (a different object) to
a reference type parameter does not change the object to which the argument refers. But
changes to the fields of the object referred to by the parameter are made to the argu-
ment object.

We recommend that you avoid modifying the contents of a reference parameter
within a method. Our example of passing a Frame to a method that adds a label to it is
poor programming practice. We used this example only to show that a reference param-
eter could be changed. However, reference parameters should not be changed. Although
Java permits us to write a method that changes its parameter, when another program-
mer reads a call statement, his or her expectation is that the object referred to by the
argument is unchanged.

Because it is poor practice to do so, Java programmers have adopted the convention
that a reference value passed as an argument to a method should not be changed. In

Java, arguments should be used only for sending data
into a method. A method that changes its arguments
is said to have a side effect. That is, it makes a change
to values outside of itself, in a manner that isn’t
expected.

Side effect Any change made by a method to values
that are declared outside of its block that isn’t explicit
in its interface



7.5 Declaring Methods | 315

A Parameter-Passing Analogy

To help you remember the behavior of simple and reference parameters, we offer
another analogy. Suppose you have in your hand a slip of paper and you are talking to
someone who has another slip of paper. You are like the call and the other person is like
the method. You read to her what’s written on your paper and she writes it down. If
your slip contains a simple type, such as a number representing the current temperature,
she can use her copy of that number to perform some task. She could also replace the
number with a different one. When she is done, she throws away her paper and your
paper remains unchanged. (See Figure 7.8.)

Now suppose your slip of paper contains the address of a house (a reference type).
The other person can use a copy of the address to go look at the house. If the person
changes the address on the slip of paper (assigns a new value to the reference type
parameter), then that person can go to a different house but she would no longer have
the address of the first house. When done, the person throws away her paper. Your slip
of paper still has the original address and so you can go and look at the house, and you
find it unchanged.

Lastly, suppose that you again have an address on your slip of paper, but this time
the person goes to the house and, instead of just looking at it, she goes inside and
rearranges the furniture. When she is done, she throws away her paper, but your paper

 125 MAIN ST
SPRINGFIELD

 MA  01210
 

 125 M
AIN S

T

SPRIN
GFIEL

D

   MA
 01210



 210 O
AK AV

E

ACTON
 CT

03451

Figure 7.8



316 | Chapter 7:  Classes and Methods

Receives

Returns

Changes

Simple Type

Parameter

???

???

Reference Type

Parameter

???

???

Figure 7.9 Method mechanisms for implementing a responsibility

still has the address of the house. When you go to the house, you find that its contents
have changed.

Note that in every case, your slip of paper remained unchanged. In Java, the argu-
ment is never affected by a method call. But in the last situation, the method made
changes to the object at the address it was given. So even though the address in the
argument was untouched, the object it refers to has been altered. Whenever you are
writing a method that changes a reference parameter, and you are unsure about how the
operation is going to behave, stop and ask yourself, “Am I going inside the house, or am
I going to a different address?”

Implementing a Responsibility as a Method

Once you have the design for the responsibilities listed on the CRC card, you need to turn
each into Java code that implements it. Observers return information, transformers change
information, and observers, constructors, and transformers may all receive information.
We have already seen that parameters enable methods to receive information. How do we
return information, and how do we change values? The mechanisms vary somewhat
depending on whether the information is a simple type or a reference type. Figure 7.9
shows the mechanisms that we need and which ones we now know how to achieve.

As you might expect, one way of returning information from a method is to write it
as a value-returning method. Recall that a value-returning method is called from within
an expression and returns a value that takes its place in further computations. In our
discussion of the syntax for method headings we saw that a value-returning method
includes the type or class of its return value preceding the name of the method. For
example, if we want to return a String from the knowFirstName instance method, we
write the following heading (our CRC card indicates that it has no parameters).

public String knowFirstName()

The heading tells Java that the method returns a value. The class name allows Java
to determine whether the value that it returns is compatible with the expression that
contains the call. For example, we can’t call knowFirstName in an expression that tries
to assign its return value to a boolean variable. But how do we actually return a value?
We use a return statement. Here is the syntax template for this new statement.

TE
AM
FL
Y

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

Team-Fly® 



7.5 Declaring Methods | 317

Receives

Returns

Changes

Simple Type

Parameter

return statement

???

Reference Type

Parameter

return statement

???

Figure 7.10 Method mechanisms for implementing a responsibility

We write the return statement at the point in the method where we are ready to
return control to the calling expression. The expression in the return statement com-
putes the value that is returned. The result of the expression must be compatible with
the class or type specified in the method’s heading.

Note that a value-returning method enables us to return just one value. What if we
need to return multiple values? Then we bind them together into an object that is
returned. Our scenario discussions should reveal when a responsibility must return an
object rather than a simple value, so this should never come as a surprise. Figure 7.10
shows the interface implementation mechanisms we have seen.

Now we consider mechanisms for changing values. Changing simple types can’t be
done directly in Java. We use a value-returning method and simply replace the value
that was passed to it. For example,

value = Math.abs(value);

As we saw earlier, changing a reference type parameter within a method is poor
practice. Instead of passing the object we wish to change as a parameter, we define an
instance method that has direct access to the fields of the object. You might be tempted
to think that the instance fields are like extra parameters to the method, but there is a
big difference: They are not copied when the method is called. Remember that they are
declared in the same block as the method.

Class methods also have access to fields, but as you might expect, they can access
only the class fields. Note that when a method changes a class field, it is not changing a
specific instance—it is changing a value accessible to all instances of that class.

Now we have seen the basic mechanisms that Java provides for implementing a
method interface, and we can fill in the blanks from Figure 7.10 as shown in Fig-
ure 7.11.

   return  expression  ;

ReturnStatement



318 | Chapter 7:  Classes and Methods

Receives

Returns

Changes

Parameter

return statement

return with
replacement assignment

after method returns

Simple Type

Parameter
Instance method accesses field of object without changing.

return statement


Implement as instance method�
Implement as class method

Reference Type

Figure 7.11 Method mechanisms for implementing a responsibility

Here is the implementation of the knowFirstName observer, within the declaration
of class Name. We examine the implementation of the remaining observer responsibili-
ties of Name in the Case Study at the end of the chapter.

public class Name
{
static final String PUNCT = ", "; // Class constant
// Instance variables
String first;
String middle;
String last;
// Declare methods that implement responsibilities of Name
public String knowFirstName()
{
return first;

}
}

There is one last bit of Java syntax that we need for implementing the responsibili-
ties of Name. We must still see how to write a constructor.

Constructors

Now that we know how to write a method, writing a constructor is easy. Syntactically, a
constructor heading looks just like other method headings except that its name is the



7.5 Declaring Methods | 319

same as the name of the class, and it has neither a return type nor the keyword void.
Just as with a normal method, the heading is followed by a block.

For example, we can write the constructor for a Name as follows.

public Name(String firstName, String middleName, String lastName)
{
first = firstName;
middle = middleName;
last = lastName;

}

The constructor might be invoked with a statement such as

someName = new Name("Martha", "Bette", "Casey");

A constructor is a special kind of method that is called when new instantiates the
object. Like an instance method, it has access to all of the instance fields of the object.
But because the object has not yet been given a name, its call can’t be written in the
usual manner with an object name and a period preceding the method name. Because a
constructor is like an instance method, we never use the static modifier in its heading.

You might think that constructor Name returns a value of class Name, but that’s the
job of the new operator. When you use new, it looks at the type of the constructor and
creates an empty object of that type. It then calls the constructor, which has access to its
fields, and thus can give them initial values. When the constructor returns, new returns
the initialized object for use in the expression. One way to think of a constructor invo-
cation is that new takes the place of the object name and period until the object value is
given a name (by assigning it to an object identifier). In our example, the expression
assigns the initialized object value to an identifier of class Name called someName.

Because a constructor is called when an object is instantiated, its primary function
is to initialize fields within the object. Some of these values may be supplied through
parameters while others may be constants (called default values). In some cases, a con-
structor may perform more complex work, such as calculating a value for a field from
several parameters, accessing a file for its initial values, and so on. The majority of
constructors that we write in this text, however, simply initialize fields from parame-
ters and constants.




Modifiers      ClassIdentifier  (    TypeName    Identifier    ,  TypeName    Identifier     . . .       )    

 ConstructorHeading



320 | Chapter 7:  Classes and Methods

7.6 Packages
As we noted previously, Java lets us group related classes together into a unit called a
package. Classes within a package can access each other’s nonprivate members, saving
us programming effort and making it more efficient to access their data. The other
advantage of packages is that they can be compiled separately and imported into our
programs.

Together with the access levels, packages provide the means for implementing
encapsulation because they allow us to distribute our classes as Bytecode files. The
unreadable nature of Bytecode prevents users from seeing the implementation details.

Package Syntax

The syntax for a package is extremely simple. We’ve been writing our applications as
unnamed packages all along, so all we have to do is to specify the package name at the
start of the application. The first line of a package is the keyword package followed by
an identifier and a semicolon. By convention, Java programmers start a package identi-
fier with a lowercase letter to distinguish package names from class names.

package someName;

After this we can write our import declarations and then one or more declarations
of classes. Java calls this a compilation unit, and its syntax diagram is shown here.

As you can see from the syntax diagram, we can write a series of class declara-
tions following the import declarations. Those classes are members of the package. All
of the package members (the classes) have access to each other’s nonprivate members.
Recall that we said that a field or method that doesn’t have an access modifier has pack-
age access.

Classes that are imported into the package can be used by any of the classes
declared in the package. From the perspective of the imported classes, the declared
classes are user code and thus can only access their public members. Note that
imported classes are not members of the package.

packageIdentifier;

ImportDeclaration 

Class

 . . .  

. . .  

Package



7.6 Packages | 321

Although we can declare multiple classes in a compilation unit, only one of them
can be declared public. The others must have the package level of access. If a compila-
tion unit can hold at most one public class, how do we create packages with multiple
public classes? We have to use multiple compilation units, as we describe next.

Packages with Multiple Compilation Units

Each Java compilation unit is stored in its own file. The Java system names the file
using a combination of the package name and the name of the public class in the
compilation unit. Java restricts us to having a single public class in a file so that it can
use file names to locate all public classes. Thus, a package with multiple public
classes must be implemented with multiple compilation units, each in a separate file.

Using multiple compilation units has the further advantage that it provides us with
more flexibility in developing the classes of a package. Team programming projects would
be very cumbersome if Java made multiple programmers share a single package file.

We split a package among multiple files simply by placing its members into separate
compilation units with the same package name. For example, we can create one file con-
taining the following code (the ... between the braces represents the code for each class):

package someName;
public class One{ ... }
class Two{ ... }

and a second file containing:

package someName;
class Three{ ... }
public class Four{ ... }

with the result that the package someName contains four classes, all of which have
access to each other’s nonprivate members. Two of the classes, One and Four are pub-
lic, and so are available to be imported by user code.

Many programmers simply place every class in its own compilation unit. Others
gather the nonpublic classes into one unit, separate from the public classes. How you
organize your packages is up to you, but you should be consistent to make it easy to
find the members of the package among all of its files.

How does the Java compiler manage to find these pieces and put them together?
The answer is that it requires that all of the compilation unit files for a package be kept
in a single directory or folder. For our preceding example, a Java system would store the
source code in files called One.java and Four.java in a directory called someName.

Splitting a package among multiple files has one other benefit. Each compilation
unit can have its own set of import declarations. Thus, if the classes in a package need
to use different sets of imported classes, you can place them in separate compilation
units, each with just the import declarations that are required.



322 | Chapter 7:  Classes and Methods

Problem-Solving Case Study
Implementing the Name Class

Earlier in the chapter we showed the CRC card design for a class called Name. Here we com-
plete its implementation. Here is the CRC card for the class.

We need to develop a method algorithm for each of the responsibilities. We’ve already done
this for the first two responsibilities, but here we want to take a moment to revisit our choice
of internal representation.

Internal Representation

Because we already have the interface design, we can skip ahead to specifying the internal
representation for the class, after which we apply our algorithmic problem-solving techniques
to each of the methods.

Our initial approach was to use three separate strings to represent the parts of the name.
But we could conserve storage space by combining all of the parts of a name into one String

Class Name: Name Superclass: Subclasses:

Responsibilities Collaborations

Create itself (First, Middle, Last)

Know its first name

return String

Know its middle name

return String

Know its last name

return String

Name in firstMidLast form

return String

Name in lastFirstMid form

return String

Are two names equal?
return boolean

Compare two names

 return int 



None

None

None

None

String

String

String

String



Problem-Solving Case Study | 323

Implementation using three strings

last

first

middle

wholeName

Martha

Bette

Casey



MarthaBetteCasey

Implementation using one string
and two int variables

midStart

lastStart

Figure 7.12 Two possible implementations of a name object

variable. Then the JVM would have to store just one address instead of an address for the start
of each string that holds a part of a name.

Along with the single string, we would use a set of int variables to record the character
position where the middle and last parts of the name begin in the string. Retrieving a part of a
name is then a matter of calling the substring method using the int variables as parame-
ters. For example, if the start of the middle name is stored in the string at a position recorded
by the int variable midStart and is followed by the last name at position lastStart, then
we would retrieve the middle name with the following call:

middleName = wholeName.substring(midStart, lastStart);

This approach sounds attractive, but we’ve actually started down a dead-end path to illus-
trate a point. This representation has some merit, but it also has some disadvantages. Before
you read the next paragraph, stop and think about what the disadvantages might be. Then read
on and see if you’ve spotted them all.

The most obvious disadvantage is that we are making the computer perform extra opera-
tions to retrieve the parts of a name. We have traded processing speed for some saving in
memory space. Secondly, the more complex the implementation, the more likely it is to have
errors. And lastly, we may not really be saving any memory space. Let’s consider this last point
more closely.

Each part of the name (except the first name, which starts at zero) has a corresponding
int variable, which in many systems takes up the same space as the address of a String
object. So as Figure 7.12 shows, we still use the same amount of space! Have we gone to all
this trouble for nothing? Not quite.

On some systems an address takes up more space than an int, so sometimes we do save
space. And some systems allocate more memory for a string than is required to hold the exact
number of characters. Combining all the strings into one saves that wasted space.

Thus, any reduction in space is dependent on the particular Java system. Yet for every sys-
tem, we have increased the processing time and the likelihood of errors in the code. The
amount of space we save may be significant if we are storing millions of names, but for a
small number it is a tiny portion of the computer’s memory.

The point we set out to make is that sometimes the simplest implementation is the best.
While it is good to explore other possibilities, be sure to weigh the benefits against the costs,
keeping in mind how the object may be used.



324 | Chapter 7:  Classes and Methods

Responsibility Algorithms

We’ve chosen the simpler implementation of the Name class with a separate string for each part
of the name. The strings are instance variables. With this representation the algorithm for the
constructor is trivial. We just assign the parameters to the corresponding instance variables.

Here is the algorithm for the constructor (which we coded earlier).

public Name(String firstName, String middleName, String lastName)

It might seem that this implementation violates the encapsulation. We are directly storing the
address of a string supplied by the user. Shouldn’t we make a copy of the string so that we
have our own internal version of its contents? Recall that String is an immutable class.

If String objects were mutable, the answer would be yes because the user could directly
change the contents of our object. That could lead to side-effect errors that would be difficult
to locate. But the immutability of String objects makes them immune to such side effects.
We need to make a copy only when a constructor is passed a mutable object.

The algorithms for the basic observers also are simple. They just return the corresponding
instance variable. Here is the algorithm for the observer that returns the first name. The other
basic observers are equally simple.

public String knowFirstName()

public String knowMiddleName()

public String knowLastName()

The preceding algorithms illustrate a particular aspect of object-oriented programming.
Many classes contain large numbers of trivial methods whose purpose is simply to ensure
encapsulation of instances. Once an interface has been designed, it is possible to code much of
its implementation with a minimum of algorithmic problem solving. There may then be only a
few methods left that require additional thought.

The next two responsibilities on the CRC card return the name in different formats. These
algorithms merely have to concatenate the parts of the name in different orders. In the case of
lastFirstMid, we use the class constant called PUNCT, which we defined earlier.

return last

return middle

return first

Set first to firstName
Set middle to middleName
Set last to lastName



Problem-Solving Case Study | 325

public String firstMidLast()

public String lastFirstMid()

The next responsibility on the CRC card is equals. Objects of type String have an
equals method, so we can use this to compare all of the parts of a Name object to another
name that’s supplied as a parameter. Here’s the algorithm for equals.

public boolean equals(Name otherName)

The last responsibility of Name is compareTo. We can use the compareTo method of
class String to compare last names. If the last names are equal, we compare first names. If
the first names are equal, we compare middle names. Only if all three are equal can we say
that the names are equal. Is that all we have to do? Not quite. As we’ve seen before, names
should be converted to all upper or lower case before they are compared.

public boolean compareTo(Name otherName)

Notice that in the preceding two algorithms we directly access the fields of otherName
rather than use its observer methods to retrieve their values. Because these are instances of
the same class and they are declared with package level access, their methods are allowed to
access each other’s fields. The accesses are all occurring inside of the capsule, so there is no
violation of the encapsulation.

Our design is now complete and can be coded in Java. Here is the complete code for the
name package. (From this Case Study on we omit the list of variables in order to save space.)

Set result to last.toUpperCase().compareTo(otherName.last.toUppercase())
if result is not zero

return result
else

Set result to
first.toUpperCase().compareTo(otherName.first.toUpperCase())

if result if not zero
return result

else
return

middle.toUpperCase().compareTo(otherName.middle.toUpperCase())

return
first.equals(otherName.first) and
middle.equals(otherName.middle) and
last.equals(otherName.last)

return last + punct + first + “ “ + middle

return first + “ “ + middle + “ “ + last



326 | Chapter 7:  Classes and Methods

Package

package name;

public class Name
// This class defines a name consisting of three parts
{
// Class constant
final String PUNCT = ", ";      // Punctuation for formatting
// Instance variables
String first;
String middle;
String last;

// Constructors
public Name(String firstName, String middleName,

String lastName)
// Initializes a Name object with first, middle and last name
{
first = firstName;
middle = middleName;
last = lastName;

}

// Basic observers that return the value of each field

public String knowFirstName()
{
return first;

}

public String knowMiddleName()
{
return middle;

}

public String knowLastName()
{
return last;

}

// Additional observers

public String firstMidLast()
{
return first + " " + middle + " " + last;

}

public String lastFirstMid()
{
return last + PUNCT + first + " " + middle;

}

TE
AM
FL
Y

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

Team-Fly® 



Problem-Solving Case Study | 327

public boolean equals(Name otherName)
{
return
first.equals(otherName.first) &&
middle.equals(otherName.middle) &&
last.equals(otherName.last);

}

public int compareTo(Name otherName)
{
int result;
result = last.toUpperCase().compareTo(othername.first.toUpperCase());
if (result != 0)
return result;

else
{
result = first.toUpperCase().compareTo(otherName.first.toUpperCase());
if (result != 0)
return result;

else
return
middle.toUpperCase().compareTo(otherName.middle.toUpperCase());

}
}

}

Testing

The Name class contains eight methods. Each one should be tested. As you can see, designing
a class and writing its code is just the beginning of the process. Testing can be as much work
or more.

In order to test the methods of a class, we
need to write an application that can call each
method. We call such an application a driver.

The class we have just written is contained
in the name package and so we can simply
import it into the driver with a statement like
the following:

import name.*;

Once the package has been imported, our driver has access to all of the public interface
components, and we simply need to write statements that call each of the methods with the
necessary arguments to test that their responsibilities are met. In principle this sounds
straightforward. But with eight methods, we must carefully write out a plan that lists every
test to ensure that we don’t miss any cases.

Because testing a package requires some new organizational concepts, we leave the devel-
opment of the driver for the Name class to the Testing and Debugging section that follows.

Driver A simple application class that is
used to call methods being tested. The use of
a driver permits direct control of the testing
process.



328 | Chapter 7:  Classes and Methods

Testing and Debugging

Now that our code is becoming more complex, we need to extend our formal test plan
to help us organize the larger number of tests. In Chapter 6 we introduced the test plan
as a table with four columns: Reason for Test Case, Input Values, Expected Output, and
Observed Output. Our test plan was written for a single method in a class.

With the large number of methods in a typical package, it’s more convenient to
combine multiple tests into a single driver. Thus, to help us write this driver, we expand
the test plan to include Class, Method, and Test Number columns. Together with the
class and method names, the test number uniquely identifies what’s being tested.

The simplest approach to developing a package test plan is to create an empty table
with seven columns and as many rows as there are methods. Insert the class and method
names in the order that they appear in the code. Then, for each method, determine the
number of different tests that are needed and add the necessary rows to the table, filling
them in before moving on to the next method.

For many methods, such as basic observers, there may be just a single test. Methods
with branches have multiple tests. Once all of the tests for a method are listed, you can
number them. As an example, here is a test plan for our Name class. We omit the empty
Observed Output column here to save space.

Class Method Test # Reason for Test Input Values Expected Output

Name Name 1 Constructor "John", Name object with 
"Kirk", "Herrel" three fields

Name knowFirstName 1 Observer instance from "John"
constructor test

Name knowMiddleName 1 Observer instance from constructor test "Kirk"
Name knowLastName 1 Observer instance from constructor test "Herrel "
Name firstMidLast 1 Observer instance from constructor test "John Kirk 

Herrel"
Name lastFirstMid 1 Observer instance from constructor test "Herrel, John 

Kirk"
Name equals 1 Equality test instance, second object with true

same values

Name equals 2 Inequality test instance, second object with false
other values

Name compareTo 1 Equality test instance, second object with 0
same value

Name compareTo 2 Greater than test instance, second object with Positive int
lesser value

Name compareTo 3 Less than test instance, second object with Negative int
greater value



Testing and Debugging | 329

Once we have a plan of all the tests, it is simply a matter of writing a driver to per-
form them. Below is the code for the driver to test the Name class in the name package.

import name.*;

public class PersonDriver
// This class is a test driver for the Name class in package name
{
static Name testName;   // Name object for testing
static Name otherName;     // Another Name object

public static void main(String[] args)
{
// Output headings
System.out.println("Test Results for Package name");
System.out.println();
System.out.println("Class     Method         Test#  " +

" Expected Output       Observed Output");
// Constructor test
testName = new Name("John", "Kirk", "Herrel");
if (testName.knowFirstName().equals("John") &&

testName.knowMiddleName().equals("Kirk") &&
testName.knowLastName().equals("Herrel"))

System.out.println("Name      Name             1    " +
"3-field Name           3-field Name");

else
System.out.println("Name      Name             1    " +
"3-field Name           Fields don't match");

// Basic observer tests
System.out.println("Name      first            1    " +
"John                   " + testName.knowFirstName ());

System.out.println("Name      middle           1    " +
"Kirk                   " + testName.knowMiddleName ());

System.out.println("Name      last             1    " +
"Herrel                 " + testName.knowLastName ());

// Additional observer tests
otherName = new Name("John", "Kirk", "Herrel");
System.out.println("Name      equals           1    " +
"true                   " +
testName.equals(otherName));

otherName = new Name("John", "Patrick", "Herrel");
System.out.println("Name      equals           2    " +
"false                  " +



330 | Chapter 7:  Classes and Methods

testName.equals(otherName));
otherName = new Name("John", "Kirk", "Herrel");
System.out.println("Name      compareTo        1    " +
"0                      " +
testName.compareTo(otherName));

otherName = new Name("John", "Kirk", "Altman");
System.out.println("Name      compareTo        2    " +
"Positive int           " +
testName.compareTo(otherName));

otherName = new Name("John", "Kirk", "Zigman");
System.out.println("Name      compareTo        3    " +
"Negative int           " +
testName.compareTo(otherName));

}
}

Here is the output from running PersonDriver.

We have kept the driver as simple as possible to emphasize how the test plan is con-
verted into a program. If you were writing a driver for your own use, you would probably
want to add features such as displaying a summary of the testing at the end of the run.

You may also notice that the test for the constructor depends on the correct func-
tioning of the basic observers. In fact, by the time we’ve tested the constructor, we’ve
effectively tested every basic observer.

The encapsulation of an object makes us dependent on its user interface for the
testing process. We can’t check the effects of a constructor without using a basic
observer, and we can’t test a basic observer without first calling a constructor to create
an object. However, we can at least see that an error has occurred in one or more tests,
which tells us to reexamine our code.

Having separate tests for the basic observers helps us to determine whether an
error detected in a constructor is really with the constructor or with one of the
observers. If we see an unexpected result from both a constructor and a basic observer



Testing and Debugging | 331

that was used to check the constructor, we can assume that the error is really in the
observer.

Testing and Debugging Hints

1. Make sure your class designs are encapsulated to avoid the possibility of side-effect
errors.

2. Use the CRC card process to design the user interface before you begin to think
about the implementation.

3. Make classes immutable unless the abstraction truly requires its objects to change
without being copied. Immutable objects are less prone to side effects.

4. When choosing an internal representation, carefully consider the tradeoff between
saving space or improving speed and the complexity of the required code. One ben-
efit of encapsulation is that you can start with a simple implementation and then go
back and make improvements after you have the class working.

5. Consciously consider whether data should be associated with a class, an instance
(object) of the class, or a particular method call.

6. When writing methods, be careful not to use parameter names, local names, or
method names that duplicate class or instance identifiers. Parameters and local identi-
fiers hide class and instance identifiers with the same name. (More on this in the next
chapter.)

7. Don’t write a semicolon at the end of a class heading or at the end of a method
heading.

8. Be sure that the braces that begin and end a class are properly matched. It requires
some effort to check that the braces match because they may be separated by many
lines of code and multiple nested blocks. Being careful about consistently indenting
your code makes this easier.

9. A method heading always has a pair of parentheses, even when there are no
parameters.

10. Remember that arguments and parameters are matched by their position and the
types of each argument must be compatible (in the sense of the assignment opera-
tor) with its corresponding parameter.

11. Assigning a new value to a parameter of a reference type causes it to refer to a new
place in memory and leaves the arguments unchanged. Modifying the contents of
the object at the location specified by the parameter modifies the same object that
the argument refers to. Such side effects are considered poor programming practice.

12. Only one value (simple or reference type) can be returned with a return statement.
Every value returning method must have at least one return statement.

13. A constructor must have the same name (including capitalization) as the class. Its
heading does not include either a return type or the keyword void. Constructors
typically take the public modifier.



332 | Chapter 7:  Classes and Methods

Package Name

Class Name Comments

name
Name

Constructors: Name(first, middle, last)

Value-Returning Instance Methods:
knowFirstName() All return String unless otherwise noted
knowMiddleName()
knowLastName()
firstMidLast()
lastFirstMid()
equals(otherName) Returns boolean
compareTo(otherName) Returns int

14. Use the package level of access for each data field unless your design specifically
calls for it to be public, protected, or private.

15. Be sure to store multifile packages in the same directory. Otherwise, you get an
error message saying that the classes in the package can’t be found.

16. Make a test plan and use it to write your driver(s).

Summary of Classes

Summary
Encapsulation is the separation of the implementation of a class from external code
except through a formal interface. Abstraction is the separation of the logical properties
of an object from its implementation. Abstraction helps us to design a well-encapsu-
lated class. Together they lead to classes that are immune to side-effects, that are easily
modified and reused.

Abstraction can be divided into data abstraction (separating the internal and external
representations of the data stored in a class) and control abstraction (separating the log-
ical properties of operations from their implementations).

Class responsibilities can be divided into four categories: constructors, observers,
transformers, and iterators. Constructors create objects, observers return the abstract
contents of objects, and transformers directly change the contents of objects. When an
object has multiple parts that can be accessed in some sequence, an iterator is used to
step through the parts.



Quick Check | 333

Objects can be mutable or immutable. Immutable objects do not have transformer
operations.

Java allocates memory space for objects from a free pool in memory. When an object
no longer has any identifiers that refer to it, the garbage collector returns its space to
the free pool. Because instance data is associated with an object, its lifetime starts with
allocation and ends when it becomes garbage (is unreachable). The lifetime of class data
is for the entire execution of an application. Local data exists only for the lifetime of an
individual method call.

Methods provide the means for implementing the responsibilities of a class. We
design the method interface from the CRC card specification of a responsibility. The
interface includes the parameters that receive the arguments that are passed to the
method, the method’s return value (if any), and access to class and instance fields of an
object. We categorize the information that flows through the interface as receives,
returns, and changes.

A method heading defines the parameters that receive the corresponding arguments
from a call to the method. In Java a copy of the argument is given to the method. Sim-
ple type arguments that are passed to a method cannot be modified by it. Assigning a
new value to a reference type parameter doesn’t change the argument because the
assignment causes the address stored in the parameter to refer to a different object.
However, the object associated with a reference type argument can be changed by a
method if it assigns new values to the fields of the object, but this is bad practice.

The return statement in combination with a value-returning method provides a
mechanism to return a value from a method. If a method’s responsibility is to change
the values in an object, the method should be an instance method applied to the object
and not a method that takes the object as a parameter. An instance method has the
option to receive, return, or change any object field.

A constructor is a special type of method that is called with the new operator to ini-
tialize a newly created object. The constructor has access to all the fields of the new
object. The heading for a constructor doesn’t include a return type or the keyword void.
The name of a constructor is the same as the name of its class including capitalization.

A package collects a set of related classes into a common structure that can be
imported by other classes. The Java compiler allows just one public class per compila-
tion unit, so a package consists of multiple files, all of which begin with identical pack-
age statements.

Test plans are especially important for verifying the correct operation of a new class
or package. Because there may be many methods to test, we need to take an organized
and methodical approach to testing each one with no case omitted. We can often com-
bine multiple tests into a single driver to save work.

Quick Check
1. What are the benefits of a well-designed interface? (p. 294)
2. What is abstraction? (p. 294)
3. Which do you design first, the class interface or the implementation? (p. 294)
4. What the four categories of responsibility? (pp. 298–299)



334 | Chapter 7:  Classes and Methods

5. (True or False?) Transformer operations may be defined on an immutable object.
(p. 300)

6. What is the default modifier for a declaration? (p. 310)
7. What is the purpose of a constructor for a class? (pp. 318–319)
8. What is an iterator? (pp. 298–299)
9. Before this chapter, you have written three method declarations on numerous

occasions. What are they? ( p. 308)
10. What do we call the transfer of data between the arguments and parameters in a

method call? (pp. 310–311)
11. Distinguish between simple and reference types. (pp. 311–314)
12. When a method is invoked, how does the system match up arguments and

parameters? (p. 310)
13. What does “lifetime of a variable or constant” mean? (p. 304)
14. What is the Java syntactic construct that bundles related classes? (p. 320)

Answers

1. A well-designed interface makes a class easy to use and to debug. 2. The separation of the
logical properties of an object from its implementation. 3. Abstraction dictates that the interface
must be designed first. 4. Constructor, observer, transformer, iterator. 5. False 6. package
7. A constructor is a method that initializes the data fields of a new class instance. 8. An itera-
tor is an operation that allows the user to view members in a collection one at a time. 9. main,
windowClosing, and actionPerformed. 10. parameter passing 11. A variable of a sim-
ple type contains a value. A variable of a reference type contains the address of a value.
12. Arguments and parameters are matched by position: The first argument is copied into the
first parameter, the second argument is copied into the second parameter, etc. 13. ”Lifetime”
refers to the portion of a program’s execution during which a variable or constant is assigned
storage space in memory. 14. package

Exam Preparation Exercises
1. What is the goal of designing a new class?
2. Why is it important to encapsulate a new class?
3. Name two benefits of encapsulating a class’s implementation.
4. Explain the advantages of modifiability.
5. Explain the advantages of reuse.
6. How can exposing implementation details cause an error in a user program?
7. What are the five basic control structures?
8. Constructors have a strange syntax. Explain.
9. Can one object have another object as a part?

10. a. What is data abstraction?
b. What is control abstraction.
c. Differentiate between data abstraction and control abstraction within an

object.
11. Distinguish between class and instance methods at the logical level.



Exam Preparation Exercises | 335

12. Distinguish between class and instance methods at the syntactic level.
13. Distinguish between a parameter and an argument.
14. a. If a parameter is of a simple type, what does the parameter receive?

b. Can the method change the value in the parameter?
c. Is the argument changed?

15. a. If a parameter is not a simple type, what does the parameter receive?
b. Can the method change the value in the parameter?
c. Is the argument changed?

16. Why doesn’t changing a parameter of type String change the argument?
17. What does a constructor do? Give an example.
18. a. What does a transformer do? Give an example.

b. What does an observer do? Give an example.
19. a. What does an iterator do?

b. Distinguish between a transformer iterator and an observer iterator.
20. Fill in the following table showing three categories of data, specifying the life-

time of each and what code can access each.

21. How does the Java compiler distinguish between class data and instance data?
22. a. From where does the JVM get the space it needs to create an object?

b. Define allocate.
c. Define deallocate.
d. Define dynamic memory management.

23. a. What does it mean when we say an object is unreachable?
b. What is the term used for unreachable objects?
c. What is the process of going through memory and reclaiming the memory

assigned to unreachable objects?
24. a. What is a compilation unit?

b. Can there be many public classes in one compilation unit?
c. Where is each compilation unit stored?
d. How is the file containing a compilation unit named?
e. Can multiple public classes be put in the same package?

25. a. What are the two places in which the data abstraction is visible to the user?
b. Should the public constants be initialized in their declarations or in assign-

ment statements?
c. Can variables be marked public in Java?

Types of Data Lifetime of Data From Where Data Is 
Accessible



336 | Chapter 7:  Classes and Methods

26. Distinguish between an immutable and a mutable object.
27. (True or False?) Transformer operations may be defined on a mutable object.
28. a. How can you change a value in an immutable object?

b. How do you create a new object with the same values as another object?

Programming Warm-Up Exercises
1. Declare the following instance variables for a class called AddressLabel: name,

address, state, zipCode, city, and country. zipCode is a long; the others
are strings.

2. Write the heading for a copy constructor for class AddressLabel that changes
the address field.

3. Write the heading for a constructor for class AddressLabel that has four
String parameters, name, address, city, and state, and one long parameter,
zipCode. The country is set by default to the United States.

4. Write the heading for a constructor for class AddressLabel that has four
String parameters: name, address, state, and country and one long param-
eter, zipCode.

5. What basic observer operations should our AddressLabel class have?
6. Declare a package named somePackage with headings for public class

AddressLabel and class PrintLabel.
7. Declare a package named somePackage with headings for public class

AddressLabel and public class PrintLabel.
8. How does Java manage to put all the pieces of a package together?
9. Write the code for a class method call to class Integer, followed by an instance

method call to the newly created object.
10. Write a Java statement that declares an integer-returning public method

named myExample.
11. Write a Java statement that assigns 1066 as the return value of myExample.
12. Design and declare an integer method that inputs an integer value from a

TextField and returns it.
13. Design and declare a float method that inputs a float value from a

TextField.

Programming Problems
1. Design and implement an address book object that contains a person’s name, home

address and phone number, business address and phone number, and numbers for
their fax machine, cellular phone, and pager. Write a test plan for the object and
implement a driver that tests it.

2. Design, implement, and test a package of one or more classes to represent a cat-
alog entry for a music library. The objects in the library are albums, which can
be in the form of tapes, records, compact disks, DVDs, and electronic files. Each
album has a title, name of the recording group, name of the record company, the

TE
AM
FL
Y

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

Team-Fly® 



Case Study Follow-Up Exercises | 337

catalog number or URL used to order the recording, number of songs, total play-
ing time, and an index used to identify the album in the library.

3. Design, implement, and test a package of one or more classes to represent a car.
The information associated with a car object is its make, model, production year,
color, vehicle identification number, registration number, and owner’s name and
address.

Case Study Follow-Up Exercises
1. Add an iterator method to the Name class that returns each of the parts of a

name in the order that they are listed in the class. That is, the first time the itera-
tor is called, it returns the first field. The second time it is called, it returns the
middle field, etc. After it returns the last field, it should reset to the first
field for the next call.

2. Modify the test plan and extend the driver program as necessary to test the iter-
ator developed for Exercise 1.





               

To be able to visualize the hierarchical nature of
classes in object-oriented programming.

To be able to demonstrate the concept of inheritance
in a class hierarchy.

To be able to distinguish between overriding and hid-
ing in Java.

To be able to define polymorphism.

To be able to differentiate between deep and shallow
copying of objects.

To be able to use the access rules for Java classes.

To be able to apply the assignment compatibility rules
for objects.

To be able to identify the interface components of a
class in a hierarchy.

To be able to design a derived class to extend an exist-
ing class hierarchy.

To be able to implement a derived class using inheritance.

To be able to use the keywords super and this to dis-
ambiguate references.

To be able to explain the concept of overloading in Java.

Inheritance,
Polymorphism, and
Scope

G
oals



340 | Chapter 8:  Inheritance, Polymorphism, and Scope

In Chapter 7 you saw how to create a new class from a CRC card design by choosing an
internal representation and implementing the responsibilities as methods. Using the CRC
card technique naturally results in a design that is encapsulated. An encapsulated class
has the advantage of being reusable in different programs. We also mentioned that
another form of reuse is to create additional classes that are variations of the base class.
In this chapter we look at how to design and implement such derived classes.

The relationship between derived classes (subclasses) and their superclass is
defined by Java’s rules of inheritance that tell us which parts of the superclass are
automatically included in the derived classes. Another aspect of Java that is similar
to the inheritance rules is called scope of access. Java provides a set of rules that
determine the fields and methods of a class that can be accessed by derived classes,
classes in the same package, user code, and so on. Understanding these rules helps
us to preserve encapsulation as the relationships between classes become more
sophisticated.

8.1 Inheritance
Let’s look at an analogy between the work of an architect and the work of a program-
mer. The way that an architect handles the complexity of a large building design sheds
some light on how we can organize our programming work. The analogy lets us con-
sider the same concepts but without the distraction of Java syntax and semantics.

An Analogy

The architect begins by considering the overall requirements for a building: square
footage, number of occupants, types of usage, size of the building lot, height limits, and
so on. Once some initial decisions are made, the architect is faced with a basic aspect of
any design: the building is composed of floors. In many buildings the floors all have
common characteristics: the same size and shape, the same number and location for ele-
vator shafts, stairways, and utility trunks, and so on. The architect could then begin by
designing a basic empty floor with all of the common elements in place. Once she
installs this plan in the library of the CAD (computer-aided design) program, she can
use it repeatedly as the starting point for designing each floor of the building.

The architect may further decide that there are two main types of floors: office
floors and mechanical equipment floors. The office floors might be of two types: execu-
tive office space and standard office space. Starting from the basic empty floor design,
she adds components such as lavatories and hallways to make an empty office floor.
She can then add offices and conference rooms to the empty space. Each of the four
types of floors is thus derived from the basic empty floor plan and is added to the
library (see Figure 8.1). Drawing the entire building is then simply a matter of creating
an instance of one of these four floor plans for each story.

The architect uses the same process to design the components that make up the
floors. She might design a basic type of office with a door, windows, lights, heating,
wiring, and so forth and then derive several types of offices from that one design. From
a given type of office, such as secretarial, she might further refine the design into sub-
types such as general secretarial, secretary/receptionist, and executive secretary.



8.1 Inheritance | 341

Util.
Trunk

Stair

Elev. Janit.

Util.
Trunk

Stair

Elev. Janit.

Lav. Lav.

Basic empty floor

Util.
Trunk

Stair

Elev. Janit.

Heating/ventilation
Air conditioning

Electrical
transformer

and
distribution

Phone and
data

network

Util
Trunk

Stair

Elev. Janit.

Util.
Trunk

Stair

Elev. Janit.

Lav. Lav.

Executive
Office

Executive
Office

Executive
Office

Executive
Office

Secretary
Receptionist

Secretary
Receptionist

Secretary
Receptionist

Secretary
Receptionist

Executive office floor

Util
Trunk

Stair

Elev. Janit.

Util.
Trunk

Stair

Elev. Janit.

Lav. Lav.

OfficeOffice Office

OfficeOffice Office

Office

Office

Office

Office

Office

Office

Office Office

Standard office floor

Basic empty
floor

Empty office
floor

Mechanical
floor

Executive
office floor

Standard
office floor

Mechanical floor Empty office floor

Figure 8.1 A hierarchy of floor types



342 | Chapter 8:  Inheritance, Polymorphism, and Scope

Creating hierarchies of designs simplifies the architect’s job. She begins each hierar-
chy with the most general form of a building component, such as the basic empty floor,
and then derives new designs by adding details to the more general forms. The new
designs inherit all of the characteristics of the general form, saving the architect from
having to redraw those pieces they have in common. In some cases she replaces existing
parts of a design, as when she substitutes a wider door for a reception area than is in
the basic secretarial office. The replacement part overrides what was originally specified
in the more general form.

In addition to the components of individual floors, the architect can specify charac-
teristics that are common to all floors, such as a color scheme. Each floor inherits these
general properties. Sometimes she hides or deletes portions of the general properties, as
in customizing the color scheme for a particular floor that has been rented in advance
by a company with its own corporate colors. We see later that inheritance, overriding,
and hiding are formally defined mechanisms in Java.

8.2 Inheritance and the Object-Oriented Design Process
Now let’s consider how a class hierarchy originates in the CRC card-design process. At
the end of the filtering phase we sometimes discover that there are several classes that
are similar. For example, in the Address Book example of Chapter 5, we noted the simi-
larity between the Address and Work Address classes. Let’s look at the CRC cards for
some different address objects. There are no class members, so we don’t bother to write
“instance” by each member field.

Class Name: WorkAddress Superclass: Subclasses:

Responsibilities Collaborations 

Create itself (name, company, street, mail stop,
city, state, zip code), Constructor
Know its name, Observer
    return String
Know its company, Observer
    return String
Know its street, Observer
    return String
Know its mail stop, Observer
    return String
Know its city, Observer
    return String
Know its state, Observer
    return String
Know its zip code, Observer  
    return String

Name: Name

Name: First Middle Last

None

None

None

None

None

None



8.2 Inheritance and the Object-Oriented Design Process | 343

These CRC cards might originate in the brainstorming phase or they could result from
a series of scenarios. No matter how they arise, it is quite obvious that they have several
responsibilities in common: Know Its Name, Know Its City, Know Its State, and Know Its

Class Name: BoxAddress Superclass: Subclassess:

Responsibilities Collaborations
Create itself (name, company, box,
city, state, zip code), Constructor
Know its name, Observer
    return String
Know its company, Observer
    return String
Know its box, Observer
    return String
Know its city, Observer
    return String
Know its state, Observer
    return String

Name: Name

Name: First Middle Last

None

None

None

None

NoneKnow its zip code, Observer    return String

Class Name: HomeAddress Superclass: Subclasses:

Responsibilities Collaborations

Create itself (name, street, apartment,
city, state, zip code), Constructor
Know its name, Observer
    return String
Know its street, Observer
    return String
Know its apartment, Observer
    return String
Know its city, Observer
    return String
Know its state, Observer
    return String

Name: Name

Name: First Middle Last

None

None

None

None

NoneKnow its zip code, Observer    return String




344 | Chapter 8:  Inheritance, Polymorphism, and Scope

Zip Code. We can save ourselves duplicate effort by
defining a superclass, Address, that has the common
responsibilities. In addition, two of the classes share the
“Know its company” responsibility. We can thus define
a subclass of Address called Company Address that
becomes the superclass of these two. The third class
directly extends Address with its specific responsibili-
ties. Here are the revised CRC cards:

Class Name: WorkAddress Superclass: CompanyAddress Subclasses:

Responsibilities Collaborations

Create itself (name, company, street, mail stop,
city, state, zip code)
Know its street, Observer
    return String
Know its mail stop, Observer
    return String

Name: Name

None

None

Class Name: Address  Superclass: Subclasses: HomeAddress, 
    CompanyAddress

Responsibilities Collaborations

Create itself (name, city, state, zip code),
Constructor
Know its name, Observer
    return String
Know its city, Observer
    return String
Know its state, Observer
    return String
Know its zip code, Observer
    return String

Name: Name

Name: First Middle Last

None

None

None

Class Name: CompanyAddress Superclass: Address Subclasses: WorkAddress, 
    BoxAddress

Responsibilities Collaborations

Create itself (name, company, city, state,
 zip code)
Know its company, Observer
    return String

Name: Name

None

Superclass A class that is extended by one or more
derived classes (its subclasses)

Subclass A class that is derived from another class
(its superclass)



8.2 Inheritance and the Object-Oriented Design Process | 345

Figure 8.2 shows the relationships between these classes. Address is the most gen-
eral form and is thus at the top of its hierarchy, just below Java’s most general class,
which is called Object.

Class Name: HomeAddress Superclass:  Address Subclassess:

Responsibilities Collaborations

Create itself (name, street, apartment, 
city, state, zip code)
Know its street, Observer
    return String
Know its apartment, Observer
    return String

Name: Name

None

None

Class Name: BoxAddress Superclass: Company Address Subclasses: 

Responsibilities Collaborations

Create itself (name, company, box, city,
state, zip code)
Know its Box (Observer, instance)
    return String

Name: Name

None

Object

Address

HomeAddress CompanyAddress

WorkAddress BoxAddress

Figure 8.2 Address class hierarchy



346 | Chapter 8:  Inheritance, Polymorphism, and Scope

The ability of a programming language to support
the creation of superclasses and subclasses is known as
inheritance. Each of the subclasses inherits the responsi-
bilities that are defined by its superclass, including all of
the responsibilities that it has inherited. In addition, sub-
classes are assignment compatible with the superclasses

above them in the hierarchy. That is, we can assign a WorkAddress object to a WorkAd-
dress variable, a CompanyAddress variable, an Address variable, or an Object variable.

Periodically in the CRC card design process it is useful to look for similarities
among the cards and decide whether a superclass should be created. Another situation
where inheritance is used can be seen when we start to create a new class and realize
that is just a variation of an existing class. For example, a field for input of numeric
values is just an extension of the familiar TextField. We simply have to add getInt
and getDouble methods that read the field and convert it to a numeric value. The
derived class could be called NumericField. There is no need to define an entirely new
class when we can simply extend one that already exists. As you look for things that
are familiar in solving a problem, keep in mind the existing classes.

In our Address example, we collected responsibilities from similar classes to form
a superclass. In the TextField case, we recognize the existence of a class with the
properties that make it suitable as a superclass. Whenever you encounter either of these
situations, you should immediately consider how you can take advantage of it through
inheritance.

8.3 How to Read a Class Hierarchy
In Java, all classes can eventually trace their roots back to the Object class, which is so
general that it does almost nothing; objects of type Object are nearly useless by them-
selves. But Object does define several basic methods: comparison for equality, conver-
sion to a string, and so on.

The Java library defines numerous classes that directly extend the Object class and
thus inherit all of its methods. For example, there is a class called Component that

extends Object with the basic operations needed to
display something in a Frame. We can’t instantiate
objects of class Component directly, however, because
they are incomplete. Java calls such classes abstract.
Returning to our analogy, the architect would never
include the basic empty floor in a building plan, but
uses it instead as the basis for designing floors that
are complete. Similarly, we would never instantiate
an object of an abstract class in a program, but we

use it as the superclass for defining new subclasses that are complete.
The familiar Button and Label classes are subclasses of the Component abstract

class. The TextField class is derived from a class called TextComponent, which is in
turn derived from Component. As you can see, the hierarchy of classes can be multiple
levels in depth, so it can become difficult to keep track of who’s descended from whom.

Abstract A modifier of a class or field that indicates
that it is incomplete and must be fully defined in a
derived class

Derived class A class that is created as an extension
of another class in the hierarchy

Inheritance A mechanism by which one class
acquires the properties—the data fields and methods—
of another class

TE
AM
FL
Y

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

Team-Fly® 



8.3 How to Read a Class Hierarchy | 347

Object

Component

Button Label TextComponent

TextField

Figure 8.3 Hierarchy of component classes

Figure 8.3 shows how these classes are related. We use boxes with their corners cut out
to represent the incomplete nature of the abstract class.

When the architect looks at a floor plan with her CAD program, she sees all of its
parts including those that are derived from the basic empty floor. But when we look at
the documentation for a Java class, we see only the fields that are added by that specific
class, and the name of its superclass.

For example, let’s look at the documentation for the TextField class. Java class
documentation is typically written in a form similar to a class declaration section.

public class TextField extends TextComponent
{
public TextField();
public TextField(int cols);
public TextField(String text);
public TextField(String text, int cols);
public void addNotify();
public boolean echoCharIsSet();
public int getColumns();
public char getEchoChar();
public Dimension minimumSize();
public Dimension minimumSize(int cols);
protected String paramString();
public Dimension preferredSize();
public Dimension preferredSize(int cols);
public void setEchoCharacter(char c);

}

A first glance at the class is somewhat disappointing. Where are the getText and
setText methods that we’ve been using? But wait! The class header says that TextField
extends TextComponent. That one little bit of code tells us that this definition is just part



348 | Chapter 8:  Inheritance, Polymorphism, and Scope

of the story. We have to look at the documentation for TextComponent to determine
what TextField inherits from it. TextComponent is defined as follows:

public class TextComponent extends Component
{
public String getSelectedText();
public int getSelectionEnd();
public int getSelectionStart();
public String getText();
public boolean isEditable();
protected String paramString();
public void removeNotify();
public void select(int selStart, int selEnd);
public void selectAll();
public void setEditable(boolean b);
public void setText(String s);

}

Now we see where getText and setText are defined. We also see additional meth-
ods for dealing with selected text within the field. There is one feature of Java in this
definition that we haven’t examined yet. The modifier protected is used with method
paramString. We’ll take a closer look at this modifier later in this chapter when we
discuss Java’s rules for accessing fields in other classes.

The class heading for TextComponent indicates that there is still more, because it
extends the class Component. If we look at the documentation for that class, we find
that it defines 75 more methods. We’ll just list a few of them here, together with the
class heading.

public abstract class Component extends Object
{
public void enable();
public void disable();
public void hide();
public void show();
public boolean isEnabled();
public boolean isVisible();
.
.
.

}

You should notice the use of the abstract modifier in the class heading. Whenever
you see the keyword abstract in a class declaration, it tells you that the class being
defined is incompletely specified and cannot be instantiated.

When a class is declared as abstract, its purpose is to provide a placeholder for a
definition to be supplied in a derived class. Class Component doesn’t have any con-
structors. It doesn’t define the structure of a useful object that we can instantiate.



8.3 How to Read a Class Hierarchy | 349

Instead, it defines a collection of methods that are common to various objects that can
appear in a Frame. By deriving those objects from this common class, Java makes it
easy to ensure that they all behave in a consistent manner.

As we can see from its definition, Component extends Object, which is the top of
the entire hierarchy. We rarely use Object’s methods directly, and several of them are
related to features of Java that are beyond the scope of this text. Here we list just the
ones that are familiar.

public class Object
{
public Object();                   // Constructor
public boolean equals(Object obj);
public String toString();
.
.
.

}

Now that we have the specification for every class that is an ancestor of
TextField, we can determine the methods that it has available. The following table
illustrates how we do this.

TextField TextComponent Component Object

TextField() getSelectedText() enable() equals(Object obj)
TextField(int cols) getSelectionEnd() disable() toString()
TextField(String text) getSelectionStart() hide() .
TextField(String text, int cols) getText() show() .
addNotify() isEditable() isEnabled() .
echoCharIsSet() removeNotify() isVisible()
getColumns() select(int start, int end) .
getEchoChar() selectAll() .
minimumSize() setEditable(boolean b) .
minimumSize(int cols) setText(String s)
paramString() paramString()
preferredSize()
preferredSize(int cols)
setEchoCharacter(char c)

We begin at the bottom of the hierarchy (TextField) and write down all of its
members. In the next column we write the members of its superclass (excluding its con-
structors, because constructors technically aren’t members and they aren’t inherited).
We repeat this process in the third column, adding the members of Component. Note
that Component is written in italics to remind us that it is abstract. Lastly, we write
the members of Object (excluding its constructors) in the fourth column.



350 | Chapter 8:  Inheritance, Polymorphism, and Scope

Overriding

Notice that TextComponent defines a method called paramString. TextField then
redefines (overrides) paramString, substituting its own version of paramString. Thus,

we write the TextComponent member name in color
to indicate that it is redefined by TextField.

Together, the columns in the table tell us every
member that is available in the class TextField.
When we first looked at the documentation for
TextField, it appeared that there were just 14 mem-
bers in the class. Now, however, we can count 32
members in the table, and if we had bothered to list all
of the members of Component and Object, we would

see over 100 members. This example illustrates the power of using inheritance in a hier-
archy of classes. Just as the architect saves effort by defining a hierarchy of building
parts, we can save ourselves a lot of work by using inheritance.

Hiding

In our TextField example, we considered only inheritance of methods, but fields may
also be inherited through the hierarchy. When a derived class defines a field with the

same name as one in its superclass, the field in the
derived class hides the one in the superclass. Java also
distinguishes the case of overriding a static (class)
method with another class method as a form of hiding.
The term overriding technically applies only to
instance methods.

If you look at the TextField hierarchy carefully,
you may notice that nothing is deleted as a result of
inheritance (except constructors). In Java, there is no

way to remove a member that is inherited. We can cover over a member with a replace-
ment member, but we can’t delete it. This is an aspect of the philosophy of object-ori-
ented design: As we go deeper in the hierarchy, we add or change functionality, but we
do not lose functionality. In object-oriented design, a derived class is always an exten-
sion of its superclass.

For example, we would say that a TextField is a TextComponent. In object-ori-
ented design, a fundamental concept is the “is a” relationship between a derived class
and its superclass. A derived class is a form of its superclass. The closest that we can get
to deleting a member of a superclass in a derived class is to override it or hide it with a
member of the same name that does nothing. However, this would be considered poor
programming practice.

Polymorphism

Let’s take a closer look at the mechanizm that allows paramString to have two different
implementations, which is called polymorphism. Object oriented languages, such as Java,

Override To provide an instance method in a derived
class that has the same form of heading as an instance
method in its superclass. The method in the derived
class redefines (overrides) the method in its superclass.
We cannot override class methods.

Hide To provide a field in a derived class that has the
same name as a field in its superclass. To provide a
class method that has the same form of heading as a
class method in its superclass. The field or class method
is said to hide the corresponding component of the
superclass.



8.4 Derived Class Syntax | 351

give us the ability to implement subclasses with
methods that override superclass methods. Our
definition of paramString in class TextField
that overrides the method in superclass
TextComponent is an example. Polymorphism
further enables the compiler and JVM to decide
which version of paramString is appropriate
to call depending on the class of the object to which it is applied. For example, when
paramString is applied to a TextField it has one implementation, but when applied to a
TextComponent, it has another. In object-oriented terms, we say that paramString is
polymorphic. That is, it has multiple forms. Java decides which form to use depending on
the class of the object.

Together with inheritance and encapsulation, polymorphism gives us the ability to
flexibly implement a hierarchy of objects. We use polymorphism to substitute different
implementations of a responsibility as required by variations in the internal representa-
tion of classes at different levels of the hierarchy. For example, Address might repre-
sent the zip code as a single string, but then we might redefine its representation in the
CompanyAddress class so that the four-digit extension is kept separately. Thus, the
Know Zip Code responsibility would be implemented differently in CompanyAddress
than in Address.

8.4 Derived Class Syntax
The declaration of a derived class looks very much like the declaration of any other
class. Here is the syntax template for a class declaration.

The only difference between this template and the one in Chapter 7 is that we’ve
added the optional extends clause that allows us to indicate the superclass that our
new class is derived from. Here’s an example declaration.

public class NumericField extends TextField
{
// Declare new methods that add numeric input to TextField

}

This new class inherits all of the fields and methods of TextField (including
everything TextField has inherited) and then adds some of its own. Is that all there is

ClassModifier extends ClassNameclass   Identifier

ClassDeclaration

{


}

. . .

. . .

Class

Polymorphism The ability of a language to have
duplicate method names in an inheritance hierarchy
and to apply the method that is appropriate for the
object to which the method is applied



352 | Chapter 8:  Inheritance, Polymorphism, and Scope

to implementing a derived class? In terms of syntax, yes. But in terms of semantics,
there is more we need to know.

In Chapter 7, we learned how to create individual classes that are fully encapsulated.
With inheritance and polymorphism we are beginning to create related sets of classes.
Java lets us group related classes in a package so that encapsulation protects the whole
collection. But within the package, Java allows the related classes to communicate
directly. Direct access is more efficient than converting back and forth between external
and internal representations when classes share a common internal representation.

Also, when a derived class overrides or hides members of its superclass, it can no
longer refer to them directly. Java provides additional syntax and semantics that enable
a subclass to access such superclass members when the need arises.

In the next section we thus examine the Java semantics for accessing members
from different places. Then we can return to the specifics of implementing a hierarchy
of derived classes.

May We Introduce...
Ada Lovelace

On December 10, 1815 (the same year that George Boole was born), a daughter—
Augusta Ada Byron—was born to Anna Isabella (Annabella) Byron and George Gor-
don, Lord Byron. In England at that time Byron’s fame derived not only from his
poetry but also from his wild and scandalous behavior. The marriage was strained
from the beginning, and Annabella left Byron shortly after Ada’s birth. By April of
1816, the two had signed separation papers. Byron left England, never to return.
Throughout the rest of his life he regretted that he was unable to see his daughter.
At one point he wrote of her,

I see thee not. I hear thee not.
But none can be so wrapt in thee.

Before he died in Greece, at age 36, he exclaimed,

Oh my poor dear child! My dear Ada!
My God, could I but have seen her!

Meanwhile, Annabella, who eventually was to become a baroness in her own right, and
who was educated as both a mathematician and a poet, carried on with Ada’s upbringing
and education. Annabella gave Ada her first instruction in mathematics, but it soon became
clear that Ada was gifted in the subject and should receive more extensive tutoring. Ada
received further training from Augustus DeMorgan, today famous for one of the basic the-
orems of Boolean Algebra. By age eight, Ada had demonstrated an interest in mechanical
devices and was building detailed model boats.

tcontinued



8.5 Scope of Access | 353

When she was 18, Ada visited the Mechanics Institute to hear Dr. Dionysius Lardner’s
lectures on the “Difference Engine,” a mechanical calculating machine being built by
Charles Babbage. She became so interested in the device that she arranged to be intro-
duced to Babbage. It was said that, upon seeing Babbage’s machine, Ada was the only per-
son in the room to understand immediately how it worked and to recognize its significance.
Ada and Charles Babbage became lifelong friends. She worked with him, helping to docu-
ment his designs, translating writings about his work, and developing programs for his
machines. In fact, Ada today is recognized as the first computer programmer in history.

When Babbage designed his Analytical Engine, Ada foresaw that it could go beyond
arithmetic computations and become a general manipulator of symbols, and thus would
have far-reaching capabilities. She even suggested that such a device eventually could be
programmed with rules of harmony and composition so that it could produce “scientific”
music. In effect, Ada foresaw the field of artificial intelligence more than 150 years ago.

In 1842, Babbage gave a series of lectures in Turin, Italy, on his Analytical Engine. One
of the attendees was Luigi Menabrea, who was so impressed that he wrote an account of
Babbage’s lectures. At age 27, Ada decided to translate the account into English, with the
intent to add a few of her own notes about the machine. In the end, her notes were twice
as long as the original material, and the document, “The Sketch of the Analytical Engine,”
became the definitive work on the subject.

It is obvious from Ada’s letters that her “notes” were entirely her own and that Babbage
was acting as a sometimes unappreciated editor. At one point, Ada wrote to him,

I am much annoyed at your having altered my Note. You know I am always willing
to make any required alterations myself, but that I cannot endure another person
to meddle with my sentences.

Ada gained the title Countess of Lovelace when she married Lord William Lovelace. The cou-
ple had three children, whose upbringing was left to Ada’s mother while Ada pursued her work
in mathematics. Her husband was supportive of her work, but for a woman of that day, such
behavior was considered almost as scandalous as some of her father’s exploits.

Ada died in 1852, just one year before a working Difference Engine was built in Sweden
from one of Babbage’s designs. Like her father, Ada lived only to age 36, and even though
they led very different lives, she undoubtedly had admired him and took inspiration from
his unconventional and rebellious nature. In the end, Ada asked to be buried beside him at
the family’s estate.

Ada Lovelace

8.5 Scope of Access
In writing a Java class we declare variables, constants, methods, and inner classes that
are given identifiers. Java defines a set of rules that specify where those identifiers can
then be used, both inside and outside of the class. We say that the rules determine the



354 | Chapter 8:  Inheritance, Polymorphism, and Scope

scope of access of an identifier. The term is usually
shortened to scope, and the rules are thus called the
scope rules of the language.

The scope rules for access within a class are
straightforward and do not depend on the access modi-
fiers attached to an identifier. External access scope
rules determine where an identifier can be used outside
of a class and depend on both the access modifiers and
where the access takes place. We look first at internal
scope, then at external scope.

Internal Scope

Any identifier declared as a static or instance member of a class can be used any-
where within the class with two exceptions. You can’t use one class variable to initialize
another before the first one has been defined. And, within its block, a local identifier
overrides a static or instance member of the same name. Let’s take a closer look at each
of these exceptions.

Order of Definition Suppose you are defining a Circle class and you want to provide
class variables that are initially set to PI and PI times two. The first of the following
two declarations is illegal because its initialization expression uses the second identifier
before it has been given a value.

public static double twoPI = PI * 2; //PI isn't defined yet
public static double PI = 3.14159265358979323846;

Reversing the order of the statements makes them both legal.

public static double PI = 3.14159265358979323846;
public static double twoPI = PI * 2; //PI already has a value

The scope rule that requires us to define a variable’s value before it is used applies
only to references in expressions that initialize other variables as part of their declaration.

It’s otherwise legal to refer to variables before they are defined. For example, the
following declarations are legal.

public static int circumference(Circle anyCircle)
{
return anyCircle.radius * twoPI;

}
public static double PI = 3.14159265358979323846;
public static double twoPI = PI * 2;

The method is allowed to refer to the variable twoPI before it is defined. Why is
this case different? The JVM performs all variable declaration initializations before it

Scope of access (scope) The region of program code
where it is legal to reference (use) an identifier

Scope rules The rules that determine where in a pro-
gram an identifier may be referenced, given the point
where the identifier is declared and its specific access
modifiers



8.5 Scope of Access | 355

starts executing statements in main, and it does them in the order that they are written
in the code. So an initialization expression can only use variables that have already
been given values.

The method circumference isn’t executed until it is called from some point in the
program, which can happen only after all of the variable declaration initializations are
complete. In terms of the order of execution, all initialization expressions are executed
before any other use of a variable.

Note that regular assignment statements that initialize variables in methods are dis-
tinct from declaration initialization expressions. They are executed in the normal flow
of control, which starts after all of the declaration initializations.

Constant declarations do not follow this rule because the compiler computes con-
stant values at compile time. The compiler first searches through our code to find all the
constant declarations before it computes their values. So it doesn’t require us to define a
constant before using it. The JVM isn’t able to search through the Bytecode in the same
way, so it requires us to initialize variables before their use.

To make life easier for human readers of your code, it’s good form to define con-
stants ahead of any references to them. Some programmers even make a point of writ-
ing all constant declarations preceding the variable declarations, just as a reminder that
constants are given their values first.

Name Precedence The scope rule that says
local identifiers hide members of the class with
the same name is called name precedence.

In Java, the scope of a local identifier is
the entire block in which it is declared. The
block includes all of the statements between
the { and } that contain the declaration. For
example:

public class someClass
{
public static int var;             // Class member var
public static final int CONST = 5; // Class member CONST
public static Label label1;
public static void someMethod(int param)
{
int var;
final int CONST = 10;
var = param * CONST;
label1.setText("" + var);

}
}

Notice in this example that the scope of the local declarations extends to the entire
block. Thus, if we used CONST to initialize var, the initialization would refer to the local

Name precedence A scope rule specifying that a local
identifier declaration hides the declaration of an iden-
tifier in the class with the same name (also called
name hiding)

Scope of local variable var and local con-
stant CONST, each of which overrides the
same identifier declared as a class member



356 | Chapter 8:  Inheritance, Polymorphism, and Scope

version of CONST. Of course, the compiler would report this as an error because we’re
using CONST before we’ve defined it.

Using this to Overcome Name Precedence Java provides a keyword, this, to refer to
members that are hidden by local declarations. With regard to their scope, formal
parameters are treated as local identifiers that are declared at the beginning of the
method body. Their scope thus includes the entire body of the method.

Here’s an example showing the use of this to access hidden class members.

public class someClass
{
public int var = –1;        // Member var
public final int const = 5; // Member CONST
public int param = 0;       // Member param

public static int someMethod(int param)  // Local param
{
int var;                               // Local var
// Set local CONST to class CONST * 2
final int CONST = this.CONST*2;        // Local CONST
// Compare local and member params
if (param > this.param) 
var = param * CONST;                 // Use local values

else
this.var = this.param * this.CONST;  // Use member values

return var;
}

}

Understanding the internal scope rules helps to avoid or locate errors in implementing
the internal representation of the class. For example, a scope-related error occurs when
you declare a local identifier that overrides a class member but misspell the name in the
local declaration. The compiler won’t complain and merely directs all of the references to
the local identifier to its correctly spelled class member equivalent, as shown here.

public class SomeClass
{
public static int var;             // Member var
public static Label label1;        // Member label1

public static void SomeMethod(int param);
{
int ver;                         // Misspelling of var
var = param * param;             // Refers to member var
label1.setText("" + var);        // Refers to members

}
}

TE
AM
FL
Y

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

Team-Fly® 



8.5 Scope of Access | 357

The program exhibits erroneous behavior in which a class member is changed and dis-
played as a side effect of calling a method. Knowing the scope rules leads us to look for
references to the class member within the method and then to check the local declarations.

External Scope

The external access scope rules for members control their use by code that is outside of the
class. There are three external places from which Java allows class members to be
accessed: derived classes, members of the same package, and code external to the package.

A package contains a set of related classes, and sometimes we want to make mem-
bers of those classes accessible to each other, even if they aren’t public. For example,
suppose that a Date class is part of a calendar package. There is another class, called
ShowWeek, in the package that displays a week surrounding a given date. Both of the
classes use the Julian day as their internal representation. It is thus more efficient for a
Date object to make its Julian day member directly accessible to ShowWeek than to
require conversion of the date to its external form and back to a Julian day in the other
object. The user is unaware of this shortcut, so the encapsulation is preserved.

Classes naturally belong together in a package if they have common internal repre-
sentations. In that case, they can bypass each other’s encapsulations because the common
details of their implementations are already known to anyone who’s working with them.

Java defines four levels of access for class members, three of which enable direct
access by other package members. The four levels of access are public, protected,
default (package), and private. There are keywords that we use as access modifiers for
each of these levels except package, which is the default level. If you omit an access
modifier from the declaration of a class member, it is at the package level of access.

Public Access A public member can be accessed from anywhere outside of the class.
User code, derived classes, and other classes in the same package can all access a public
member. The member may still be hidden by a declaration of the same name in another
class, in which case references to it must be qualified with its class or instance name.

Here’s an example of using qualified names. If class ShowWeek defines a julian-
Day member and Date also defines julianDay as a static member, then ShowWeek
would need to refer to

Date.julianDay

to access the static field of Date. If julianDay is an instance member of Date and the
particular object is called instanceName, then ShowWeek must refer to it as:

instanceName.julianDay

Protected Access A protected member is accessible to classes in the same package
and can be inherited by derived classes outside of the package. Code that is outside of
the package can only inherit protected members of a class. It can’t access them
directly.



358 | Chapter 8:  Inheritance, Polymorphism, and Scope

The following code segment shows the definition of two packages. The second
package has a class (DerivedClass) that is derived from the class in the first package
(SomeClass). DerivedClass inherits the protected field someInt from SomeClass.
Notice that it doesn’t include its own declaration of someInt.

DerivedClass defines a method that has one parameter of class SomeClass and
another of its own class. It then tries to access the someInt field in both parameters.

package one;
public class SomeClass
{
protected int someInt;

}

package two;
import one.*;
public class DerivedClass extends SomeClass
{
void demoMethod (SomeClass param1, DerivedClass param2)
{
param1.someInt = 1;   // Generates compiler error
// Can't access member of SomeClass in other package
param2.someInt = 1;   // This access is legal
// It refers to the inherited member in this package

}
}

The compiler issues an error message for the first assignment statement because it is
illegal to access the protected field of a superclass when the superclass is in a differ-
ent package. The second assignment is valid because it refers to the inherited field
within DerivedClass.

The protected modifier provides the least restrictive level of access that isn’t pub-
lic. We use protected to enable users to extend our class with a subclass. The subclass
inherits its own copies of the protected members and cannot access the originals.

It is unusual to use protected in an application designed with CRC cards because
all of the responsibilities and collaborations are known in advance. But if a package of
classes is independent of an application (such as the java.util package), it is often
desirable to enable the user to derive their own classes from the library classes.

Package Access When no access modifier is specified, then classes in the same
package can access the member. No other external access is allowed. A member at the
package level of access cannot be inherited by a derived class in another package. Up to
this point, we’ve only given examples in which every member of a class is inherited by
a subclass. With the introduction of the package level of access, we see that Java also
lets us selectively restrict the members that are inherited.



8.5 Scope of Access | 359

External access public protected default (package) private

Same package yes yes yes no
Derived class in another package yes yes (inheritance only) no no
User code yes no no no

A derived class in the same package still has access to the members of its superclass
that are at the package level of access. All classes within the same package have access
to each other’s public, protected, and package members.

Here’s the preceding example, but with both classes in the same package and
someInt at the package level of access. In this case, both assignment statements are valid.

package one;
public class SomeClass
{
int someInt;

}

package one;
public class DerivedClass extends SomeClass
{
void demoMethod (SomeClass param1, DerivedClass param2)
{
param1.someInt = 1; // Accesses someInt in param1 superclass object
param2.someInt = 1;  // Accesses someInt inherited from superclass

}
}

Private Access Lastly, the private modifier cuts off all external access, even by
classes in the same package. A private member of a class can be referred to only by
other members of the class, and only the internal scope rules apply to it. It isn’t even
permissible for a derived class in the same package to access a private member of its
superclass.

Instances of a class can refer to each other’s private members. A member is pri-
vate to its class, which includes all instances of the class. Thus, two objects, someObj
and otherObj that have private int fields called someInt can refer to each other’s
fields. That is, someObj can refer to otherObj.someInt and otherObj can refer to
someObj.someInt.

Note that within a method, all local identifiers are automatically private and Java
doesn’t allow us to declare them with access modifiers. The reason is that the lifetime of
a local identifier is limited to a particular method call, so it simply doesn’t exist when
external code is running. The following table summarizes the external scope rules.



360 | Chapter 8:  Inheritance, Polymorphism, and Scope

Thus far we have primarily used the public and package levels of access, keeping
data members at the package level and making most methods and classes public. This
simple scheme provides encapsulation and a consistent user interface that is strictly a set
of method calls. However, the scheme is inflexible and limits our ability to provide for
either extension or the construction of related classes that are grouped into a package.

Now that we have a better understanding of the Java access rules, we must consider
which access modifier is most appropriate for each member of a class. Once you have iden-
tified all of its members, take a second look at each one and ask the following question.

Do I want to access this member from other classes in the same package, from
derived classes, or from user code?

Based on your answer to each part of this question, you can use the preceding table
to decide which access modifier is most appropriate.

8.6 Implementing a Derived Class
Given the CRC card design for a subclass and its superclass, you can determine what it
is that you must include in the subclass to implement its responsibilities. You may find
that you simply need to change the operation of an inherited method, which means that
you override or hide it with a new version. Because a derived class doesn’t inherit any
constructors, it probably needs one or more new constructors. We often implement new
constructors by calling the old ones to do much of the work, and then adding a few
statements to take care of initializing any fields that we’ve added. In some cases you
may find it necessary to change the internal representation of the subclass.

After you have designed the subclass interface and its internal representation, you
implement it by writing the necessary field and method declarations within a class dec-
laration that extends the superclass. Here are the steps in the form of a checklist.

1. Study the interfaces of the superclass and the subclass, identifying the members
that are inherited.

2. Determine whether the internal representation must change in the subclass.
3. Provide constructors as needed.
4. Add fields and methods to those that are inherited, as necessary.
5. Hide any inherited fields or class methods that you wish to replace.
6. Override any instance methods that you wish to replace.

We have already seen how to read an existing class hierarchy to determine what is
inherited by a subclass. When we are creating a new hierarchy we start from a set of
CRC cards. During the enactment of the scenarios, it may become clear that certain
responsibilities are public, private, or package in their access requirements and this
should be written on the cards. As we’ve noted, it is rare for a CRC card design to result
in a protected responsibility.

As we design the internal representation for a class, we may also notice that certain
fields need an access level other than package. For example, we might define some



8.6 Implementing a Derived Class | 361

public class constants. Once we have this information, we can list the members that a
subclass inherits.

Next we reconsider the choice of internal representation given the responsibilities of
the subclass. Unless there is a good reason for making the representation different from
the superclass, it should remain the same. Thus, we begin with the inherited representa-
tion and look for any omissions. We can easily add extra fields.

Sometimes an inherited field is inappropriate for the subclass. Perhaps the super-
class uses an int field for part of its representation, and the purpose of the subclass is
to extend its range by using long. Then we must hide the inherited field in the subclass.

Once we have the interface and internal representation, we can begin to implement
the constructors. Java has some special rules regarding constructors in derived classes
that we examine next.

Constructors in Derived Classes

What would happen if we forgot to include a constructor in the declaration of a derived
class? Java automatically provides a default constructor that calls the superclass con-
structor with an empty parameter list. If the superclass doesn’t have a constructor of
that form, then the compiler issues an error message.

In fact, Java requires every constructor in a derived class to call a constructor in its
superclass. That call must be the first statement in the constructor, even before any dec-
larations. If it isn’t the first statement, Java automatically inserts the same default call.

The reason that Java requires us to call a superclass constructor is that every
derived class is a specialized form of its superclass. An object of the subclass can be
assigned to a variable of both its own class and of its superclass (and by extension, any
of the classes above it in the hierarchy). The superclass may perform initialization oper-
ations to create a valid object. Rather than requiring every derived class to duplicate
those operations, Java simply enforces the rule that one of the superclass constructors
must be called, either explicitly in our constructor or implicitly by default.

Of course, the superclass constructor must call a constructor for its superclass, and
so on until the constructor for Object is called. Thus, the process of instantiating an
object calls a chain of constructors that provides essential initialization all the way up
to Object. Next we examine how Java identifies methods and the Java syntax for call-
ing a constructor in the superclass.

Overloading and Method Signatures

If you were to examine the interface of class TextField, you would discover that it has
not one but four constructors.

public TextField();
public TextField(String text);
public TextField(int columns);
public TextField(String text, int columns);



362 | Chapter 8:  Inheritance, Polymorphism, and Scope

We’ve always been careful to avoid declaring duplicate identifiers in our programs,
yet TextField has four constructors all with the same name. How is this possible? In
the case of methods, Java uses more than just the name to identify them; it also uses the
parameter list. A method’s name, the number and type of parameters that are passed to

it, and the arrangement of the different parameter
types within the list, combine into what Java calls the
signature of the method.

Java allows us to use the name of a method as
many times as we wish, as long as each one has a dif-
ferent signature. When we use a method name more
than once, we are overloading its identifier. The Java
compiler needs to be able to look at a method call and
determine which version of the method to invoke. The
four constructors in class TextField all have differ-

ent signatures: one takes no arguments, the second takes a String, the third takes an
int, and the fourth takes both a String and an int. Java decides which version to call
according to the arguments in the statement that invokes TextField.

The following method headings have different signatures and thus overload each other.

public static void someName(int param1, int param2, int param3)
public static void someName(int param1, double param2, int param3)
public static void someName(double param1, int param2, int param3)
public static void someName(int param1, int param2, String param3)

Even though the parameters all have the same names, the differences in their types
enable Java to distinguish between them. For example, the statement

someName(1, 2.0, 3)

calls the second version because it has an int value, a double value, and another int
value as its arguments. If we write the call as

someName(1.0, 2, 3)

then the double, int, int pattern of its arguments identifies the third version of the
method as the target of the call.

The following method headings all have the same signature, and cannot be declared
together in a class. Their signature is the method name (aName) and the presence of
three parameters of types int, double, and String in that order.

public static void aName(int param1, double param2, String param3)
public static void aName(int large, double medium, String small)
public void aName(int red, double green, String blue)
static int aName(int thing1, double thing2, String hatCat)

Signature The distinguishing features of a method
heading. The combination of the method name with
the number and type(s) of its parameters in their given
order

Overloading The repeated use of a method name
with a different signature



8.6 Implementing a Derived Class | 363

Keep in mind that the types of the parameters determine the signature of a method.
The names of the parameters, the return type, and the modifiers of a method are not
part of its signature.

Overloading is related to but different from hiding and overriding. Hiding and over-
riding are mechanisms whereby a name is replaced when the same name is declared in a
new context. For example, an instance method identifier overrides a method with the
same name in its superclass if it has the same signature. The declaration in the derived
class results in an identifier that duplicates the one in the superclass. But because they
are in different classes, the duplication is acceptable. When we use the identifiers, we
indicate which one we mean. An instance identifier is associated with a specific object
of one or the other class type, and a class identifier is preceded with the name of the
class and a period.

If we declare a method with the same name as an inherited superclass method, but
their signatures are different, then the new method overloads the name of the superclass
method. The two identifiers are the same, but the different signatures allow them to be
distinguished. Different signatures also serve to distinguish overloaded methods within
the same class. The Java compiler decides which version to call by comparing the types
of the arguments with the types of the parameters in each signature.

To summarize, overloading allows us to add new versions of a name that can exist
together in a single context, while hiding and overriding provide a way to replace a
name with a new declaration in a different context.

Accessing Overridden and Hidden Methods and Fields

Suppose you need to extend the Frame class so that, when a window is closed, a confir-
mation is requested of the user. The interface of this derived class is the same as the
superclass except that you are overriding the dispose instance method with a new ver-
sion. Within your version of dispose, you present the message to the user, handle the
event that signals the user has acknowledged the message, and then dispose of the
Frame if the user has confirmed the closing.

There’s just one problem with this approach. To actually dispose of the Frame you
need to call the dispose method that’s defined by the superclass. But you just overrode
dispose with a local definition that has the same signature. If it was a class method, you
could access the hidden form by writing the full name of the method: the superclass name,
a period and the method name. That is, if dispose was a class method, you could write

Frame.dispose()

to access its hidden form. But dispose is an instance method, and there’s no instance
(object) of class Frame to refer to.

Java solves this problem by providing the keyword super, which refers to the
superclass of a derived class. We write

super.dispose()



364 | Chapter 8:  Inheritance, Polymorphism, and Scope

to refer to the dispose method in Frame from within a derived class that overrides
dispose. We can also use super as an alternative to naming the superclass when refer-
ring to a hidden method or field.

The reference to super.dispose() invokes the method from the superclass just
like any other instance method inherited by the derived class. Our example illustrates an
important point regarding hiding and overriding: All the fields and methods from the
inheritance interface of the superclass are inherited, but some of them are covered-up
by new declarations in the derived class. In effect, they are still there, and super simply
provides a way to uncover them for a particular reference.

Using super followed by a parameter list refers to the constructor in the superclass
with the same signature.

For example, in a class derived from TextField, we can write

myField = super("Initial string", 25);

to call the version of the TextField constructor that has a String and an int as its
two parameters. We would write

myField = super();

to explicitly call the default constructor for the superclass. Recall that the constructor is
not inherited. Thus, even though it has not been overridden, we can’t call it by name.
The statement

myField = new TextField("Initial String", 25);  // Invalid reference

is invalid if written in a class derived from TextField.
Keep in mind that there are only two cases where you have to use super or the

name of the superclass:

1. To access a method or field that has been overridden or hidden
2. To access a superclass constructor

Otherwise, the name has been inherited and you can refer to it directly.
There is one other situation in which hiding can occur. A local declaration that

takes name precedence over a class declaration is said to hide the class declaration. As
we have already seen, in this situation we use the keyword this to refer to the class
declaration.

Before we move on to a Case Study, there is one more technique that we would like
to introduce. In Chapter 7 we mentioned that it is sometimes useful to create construc-
tors that take an existing instance and use its contents to build a new instance. These
are called copy constructors and we use them to illustrate the difference between shal-
low and deep copying of objects.



8.7 Copy Constructors | 365

8.7 Copy Constructors
One way to simplify the creation of a new instance of an immutable object from an old
one is to provide a constructor that takes an existing object as a parameter. It may also
have other parameters that take values to substitute in creating the new object. Here’s
an example of the heading and documentation for such a constructor.

public SavingsAccount(SavingsAccount oldAcct, String address)
// oldAcct must contain valid account information.
//  A SavingsAccount object is created with its
//  contents equal to those of the old account except that
//  the address is set equal to the address parameter

Here’s an example of how it would be called, where oldAccount is an existing
object of type SavingAccount and address is a string holding a new address value for
the account.

account = new SavingsAccount(oldAccount, address)

The body of the constructor would copy every field from oldAccount to its own
equivalent fields, substituting the value in its address parameter for the one in the
address field of oldAccount. Note that if any of the fields in the object are themselves
objects, it is necessary to use their observers to copy the actual values from the fields of
the nested objects. Otherwise, the new object
simply refers to the same places in memory as
oldAccount.

This copy constructor is said to perform a
deep copy of the object. A deep copy copies
what a reference refers to, rather than the ref-
erence itself. A shallow copy ignores the pres-
ence of nested objects, treating them like
fields of simple types. Figure 8.4 illustrates
shallow copying and Figure 8.5 shows deep
copying. In both figures, the colored arrows
indicate that a field is a reference type with
an address that specifies another place in
memory. The black arrows indicate copying of values.

Now that we have seen the mechanics of implementing a derived class and dis-
cussed the method for designing a class interface, let’s bring all the pieces together in a
Case Study that illustrates the process.

Deep copy An operation that copies one class
instance to another, using observer methods as neces-
sary to eliminate nested references and copy only the
simple types that they refer to. The result is that the
two instances do not contain any duplicate references.

Shallow copy An operation that copies a source class
instance to a destination class instance, simply copying
all references so that the destination instance contains
duplicate references to values that are also referred to
by the source



366 | Chapter 8:  Inheritance, Polymorphism, and Scope

New SavingsAccount
Object

account # 4295110
name
address
phone
balance = 8337.26
activation =
status = 1

Existing SavingsAccount
Object

Existing Nested
Objects

account # 4295110
name
address
phone
balance = 8337.26
activation =
status = 1

"Jane A. Smith"

"4731 East Oak St., Fossil, OR, 97364"

"541-555-9111"

month =
day = 17
year = 1993

"August"

Figure 8.4 Shallow copying

Existing SavingsAccount
Object

Existing Nested
Objects

account # 4295110
name
address
phone
balance = 8337.26
activation =
status = 1

"Jane A. Smith"

"4731 East Oak St., Fossil, OR, 97364"

"541-555-9111"

month =
day = 17
year = 1993

"August"

New SavingsAccount
Object

New Nested
Objects

account # 4295110
name
address
phone
balance = 8337.26
activation =
status = 1

"Jane A. Smith"

"4731 East Oak St., Fossil, OR, 97364"

"541-555-9111"

month =
day = 17
year = 1993

"August"

Figure 8.5 Deep copying

TE
AM
FL
Y

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

Team-Fly® 



Problem-Solving Case Study | 367

Problem-Solving Case Study
Extending TextField for Numeric Input and Output

Problem Reading a numeric value from a field requires us to perform two type conversions.
The expressions containing the conversions are tiresome to write and difficult to read. It would
be much nicer to have a field object that specifically handles numeric input, automatically
doing the conversion for us. The nearest superclass is type TextField. We can extend it with
a set of methods, each of which reads the field and returns a value of a specific numeric type.

Brainstorming The Java class library documentation tells us that TextField extends
TextComponent, which extends Component, which extends Object. To study the interface
of our superclass, we thus work our way upward through this hierarchy. We showed this
process earlier in the chapter, so we won’t repeat the analysis here. Recall that we found that
TextField has access to over 100 methods.

Filtering Of all the methods in the TextField hierarchy, there are three that we need
to examine closely because they deal with input and output in the field: getText,
setText, and getSelectedText. We have used getText and setText before;
getSelectedText returns the part of the string that the user has highlighted within the
text field. We should add equivalent methods that handle numeric values. The remaining
methods in TextComponent are not related to our extension of the class.

For numeric input, we would like our derived class to have responsibilities similar to these
three for each of the numeric types—for example, getint, setint, and getSelectedint.
Rather than add responsibilities for every numeric type, here we simply add the ones for the
int and double types. We leave it as an exercise to develop the responsibilities for Java’s
remaining numeric types. Thus, we have six responsibilities in our NumericField class. The
responsibilities that get values are observers, and those that set the value in the field are
transformers.

We also must provide constructors for our new class. The superclass has four constructors,
two of which allow the user to display an initial string in the field. Because we want the field
to contain only numbers, we should supply a constructor for creating the field with an initial
value of the appropriate numeric types.

The constructors for the TextField class include a form that allows the user to specify
an initial string without specifying the width of the field as a number of columns. An analo-
gous constructor in our new class would enable us to specify an int or double value and
have the field be automatically sized to fit. However, if we write the constructor heading

NumericField(int value)

we get a constructor with the same signature as

NumericField(int columns)



368 | Chapter 8:  Inheritance, Polymorphism, and Scope

and such duplication isn’t allowed. We can’t eliminate the latter form of constructor because it
enables us to initially display the field with nothing in it. So we instead choose to forego the
ability to create a numeric field with the width set automatically to fit its initial contents.

Because we are extending an existing class in a specified manner, we don’t need to walk
through any scenarios. However, if we were creating this extension for a real application, then
we would need to consider its use. We can identify its collaborations simply by noting that
each of our responsibilities needs to use the corresponding methods in TextField. Here’s a
the CRC card for our new class:

Responsibility Algorithms Now that we’ve designed the method interfaces, let’s design their
algorithms. We begin with the constructors. The first form of constructor takes no parameters and
relies on the default size established by TextField. We thus create it by calling the
corresponding constructor for TextField, by using super with a parameter list that matches
the signature, as shown below. Note that this satisfies Java’s requirement that each constructor
call a constructor for its superclass before doing anything else.

NumericField()

super()

Class Name: NumericField Superclass: Subclasses:

Responsibilities Collaborations

TextField

Create itself, default

Create itself (int columns)
Create itself (int value, int columns)

Create itself (double value, int columns)
Get int, Observer
    return int
Set int (int value), Transformer
Get selected int, Observer
    return int
Get double, Observer
    return double
Set double (double value), Transformer
Get selected double, Observer
    return double

Textfield: Textfield

Textfield: Textfield
Textfield: Textfield

Textfield: Textfield

Textfield: GetText

Textfield: SetText

Textfield: GetSelectedText

TextField: GetText

TextField: SetText

TextField: GetSelectedText



Problem-Solving Case Study | 369

Similarly, for the constructor that creates a field with a width of a specified number of
columns, we can use the corresponding constructor from TextField.

NumericField(int columns)

The next constructor takes two integer values, the first to be printed and the second to set
the number of columns. We can use TextField’s constructor that takes a string to be printed
and the number of columns, but we must convert the numeric input into a string.

NumericField(int value, int columns)

The fourth constructor is identical to the third, except that its first parameter is a float-
ing-point value.

NumericField(double value, int columns)

The remaining methods use the corresponding methods from the superclass to get or set
the text in the field, but with appropriate conversion to or from a numeric type.

getint

setint(int value)

getSelectedint

getdouble

return super.getText() converted to double

return super.getSelectedText() converted to int

super.setText(" " + value)

return super.getText() converted to int

super(" " + value, columns)

super(" "+ value, columns)

super(columns)



370 | Chapter 8:  Inheritance, Polymorphism, and Scope

setdouble(double value)

getSelecteddouble

Now we’re ready to code the implementation of our class. In the comments, we note that
if the user enters a string that’s an invalid number, an error occurs. In Chapter 10, we show
how you can handle this error.

package numericField;
public class NumericField extends TextField
// This class provides a set of methods for directly getting and setting
//  numeric values in a TextField derived object. It does not check for
//  number format exceptions. No TextField methods are overridden. Only
//  int and double are supported
{
// Constructors
public NumericField()
{                                      // Default constructor
super();

}
public NumericField(int columns)
{                                      // Makes empty field, columns wide

super(columns);
}
public NumericField(int value, int columns)
{                                      // Field with int value, width
super("" + value, columns);

} 
public NumericField(double value, int columns)
{                                      // Field with double value, width

super("" + value, columns);
}
// Added methods
public int getint()
{                                     // Get an int from the field
return Integer.valueOf(super.getText()).intValue();

}

return super.getSelectedText() converted to double

super.setText(" " + value)



Testing and Debugging | 371

public void setint(int value)
{                                      // Change int value in field
super.setText("" + value);

}
public int getSelectedint()
{                                      // Get int from user selection
return Integer.valueOf(super.getSelectedText()).intValue();

}
public double getdouble()
{                                      // Get a double from the field

return Double.valueOf(super.getText()).doubleValue();
}
public void setdouble(double value)
{                                      // Change double value in field
super.setText("" + value);

}
public double getSelecteddouble()
{                                      // Get double from user 

//  selection
return Double.valueOf(super.getSelectedText()).doubleValue();

}
}

To test this class, we must import it into a driver that can call its methods.

Testing and Debugging

As we noted in our discussion of the driver for class Name in Chapter 7, when we test a
class we can usually test multiple methods with one driver to reduce the amount of user
interface code that we have to write. For the NumericField class, there are four con-
structors and six methods to test. Because each of the methods is independent of the
others, there are a total of 10 tests to be performed. When a class has methods that can
affect each other’s behavior, then we need to test the combinations of methods as well.
For example, if one method stores a value in a field of the class that another method
then uses, we have to test the combination of these two methods.

Each method is tested to verify that it satisfies its responsibilities if it is called with
the proper inputs. We may also test a method to verify its operation when its inputs are
erroneous. For example, we may check that a method throws an appropriate exception
when it is given invalid data. When a method contains a branch, then we must apply
the testing strategies for that control structure to the method just as we would apply
them to an application.

The driver is responsible for setting up the proper conditions prior to each method
call and reporting the conditions after it returns. It supplies arguments or initializes an



372 | Chapter 8:  Inheritance, Polymorphism, and Scope

object as necessary, and after the call it outputs the results from the method. In some
cases, the output is simply a statement that the responsibilities were satisfied. In other
cases it is more useful to display the actual return value or fields of the object. It is up
to you to decide what to output, but in general the more information that you have, the
easier it is to identify errors.

To test the NumericField class, we need a driver that first declares and initializes an
object of that class. We must also provide a frame to display the field and some labels to
provide instructions to the user and to show the results of the method calls. Each of the
methods has a single line of code in its body, so there are no control structures to test. We
simply call each one to either display a value in the field or to get a value from the field.

We can create a separate NumericField object for each test case or we can create
a single object and use it in multiple cases. We choose the latter here because it simpli-
fies the user interface to just have one data entry field in the frame. The main method
declares the object, gives it an initial value and prepares the user interface. The actual
testing must take place in the button listener because we can only get information from
the field when the user signals through an event that its contents are ready.

We want to perform a series of tests that together cover all of the methods. Each
test involves handling a user event. We use the same event (pressing a button) for all of
the tests, so within the listener class ActionHandler we need a way to determine
which test is being performed. We can declare an int field, testNumber, in the pro-
gram class that keeps track of the test number between events. The main method initial-
izes testNumber to 1, and at the end of each test we assign it the number for the next
test. The actionPerformed method then contains an if-then-else-if control structure
that branches to the appropriate test depending on testNumber.

public void actionPerformed(ActionEvent event)
{
// Declarations
if (testNumber == 1)
{
// Perform first test

}
else if (testNumber == 2)
{
// Perform second test

}
else if (testNumber == 3)
{
// Perform third test

}
// And so on...

}

We can combine testing of more than one method into a single branch in this con-
trol structure. For example, we can use setint to place a number in the field in prepa-



Testing and Debugging | 373

ration for testing getSelectedint. We would thus combine testing of getint and
setint in a single branch, followed by a separate test of getSelectedint.

The typical form of an individual test is getting a value from the field, displaying it
in a label, setting testNumber to the next test, and packing and showing the revised
frame. The different tests vary this pattern slightly but are all very similar. Testing
NumericField is very straightforward because we have added methods that are very
similar to each other, which is fairly common in extending a class.

Here is the complete driver for testing class NumericField.

import java.awt.*;                                  // User interface
classes
import java.awt.event.*;                            // Event handling
classes
import numericField.*;                             // Class being tested

public class NumericFieldDriver
{

// Define a button listener
private static class ActionHandler implements ActionListener
{
public void actionPerformed(ActionEvent event)
// Handles events from the Enter button in inputFrame
{
int intAmount;
double doubleAmount;
if (testNumber == 1)
{
// Convert string in testField to a double value and display
doubleAmount = testField.getdouble();              // Test getdouble
outputLabel.setText("You input: " + doubleAmount); // Show results
testField.setdouble(doubleAmount);                 // Test setdouble
// Show instructions
entryLabel.setText("Select part of the field " +

"and press enter");
// Set up for test 2
testNumber = 2;
inputFrame.pack();
inputFrame.show();

}
else if (testNumber == 2)
{
// Convert selected string in testField to a double value and display
// Test getSelecteddouble



374 | Chapter 8:  Inheritance, Polymorphism, and Scope

doubleAmount = testField.getSelecteddouble();
outputLabel.setText("You input: " + doubleAmount); // Show results
testField.setText("");                             // Clear field
// Show instructions
entryLabel.setText("Type an integer " +

"and press enter");
// Set up for test 3
testNumber = 3;
inputFrame.pack();
inputFrame.show();

}
else if (testNumber == 3)
{
// Convert string in testField to an int value and display
intAmount = testField.getint();                    // Test getint
outputLabel.setText("You input: " + intAmount);    // Show results
testField.setint(intAmount);                       // Test setint
// Show instructions
entryLabel.setText("Select part of the field " + 

"and press enter");
// Set up for test 4
testNumber = 4;
inputFrame.pack();
inputFrame.show();

}
else if (testNumber == 4)
{
// Convert selected string in testField to an intvalue and display
// Test getSelectedint
intAmount = testField.getSelectedint(); 
entryLabel.setText("You input: " + intAmount);     // Show results
// Show instructions
outputLabel.setText("End of test. " +

"Please close the window.");
inputFrame.remove(enter);                          // Remove button
inputFrame.remove(testField);                      // Remove field
inputFrame.pack();
inputFrame.show();

}
}

}



Testing and Debugging | 375

static Frame inputFrame;                 // Declare a frame
static Label entryLabel;                 // Label for input
static Label outputLabel;                // Label for output
static NumericField testField;           // Input field
static Button enter;                     // Enter button
static ActionHandler action;             // Declare the action handler
static int testNumber;                   // Keeps track of which test

public static void main(String[] args)
{ // Prepare user interface components
inputFrame = new Frame();
entryLabel = new Label("Enter a real number here:");
outputLabel = new Label("Press enter when input is ready.",

Label.RIGHT);
testField = new NumericField(10);
enter = new Button("Enter");
enter.setActionCommand("enter");
action = new ActionHandler();
enter.addActionListener(action);
testNumber = 1;                                // Initialize test number
// Add user interface components to the frame and display it
inputFrame.setLayout(new GridLayout(2,2));
inputFrame.add(entryLabel);
inputFrame.add(testField);
inputFrame.add(enter);
inputFrame.add(outputLabel);
inputFrame.pack();
inputFrame.show();
// Define window closing event handler
inputFrame.addWindowListener(new WindowAdapter()
{
public void windowClosing(WindowEvent event)
{
inputFrame.dispose();
System.exit(0);

}
});

}
}

Here is the series of dialogs that appears on the screen when the test is executed.



376 | Chapter 8:  Inheritance, Polymorphism, and Scope

TE
AM
FL
Y

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

Team-Fly® 



Testing and Debugging | 377

Note that we tested just one of the constructors in our driver program. You can test
the other constructors by modifying the statement

testField = new NumericField(10);

in main to call a different constructor and recompile and run the program. Then repeat
the process for each of the constructors. An alternative would be to create a separate
driver that simply declares a frame with four fields, each created by a different con-
structor. Here’s how the first part of the main method for such a driver could be written.

static Frame inputFrame;                        // Declare a frame
static NumericField testField1;                 // Field1
static NumericField testField2;                 // Field2
static NumericField testField3;                 // Field3
static NumericField testField4;                 // Field4

public static void main(String[] args)
{
inputFrame = new Frame();                     // Give the frame a value
testField1 = new NumericField();              // Give field1 a value
testField2 = new NumericField(10);            // Give field2 a value
testField3 = new NumericField(1234, 10);      // Give field3 a value
testField4 = new NumericField(12.34, 10);     // Give field4 a value

inputFrame.setLayout(new GridLayout(2,2));    // Set the layout manager
inputFrame.add(testField1);                   // Add field1 to frame
inputFrame.add(testField2);                   // Add field2 to frame
inputFrame.add(testField3);                   // Add field3 to frame
inputFrame.add(testField4);                   // Add field4 to frame
inputFrame.pack();                            // Pack the frame
inputFrame.show();                            // Show the frame
// 

} . . .

Once a class has been thoroughly tested, it can be used in many different program-
ming projects. One of the major goals of object-oriented design is to enable the reuse of
code in multiple programs. But if a class has an error in it, then the error gets trans-
ferred to every program that uses it. You would be very upset if you built a program on
top of a class that was written by someone else, only to discover that the class has bugs
that make your program fail. Be sure to test your classes thoroughly so that you don’t
cause similar problems for other programmers!

Testing and Debugging Hints

1. Study the entire hierarchy for a class before you try to use or extend it. Watch out
for cases of overriding and hiding that change the semantics of a class member.

2. An abstract class cannot be instantiated as an object; a derived class must be
written to use it.

3. Overriding applies to instance methods, hiding applies to class methods. You cannot
hide an instance method with a class method or override a class method with an



378 | Chapter 8:  Inheritance, Polymorphism, and Scope

Package Name

Class Name Comments

numericField
NumericField extends TextField

Constructors:
NumericField()
NumericField(int)
NumericField(int, int)
NumericField(double, int)

Value-Returning Instance Methods:
getint() Returns int
setint(int)
getSelectedint() Returns int
getdouble() Returns double
setdouble(double)
getSelecteddouble() Returns double

instance method. However, Java does allow static and instance fields to hide and
override each other.

4. When you write a class that extends a superclass, be sure that the compilation unit
(program or package) imports the superclass if it isn’t one of the standard ones that
is always imported.

5. The access modifiers for a method that overrides or hides a method in a superclass
must grant the same level of access or greater. The most restrictive form of access is
private, then protected, then public. You can override a private method with
a public one, but you can’t use private to override a public method.

6. Be sure that the first statement of every constructor is a call to one of the superclass
constructors. If you omit the call, Java automatically inserts a call to super().

7. Overloading a method requires that the two methods have a different signature. The
signature is the name of the method plus the types of its parameters in their specific
order. The return type and modifiers are not part of the signature.

8. Use super to access fields or methods of a superclass that have been hidden or
overridden by a derived class.

9. Use this to access class fields that have been hidden by a local declaration.
10. Thoroughly document the interface of a class to facilitate its proper use, ensure its

correct design, and to simplify testing.

Summary of Classes



Summary | 379

Summary
Object-oriented languages such as Java organize class data types into a hierarchy. At
the top of Java’s hierarchy is a class called Object that provides a few basic operations.
Using inheritance, other classes extend Object and are said to be derived from it.
Derived classes inherit all of the public and protected fields and methods of their super-
class except for its constructors. We must explore the entire inheritance hierarchy for a
class to determine its full interface.

Instance methods can override superclass instance methods, and class methods and
fields can hide superclass class methods and fields. Overriding and hiding provide ways
for us to change the meaning of a method or field when extending a superclass with a
derived class. The derived class can thus retain the same form of interface, but operate
in a different manner.

Constructors are not inherited by derived classes. The first statement in a constructor
must be a call to a constructor for the superclass; otherwise, Java automatically inserts
such a call to the default constructor for the superclass.

Java allows us to declare multiple methods with the same name as long as they have
different signatures. The method name is then said to be overloaded. The signature is
the combination of the method name and the types of its parameters in their given
order. The return type and modifiers are not part of the signature. Java determines
which version of an overloaded method to call by examining the types in the argument
list and selecting the method with the matching parameter list.

Sometimes we need to access a method or field in a superclass that has been overrid-
den or hidden. We can use the super keyword to refer to the superclass version of a
field or method instead of the local version. Similarly, a method can define a local vari-
able or parameter with the same name as a field in the class and we can use this to
refer to the class version instead of the local version.

Scope rules determine the range of code that has access to an identifier. Internal
scope rules specify where class members can be accessed within a class. In Java, mem-
bers can be used anywhere within a class except that class variables must be defined
before they are used to initialize other variables, and local variables can override class
variables (name precedence).

External scope specifies where a member can be accessed outside of a class. Java pro-
vides four levels of external access. The default level is package, and extends access to all
classes in the same package. With protected access, derived classes are also able to
access a member. A member with public access can be used by any code that imports
the class. The private access level restricts access to only the class containing the mem-
ber.

In this chapter we have learned how to declare derived classes. The advantage of a
derived class is that we have the interface from the superclass as the model for our
design. We benefit from inheriting many fields and methods that give our derived class
powerful capabilities with no extra work on our part. In some cases, however, a new
object is sufficiently different from anything that exists in the standard hierarchy that
we have to design it entirely from the ground up. Now that you know how to design
and implement both derived classes and top-level classes, you are prepared to explore a



380 | Chapter 8:  Inheritance, Polymorphism, and Scope

wide range of useful and general abstractions that computer scientists have identified as
fundamental to the development of more advanced algorithms. The remainder of this
text primarily examines some of these abstractions and their implementation.

Quick Check
1. What is the most general class in Java? (p. 346)
2. What is the mechanism that allows one class to extend another class? (pp.

345–346)
3. What do you call a class that is an extension of another class in the hierarchy?

(pp. 346–347)
4. Overriding refers to _________ methods; hiding refers to fields and ________

methods. (pp. 350–351)
5. What kinds of members are not accessible to a derived class? (p. 359)
6. What is an operation that has multiple meanings depending on the object to

which it is applied? (p. 351)
7. Are constructors inherited? (p. 361)
8. An object of a _______ class can be assigned to an object of its __________ class.

(p. 361)
9. Explain the meaning of the keyword extends. (pp. 346–348, 351)

10. What do we call the rules that determine where in a program that an identifier
can be recognized? (pp. 353–355)

11. What keyword refers to a class’s superclass? (pp. 363–364)
12. What keyword refers to hidden class members? (p. 364)

Answers

1. Object 2. Inheritance 3. Derived class 4. instance, class 5. private 6. a polymorphic opera-
tion 7. Class constructors are not inherited. 8. derived, super 9. extends tells the compiler the class
from which this class is being derived. 10. scope rules 11. super 12. this

Exam Preparation Exercises
1. a. Name two kinds of scope.

b. Do both internal and external scope depend on the access modifiers of an
identifier?

c. Define internal scope.
d. What are these two exceptions noted in 1c?
e. What is name precedence?
f. Is it legal to define local variables with the same identifier in nested blocks?

2. Name the three external places from which Java allows class members to be
accessed.

3. a. List the four levels of access for class members.
b. Which of the four is the default access?
c. From where can a public member be accessed?
d. From where can a member with no access modifier be accessed?
e. From where can a private member be accessed?
f. From where can a protected member be accessed?



Exam Preparation Exercises | 381

4. a. What nonpublic members should be part of the interface?
b. How do you make them part of the interface?

5. What happens if we forget to include a constructor in our new class?

6. a. Distinguish between a deep copy and a shallow copy.
b. Under what conditions are a deep copy and a shallow copy the same?

7. To what class can all Java objects trace themselves back?
8. What is the modifier of a class or field that indicates that it is incomplete?
9. What does the inheritance mechanism allow one class to acquire from another?

10. What do you call the class that is extended by a derived class?
11. When we examine a derived class, we have access to more than just the methods

and fields defined in the class. Explain.
12. What happens if a derived class defines an instance method with the same form

of heading as a method in its superclass?
13. What happens if a derived class defines a data field with the same name as a

data field in the superclass?
14. Distinguish between overriding and hiding.
15. Is it possible to remove a member that is inherited?
16. Overloading, overriding, and hiding are similar, yet different. Fill in the following

table showing whether the sentence describes overloading, overriding, or hiding.

Situation Hiding Overriding Overloading

A class method has the same 
name and signature of a superclass 
method.

An instance method has the same 
name and signature of a superclass 
instance method.

A class has two methods with the 
same name but different signatures.

A field in a derived class has the same 
name as a field in its superclass.

An instance method has the same 
name but a different signature of a 
superclass instance method.

A method declares a field with the 
same name as a field in the class.

A method has a formal parameter with 
the same name as a field in the class.

17. What parts of a superclass’s interface cannot be inherited?



382 | Chapter 8:  Inheritance, Polymorphism, and Scope

Programming Warm-Up Exercises
1. Declare three constructors for class MyClass.
2. Fill in the blanks in the documentation in the following code segment.

public class MyName extends YourName
{
public static int myField;      // myField is a ______ field.

public MyName(int myField)      

// ______ with a parameter that hides the ______ ______
{
// Assign the _____ to the _____ field.
this.myField = myField;

}
}

3. a. How does the syntax of a constructor differ from that of an ordinary method?
b. How is a constructor invoked?
c. How many constructors can a class have?
d. What is the signature of a method?
e. What happens if a class does not have a constructor?
f. What must be the first statement in every constructor?

4. a. Declare a public class SomeClass.
b. Write the heading for a public class method someMethod.
c. Write the heading for an integer class method someMethod that should be

accessible by the classes in the package but not to derived classes.
d. Write the heading for an integer class method someMethod that should be

accessible only to other methods in the class.
e. Write the heading for a character class method someMethod that should be

accessible by classes in the package and any derived classes.
5. a. Write the heading for a public method someMethod.

b. Write the heading for an integer method someMethod that should be accessi-
ble by the classes in the package but not to derived classes.

c. Write the heading for an integer method someMethod that should be accessi-
ble only to other methods in the class.

6. Is the following code segment correct? If so, to what does each reference to
var refer?

public static class someClass
{
public static int var;             // Class member var
public static final int const;     // Class member const
public static void someMethod(int param);
{
int var;



Programming Problems | 383

var = param * const;
final int const = 10;
{
var = 5;
label1.setText("" + this.var);

}
}

}

7. Examine the following constructor headings and list the signature for each.

public someClass()
public someClass(int)
public someClass(double)
public someClass(String, int, double)

8. Examine the following method headings and list the signature for each. Can this
set of signatures be declared in the same class?

public int someMethod()
public void someMethod()
public double someMethod()
public double someMethod(int)
public double someMethod(String)
public double someMethod(int, int)

9. Are these code segments correct? If not, why not?
a. public double taxRate = 29.3;

public double myRate = taxRate*1.1;
b. public double myRate = taxRate*1.1;

public double taxRate = 29.3;

Programming Problems
1. Take the CRC cards used to design the Address hierarchy and complete the

design and implementation of a package that contains the five classes. Design
and implement a test plan for the package.

2. Design and implement an application that creates an electronic address book.
Use the name class from Chapter 7 and the HomeAddress class from this chap-
ter. The application prompts the user to enter a name and an address. When the
name has been entered and verified by the user, it is written to a file. Design and
implement a test plan for the application.

3. Design, implement, and test a class that represents a telephone number. There
should be fields for the local number, the area code, and the country code.



384 | Chapter 8:  Inheritance, Polymorphism, and Scope

Case Study Follow-Up Exercises
1. To extend class NumericField to handle values of type float, what new meth-

ods would you need to declare?
2. Would you need to add a constructor?
3. Write the interface for your new methods.
4. Implement and test your new methods.



                 

To be able to recognize when noninteractive input/out-
put is appropriate and describe how it differs from
interactive input/output.

To be able to write applications that use data files
for input and output.

To be able to construct syntactically correct while
loops.

To be able to construct count-controlled loops with a
while statement.

To be able to construct event-controlled loops with a
while statement.

To be able to use the end-of-file condition to control
the input of data.

To be able to use sentinels to control the execution of
a while statement.

To be able to construct counting loops with a while
statement.

To be able to construct summing loops with a while
statement.

To be able to choose the correct type of loop for a
given problem.

To be able to construct nested while loops.

To be able to choose data sets that test a looping
application comprehensively.

File I/O and Looping
G

oals



386 | Chapter 9:  File I/O and Looping

Figure 9.1 Disks used for file storage

In Chapters 1 through 8, we have used interactive input. We have written our programs
so that the user could enter more than one set of data values by continuing to push a
button indicating input data is ready to be read; that is, we have used events to control
data input. This strategy works well when the data sets are small. However, there are
times when the data sets are too large to be entered in this fashion, so they are stored
on a file. In this chapter we examine how to read data into our program that has been
previously stored on a file.

Entering data from a file leads to the need for an additional control structure that
allows us to explicitly repeat a process rather than relying on a user-initiated event to
control the processing.

9.1 File Input and Output
In everything we’ve done so far, we’ve assumed that input is via the user interface on
the screen. We have used both the System.out object and the user interface to send
messages to the screen. We look now at input/output (I/O) with files.

Files

Earlier we defined a file as a named area in secondary storage that holds a collection of
information (for example, the program code we have typed into the editor). The infor-
mation in a file usually is stored on an auxiliary storage device, such as a disk (see Fig-
ure 9.1).

TE
AM
FL
Y

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

Team-Fly® 



9.1 File Input and Output | 387

Reading and writing data on files is a different process than input and output on
the screen. A file contains a sequence of values and has a distinct beginning and end,
that is, a first value and a last value. You may think of reading a file as analogous to
reading a book in that it is read from the front to the back. Just as you might use a
bookmark to keep track of where you are in a book, Java uses something called the file
pointer to remember its place in a file. Each time some data is read from the file, the file
pointer advances to the point where reading should next resume. Each read operation
copies a value from the file into a variable in the program and advances the file pointer.
A series of read operations eventually reads the last value in the file, and the pointer is
said to be at end-of-file (EOF).

Writing data on a file is like writing in an empty notebook. At the beginning, the
file is empty, and then data is written onto it from front to back. The file pointer always
indicates the end of the last value written so that writing can resume after that point. In
effect, the file pointer is always at EOF when a file is being written. The size of the file
increases with each write operation. The only limit to the size of a file is the amount of
disk space available to the program.

Why would we want a program to read data from a file instead of the user inter-
face? If a program is going to read a large quantity of data, it is easier to enter the data
into a file with an editor than to enter it while the program is running. With the editor,
we can go back and correct mistakes. Also, we do not have to enter the data all at once;
we can take a break and come back later. And if we want to rerun the program, having
the data stored in a file allows us to do so without retyping the data.

Why would we want the output from a program to be written to a disk file? The
contents of a file can be displayed on a screen or printed. This gives us the option of
looking at the output over and over again without having to rerun the program. Also,
the output stored in a file can be read into another program as input. For example, the
Payroll program writes its output to a file named payFile. We can take payFile and
read it into another program, perhaps one that prints out paychecks.

Using Files

If we want a program to use file I/O, we have to do five things:

1. Import the library package java.io.*.
2. Use declaration statements to declare the file variable identifiers we are going to use.

3. Instantiate a file object for each variable.

4. Use methods associated with the file objects to read or write data.

5. Call a method to close the files when we are through with them.

Import the Package java.io.* The first thing we must do any time we want to read
from or write to a file is import the package containing the classes that define files.

import java.io.*;



388 | Chapter 9:  File I/O and Looping

Through the package java.io.*, Java defines many classes for different forms of I/O.
In the case of our programs we use just four of these classes, FileReader,
FileWriter, BufferedReader, and PrintWriter. The FileReader and Buffered-
Reader classes represent streams of characters coming from an input file. FileWriter
and PrintWriter represent streams of characters going to an output file. We first go
through the five steps using the simpler FileReader and FileWriter classes and then
look at the extra capabilities offered by FileWriter and BufferedReader.

Declare the File Identifiers In a program, you declare file identifiers the same way that
you declare any variable—you specify the class and then the name:

FileWriter outFile;
FileReader inFile;

Note that FileReader is for input files only, and FileWriter is for output files
only. With these classes, you cannot read from and write to the same file. The classes
FileReader and FileWriter allow us to read and write individual characters on files.
They are useful when we need to control every aspect of input or output on a character
by character basis.

The data in character stream files are organized into lines. A line is a string of char-
acters that ends with a special character called an end-of-line (EOL) mark. When you
examine such a file with an editor, each line in the file appears as a line of text on the
screen. The editor doesn’t display the EOL mark. The EOL mark simply tells the editor
when to go to the next line as it places the characters on the screen.

Instantiate the File Objects The third thing we have to do is to instantiate the file
objects. Part of instantiating a file object involves telling the operating system the name
of the file on the disk. Thus, we pass the file’s name on the disk to the constructor for
the object. That way, the JVM and operating system know which disk file to use when
the program performs an operation on the file.

For example, we can write these statements:

outFile = new FileWriter("outfile.dat");
inFile = new FileReader("infile.dat");

Exactly what do these statements do? The constructors create file objects for use in
your program and associate them with physical files on disk. The object is then assigned
to a file variable that you can reference in other statements in your program. The first
statement creates a connection between the file variable outFile and the disk file
named outfile.dat. (Names of file variables must be Java identifiers. But many com-
puter systems do not use Java syntax for file names on disk. For example, file names
can include dots and slashes (/) but file variable identifiers cannot.) Similarly, the sec-
ond statement associates the identifier inFile with the disk file infile.dat.

The constructor performs additional operations depending on whether the file is an
input file or an output file. With an input file, the constructor places the file pointer at
the first piece of data in the file. (Each input file has its own file pointer.)



9.1 File Input and Output | 389

File inFile after the call
to the constructor

File outFile after the call
to the constructor

inFile outFile

File
pointer

Operating system
file name:
infile.dat

Operating system
file name:
outfile.dat

File
pointer

Figure 9.2 The effect of calling a constructor for a character stream file object

With an output file, the constructor checks to see whether the file already exists. If
the file doesn’t exist, it creates a new, empty file for you. If the file does exist, it erases
the old contents of the file. Then the file pointer is placed at the beginning of the empty
file (see Figure 9.2). As output proceeds, each successive output operation advances the
file pointer to add data to the end of the file.

Because calling the constructor creates a file object and prepares the file for reading
or writing, you must call it before you can use any input or output methods that refer to
the file. It’s a good habit to call the constructor early in the program to be sure that the
files are prepared before any attempts to perform file I/O.

public static void main(String[] args)
{
FileWriter outFile;
FileReader inFile;
// Instantiate the file objects
outFile = new FileWriter("outfile.dat");
inFile = new FileReader("infile.dat");

}

Use Methods Associated with the File Object To Read or Write Data Once a file has
been declared and instantiated, we are ready to use it. The main operation that we can
perform on a file of class FileWriter is to write a value onto it. The write method can

.
.
.



390 | Chapter 9:  File I/O and Looping

either be passed a value of type int or a String object. The int value is converted
into the corresponding character code and written to the file as a character. If you use a
value of type char in place of an int, Java automatically converts the char value to
type int before calling write.

The conversion from char to int before the value is then output as a character
seems rather convoluted, and you may wonder why write doesn’t simply take a value
of type char directly. The reason is that there are characters we can’t type directly on
the keyboard, but all characters have a numerical equivalent in the Unicode character
set. Thus, if you want to output one of these characters, you can look up its correspon-
ding number and pass that value to write (see Appendix D for a partial listing of the
Unicode characters and their numerical values).

Here are some examples of calls to write. Recall from Chapter 2 that a literal of
type char is enclosed in single quotes and contains just one character.

outFile.write('X');
outFile.write(88);                            // Code 88 = 'X'
outFile.write("This is a string value.");

These statements write

XXThis is a string value.

onto outFile. To separate the values from each other in the output we can explicitly
insert blanks. For example, the statements

outFile.write('X');
outFile.write(' ');
outFile.write(88);                            // Code 88 = 'X'
outFile.write(' ');
outFile.write("This is a string value.");

produce the following output on the file:

X X This is a string value.

We can also separate the values by explicitly inserting the EOL, or new line mark (\n),
as follows.

outFile.write('X');
outFile.write('\n');
outFile.write(88); // Code 88 = 'X'
outFile.write('\n');
outFile.write("This is a string value.");



9.1 File Input and Output | 391

Recall from Chapter 2 that we said to use the escape sequence \' to write a single
quote as a char literal. Similarly, Java interprets the pair of characters \n as a single
character corresponding to the EOL mark. The output from this code segment is:

X
X
This is a string value.

Some operating systems do not immediately write data to a file after each call to
write. Instead, they keep the data in an area of main memory called a buffer and write
the data to the disk only when the buffer is full. The reason that this is done is to make
the program run faster. A disk access is about 100,000 times slower than copying data
between locations in memory. The operating system might save the data from 1,000
write operations in main memory before transferring the data to the disk, making the
program run nearly 1,000 times faster.

Occasionally, we need to force the operating system to write a partially filled buffer
to the disk. The FileWriter class has a method called flush that does this for us. For
example, if a user is entering data slowly, it could take an hour to fill the buffer, and a
power failure would lead to the loss of all the data in the buffer. We could write our
program so that every 10 minutes it calls flush to save the buffer’s contents on the
disk and thus reduce the potential for lost data. When we close the file, as discussed in
the next section, the buffer is automatically flushed.

Now we turn our attention to file input. The FileReader class has just one method
that we use for input. Reasonably enough, the name of the method is called read.
Unlike write, however, read is a value-returning method. It is called with no parame-
ters and returns an int value containing the code for a single Unicode character. If the
file contains no more data when read is called (the file pointer is at EOF), then read
returns the value 21, which is not a valid character code. As we will see later in this
chapter, detecting when there is no more data to be read is an important aspect of
working with files. Assuming that the variable datum is of type int, we can write a call
to read from the FileReader object inFile as follows:

datum = inFile.read();

When this statement executes, a single character is read from the disk file associated
with inFile, converted to the int value in the Unicode character set that represents it,
and then stored in datum. In addition, the file pointer advances to the next character in
the file. If the character 'M' had been written on the file, datum would contain the inte-
ger 77, because 77 is the character code for the letter M. If the digit 8 had been written
on the file, datum would contain 56, the character code for an 8. If the value in datum
is 21, then the file pointer is at EOF. If the value in datum is not 21, then it can be
converted to type char with an explicit type conversion. For example, if letter is of
type char, we can write:

letter = (char)datum;



392 | Chapter 9:  File I/O and Looping

If datum contained 77, letter would contain 'M'. If datum contained 56, letter
would contain '8'.

A value that has been input with read can be output to another file with write.
For example,

outFile.write(datum);

places the character associated with datum on the disk file associated with outFile.
That is, the value in datum is automatically converted to the character that it represents
before writing it on the file.

Reading data from a file does not destroy the data on the file. But because the file
pointer moves in just one direction, we cannot go back and reread data that has been
read from the disk file unless we return the pointer to the beginning of the file and start
over. As we see in the next section, closing a file and reassigning it to a file object with
new causes the file pointer to return to the start of the file.

Another method associated with objects of class FileReader is called skip. We
pass a long value to skip, which causes the file pointer to skip over that many charac-
ters in the file. Recall that we write a literal value of type long with an L at the end. For
example, the statement

inFile.skip(100L);

skips the next 100 characters in the file. Reading can then resume at the new position of
the file pointer. If skip reaches EOF before it has skipped the specified number of char-
acters, then the program halts with an error message.

Call a Method To Close the File After we have finished reading from or writing to a
file, it must be closed. Closing a file tells the operating system that we no longer need
the file, and makes it available for use by another program. Once a file is closed, it is no
longer associated with the corresponding identifier in our program. Each of the file
classes that we have discussed in this chapter has a void method called close
associated with it. The close method does not take any parameters. The following code
segment closes the files that we have been using in our discussions.

inFile.close();
outFile.close();

Although most Java systems automatically close every file when the program exits,
it is good programming practice to explicitly close each file. Also, once a program has
finished using a file, it should be closed immediately. You don’t have to wait until the
end of a program to close a file.

Once a file is closed, it can again be assigned a file object with a call to new. For
example, if the file infile.dat is associated with the file object inFile, we can write:

inFile.close();
inFile = new FileReader("infile.dat");



9.1 File Input and Output | 393

The effect of these two statements is to temporarily break the association between
the disk file (infile.dat) and the file identifier (inFile), and then restore their con-
nection. A side effect of these operations is that the file pointer is reset to the start of
the file as part of the constructor call. After the call to close, it would also be possible
to assign a different disk file to inFile, or to assign infile.dat to a different file
identifier. Here’s an example that does both:

inFile.close();
inFile = new FileReader("somefile.dat");
differentFile = new FileReader("infile.dat");

Extending File I/O with PrintWriter and BufferedReader

Java provides two file classes, PrintWriter and BufferedReader, which add useful
operations to those of FileWriter and FileReader. The BufferedReader and
PrintWriter classes allow us to read or write an entire line at once. These are gener-
ally more convenient than single character I/O.

We follow the same five steps for using these two new classes. The first step,
importing java.io.*, is exactly the same for all four file classes. We need not discuss
it further, except to note that it has only to be done once in a program, regardless of
which file classes we actually use. Now let’s look at the second step.

Declare the File Identifier The declaration of identifiers for PrintWriter and
BufferedReader is done in the same way as for FileReader and FileWriter, except
that we use the corresponding class names. Here’s an example:

PrintWriter payFile;
BufferedReader dataFile;

Instantiate the File Object The BufferedReader and PrintWriter file classes are
also instantiated with new, but the values passed to their constructors are different. We
pass file names to the constructors for FileWriter and FileReader objects. But
BufferedReader and PrintWriter are derived from FileWriter and FileReader
and simply add some extra methods so that we can read and write whole lines at once.

The extra methods work by repeatedly calling the methods associated with File-
Reader and FileWriter objects that input and output individual characters. Thus,
when we instantiate a BufferedReader object, we pass a FileReader object to its
constructor, and when we instantiate a PrintWriter object we pass a FileWriter
object to its constructor. For example, given the following declarations and statements,

FileWriter outFile;
FileReader inFile;
PrintWriter payFile;
BufferedReader dataFile;
outFile = new FileWriter("outfile.dat");
inFile = new FileReader("infile.dat");



394 | Chapter 9:  File I/O and Looping

PrintWriter
	 payFile

Added methods:
	 print
	 println

FileWriter outFile
Methods:
	 write
	 flush
	 close

Disk file
outfile.dat

BufferedReader
	 dataFile

Added methods:
	 readLine

FileReader inFile
Methods:
	 read
	 skip
	 close

Disk file
infile.dat

Figure 9.3 Relationship beween FileWriter and Printwriter, FileReader and BufferedReader

we can then write:

payFile = new PrintWriter(outFile);
dataFile = new BufferedReader(inFile);

Both payFile and outFile now refer to the disk file called outfile.dat. Simi-
larly, dataFile and inFile are objects that represent the file that the operating system
calls infile.dat. The objects payFile and dataFile merely have some extra meth-
ods associated with them. When we don’t need those methods, there’s no reason to use
PrintWriter or BufferedReader to extend FileWriter and FileReader. Figure 9.3
illustrates the relationship between these types in the context of our example declara-
tions and assignments.

Because the PrintWriter and BufferedReader classes include the same methods
as the FileWriter and FileReader classes, we don’t have to use the outFile and
inFile objects once the payFile and dataFile objects have been created. In fact,
when the only use for a FileWriter or FileReader is to give a value to a Print-
Writer or BufferedReader, we don’t even need to separately declare names for them.



9.1 File Input and Output | 395

We can create anonymous (nameless) FileWriter and FileReader objects within the
calls to the PrintWriter and BufferedReader constructors. That is, where we previ-
ously wrote

outFile = new FileWriter("outfile.dat");
payFile = new PrintWriter(outFile);

we can write:

payFile = new PrintWriter(new FileWriter("outfile.dat"));

And in place of writing

inFile = new FileReader("infile.dat");
dataFile = new BufferedReader(inFile);

we can just write:

dataFile = new BufferedReader(new FileReader("infile.dat"));

In most of our example applications we use PrintWriter and BufferedReader.
But on occasion, when we don’t need the ability to write and read whole lines at once,
we declare and use objects of the FileWriter and FileReader classes.

Use Methods Associated with the File Object To Read or Write The PrintWriter class
adds two more methods to those of the FileWriter classes: print and println.
These methods are programming conveniences that avoid the need to convert values to
char and String. In the case of println, we are also freed from having to write the
EOL escape sequence. Both print and println can be passed values of any of the
built-in Java data types. This is especially useful when you want to output a value of
type int. With a FileWriter, an int value is converted to the corresponding Unicode
character. But if we write

payFile.print(7419);

then the string "7419" is written out to the file.
When print and println write numbers on a file, they do not apply any format-

ting. All of the significant digits of a number are output so that it is possible for another
program to read the values back into main memory without any loss of precision.

The only difference between print and println is that println automatically
adds the EOL mark at the end of whatever it writes. For example, the following state-
ments do exactly the same thing.

payFile.print("Rate = " + rate + "\n");
payFile.println("Rate = " + rate);



396 | Chapter 9:  File I/O and Looping

Using println merely saves a small amount of extra typing. This example also
illustrates the typical usage of the string concatenation operator to combine several val-
ues in a single output statement. The value of the double variable rate is automati-
cally converted to class String before the concatenations take place.

We can also call println with no parameters as follows.

payFile.println();

What do you suppose this call does? Even when there is nothing for println to
output, it still writes an EOL mark on the file. This call is equivalent to writing,

payfile.print('\n');

In both cases, the result is that an EOL mark is written at the end of the file, indicat-
ing that any subsequent output starts on a new line. If you need to write multiple values
on one output line, you can use a series of calls to print, followed by a call to println:

payFile.print("Rate = ");
payFile.print(rate);
payFile.println();

The preceding three statements are equivalent to the following single statement.

payFile.println("Rate = " + rate);

Why would we ever want to write three statements when we can use just one? Some-
times values are computed in different sections of a program, yet you want them to all
appear together on one line. As each value is computed, you can write it to the file with
a call to print, and after all of the values have been written, you can start a new line
using a call to println.

A series of calls to println can be used to produce blank lines in the output. For
example, if we run the following code segment,

payFile.println('X');
payFile.println();
payFile.println(88);
payFile.println();
payFile.println("This is a string value.");

the output is:

X

88

This is a string value.

TE
AM
FL
Y

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

Team-Fly® 



9.1 File Input and Output | 397

We can rewrite these five statements as a single call to println,

payFile.println('X' + "\n\n" + 88 + "\n\nThis is a string value.");

but notice that this statement does not look much like the actual output. It is easier for a
human reader to determine what is output by the longer version. Calling println five
times in a row with simple values as parameters obviously writes five lines to the file.
With the shorter version, you must count the number of \n escape sequences and add 1
for the EOL that println automatically inserts, to know how many lines are output. As
you gain experience in reading programs written by other programmers, you grow to
appreciate every effort that makes the code easier to understand.

If you write a floating-point value to a file (or a text field, for that matter) that has
been calculated within the program, you have no control over the number of digits
printed. For example, in the extended Calculator program, if you divide 1 by 3, you
get .333333333. . . . You can use the String class valueOf method in conjunction with
String methods indexOf and substring to print only as many decimal digits as you
wish. The valueOf method is a class method that takes a value of a numeric type as a
parameter and returns a string representation of the value. We ask you to explore this
technique in the exercises.

Everything that we have said about writing to a file should sound somewhat familiar.
Recall the System.out object we introduced in Chapter 2. This object behaves in much
the same way as a PrintWriter object. However, System.out displays the output on
the screen, is automatically instantiated, and we don’t have to close it.

The BufferedReader class extends the FileReader type with a value-returning
method called readLine that returns an object of class String. The returned string
contains a line of input from the file, but without the EOL mark at the end of the line.
The readLine method actually reads the EOL mark but then discards it instead of stor-
ing it in the string. The file pointer thus advances to the start of the next line. If we read
a line from one file we can write it out to another file with println. For example, if
dataLine is a String object, we can write

dataLine = dataFile.readLine();
payFile.println(dataLine);

When println outputs the string in dataLine, it appends an EOL mark that
replaces the one discarded by readLine. The advantage of having readLine discard
the EOL mark is that is it easier to work with the input string. For example, if we want
to add some characters to the end of the string before we write it to payFile, we can
simply use string concatenation:

dataLine = dataFile.readLine();
dataLine = dataLine + "***";
payFile.println(dataLine);



398 | Chapter 9:  File I/O and Looping

If readLine did not discard the EOL mark, then after the concatenation there would be
an EOL mark between the last character from the input line and the appended stars. The
call to println would then output two lines on payFile.

What happens when we call readLine and the file pointer is at EOF? The answer is
similar to what happens with read. Recall that read returns an int value (21) that
isn’t a valid character code. Because readLine returns a instance of class String, it
can’t return 21. There is no corresponding invalid value of class String; even the
empty string ("") is a valid string. So Java defines a special value called null that sig-
nifies that a reference type variable contains an invalid value. When readLine discov-
ers that the file pointer is already at EOF, it returns the value null. Note that null is
not the same as the empty string. It is a unique value in Java that does not correspond
to any valid data value.

If readLine returns a string, how do we get numbers into our program? We do it
exactly the same way we did when using TextField variables. getText returns a
string that we must convert to a numeric value; we must do the same with the string
returned from readLine. Here is the example we used when getting a floating-point
value from the frame.

number = Double.valueOf(inputField.getText()).doubleValue();

Using this as a model, we see that we can input a floating-point value from the file as
follows.

double floatNumber;
floatNumber = Double.valueOf(dataFile.readLine()).doubleValue();

Likewise, an integer value can be read as

int intNumber;
intNumber = Integer.valueOf(dataFile.readLine()).intValue();

We return to the subject of reading data from files later in this chapter. Except for
some trivial cases, we must combine reading operations with loops to read through all
of the data on a file.

Call a Method To Close the File The last step is exactly the same for PrintWriter
and BufferedReader as for FileWriter and FileReader. Here’s an example:

dataFile.close();
payFile.close();

Exceptions with Input and Output

Recall in our discussion of the FileReader methods that we said there are situations
when calling skip can cause the program to halt with an error message. If we try to



9.1 File Input and Output | 399

assign a value to an input file object and the file doesn’t exist on the disk, the program
also halts with an error message. These kinds of errors are representative of an unusual
situation that Java calls an exception.

When a method signals that one of these
unusual errors has occurred, it is said to
throw an exception. We shall see in Chapter
10 how a Java program can in turn catch an
exception. If an exception isn’t caught by the
program, then it is subsequently caught by
the JVM, which halts the program and dis-
plays an error message.

Java recognizes two types of exceptions,
checked and unchecked. A checked exception
must be explicitly recognized by a program,
whereas unchecked exceptions can be ignored. For example, there are several excep-
tions that can happen when we work with strings. Because Java defines the String
class so that its exceptions are unchecked, we can simply write our string operations
and allow the JVM to catch any exceptions that are thrown. The file object types, File-
Reader and BufferedReader, and FileWriter define several exceptions that are
checked. We cannot simply ignore these exceptions. But Java does give us an option to
avoid catching a checked exception: We can explicitly ignore it by forwarding it.

When you forward an exception, you are
effectively saying, “OK, Java, I acknowledge
that you want me to catch this exception, but
I’m not going to do it here; I’m sending it on
to a higher authority.” You can think of for-
warding as the computer equivalent of “pass-
ing the buck.” If the exception is never
caught within the program, it eventually ends up at the desk of the JVM, which effec-
tively has a big sign saying “The Buck Stops Here!” The JVM is the ultimate higher
authority for a Java program.

To forward an exception, you simply add a throws clause to a method heading.
The clause specifies the name of the exception that is being forwarded. The
FileReader, BufferedReader, and FileWriter classes all throw an exception called
IOException. Thus, we need to add the clause throws IOException to the end of the
heading for each of our methods that call any of their methods. Here is an example of
the heading for main with the appropriate throws clause:

public static void main(String[] args) throws IOException

Note that we haven’t mentioned PrintWriter in any of the preceding discussion.
That is because PrintWriter methods do not throw any exceptions. However, even if
your program uses only PrintWriter objects for file output, you still need to forward

Exception An unusual situation that is detected
while a program is running. An exception halts the nor-
mal execution of the method.

Throw The act of signaling that an exception has
occurred. Throwing an exception is said to abnormally
terminate execution of a method.

Catch The processing of a thrown exception by a sec-
tion of code called an exception handler

Forward When a method calls another method that
throws an exception, it may pass the exception to its
own caller rather than catch the exception.



400 | Chapter 9:  File I/O and Looping

or catch an IOException because you have to create and pass a FileWriter object to
the PrintWriter constructor, and that FileWriter can throw an exception.

An Example Program Using Files

Now let’s put all of our discussion of file I/O together by writing a simple application.
The application should read a single line from an input file and display it in a field on
the screen so that the user can edit it. When the user closes the window, the contents of
the field are then written to an output file. Our user interface needs a label to prompt
the user, and a field to display the data, but there is no need for a button. Thus, the only
event handler that is required is the one that handles closing of the window. However,
that event handler is also where we write the contents of the field to the output file and
then close the file.

We use BufferedReader and PrintWriter file objects to simplify the input and
output of the line. They are given values that associate them with files called
infile.dat and outfile.dat. We can call readLine directly within the call to the
Textfield’s constructor because readLine returns a string and the constructor takes a
string as a parameter that specifies its default contents. Once the line has been read, we
close the input file.

When the window-closing event handler is called, it retrieves the contents of the
field using getText. The string that is returned by getText is passed directly to
println, which writes it on the file. After closing the output file, the event handler
removes the frame from the screen and halts the program.

import java.awt.*;                                // User interface classes
import java.awt.event.*;                          // Event handling classes
import java.io.*;                                 // File classes

public class EditLine
{
private static Frame editFrame;                 // Declare a frame
private static Label entryLabel;                // Label for field
private static TextField lineField;             // Editing field
private static PrintWriter outFile;             // Output data file
private static BufferedReader inFile;           // Input data file

public static void main(String[] args) throws IOException
{
inFile = new BufferedReader(

new FileReader("infile.dat"));         // Prepare input file
outFile = new PrintWriter(

new FileWriter("outfile.dat"));       // Prepare output file 
editFrame = new Frame();                      // Instantiate the frame



9.1 File Input and Output | 401

entryLabel = new Label("Edit then close window:"); // Give label a value
// Put input value in field
lineField = new TextField(inFile.readLine(), 40);
inFile.close();                                  // Done reading, 

//  close file

editFrame.setLayout(new FlowLayout());         // Set the layout 
//  manager

editFrame.add(entryLabel);                      // Add field label
//  to frame

editFrame.add(lineField);                   // Add edit field to
//  frame

editFrame.pack();                           // Pack the frame
editFrame.show();                            // Show the frame
editFrame.addWindowListener(new WindowAdapter()
{                //  event listener
// Register window closing
public void windowClosing(WindowEvent event)
{
// Put edited value on file
outFile.println(lineField.getText());
outFile.close();              // Close output file
editFrame.dispose();                   // Close the frame
System.exit(0);                        // Quit the program

}
});

}
}

If infile.dat contains the string "27.000", then here is how the frame initially
appears on the screen.

Here is the frame after being edited by the user.



402 | Chapter 9:  File I/O and Looping

After the window is closed, examination of outfile.dat with a text editor reveals that
it contains the single line,

This is a line of data to output to a file.

Before we move on, let’s take a closer look at the statements that perform the file input
and output operations in program EditLine. Both of them are examples of nested
method calls, which you have seen before:

lineField = new TextField(inFile.readLine(), 40);
outFile.println(lineField.getText());

Because Java depends so heavily on the use of method calls, it is quite natural to
see one call nested inside another in this manner. Nesting calls avoids having to declare
a separate variable or object to hold the return value, and saves an assignment opera-
tion. They can be used whenever a return value has no other use than to be passed
directly to another method. If the return value is needed at any other point in the pro-
gram, then it should be assigned to an identifier, and that identifier can then be used in
all of the places where the return value is needed. For example, if the input line is to be
written both in its original and its edited form onto the output file, then we would
instead declare a string variable, such as lineData, to hold the return value and write
the input section of the program as follows:

lineData = inFile.readLine();
lineField = new TextField(lineData, 40);
outFile.println(lineData);

9.2 Looping
In Chapter 6, we said that the flow of control in a program can differ from the physical
order of the statements. The physical order is the order in which the statements appear
in a program; the order in which we want the statements to be executed is called the
logical order.

The if statement is one way of making the logical
order different from the physical order. Looping con-
trol structures are another. A loop executes the same
statement (simple or compound) over and over, as
long as a condition or set of conditions is satisfied.

Loop A control structure that causes a statement or
group of statements to be executed repeatedly.

LOOP      (also called repetition or iteration)

WHILE condition DO statement1

Statement1

Condition
True

False





9.2 Looping | 403

In this chapter, we discuss different kinds of loops and how they are constructed
using the while statement. We also discuss nested loops (loops that contain other
loops) and introduce a notation for comparing the amount of work done by different
algorithms.

The while Statement

The while statement, like the if statement, tests a condition. Here is the syntax template
for the while statement:

and this is an example of one:

count = 1;
while (count <= 25)
count = count + 1;

The while statement is a looping control structure. The statement to be executed
each time through the loop is called the body of the loop. In the example above, the
body of the loop is a statement that adds 1 to the value of count. This while statement
says to execute the body repeatedly as long as count is less than or equal to 25. The
while statement is completed (hence, the loop stops) when count is greater than 25. The
effect of this loop, then, is to count through the int values from 1 to 25.

Just like the condition in an if statement, the condition in a while statement must
be an expression of type boolean. The while statement says, “If the value of the expres-
sion is true, execute the body and then go back and test the expression again. If the
expression’s value is false, skip the body.” So the loop body is executed over and over
as long as the expression is true when it is tested. When the expression is false, the
program skips the body and execution continues at the statement immediately following
the loop. Of course, if the expression is false to begin with, the body is not even exe-
cuted. Figure 9.4 shows the flow of control of the while statement, where Statement1 is
the body of the loop and Statement2 is the statement following the loop.

The body of a loop can be a block of statements, which allows us to execute any
group of statements repeatedly. Most often we use while loops in the following form:

while (Expression)
{

}

while ( Expression )
	 Statement

WhileStatement

.
.
.



404 | Chapter 9:  File I/O and Looping

while ( Expression )

Statement2

Statement1

false true

Figure 9.4 while statement flow of control

In this structure, if the expression is true, the entire sequence of statements in the
block is executed, and then the expression is checked again. If it is still true, the
statements are executed again. The cycle continues until the expression becomes
false.

Although in some ways the if and while statements are alike, there are fundamental
differences between them (see Figure 9.5). In the if structure, Statement1 is either
skipped or executed exactly once. In the while structure, Statement1 can be skipped,
executed once, or executed over and over. The if is used to choose a course of action;
the while is used to repeat a course of action.

Phases of Loop Execution

The body of a loop is executed in several phases:

• The moment that the flow of control reaches the
first statement inside the loop body is the loop
entry.

• Each time the body of a loop is executed, a pass is
made through the loop. This pass is called an
iteration.

Loop entry The point at which the flow of control
reaches the first statement inside a loop

Iteration An individual pass through, or repetition of,
the body of a loop



9.2 Looping | 405

if ( Expression )

Statement2

Statement1
false true

if (then ) Statement

while ( Expression )

Statement2

Statement1
false true

while Statement

Figure 9.5 A comparison of if and while

• Before each iteration, control is trans-
ferred to the loop test at the beginning
of the loop.

• When the last iteration is complete and
the flow of control has passed to the
first statement following the loop, the
program has exited the loop. The con-
dition that causes a loop to be exited is
the termination condition. In the case
of a while loop, the termination condi-
tion is that the while expression
becomes false.

Notice that the loop exit occurs only at one point: when the loop test is performed.
Even though the termination condition may become satisfied midway through the exe-
cution of the loop, the current iteration is completed before the computer checks the
while expression again.

The concept of looping is fundamental to programming. In this chapter, we spend
some time looking at typical kinds of loops and ways of implementing them with the
while statement. These looping situations come up again and again when you are ana-
lyzing problems and designing algorithms.

Loops Using the while Statement

In solving problems, you will come across
two major types of loops: count-controlled
loops, which repeat a specified number of
times, and event-controlled loops, which
repeat until something happens within the
loop. In the context of a loop, we use the
word event to mean a specific condition that

Loop test The point at which the while expression is
evaluated and the decision is made either to begin a
new iteration or skip to the statement immediately fol-
lowing the loop

Loop exit The point at which the repetition of the
loop body ends and control passes to the first state-
ment following the loop

Termination condition The condition that causes a
loop to be exited

Count-controlled loop A loop that executes a speci-
fied number of times

Event-controlled loop A loop that terminates when
something happens inside the loop body to signal that
the loop should be exited



406 | Chapter 9:  File I/O and Looping

we expect to occur during some iteration of the loop and that can be tested by a
boolean expression. Don’t confuse looping events with those that are caused by asyn-
chronous processes such as buttons. The latter cause an asynchronous transfer of con-
trol to an event handler, while looping events are merely Boolean conditions that are
checked in the loop test.

If you are making an angel food cake and the recipe reads, “Beat the mixture 300
strokes,” you are executing a count-controlled loop. If you are making a pie crust and
the recipe reads, “Cut with a pastry blender until the mixture resembles coarse meal,”
you are executing an event-controlled loop; you don’t know ahead of time the exact
number of loop iterations.

Count-Controlled Loops

A count-controlled loop uses a variable we call the loop control variable in the loop test.
Before we enter a count-controlled loop, we have to initialize (set the initial value of)
the loop control variable and then test it. Then, as part of each iteration of the loop, we
must increment (increase by 1) the loop control variable. Here’s an example:

loopCount = 1;                     // Initialization
while (loopCount <= 10)            // Test
{
.
.                                // Repeated actions
.
loopCount = loopCount + 1;       // Incrementation

}

Here loopCount is the loop-control variable. It is set to 1 before loop entry. The
while statement tests the expression

loopCount <= 10

and executes the loop body as long as the expression is true. The dots inside the com-
pound statement represent a sequence of statements to be repeated. The last statement
in the loop body increments loopCount by adding 1 to it.

Look at the statement in which we increment the loop control variable. Notice its form:

variable = variable + 1;

This statement adds 1 to the current value of the variable, and the result replaces the old
value. Variables that are used this way are called counters. In our example, loopCount
is incremented with each iteration of the loop—we use it to count the iterations. The
loop control variable of a count-controlled loop is always a counter.

TE
AM
FL
Y

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

Team-Fly® 



9.2 Looping | 407

We’ve encountered another way of incrementing a variable in Java. The incremen-
tation operator (++) increments the variable that is its operand. The statement

loopCount++;

has precisely the same effect as the assignment statement

loopCount = loopCount + 1;

From here on, we typically use the ++ operator, as do most Java programmers.
When designing loops, it is the programmer’s responsibility to see that the condi-

tion to be tested is set correctly (initialized) before the while statement begins. The pro-
grammer also must make sure the condition changes within the loop so that it
eventually becomes false; otherwise, the loop is never exited.

loopCount = 1; � Variable loopCount must be initialized
while (loopCount <= 10)
{

loopCount++; � loopCount must be incremented
}

A loop that never exits is called an infinite loop because, in theory, the loop exe-
cutes forever. In the code above, omitting the incrementation of loopCount at the bot-
tom of the loop leads to an infinite loop; the while expression is always true because
the value of loopCount is forever 1. If your program goes on running for much longer
than you expect it to, chances are that you’ve created an infinite loop. You may have to
issue an operating system command to stop the program.

How many times does the loop in our example execute—9 or 10? To determine this, we
have to look at the initial value of the loop control variable and then at the test to see what
its final value is. Here we’ve initialized loopCount to 1, and the test indicates that the loop
body is executed for each value of loopCount up through 10. If loopCount starts out at 1
and runs through 10, the loop body is executed 10 times. If we want the loop to execute 11
times, we have to either initialize loopCount to 0 or change the test to

loopCount <= 11

Event-Controlled Loops

There are several kinds of event-controlled loops: sentinel-controlled, end-of-file-con-
trolled, and flag-controlled. In all of these loops, the termination condition depends on
some event occurring while the loop body is executing.

Sentinel-Controlled Loops Loops often are used to read in and process long lists of
data. Each time the loop body is executed, a new piece of data is read and processed.

.
.
.



408 | Chapter 9:  File I/O and Looping

Often a special data value, called a sentinel or trailer value, is used to signal the
program that there is no more data to be processed. Looping continues as long as the
data value read is not the sentinel; the loop stops when the program recognizes the
sentinel. In other words, reading the sentinel value is the event that controls the looping
process.

A sentinel value must be something that never shows up in the normal input to a
program. For example, if a program reads calendar dates, we could use February 31 as a
sentinel value:

// This code is incorrect:
while ( !date.equals("0231") )
{
date = dataFile.readLine();           // Get a date

// Process it
}

There is a problem in the loop in the example above. The value of date is not
defined before the first pass through the loop. Somehow we have to initialize this string.
We could assign it an arbitrary value, but then we would run the risk that the first value
input is the sentinel value, which would then be processed as data. Also, it’s inefficient
to initialize a variable with a value that is never used.

We can solve the problem by reading the first data value before entering the loop.
This is called a priming read. (The idea is similar to priming a pump by pouring a bucket
of water into the mechanism before starting it.) Let’s add the priming read to the loop:

// This is still incorrect:
date = dataFile.readLine();             // Get a date--priming read
while ( !date.equals("0231") )
{
date = dataFile.readLine();           // Get a date

// Process it
}

With the priming read, if the first value input is the sentinel value, then the loop
correctly does not process it. We’ve solved one problem, but now there is a problem
when the first value input is valid data. Notice that the first thing the program does
inside the loop is to get a date, destroying the value obtained by the priming read. Thus,
the first date in the data list is never processed. Given the priming read, the first thing
that the loop body should do is process the data that’s already been read. But then at
what point do we read the next input value? We do this last in the loop. In this way, the
while condition is applied to the next input before it gets processed. Here’s how it looks:

// This version is correct:
date = dataFile.readLine();             // Get a date--priming read
while ( !date.equals("0231") )

.
.
.

.
.
.



9.2 Looping | 409

{
// Process it

date = dataFile.readLine();        // Get a date
}

This segment works fine. The first value is read in; if it is not the sentinel, it gets
processed. At the end of the loop, the next value is read in, and we go back to the
beginning of the loop. If the new value is not the sentinel, it gets processed just like the
first. When the sentinel value is read, the while expression becomes false, and the loop
exits (without processing the sentinel).

Many times the problem dictates the value of the sentinel. For example, if the prob-
lem does not allow data values of 0, then the sentinel value should be 0. Sometimes a
combination of values is invalid. The combination of February and 31 as a date is such
a case. Sometimes a range of values (negative numbers, for example) is the sentinel.
And when you process char data, one line of input at a time, the newline character
('\n') often serves as the sentinel. Here’s a code segment that reads and prints all of the
characters on an input line (inChar is of type char):

inChar = (char)inFile.read();           // Get first character
while (inChar != '\n')
{
outFile.write(inChar);                // Echo it
inChar = (char)inFile.read();         // Get next character

}

(Notice that for this particular task we use the read method, not the readLine method,
to input a single character.)

When you are choosing a value to use as a sentinel, what happens if there aren’t
any invalid data values? Then you may have to input an extra value in each iteration, a
value whose only purpose is to signal the end of the data. For example, look at this code
segment:

data = dataFile.readLine();             // Get first data line
sentinel = data.substring(0, 1);        // Extract sentinel character
while (sentinel.equals("Y"))
{
// Extract data value from line and convert to double
value = Double.valueOf(data.substring(1, data.length())).doubleValue();

// Process data value
data = dataFile.readLine();           // Get next data line
sentinel = data.substring(0, 1);      // Extract sentinel character

}

.
.
.

.
.
.



410 | Chapter 9:  File I/O and Looping

The first value on each line of the following data set is used to indicate whether or not
there are more lines of data. In this data set, when the sentinel value is anything other
than "Y", there is no more data; when it is "Y", there is more data.

Sentinel Data
Values Values

Y 12.78
Y –47.90
Y 5.33
Y 21.83
Y –99.01
N 59.99

What happens if you forget to include the sentinel value? Once all the data has
been read from the file, the loop body is executed again. However, there isn’t any data
left because the computer has reached the end of the file. In the next section, we
describe a way to use the end-of-file situation as an alternative to using a sentinel.

End-of-File-Controlled Loops After a program has read the last piece of data from an
input file, the computer is at the end of the file (EOF, for short). The next time that we
attempt to read from the file, there is nothing to read and thus there is nothing for the
read or readLine method to return. What happens? Each method has its own sentinel
value to return, which signals EOF. The read method normally returns a positive int
value corresponding to the code for a single character, so it returns the sentinel value
21. The readLine method normally returns a String value that holds the contents of
the line, and so it returns the null string as its sentinel.

Thus, to read and process lines from a file, we can write a sentinel-controlled loop
like the following:

line = dataFile.readLine();        // Get a line--priming read
while ( line != null )
{

// Process it
line = dataFile.readLine();        // Get the next line

}

Notice that the test in this while statement uses the relational operator != instead of
the equals method. The reason is that equals compares the contents of two strings,
but the meaning of null is that the String variable doesn’t even contain the address
of a String object. Thus, a null String has no contents to compare with. Be sure
that you understand the distinction between a null String and an empty string ("").
If the empty string is assigned to a String variable, then the variable contains the
address of a place in memory where a String object of length 0 is stored. When null

.
.
.



9.2 Looping | 411

is assigned to a String variable, it is given an invalid address value that refers to
nowhere in memory. The comparison

line.equals(null)

always returns false, because the null String has no contents that can be compared
to line. Even when

line == null

is true, the equals method in the preceding example returns false because it can’t
find any contents to compare.

Java provides a convenient way of avoiding the need to separately write the prim-
ing read and the read that gets the next value. When the input operation consists of a
simple assignment statement, we can instead write the loop as follows.

while ((line = dataFile.readLine()) != null)   // Get a line
{

// Process it
}

At first glance, the expression in the while statement looks rather strange. The rea-
son for its strangeness is that there is an aspect of the assignment operator that we
haven’t discussed yet. We have been writing the assignment operator in assignment
statements, such as

x = 2;

But the assignment operator can also appear in expressions, where it has a value and a
side effect. The side effect is the action we normally associate with assignment state-
ments: The result of the expression to the right of = is assigned to the variable to its left.
The value that = returns is the same as the value that is assigned to the variable. An
assignment statement is really just a special form of assignment expression where the
side effect (the assignment) takes place and then the value returned by the expression is
discarded. For example, in the following comparison,

(x = 2 + 2) == 5

the value 4 is assigned to the int variable x as a side effect, and the subexpression (x
= 2 + 2) has the result 4, which is compared to the literal 5, giving a final result of
false. When we use the result of an assignment expression in a comparison, we must
enclose the assignment expression in parentheses because = has the lowest precedence
of all the operators. Note that this is another example of why you must be careful not to
confuse the = and == operators in writing a comparison!

.
.
.



412 | Chapter 9:  File I/O and Looping

In the while statement,

while ((line = dataFile.readLine()) != null)    // Get a line
{

// Process it
}

line is thus assigned the value returned by readLine, and that same value (the result
of the assignment expression) is compared to null by the != operator.

Because the parentheses force the input operation to happen before the first com-
parison, the effect is the same as using a separate priming read. When control flow
reaches the end of the loop, it returns to the test in the while statement where another
input operation takes place before the comparison, with the same effect as using a sepa-
rate input operation at the end of the loop body. Thus, the input operation in the
assignment expression within the while statement’s comparison takes the place of two
separate input operations.

If we can write the while statement in this manner, why would we ever need the
longer form with the two separate input operations? When the test in the while state-
ment depends on something other than the value returned by the input operation, we
need to use the longer form. For example, if an input line contains three numbers that
must be converted to int values and their sum is then compared to zero to decide if the
loop should exit, we can’t use a simple assignment expression within the while. When-
ever the condition in the while depends on performing multiple operations on the input
value, it is best to code the input and the operations as separate priming and updating
statements before and within the loop.

Looping Subtasks

We have been looking at ways to use loops to affect the flow of control in programs.
But looping by itself does nothing. The loop body must perform a task in order for the
loop to accomplish something. In this section, we look at two tasks—counting and sum-
ming—that often are used in loops.

Counting A common task in a loop is to keep track of the number of times the loop
has been executed. For example, the following program fragment reads and counts
input characters until it comes to a period. (inChar and count are of type int.) The
loop in this example has a counter variable; but the loop is not a count-controlled loop
because the variable is not being used as a loop control variable.

count = 0;                              // Initialize counter
inChar = inFile.read()                  // Read a character
while ((char)inchar != '.')             // Test the character
{
count++;                              // Increment counter
inChar = inFile.read();               // Read a character

}

.
.
.



9.2 Looping | 413

The loop continues until a period is read. After the loop is finished, count contains
one less than the number of characters read. That is, it counts the number of characters
up to, but not including, the sentinel value (the period). Notice that if a period is the first
character, the loop body is not entered and count contains a zero, as it should. We use
a priming read here because the loop is sentinel-controlled, and because we are storing
the input character as an int but need to convert it to a char for the comparison.

The counter variable in this example is
called an iteration counter because its value
equals the number of iterations through the
loop. According to our definition, the loop
control variable of a count-controlled loop is
an iteration counter. However, as you’ve just
seen, not all iteration counters are loop control variables.

What happens if our example loop encounters EOF before it reads a period? It runs
forever (or at least until we terminate the program with an operating system command).
The reason is that read returns 21 when the file pointer is at EOF. The (char) conver-
sion translates this into a character code that doesn’t correspond to any valid character.
Thus, the result of comparing this invalid character for inequality with '.' is always
true, and the loop continues executing forever. The test in the while statement is thus
more properly written as follows:

while (inchar != –1 && (char)inchar != '.')          // Test the character

Summing Another common looping task is to sum a set of data values. Notice in the
following example that the summing operation is written the same way, regardless of
how the loop is controlled.

sum = 0;                                              // Initialize sum
count = 1;
while (count <= 10)
{
number = Integer.valueOf(dataFile.readLine()).intValue(); // Input a value
sum = sum + number;                                // Add value to sum
count++;

}

We initialize sum to 0 before the loop starts so that the first time the loop body exe-
cutes, the statement

sum = sum + number;

adds the current value of sum (0) to number to form the new value of sum. After the
entire code fragment has executed, sum contains the total of the 10 values read, count
contains 11, and number contains the last value read.

Iteration counter A counter variable that is incre-
mented with each iteration of a loop



414 | Chapter 9:  File I/O and Looping

Here count is incremented in each iteration. For each new value of count, there is
a new value for number. Does this mean we could decrement count by 1 and inspect
the previous value of number? No. Once a new value has been read into number, the
previous value is gone forever unless we’ve saved it in another variable. 

Let’s look at another example. This time, let’s also check for EOF. We want to count
and sum the first 10 odd numbers in a data set. We need to test each number to see if it
is even or odd. (We can use the modulus operator to find out. If number % 2 equals 1,
number is odd; otherwise, it’s even.) If the input value is even, we do nothing. If it is odd,
we increment the counter and add the value to our sum. We use a flag to control the loop
because this is not a normal count-controlled loop. In the following code segment, all
variables are of type int except the String line and the Boolean flag, notDone.

count = 0;                              // Initialize event counter
sum = 0;                                // Initialize sum
notDone = true;                         // Initialize loop control flag
while (notDone)
{
line = dataFile.readLine();           // Get a line
if (line != null) // Got a line?
{                                     // Try converting line to an int
number = Integer.valueOf(line).intValue();
if (number % 2 == 1)                // Is the int value odd?
{
count++;                          // Yes--Increment counter
sum = sum + number;               // Add value to sum
notDone = (count < 10);           // Update loop control flag

}
}
else // Hit EOF unexpectedly
{
errorFile.println("EOF reached before ten odd values read.");
notDone = false;                    // Update loop control flag

}
}

We control the loop with the flag notDone, because the loop exits when either of
two events occur: reading and processing 10 odd values or reaching EOF. Because we use
a Boolean flag to control the loop, this type of loop is often called a flag-controlled loop.

In this example, there is no relationship between
the value of the counter variable and the number of
times the loop is executed. Note that count is incre-
mented only when an odd number is read; it is an
event counter. We initialize an event counter to 0 and
increment it only when a certain event occurs. The

Event counter A variable that is incremented each
time a particular event occurs



9.2 Looping | 415

counter in the previous example was an iteration counter; it was initialized to 1 and
incremented during each iteration of the loop.

How to Design Loops

It’s one thing to understand how a loop works when you look at it and something else
again to design a loop that solves a given problem. In this section, we look at how to
design loops. We can divide the design process into two tasks: designing the control
flow and designing the processing that takes place in the loop. And we can break each
task into three phases: the task itself, initialization, and update. It’s also important to
specify the state of the program when it exits the loop, because a loop that leaves vari-
ables and files in a mess is not well designed.

There are seven different points to consider in designing a loop:

1. What is the condition that ends the loop?
2. How should the condition be initialized?
3. How should the condition be updated?
4. What is the process being repeated?
5. How should the process be initialized?
6. How should the process be updated?
7. What is the state of the program on exiting the loop?

We use these questions as a checklist. The first three help us design the parts of the loop
that control its execution. The next three help us design the processing within the loop.
The last question reminds us to make sure that the loop exits in an appropriate manner.

Designing the Flow of Control

The most important step in loop design is deciding what should make the loop stop. If
the termination condition isn’t well thought out, there’s the potential for infinite loops
and other mistakes. So here is our first question:

• What is the condition that ends the loop?

This question usually can be answered through a close examination of the problem
statement. For example:

Key Phrase in Problem Statement Termination Condition

“Sum 365 temperatures” The loop ends when a counter reaches 366 (count-controlled loop).

“Process all the data in the file” The loop ends when EOF occurs (EOF-controlled loop).

“Process until 10 odd integers have been read” The loop ends when 10 odd numbers have been input (event
counter).

“The end of the data is indicated by a negative The loop ends when a negative input value is encountered 
test score” (sentinel-controlled loop).



416 | Chapter 9:  File I/O and Looping

Now we need statements that make sure the loop gets started correctly and state-
ments that allow the loop to reach the termination condition. So we have to ask the
next two questions:

• How should the condition be initialized?
• How should the condition be updated?

The answers to these questions depend on the type of termination condition.

Count-Controlled Loops If the loop is count controlled, we initialize the condition by
giving the loop control variable an initial value. For count-controlled loops in which
the loop control variable is also an iteration counter, the initial value is usually 1. If the
process requires the counter to run through a specific range of values, the initial value
should be the lowest value in that range.

The condition is updated by increasing the value of the counter by 1 for each itera-
tion. (Occasionally, you may come across a problem that requires a counter to count
down from some higher value to a lower value. In this case, the initial value is the
greater value, and the counter is decremented by 1 for each iteration.) So, for count-
controlled loops that use an iteration counter, these are the answers to the questions:

• Initialize the iteration counter to 1.
• Increment the iteration counter at the end of each iteration.

If the loop is controlled by a variable that is counting an event within the loop, the
control variable usually is initialized to 0 and is incremented each time the event
occurs. For count-controlled loops that use an event counter, these are the answers to
the questions:

• Initialize the event counter to 0.
• Increment the event counter each time the event occurs.

Sentinel-Controlled Loops In sentinel-controlled loops, a priming read may be the only
initialization necessary. It also may be necessary to open the file in preparation for
reading. To update the condition, a new value is read at the end of each iteration. So,
for sentinel-controlled loops, we answer our questions this way:

• Open the file, if necessary, and input a value before entering the loop (priming read).
• Input a new value for processing at the end of each iteration.

EOF-Controlled Loops EOF-controlled loops require the same initialization as sentinel-
controlled loops. You must open the file, if necessary, and perform a priming read.
Updating the loop condition happens implicitly; the input value reflects the success or
failure of the operation. However, if the loop doesn’t read any data, it never reaches
EOF, so updating the loop condition means the loop must keep reading data.

Flag-Controlled Loops In flag-controlled loops, the Boolean flag variable must be
initialized to true or false and then updated when the condition changes.

TE
AM
FL
Y

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

Team-Fly® 



9.2 Looping | 417

• Initialize the flag variable to true or false, as appropriate.
• Update the flag variable as soon as the condition changes.

In a flag-controlled loop, the flag variable essentially remains unchanged until it is
time for the loop to end. Then the code detects some condition within the process being
repeated that changes the value of the flag (through an assignment statement). Because
the update depends on what the process does, at times we have to design the process
before we can decide how to update the condition.

Designing the Process within the Loop

Once we’ve determined the looping structure itself, we can fill in the details of the
process. In designing the process, we first must decide what we want a single iteration
to do. Assume for a moment that the process is going to execute only once. What tasks
must the process perform?

• What is the process being repeated?

To answer this question, we have to take another look at the problem statement.
The definition of the problem may require the process to sum up data values or to keep
a count of data values that satisfy some test. For example:

Count the number of integers in the file howMany.

This statement tells us that the process to be repeated is a counting operation.
Here’s another example:

Read a stock price for each business day in a week and compute the average price.

In this case, part of the process involves reading a data value. We have to conclude
from our knowledge of how an average is computed that the process also involves sum-
ming the data values.

In addition to counting and summing, another common loop process is reading
data, performing a calculation, and writing out the result. Many other operations can
appear in looping processes. We’ve mentioned only the simplest here; we look at some
other processes later on.

After we’ve determined the operations to be performed if the process is executed only
once, we design the parts of the process that are necessary for it to be repeated correctly.
We often have to add some steps to take into account the fact that the loop executes more
than once. This part of the design typically involves initializing certain variables before
the loop and then reinitializing or updating them before each subsequent iteration.

• How should the process be initialized?
• How should the process be updated?

For example, if the process within a loop requires that several different counts and
sums be performed, each must have its own statements to initialize variables, increment
counting variables, or add values to sums. Just deal with each counting or summing opera-



418 | Chapter 9:  File I/O and Looping

tion by itself—that is, first write the initialization statement, and then write the increment-
ing or summing statement. After you’ve done this for one operation, you go on to the next.

The Loop Exit

When the termination condition occurs and the flow of control passes to the statement
following the loop, the variables used in the loop still contain values. And if an input
file has been used, the reading marker has been left at some position in the file. Or
maybe an output file has new contents. If these variables or files are used later in the
program, the loop must leave them in an appropriate state. So, the final step in design-
ing a loop is answering this question:

• What is the state of the program on exiting the loop?

Now we have to consider the consequences of our design and double-check its valid-
ity. For example, suppose we’ve used an event counter and later processing depends on
the number of events. It’s important to be sure (with an algorithm walk-through) that the
value left in the counter is the exact number of events—that it is not off by 1.

Look at this code segment:

commaCount = 1;                 // This code is incorrect
while ((inChar = (char)inFile.read()) != '\n')
if (inChar == ',')
commaCount++;

outLabel.setText("" + commaCount);

This loop reads characters from an input line and counts the number of commas on the
line. However, when the loop terminates, commaCount equals the actual number of
commas plus 1 because the loop initializes the event counter to 1 before any events take
place. By determining the state of commaCount at loop exit, we’ve detected a flaw in the
initialization. commaCount should be initialized to zero. Note that this code segment is
also an example of using an assignment expression within a loop test, and because
there is just a single statement in the loop (the if statement) there is no need for the
usual brackets to enclose a block of statements.

Designing correct loops depends as much on experience as it does on the applica-
tion of design methodology. At this point, you may want to read through the Problem-
Solving Case Study at the end of the chapter to see how the loop-design process is
applied to a real problem.

Nested Loops

In Chapter 6, we described nested if statements. It’s also possible to nest while state-
ments. Both while and if statements contain statements and are themselves statements.
So the body of a while statement or the branch of an if statement can contain other
while and if statements. By nesting, we can create complex control structures.

Suppose we want to extend our code for counting commas on one line, repeating it
for all the lines in a file. We put an EOF-controlled loop around it:



9.2 Looping | 419

inChar = inFile.read();                   // Initialize outer loop
while (inChar != –1)                      // Outer-loop test for EOF
{
commaCount = 0;                         // Initialize inner loop
// Priming read is taken care of by outer loop's priming read
while (inChar != –1 && (char)inChar != '\n' )  // Inner-loop test
{
if (inChar == ',')
commaCount++;

// Update inner-termination condition
inChar = inFile.read();               

}
outLabel.setText("" + commaCount);
// Update outer-termination condition
inChar = inFile.read();                 

}

In this code, notice that we have omitted the priming read for the inner loop. The prim-
ing read for the outer loop has already “primed the pump.” It would be a mistake to
include another priming read just before the inner loop; the character read by the outer
priming read would be destroyed before we could test it. Our inner-loop test checks for
both end of line (\n) and for EOF (–1), just in case the last line in the file doesn’t end
with the newline character.

General Pattern

Let’s examine the general pattern of a simple nested loop. The dots represent places
where the processing and update may take place in the outer loop.

Notice that each loop has its own initialization, test, and update. It’s possible for an
outer loop to do no processing other than to execute the inner loop repeatedly. On the

Initialize outer loop

while ( Outer loop condition )
{

         :





      Initialize inner loop

      while ( Inner loop condition )
      {

        Inner loop processing and update

      }

        :

}



420 | Chapter 9:  File I/O and Looping

other hand, the inner loop might be just a small part of the processing done by the outer
loop; there could be many statements preceding or following the inner loop.

Let’s look at another example. For nested count-controlled loops, the pattern looks like
this (where outCount is the counter for the outer loop, inCount is the counter for the inner
loop, and limit1 and limit2 are the number of times each loop should be executed):

outCount = 1;                           // Initialize outer-loop counter
while (outCount <= limit1)
{

inCount = 1;                          // Initialize inner-loop counter
while (inCount <= limit2)
{

inCount++;                          // Increment inner-loop counter
}

outCount++;                           // Increment outer-loop counter
}

Here, both the inner and outer loops are count-controlled loops, but the pattern can be
used with any combination of loops. The following program fragment shows a count-
controlled loop nested within an EOF-controlled loop. The outer loop inputs an integer
value telling how many asterisks to print on each line of an output file. (We use the
numbers to the right of the code to trace the execution of the program.)

line = dataFile.readLine(); 1
while (line != null) 2
{
starCount = Integer.valueOf(line).intValue(); 3
loopCount = 1; 4
while (loopCount <= starCount) 5
{
outFile.print('*'); 6
loopCount++; 7

}
outFile.println(); 8
line = dataFile.readLine(); 9

}
outFile.println("End"); 10

To see how this code works, let’s trace its execution with these data values (<EOF>
denotes end-of-file):

3
1
<EOF>

.
.
.

.
.
.

.
.
.



9.2 Looping | 421

We’ll keep track of the variables line, starCount, and loopCount, as well as the logi-
cal expressions. To do this, we’ve numbered each line (except those containing only a
left or right brace). As we trace the program, we indicate the first execution of line 3 by
3.1, the second by 3.2, and so on. Each loop iteration is enclosed by a large brace, and
true and false are abbreviated as T and F (see Table 9.1).

Table 9.1 Code trace

Variables Logical Expressions

Statement line starCount loopCount line != null loopCount <= starCount Output

1.1 ’3’ — — — — —
2.1 ’3’ — — T — —
3.1 ’3’ 3 — — — —
4.1 ’3’ 3 1 — — —
5.1 ’3’ 3 1 — T —
6.1 ’3’ 3 1 — — *
7.1 ’3’ 3 2 — — —
5.2 ’3’ 3 2 — T —
6.2 ’3’ 3 2 — — *
7.2 ’3’ 3 3 — — —
5.3 ’3’ 3 3 — T —
6.3 ’3’ 3 3 — — *
7.3 ’3’ 3 4 — — —
5.4 ’3’ 3 4 — F —
8.1 ’3’ 3 4 — — \n (new-
line)
9.1 ’1’ 3 4 — — —
2.2 ’1’ 3 4 T — —
3.2 ’1’ 1 4 — — —
4.2 ’1’ 1 1 — — —
5.5 ’1’ 1 1 — T —
6.4 ’1’ 1 1 — — *
7.4 ’1’ 1 2 — — —
5.6 ’1’ 1 2 — F —
8.2 ’1’ 1 2 — — \n (new-
line)
9.2 null 1 2 — — —
2.3 null 1 2 F — —
10.1 null 1 2 — — End

Here’s the output on outFile from the program given the input used for our trace.

***
*
End



422 | Chapter 9:  File I/O and Looping

Because starCount and loopCount are variables, their values remain the same until
they are explicitly changed, as indicated by the repeating values in Table 9.1. The values of
the logical expressions line != null and loopCount <= starCount exist only when
the test is made. We indicate this fact with dashes in those columns at all other times.

Designing Nested Loops

To design a nested loop, we begin with the outer loop. The process being repeated
includes the nested loop as one of its steps. Because that step is more complex than a
single statement, our functional decomposition methodology tells us to make it a sepa-
rate module. We can come back to it later and design the nested loop just as we would
any other loop.

For example, here’s the design process for the outer loop for the preceding code
segment:

1. What is the condition that ends the loop? EOF is reached in the input.
2. How should the condition be initialized? A priming read should be performed before

the loop starts.

3. How should the condition be updated? An input statement should occur at the end
of each iteration.

4. What is the process being repeated? Using the value of the current input integer
starCount, the code should print that many asterisks across one output line.

5. How should the process be initialized? No initialization is necessary.
6. How should the process be updated? A sequence of asterisks is output and then a

newline character is output. There are no counter variables or sums to update.

7. What is the state of the program on exiting the loop? File dataFile is at EOF,
starCount contains the last integer read from the input stream, and the rows of
asterisks have been printed along with a concluding message.

From the answers to these questions, we can write this much of the algorithm:

Read line from dataFile
while NOT EOF

Set starCount to the integer equivalent to the string in line
Set loopCount = 1
while loopCount <= starCount

Print '*' on outFile
Increment loopCount

Output newline on outFile
Read line from dataFile

Print "End"



9.2 Looping | 423

After designing the outer loop, it’s obvious that the process in its body (printing a
sequence of asterisks) is a complex step that requires us to design an inner loop. So we
repeat the methodology for the corresponding lower-level module:

1. What is the condition that ends the loop? An iteration counter exceeds the value of
starCount.

2. How should the condition be initialized? The iteration counter should be initialized to 1.
3. How should the condition be updated? The iteration counter is incremented at the

output file.

4. What is the process being repeated? The code should print a single asterisk on the
output file

5. How should the process be initialized? No initialization is needed.
6. How should the process be updated? No update is needed.
7. What is the state of the program on exiting the loop? A single row of asterisks has

been printed, the writing marker is at the end of the current output line, and loop-
Count contains a value one greater than the current value of starCount.

Now we can write the algorithm:

Of course, nested loops themselves can contain nested loops (called doubly-nested
loops), which can contain nested loops (triply-nested loops), and so on. You can use this
design process for any number of levels of nesting. The trick is to defer details using the
functional decomposition methodology—that is, focus on the outermost loop first, and
treat each new level of nested loop as a module within the loop that contains it.

It’s also possible for the process within a loop to include more than one loop. For
example, here’s an algorithm that reads people’s names from a file and prints them on
another file, omitting the middle name in the output:

Read line from dataFile
while NOT EOF

Set starCount to the integer equivalent to the string in line
Print starCount asterisks
Output newline on outFile
Read line from dataFile

Print "End"



424 | Chapter 9:  File I/O and Looping

The steps for reading the first name, middle name, and last name require us to design
three separate loops. All of these loops are sentinel-controlled.

This kind of complex control structure would be difficult to read if written out in
full. There are simply too many variables, conditions, and steps to remember at one
time. When a responsibility algorithm becomes this complex, it is an indication that we
have missed some objects in the brainstorming and scenario phases. In this case, we
should extend FileReader with new methods that get the first, middle, and last names.
We could call the new class NameFileReader.

Theoretical Foundations
Analysis of Algorithms

If you are given the choice of cleaning a room with a toothbrush or a broom, you probably
would choose the broom. Using a broom sounds like less work than using a toothbrush. True, if
the room is in a doll house, it may be easier to use the toothbrush, but in general a broom is
the faster way to clean. If you are given the choice of adding numbers together with a pencil
and paper or a calculator, you would probably choose the calculator because it is usually less
work. If you are given the choice of walking or driving to a meeting, you would probably
choose to drive; it sounds like less work.

What do these examples have in common? What do they have to do with computer sci-
ence? In each of the settings mentioned, one of the choices seems to involve significantly less
work. Precisely measuring the amount of work is difficult in each case, because there are
unknowns. How large is the room? How many numbers are there? How far away is the meet-
ing? In each case, the unknown information is related to the size of the problem. If the prob-
lem is especially small (for example, adding 2 plus 2), our original estimate of which approach

t

Read and print first name (ends with a comma)
while NOT EOF

Read and discard characters from middle name (ends with a comma)
Read and print last name (ends at newline)
Output newline
Read and print first name (ends with a comma)

continued



9.2 Looping | 425

to take (using the calculator) might be wrong. However, our intuition is usually correct, because most
problems are reasonably large.

In computer science, we need a way of measuring the amount of work done by an algorithm rela-
tive to the size of a problem, because there is usually more than one algorithm that solves any given
problem. We often must choose the most efficient algorithm—the algorithm that does the least work
for a problem of a given size.

The amount of work involved in executing an algo-
rithm relative to the size of the problem is called the
complexity of the algorithm. We would like to be able
to look at an algorithm and determine its complexity.
Then we could take two algorithms that perform the
same task and determine which completes the task
faster (requires less work).

How do we measure the amount of work required to execute an algorithm? We use the total
number of steps executed as a measure of work. One statement, such as an assignment, may require
only one step; another, such as a loop, may require many steps. We define a step as any operation
roughly equivalent in complexity to a comparison, an I/O operation, or an assignment.

Given an algorithm with just a sequence of simple statements (no branches or loops), the number of
steps performed is directly related to the number of statements. When we introduce branches, however,
we make it possible to skip some statements in the algorithm. Branches allow us to subtract steps with-
out physically removing them from the algorithm because only one branch is executed at a time. But
because we usually want to express work in terms of the worst-case scenario, we use the number of
steps in the longest branch.

Now consider the effect of a loop. If a loop repeats a sequence of 15 simple statements 10 times,
it performs 150 steps. Loops allow us to multiply the work done in an algorithm without physically
adding statements.

Now that we have a measure for the work done in an algorithm, we can compare algorithms. For
example, if Algorithm A always executes 3,124 steps and Algorithm B always does the same task in
1,321 steps, then we can say that Algorithm B is more efficient—that is, it takes fewer steps to
accomplish the same task.

If an algorithm, from run to run, always takes the same number of steps or fewer, we say that it
executes in an amount of time bounded by a constant. Such algorithms are referred to as having
constant-time complexity. Be careful: Constant time doesn’t mean small; it means that the amount
of work done does not exceed some amount from one run to another regardless of the size of the
problem.

If a loop executes a fixed number of times, the work done is greater than the physical number of
statements but still is constant. What happens if the number of loop iterations can change from one
run to the next? Suppose a data file contains N data values to be processed in a loop. If the loop reads
and processes one value during each iteration, then the loop executes N iterations. The amount of

Analysis of Algorithms

Complexity A measure of the effort expended by the
computer in performing a computation, relative to the
size of the computation

tcontinued



426 | Chapter 9:  File I/O and Looping

work done thus depends on a variable, the number of data values. The variable N determines the size of
the problem in this example.

If we have a loop that executes N times, the number of steps to be executed is some factor times
N. The factor is the number of steps performed within a single iteration of the loop. Specifically, the
work done by an algorithm with a data-dependent loop is given by the expression

where S1 is the number of steps in the loop body (a constant for a given simple loop), N is the num-
ber of iterations (a variable representing the size of the problem), and S0 is the number of steps out-
side the loop. Mathematicians call expressions of this form linear; hence, algorithms such as this are
said to have linear-time complexity. Notice that if N grows very large, the term S1 3 N dominates
the execution time. That is, S0 becomes an insignificant part of the total execution time. For example,
if S0 and S1 are each 20 steps, and N is 1,000,000, then the total number of steps is 20,000,020. The
20 steps contributed by S0 are a tiny fraction of the total.

What about a data-dependent loop that contains a nested loop? The number of steps in the inner
loop, S2, and the number of iterations performed by the inner loop, L, must be multiplied by the num-
ber of iterations in the outer loop:

By itself, the inner loop performs (S2 3 L) steps, but because it is repeated N times by the outer loop,
it accounts for a total of (S2 3 L 3 N ) steps. If L is a constant, then the algorithm still executes in
linear time.

Now, suppose that for each of the N outer loop iterations the inner loop performs N steps (L = N ).
Here the formula for the total steps is

S N N S N S2 1 0× ×( ) + ×( ) +

S L N S N S2 1 0× ×( ) + ×( ) +

Steps performed
by the nested loop

Steps performed
by the outer loop

Steps performed outside
the outer loop

S N S1 0× +

Steps performed
by the loop

Steps performed
outside the loop

Analysis of Algorithms

tcontinued

TE
AM
FL
Y

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

Team-Fly® 



9.2 Looping | 427

or

Because N 2 grows much faster than N (for large values of N ), the inner-loop term (S 2 3 N
2)

accounts for the majority of steps executed and the work done. So the corresponding execution time
is essentially proportional to N 2 Mathematicians call this type of formula quadratic. If we have a
doubly nested loop, where each loop depends on N , then the expression is

and the work and time are proportional to N 3 whenever N is reasonably large. Such a formula is
called cubic.

The following table shows the number of steps required for each increase in the exponent of N,
where N is a size factor for the problem, such as the number of input values.

As you can see, each time the exponent increases by 1, the number of steps is multiplied by an
additional order of magnitude (factor of 10). That is, if N is made 10 times greater, the work involved
in an N 2 algorithm increases by a factor of 100, and the work involved in an N 3 algorithm increases
by a factor of 1,000. To put this in more concrete terms, an algorithm with a doubly-nested loop, in
which each loop depends on the number of data values, takes 1,000 steps for 10 input values and 1
quadrillion steps for 100,000 values. On a computer that executes 1 billion instructions per second,
the latter case would take more than 10 days to run.

The table also shows that the steps outside of the innermost loop account for an insignificant por-
tion of the total number of steps as N gets bigger. Because the innermost loop dominates the total
time, we classify the complexity of an algorithm according to the highest order of N that appears in
its complexity expression, called the order of magnitude, or simply the order of that expression. So we 

S N S N S N S3
3

2
2

1 0×( ) + ×( ) + ×( ) +

S N S N S2
2

1 0×( ) + ×( ) +

Analysis of Algorithms

t

N N0 N1 N2 N3
(Constant) (Linear) (Quadratic) (Cubic)

1 1 1 1 1
10 1 10 100 1,000

100 1 100 10,000 1,000,000
1,000 1 1,000 1,000,000 1,000,000,000

10,000 1 10,000 100,000,000 1,000,000,000,000
100,000 1 100,000 10,000,000,000 1,000,000,000,000,000

continued



428 | Chapter 9:  File I/O and Looping

talk about algorithms having “order N-squared complexity” (or cubed or so on) or we describe them
with what is called Big-O notation. We express the complexity by putting the highest order term in
parentheses with a capital O in front. For example, O(1) is constant time; O(N ) is linear time; O(N 2 ) is
quadratic time; and O(N 3 ) is cubic time.

Determining the complexities of different algorithms allows us to compare the work they require
without having to program and execute them. For example, if you had an O(N 2 ) algorithm and a lin-
ear algorithm that performed the same task, you probably would choose the linear algorithm. We say
probably because an O(N 2 ) algorithm actually may execute fewer steps than an O(N ) algorithm for
small values of N. Remember that if the size factor N is small, the constants and lower-order terms in
the complexity expression may be significant.

Let’s look at an example. Suppose that algorithm A is O(N 2 ) and that algorithm B is O(N ). For large
values of N, we would normally choose algorithm B because it requires less work than A. But suppose
that in algorithm B, S0 = 1,000 and S1 = 1,000. If N = 1, then algorithm B takes 2,000 steps to execute.
Now suppose that for algorithm A, S0 = 10, S1 = 10, and S2 = 10. If N = 1, then algorithm A takes only
30 steps. Here is a table that compares the number of steps taken by these two algorithms for different
values of N.

From this table we can see that the O(N 2 ) algorithm A is actually faster than the O(N ) algorithm
B, up to the point that N equals 100. Beyond that point, algorithm B becomes more efficient. Thus, if
we know that N is always less than 100 in a particular problem, we would choose algorithm A. For
example, if the size factor N is the number of test scores on an exam and the class size is limited to
30 students, algorithm A would be more efficient. On the other hand, if N is the number of scores at
a university with 25,000 students, we would choose algorithm B.

Constant, linear, quadratic, and cubic expressions are all examples of polynomial expressions.
Algorithms whose complexity is characterized by such expressions are therefore said to execute in 

Analysis of Algorithms

N Algorithm A Algorithm B

1 30 2,000
2 70 3,000
3 130 4,000

10 1,110 11,000
20 4,210 21,000
30 9,310 31,000
50 25,510 51,000

100 101,010 101,000
1,000 10,010,010 1,001,000

10,000 1,000,100,010 10,001,000

tcontinued



Problem-Solving Case Study | 429

Problem-Solving Case Study
Average Income by Gender

Problem You’ve been hired by a law firm that is working on a sex discrimination case. Your
firm has obtained a file of incomes, gender.dat, which contains the salaries for every
employee in the company being sued. Each salary amount is preceded by 'F' for female or
'M' for male. As a first pass in the analysis of this data, you’ve been asked to compute the
average income for females and the average income for males. The output should be saved on
a file to be reviewed later.

Brainstorming Most of the nouns in this problem statement relate to the reason for the
problem, not the problem itself. There are two file objects, one for input and one for output.
The result of the application is a pair of averages, one for males and one for females. These
averages are double values, not classes. Therefore, we only have three classes.

Filtering No filtering is necessary in a problem this simple.

Scenarios What happens when we see an 'F'? We add the corresponding salary to the
female sum. Otherwise, we add the salary to the male sum. When all of the figures have been
read and summed, we calculate the average female’s salary and the average male’s salary.
Calculate the average—we musn’t forget to keep track of how many males and females there
are. All the responsibility for this application lies in the application class; let’s call it class
Incomes. Because there is no event processing in this application and there is only one class,
all the processing is done in class Incomes.

input file
output file
application class

polynomial time and form a broad class of algorithms that encompasses everything we’ve discussed
so far.

In addition to polynomial-time algorithms, we encounter a logarithmic-time algorithm in Chapter
12. There are also factorial (O(N! )), exponential (O(N N )), and hyperexponential (O(N N N )) class algo-
rithms, which can require vast amounts of time to execute and are beyond the scope of this book. For
now, the important point to remember is that different algorithms that solve the same problem can
vary significantly in the amount of work they do.

Analysis of Algorithms



430 | Chapter 9:  File I/O and Looping

CRC card

Responsibility Algorithms
The algorithms for preparing the input and output files are very straightforward.

Prepare File for Input Level 1

Prepare File for Output Level 1

Calculating the averages is more difficult. We remember the basic algorithm from applica-
tion RainFall. To calculate a single average we sum the values and divide by the number of
values. In that problem the processing was done in the event handler for the input button.
Here we must explicitly write the loop, which involves a loop with several subtasks, because
we must calculate two averages instead of just one. We use our checklist of questions to
develop these subtasks in detail.

1. What is the condition that ends the loop? The termination condition is EOF on the file
inFile. It leads to the following loop test (in pseudocode).

while NOT EOF on inFile

Declare PrintWriter, outFile
Instantiate outFile, “results.dat”

Declare BufferedReader, inFile
Instantiate inFile, “incomes.dat”

Class Name: Incomes Superclass: Object Subclasses:

Responsibilities Collaborations

Prepare the file for input FileReader, BufferedReader

Prepare the file for output FileWriter, PrintWriter

Calculate the averages BufferedReader

Write results to file PrintWriter



Problem-Solving Case Study | 431

2. How should the condition be initialized? A priming read must take place to enter a gender
code and amount.

3. How should the condition be updated? We must input a new data line with a gender code
and amount at the end of each iteration.

We must input each data line as a string. Then we need to extract the gender code and
amount from the string. Because the input of the line is a single operation, we can com-
bine the priming read and the updating read using Java’s assignment expression shortcut.
Here’s the resulting algorithm:

4. What is the process being repeated? From our knowledge of how to compute an average, we
know that we have to count the number of amounts and divide this number into the sum of
the amounts. Because we have to do this separately for females and males, the process con-
sists of four parts: counting the females and summing their incomes, and then counting the
males and summing their incomes. We develop each of these in turn.

5. How should the process be initialized? femaleCount and femaleSum should be set to
zero. maleCount and maleSum should also be set to zero.

6. How should the process be updated? When a female income is input, femaleCount is
incremented, and the income is added to femaleSum. Otherwise, an income is assumed
to be for a male, so maleCount is incremented, and the amount is added to maleSum.

7. What is the state of the program on exiting the loop? The file inFile is at EOF; female-
Count contains the number of input values preceded by 'F'; femaleSum contains the
sum of the values preceded by 'F'; maleCount contains the number of values not pre-
ceded by 'F'; and maleSum holds the sum of those values.

From the description of how the process is updated, we can see that the loop must
contain an if structure, with one branch for female incomes and the other for male
incomes. Each branch must increment the correct event counter and add the income
amount to the correct total. After the loop has exited, we have enough information to
compute the averages, dividing each total by the corresponding count.

Now we’re ready to write the complete algorithm:

Calculate the Averages Level 1

Initialize variables
while Reading inLine from inFile does not return EOF

Extract gender code and amount from inLine
Update process

Compute average incomes

while Reading inLine from inFile does not return EOF
Extract gender code and amount from inLine
: (Process being repeated)



432 | Chapter 9:  File I/O and Looping

Initialize Variables Level 2

Extract Gender Code and Amount from inLine

We haven’t discussed the operation of getting a single character from a string. The String
class provides a value-returning instance method called charAt that takes an int value as its
parameter. The int specifies the position of the character to be copied from the string and the
method returns the character as a value of type char. We can thus implement the first line of
this algorithm with the statement:

gender = inLine.charAt(0);

Update Process

Compute Average Incomes

Write Results to File Level 1

Println “For “ + femaleCount + “ females, the average income is “ +  femaleAvg + “.”
Println “For “ + maleCount + “ males, the average income is “ +  maleAvg + “.”

Set femaleAverage to femaleSum / (double)femaleCount
Set maleAverage to maleSum / (double)maleCount

if gender is ‘F’
Increment femaleCount
Add amount to femaleSum

else
Increment maleCount
Add amount to maleSum

Set gender to char at position 0 of inLine
Set amountString to substring of inLine starting at position 2, through end of inLine
Set amount to amountString converted to double

Set femaleCount to 0
Set femaleSum to 0.0
Set maleCount to 0
Set maleSum to 0.0



Problem-Solving Case Study | 433

All of these algorithms depend on the file being created in a certain way. These assump-
tions should be stated in a special section of the design.

Assumptions There is at least one male and one female among all the data sets. The data sets
are all entered properly in the input file, with the gender code in the first character position on
each line and a floating point number starting in the third character position. The only gender
codes in the file are 'M' and 'F'—any other codes are counted as 'M'. (This last assumption
invalidates the results if there are any illegal codes in the data. Case Study Follow-Up Exercise 1
asks you to change the program as necessary to address this problem.)

Before we write the program, we need to look back over the algorithm and see if there are
repeating processes that should be encapsulated into helper methods. The summing and
counting are the same for both males and females. There could be a summing and counting
method, but it would need three parameters for a two statement method body. Let’s just code
it inline.

Here is the code for the application.

import java.io.*;                          // File types

public class Incomes
// This program reads a file of income amounts classified by
//  gender and computes the average income for each gender
{
public static void main(String[] args) throws IOException
{
int femaleCount;                       // Keeps count of females
double femaleSum;                      // Keeps total of salaries
double femaleAvg;                      // Holds average salary
int maleCount;                         // Keeps count of males
double maleSum;                        // Keeps total of salaries
double maleAvg;                        // Holds average salary
String inLine;                         // A line from the file
char gender;                           // Indicates gender
String amountString;                   // Amount part of input line
double amount;                         // Salary amount
BufferedReader inFile;                 // Input data file
PrintWriter outFile;                   // Output data file

// Prepare files for reading and writing
inFile = new BufferedReader(new FileReader("gender.dat"));
outFile = new PrintWriter(new FileWriter("results.dat"));

// Calculate averages
// Initialize process
femaleCount = 0;
femaleSum = 0.0;
maleCount = 0;



434 | Chapter 9:  File I/O and Looping

maleSum = 0.0;

while ((inLine = inFile.readLine()) != null)
{
// Update process
// Extract gender code and amount from input line
gender = inLine.charAt(0);           // Gender is the first character
//  Amount begins in the third position.
amountString = inLine.substring(2, inLine.length());
amount = Double.valueOf(amountString).doubleValue();

// Process amount based on gender code
if (gender == 'F')
{ // female
femaleCount++;
femaleSum = femaleSum + amount;

}
else
{ // male
maleCount++;
maleSum = maleSum + amount;

}
}

// Compute average incomes
femaleAvg = femaleSum / (double)femaleCount;
maleAvg = maleSum / (double)maleCount;

// Write results
outFile.println ("For " + femaleCount + " females, the average income "
"is " +  femaleAvg + ".")

outFile.println ("For " + maleCount + " males, the average income is "
+

maleAvg + ".")
inFile.close();
outFile.close();

}
}

Testing Given the following data on file incomes.dat:

F 24345.23
F 17812.99
F 59207.34



Testing and Debugging | 435

M 38119.29
M 29228.99
M 89101.73
F 47237.83
M 31820.04
F 32933.73
F 45910.86

program Incomes writes the following on file results.dat:

For 6 females, the average income is 37907.99666666667.
For 4 males, the average income is 47067.51250000004.

With an EOF-controlled loop, the obvious test cases are a file with data (as shown above)
and an empty file. We should test input values of both 'F' and 'M' for the gender, and try
some typical data (so we can compare the results with our hand-calculated values) and some
atypical data (to see how the process behaves). The application assumed that the data file
included at least one woman and one man, but in general, an atypical data set for testing a
counting operation is an empty file, which should result in a count of zero. Any other result for
the count indicates an error. For a summing operation, atypical data might include negative or
zero values.

The Incomes program is not designed to handle empty files or negative income values;
the assumption that the file was not empty and contained at least one male and one female
was written in the design. An empty file causes both femaleCount and maleCount to equal
zero at the end of the loop. Although this is correct, the statements that compute average
income cause the program to produce invalid results (infinity) because they divide by zero. And
a negative income would be treated like any other value, even though it is probably a mistake.

To correct these problems, we should insert if statements to test for the error conditions
at the appropriate points in the program. When an error is detected, the program should either
display an error message or write an error report to a file instead of carrying out the usual
computation. This prevents a crash and allows the program to keep running. We call a program
that can recover from erroneous input and keep running a robust program.

Testing and Debugging
Loop-Testing Strategy

Even if a loop has been properly designed, it is still important to test it rigorously,
because the chance of an error creeping in during the implementation phase is always
present. To test a loop thoroughly, we must check for the proper execution of both a
single iteration and multiple iterations.

Remember that a loop has seven parts (corresponding to the seven questions in our
checklist). A test strategy must test each part. Although all seven parts aren’t imple-
mented separately in every loop, the checklist reminds us that some loop operations
serve multiple purposes, each of which should be tested. For example, the incrementing



436 | Chapter 9:  File I/O and Looping

statement in a count-controlled loop may be updating both the process and the ending
condition. So it’s important to verify that it performs both actions properly with respect
to the rest of the loop.

Consider what the acceptable ranges of variables are and what sorts of I/O opera-
tions you expect to see in the loop. Try to devise data sets that could cause the variables
to go out of range or leave the files in unexpected states.

It’s also good practice to test a loop for four special cases: (1) when the loop is
skipped entirely, (2) when the loop body is executed just once, (3) when the loop exe-
cutes some normal number of times, and (4) when the loop fails to exit.

Statements following a loop often depend on its processing. If a loop can be
skipped, those statements may not execute correctly. If it’s possible to execute a sin-
gle iteration of a loop, the results can show whether the body performs correctly in
the absence of the effects of previous iterations, which can be very helpful when
you’re trying to isolate the source of an error. Obviously, it’s important to test a loop
under normal conditions, with a wide variety of inputs. If possible, you should test
the loop with real data in addition to mock data sets. Count-controlled loops should
be tested to be sure they execute exactly the right number of times. And finally, if
there is any chance that a loop might never exit, your test data should try to make
that happen.

Testing a program can be as challenging as writing it. To test a program, you need
to step back, take a fresh look at what you’ve written, and then attack it in every way
possible to make it fail. This isn’t always easy to do, but it’s necessary if your programs
are going to be reliable. (A reliable program is one that works consistently and without
errors regardless of whether the input data is valid or invalid.)

Test Plans Involving Loops

In Chapter 6, we introduced formal test plans and discussed the testing of branches.
Those guidelines still apply to programs with loops, but here we provide some addi-
tional guidelines that are specific to loops. In general, the goal of testing a loop is to
verify that it behaves as expected.

Unfortunately, when a loop is embedded in a larger program, it sometimes is diffi-
cult to control and observe the conditions under which the loop executes using test data
and output alone. In come cases we must use indirect tests. For example, if a loop reads
floating-point values from a file and prints their average without echo-printing them,
you cannot tell directly that the loop processes all the data. If the data values in the file
are all the same, then the average appears correct as long as even one of them is
processed. You must construct the input file so that the average is a unique value that
can be arrived at only by processing all the data.

What we would like to do to simplify our testing of such loops is to observe the
values of the variables involved in the loop at the start of each iteration. How can we
observe the values of variables while a program is running? Two common techniques
are the use of the system’s debugger program and the use of extra output statements
designed solely for debugging purposes. We discuss these techniques in the section Test-
ing and Debugging Hints.

TE
AM
FL
Y

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

Team-Fly® 



Testing and Debugging | 437

Now let’s look at some test cases that are specific to the different types of loops that
we’ve seen in this chapter.

Count-Controlled Loops When a loop is count-controlled, you should include a test
case that specifies the output for all the iterations. It may help to add an extra column
to the test plan that lists the iteration number. If the loop reads data and outputs a
result, then each input value should produce a different output to make it easier to spot
errors. For example, in a loop that is supposed to read and print 100 data values, it is
easier to tell that the loop executes the correct number of iterations when the values are
1, 2, 3 ... 100 than if they are all the same.

If the program inputs the iteration count for the loop, you need to test the cases in
which the count is invalid. For example, when a negative number is input, an error
message should be output and the loop should be skipped. You should also test various
valid cases. When a count of 0 is input, the loop should be skipped; when a count of 1
is input, the loop should execute once; and when some typical number of iterations is
input, the loop should execute the specified number of times.

Event-Controlled Loops In an event-controlled loop, you should test the situation in
which the event occurs before the loop, in the first iteration, and in a typical number of
iterations. For example, if the event is that EOF occurs, then try an empty file, a file
with one data set, and another with several data sets. If your testing involves reading
from test files, you should attach printed copies of the files to the test plan and identify
each in some way so that the plan can refer to them. It also helps to identify where each
iteration begins in the Input and Expected Output columns of the test plan.

When the event is the input of a sentinel value, you need the following test cases:
The sentinel is the only data set, the sentinel follows one data set, and the sentinel fol-
lows a typical number of data sets. Given that sentinel-controlled loops involve a prim-
ing read, it is especially important to verify that the first and last data sets are processed
properly.

Testing and Debugging Hints

1. For each file that a program uses, check that all five of the required steps are per-
formed: import the package java.io.*, declare an object of the given file class,
instantiate the file object, use the methods associated with the file object to perform
input or output operations, and close the file when you are done using it.

2. Remember that the constructor for a FileReader or a FileWriter can be passed
the name of the disk file, but the constructor for a BufferedReader must be
passed an object of type FileReader and the constructor for a PrintWriter must
be passed a FileWriter object.

3. Keep in mind that if you pass an integer value to the write method of a FileWriter
object, the number is converted into a Unicode character. In contrast, the print
method of a PrintWriter object outputs the integer as a string of digit characters.



438 | Chapter 9:  File I/O and Looping

4. If you use file I/O, remember that main must have the throws IOException
clause appended to its heading.

5. Plan your test data carefully to test all sections of a program.
6. Beware of infinite loops, where the expression in the while statement never

becomes false. The symptom: the program doesn’t stop.
If you have created an infinite loop, check your logic and the syntax of your loops.

Be sure there’s no semicolon immediately after the right parenthesis of the while
condition:

while (expression);         // Wrong
statement;

This semicolon causes an infinite loop in most cases; the compiler thinks the loop
body is the null statement (the do-nothing statement composed only of a semi-
colon). In a count-controlled loop, make sure the loop control variable is incre-
mented within the loop. In a flag-controlled loop, make sure the flag eventually
changes.

7. Check the loop-termination condition carefully, and be sure that something in the
loop causes it to be met. Watch closely for values that cause one iteration too many
or too few (the “off-by–1” syndrome).

8. Write out the consistent, predictable part of a loop’s behavior in each iteration.
Look for patterns that this establishes. Are they just what you want? Perform an
algorithm walk-through to verify that all of the appropriate conditions occur in the
right places.

9. Trace the execution of the loop by hand with a code walk-through. Simulate the
first few passes and the last few passes very carefully to see how the loop really
behaves.

10. Use a debugger if your system provides one. A debugger is a program that runs your
program in “slow motion,” allowing you to execute one instruction at a time and to
examine the contents of variables as they change. If you haven’t already done so,
check to see if a debugger is available on your system.

11. If all else fails, use debug output statements—output statements inserted into a pro-
gram to help debug it. They output a message to a separate file that indicates the
flow of execution in the program or reports the values of variables at certain points
in the program.

For example, if you want to know the value of variable beta at a certain point
in a program, you could insert this statement:

logFile.println("beta = " + beta);

If this output statement is in a loop, you will get as many values of beta on the file
associated with logFile as there are iterations of the body of the loop.

After you have debugged your program, you can remove the debug output
statements or just precede them with // so that they’ll be treated as comments.



Summary of Classes | 439

(This practice is referred to as commenting out a piece of code.) You can remove the
double slashes if you need to use the statements again.

12. An ounce of prevention is worth a pound of debugging. Use the checklist questions
and design your loop correctly at the outset. It may seem like extra work, but it
pays off in the long run.

Summary of Classes

Package Name

Class Name Comments

java.lang Automatically imported to every Java program
String

Value-Returning Instance Methods:
valueOf(any numeric type) Class method that returns the string representation of its

argument

java.io
BufferedReader throws IOException

Constructor: BufferedReader(FileReader)

Value-Returning Instance Methods:
read() Returns int
readLine Returns String

Void Instance Methods:
close()
skip(long)

FileReader Some methods can throw IOException

Constructor: FileReader(String)

Value-Returning Instance Method:
read() Returns int

Void Instance Methods:
close()
skip(long)

FileWriter Some methods can throw IOException

(continued)



440 | Chapter 9:  File I/O and Looping

Package Name

Class Name Comments

Constructor: FileWriter(String)

Void Instance Methods:
close()
flush()
write(char)

PrintWriter

Constructor: PrintWriter(FileWriter)

Void Instance Methods:
close()
flush()
print(char)
print(double)
print(float)
print(int)
print(long)
print(String)
println(char)
println(double)
println(float)
println(int)
println(long)
println(String)
write(char)

Summary
Programs operate on data. If data and programs are kept separate, the data is available
to use with other programs, and the same program can be run with different sets of
data. Noninteractive input/output allows data to be prepared before a program is run
and allows the program to run again with the same data in the event that a problem
crops up during processing.

Data files are often used for noninteractive processing and to permit the output
from one program to be used as input to another program. In Java we use four types
of file classes: FileReader, FileWriter, BufferedReader, and PrintWriter.



Summary | 441

FileReader and FileWriter work with individual characters using the read and
write methods, respectively. BufferedReader adds to FileReader a readLine
method that inputs an entire line as a string. PrintWriter adds the print and
println methods to FileWriter that enable the output of all the standard Java data
types and classes.

To use files, you must do five things: (1) import the package java.io.*, (2) declare
the file variables along with your other variable declarations, (3) instantiate each file
object, (4) use methods associated with each file object to read or write it, and (5) call
the close method associated with each file object when you are done with it. When
using files, we must forward exceptions to the JVM by adding a throws IOException
clause to the heading of main and any other method that uses the file operations.

The while statement is a looping construct that allows the program to repeat a state-
ment as long as the value of an expression is true. When the value of the expression
becomes false, the statement is skipped, and execution continues with the first state-
ment following the loop.

With the while statement you can construct several types of loops that you use again
and again. These types of loops fall into two categories: count-controlled loops and event-
controlled loops.

In a count-controlled loop, the loop body is repeated a specified number of times.
You initialize a counter variable right before the while statement. This variable is the
loop control variable. The control variable is tested against the limit in the while expres-
sion. The last statement in the loop body increments the control variable.

Event-controlled loops continue executing until something inside the body signals
that the looping process should stop. Event-controlled loops include those that test for a
sentinel value in the data, end-of-file, or a change in a flag variable.

Sentinel-controlled loops are input loops that use a special data value as a signal to
stop reading. EOF-controlled loops are loops that continue to input (and process) data
values until there is no more data. To implement them with a while statement, you must
test the value returned by the input method. The read method returns 21 when it
reaches EOF and readLine returns null. Sentinel controlled loops usually require a
priming read just before entry into the loop and an updating read at the end of the loop;
however, Java’s assignment expression can be used as a shortcut to combine these two
input operations into one within the loop test. The assignment expression shortcut
should be used only in simple cases where the intent is clear to a human reader. Other-
wise, it is preferable to write a sentinel-controlled loop in the usual manner.

A flag is a variable that is set in one part of the program and tested in another. In a
flag-controlled loop, you must set the flag before the loop begins, test it in the while
expression, and change it somewhere in the body of the loop.

Counting is a looping operation that keeps track of how many times a loop is
repeated or how many times some event occurs. This count can be used in computations
or to control the loop. A counter is a variable that is used for counting. It may be the
loop control variable in a count-controlled loop, an iteration counter in a counting
loop, or an event counter that counts the number of times a particular condition occurs
in a loop.



442 | Chapter 9:  File I/O and Looping

Summing is a looping operation that keeps a running total of certain values. It is like
counting in that the variable that holds the sum is initialized outside the loop. The sum-
ming operation, however, adds up unknown values; the counting operation adds a con-
stant (1) to the counter each time.

When you design a loop, there are seven points to consider: how the termination
condition is initialized, tested, and updated; how the process in the loop is initialized,
performed, and updated; and the state of the program upon loop exit. By answering the
checklist questions, you can bring each of these points into focus.

To design a nested loop structure, begin with the outermost loop. When you get to
where the inner loop must appear, make it a separate module and come back to its
design later.

Quick Check
1. If a program is going to input 1,000 integer numbers, is interactive input appro-

priate? (p. 387)
2. What does a constructor for an input file do? (pp. 388–389)
3. What does the following series of statements write on the file fileOut? (pp.

390–391)

fileOut.write('W’);
fileOut.write(88);
fileOut.write("  What letter comes next?");

4. What is the statement that reads in a string and stores the integer equivalent
into number? (p. 398)

5. Write the first line of a while statement that loops until the value of the Boolean
variable done becomes true. (p. 403)

6. What are the four parts of a count-controlled loop? (pp. 406–407)
7. Should you use a priming read with an EOF-controlled loop? (pp. 410–412)
8. How is a sentinel used to control a loop? (pp. 407–408)
9. What is the difference between a counting operation in a loop and a summing

operation in a loop? (pp. 412–414)
10. What is the difference between a loop control variable and an event counter?

(pp. 412–415)
11. What kind of loop would you use in a program that reads the closing price of a

stock for each day of the week? (pp. 415–417)
12. How would you extend the loop in Question 11 to make it read prices for 52

weeks? (pp. 415–418)

Answers

1. No. File input is more appropriate for programs that input large amounts of data. 2. The
constructor associates the name of the disk file with the file variable used in the program, and
places the file pointer at the first piece of data in the file. 3. WX  What letter comes
next? 4. number = Integer.valueOf(infile.readln()).intValue();



Exam Preparation Exercises | 443

5. while ( !done ) 6. The process being repeated, plus initializing, testing, and increment-
ing the loop control variable. 7. Yes. 8. A sentinel is a value that is used to signal the end of
data. The loop expression compares each data value to the sentinel and the loop continues until
they are equal. 9. A counting operation increments by a fixed value with each iteration of the
loop; a summing operation adds unknown values to the total. 10. A loop-control variable con-
trols the loop; an event counter simply counts certain events during execution of the loop. 11.
Because there are five days in a business week, you would use a count-controlled loop that runs
from 1 to 5. 12. Nest the original loop inside a count-controlled loop that runs from 1 to 52.

Exam Preparation Exercises
1. What are the five steps in using file input?
2. What is the meaning of the parameter for the constructor for file classes

FileReader and FileWriter?
3. Where should the file declarations and the calls to the appropriate constructors

be placed in a program? Why?
4. What does the following statement do?

fileOut.flush();

5. What does the read method for class FileReader return?
6. a. What value does the read method return?

b. What value does the readLine method return?
c. Distinguish between a null string and an empty string.

7. Explain the difference between a loop and a branch.
8. What does the following loop print out? (number is of type int.)

number = 1;
while (number < 11)
{
number++;
out.println(number);

}

9. By rearranging the order of the statements (don’t change the way they are writ-
ten), make the loop in Exercise 8 print the numbers from 1 through 10.

10. When the following code is executed, how many iterations of the loop are
performed?

number = 2;
done = false;
while ( !done )
{
number = number * 2;
if (number > 64)
done = true;

}



444 | Chapter 9:  File I/O and Looping

11. What is the output of this nested-loop structure?

i = 4;
while (i >= 1)
{
j = 2;
while (j >= 1)
{
out.print (j + " ");
j--;

}
out.println(i);
i--;

}

12. The following code segment is supposed to write out the even numbers between
1 and 15. (n is an int variable.) The code has two flaws in it.

n = 2;
while (n != 15)
{
n = n + 2;
out.print(n + " ");

}

a. What is the output of the code as written?
b. Correct the code so that it works as intended.

13. The following code segment is supposed to copy one line from file infile to file
outfile.

inChar = (char)infile.read();
while (inChar != '\n’)
{
inChar = (char)infile.read();
outfile.write(inChar);

}

a. What is the output if the input line consists of the characters ABCDE?
b. Rewrite the code so that it works properly.

14. Does the following program segment need any priming reads? If not, explain why.
If so, add the input statement(s) in the proper place. (letter is of type char.)

while (datum != –1)
{
letter = (char) datum;
while (letter != '\n’)



Exam Preparation Exercises | 445

{
outFile.print(letter);
inFile.read(datum);
letter = (char)datum;

}
outFile.println;
outFile.println("Another line read...");
datum = inFile.read();

}

15. What sentinel value would you choose for a program that reads telephone num-
bers as integers?

16. Consider the following code segment:

sum = 0;
i = 1;
limit = 8;
finished = false;
while (i <= limit && !finished)
{
number = Integer.valueOf(dataFile.readLine()).intValue();
if (number > 0)
sum = sum + number;

else if (number == 0)
finished = true;

i++;
}
out.add(new Label("End of test. " + sum + ' ' + number));

and these data values (written one per line):

5  6  –3  7  –4  0  5  8  9

a. What are the contents of sum and number after exit from the loop?
b. Does the data fully test the program? Explain your answer.

17. What is the output of the following program segment? (All variables are of
type int.)

i = 1;
while (i <= 5)
{
sum = 0;
j = 1;
while (j <= i)
{
sum = sum + j;
j++;

}



446 | Chapter 9:  File I/O and Looping

System.out.print(sum + " ");
i++;

}

18. The physical order of a program is the order in which the statements are
_________ (written, executed).

19. The logical order of a program is the order in which the statements are
__________ (written, executed).

20. a. What are the two major types of loops?
b. Distinguish between a count-controlled loop and an event-controlled loop.
c. What happens if you forget to increment the loop control variable in a

count-controlled loop?
d. What happens if you forget to change the event within the body of an event

controlled-loop?
e. Name three kinds of event-controlled loops.

21. Distinguish between an iteration counter and an event counter.
22. a. What is an assignment expression?

b. Write the assignment expression that can be used to control a reading loop
with method read.

c. Write the assignment expression that can be used to control a reading loop with
method readLine.

Programming Warm-Up Exercises
1. Write the statements that associate an object of class FileReader with file

infile.dat.
2. Write the statements that associate an object of class BufferedReader with file

infile.dat.
3. Write the statements that associate an object of PrintWriter with file

outfile.dat.
4. What does the following series of statements write on the file fileOut?

fileOut.write('W');
fileOut.write('\n');
fileOut.write(88);
fileOut.write('\n');
fileOut.write("  What letter comes next?");

5. What is printed by the following series of statements?

fileOutPr.println('W');
fileOutPr.print(88);
fileOutPr.print("  What letter comes next?");

TE
AM
FL
Y

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

Team-Fly® 



Programming Warm-Up Exercises | 447

6. Write a code fragment that reads two characters from fileIn and stores them in
two char variables, first and second. (fileIn, of class FileReader and has
been declared and given a value.)

7. Write a code fragment that reads a line from fileInBuf and prints it on file-
Out with blank lines before and after it.

8. Write the statements that close fileOut and associate it with file dataOut.dat.
9. Write a program segment that sets a Boolean variable dangerous to true and

stops reading data if pressure (a float variable being read in) exceeds 510.0.
Use dangerous as a flag to control the loop.

10. Here is a simple count-controlled loop:

count = 1;
while (count < 20)
count++;

a. List three ways of changing the loop so that it executes 20 times instead of 19.
b. Which of those changes makes the value of count range from 1 through 21?

11. Write a program segment that counts the number of times the integer 28 occurs
in a file of 100 integers.

12. Write a nested loop code segment that produces this output:

1
1 2
1 2 3
1 2 3 4

13. Write a program segment that reads a file of student scores for a class (any size)
and finds the class average.

14. Write a program segment that reads in integers and then counts and prints out
the number of positive integers and the number of negative integers. If a
value is zero, it should not be counted. The process should continue until end-
of-file occurs.

15. Write a program segment that adds up the even integers from 16 through 26,
inclusive.

16. Write a statement(s) that increments count by 1 and sets it back to 0 when it
reaches 13.

17. Write a program segment that prints out the sequence of all the hour and minute
combinations in a day, starting with 1:00 A.M. and ending with 12:59 A.M.

18. Rewrite the code segment for Exercise 17 so that it prints the times in 10-minute
intervals.

19. Write a loop to count the number of not-equal operators (!=) in a file that con-
tains a Java program. Your algorithm should count the number of times an
exclamation mark (!) followed by an equal sign (=) appears in the input. Read



448 | Chapter 9:  File I/O and Looping

the input file one character at a time, keeping track of the two most recent char-
acters, the current value, and the previous value. In each iteration of the loop, a
new current value is read and the old current value becomes the previous value.
When EOF is reached, the loop is finished.

Programming Problems
1. Design and write a Java application that inputs an integer and a character from

the screen. The output should be a diamond on the screen composed of the char-
acter and extending the width specified by the integer. For example, if the inte-
ger is 11 and the character is an asterisk (*), the diamond would look like this:

*
***
*****
*******
*********
***********
*********
*******
*****
***
*

If the input integer is an even number, it should be increased to the next odd
number. Use meaningful variable names, proper indentation, appropriate com-
ments, and good prompting messages. Use a Frame object for input and a
PrintWriter object for output.

2. Write a design and a Java application that inputs an integer larger than 1 and
calculates the sum of the squares from 1 to that integer. For example, if the inte-
ger equals 4, the sum of the squares is 30 (1 + 4 + 9 + 16). The output should be
the value of the integer and the sum, properly labeled on the screen. The pro-
gram should repeat this process for several input values. Use buttons and screen
input and output.

3. You are putting together some music tapes for a party. You’ve arranged a list of
songs in the order in which you want to play them. However, you would like to
minimize the empty tape left at the end of each side of a cassette (the cassette
plays for 45 minutes on a side). So you want to figure out the total time for a
group of songs and see how well they fit. Write a design and a Java application
to help you do this. The data is on file songs.dat. The time is entered as sec-
onds. For example, if a song takes 7 minutes and 42 seconds to play, the data
entered for that song would be

462

After all the data has been read, the program should print a message indicating
the time remaining on the tape.



Case Study Follow-Up Exercises | 449

The output should be in the form of a table with columns and headings writ-
ten on a file. For example,

Song          Song Time             Total Time
Number     Minutes    Seconds     Minutes   Seconds
------     -------    -------     -------   -------

1           5          10          5         10
2           7          42         12         52
5           4          19         17         11
3           4          33         21         44
4          10          27         32         11
6           8          55         41          6

There are 3 minutes and 54 seconds of tape left on the 45-
minute tape.

Note that the output converts the input from seconds to minutes and seconds.
4. Design and write an application that prints out the approximate number of

words in a file of text. For our purposes, this is the same as the number of gaps
following words. A gap is defined as one or more spaces in a row, so a sequence
of spaces counts as just one gap. The newline character also counts as a gap.
Anything other than a space or newline is considered to be part of a word. For
example, there are 13 words in this sentence, according to our definition. The
program should echo-print the data.

Solve this problem with two different programs:
a. Use a String object into which you input each line as a string. This

approach is quite straightforward.
b. Assume the String class does not exist, and input the data one character at

a time. This approach is more complicated. (Hint: Count a space as a gap
only if the previous character read is something other than a space.)

Use meaningful variable names, proper indentation, and appropriate comments.
Thoroughly test the programs with your own data sets.

Case Study Follow-Up Exercises
1. Change the Incomes program in the following ways.

a. The program prints an error message when a negative income value is input
and then goes on processing any remaining data. Do not include the erro-
neous data in any of the calculations. Thoroughly test the modified program
with your own data sets.

b. The program does not crash when there are no males in the input file or no
females (or the file is empty). Instead, it prints an appropriate error message.
Test the revised program with your own data sets.

c. The program rejects data sets that are coded with a letter other than 'F' or 'M'
and prints an error message before continuing to process the remaining data.
The program also prints a message indicating the number of erroneous data sets
encountered in the file.



2. Develop a thorough set of test data for the Incomes program as modified in
Exercise 1.

3. Rather than put the responsibility for reading in the application, redesign this
problem to extend BufferedReader with two new methods, readGender and
readSalary. Code and test your redesign.

4. Use the String methods valueOf, indexOf, and substring to print only two
decimal places for all floating-point values. To accomplish this conversion, you
must do the following tasks:

• Convert the floating point value to a string using the valueOf method.
• Find the location of the decimal point using the indexOf method.
• Create a new string that is a substring of the original with only two characters

following the decimal point using the substring method.

450 | Chapter 9:  File I/O and Looping



               

To be able to write a switch statement for a multi-
way branching problem.

To be able to write a do statement and contrast it
with a while statement.

To be able to write a for statement as an alternative
to a while statement.

To be able to choose the most appropriate looping
statement for a given problem.

To be aware of Java’s additional operators and their place
in the precedence hierarchy with respect to each other.

To be able to use the Java exception-handling mecha-
nism using try and catch.

To be able to define an exception class and throw an
exception.

Additional Control
Structures and
Exceptions

G
oals



452 | Chapter 10:  Additional Control Structures and Exceptions

In Chapters 6 and 9, we introduced Java statements for the selection and loop control
structures. In some cases, we introduced more than one way of implementing these
structures. For example, selection may be implemented by an if structure. The if-(then)
is sufficient to implement any selection structure, but Java provides the if-else for con-
venience because the two-way branch is frequently used in programming.

This chapter introduces four new statements that are also nonessential to, but
nonetheless convenient for, programming. One, the switch statement, makes it easier to
write selection structures that have many branches. Two new looping statements, for
and do, make it easier to program certain types of loops.

This chapter also covers the try-catch statement used for exception-handling in
Java. Rather than continuing to forward exceptions, we show how to handle one. We
also show you how to generate exceptions of your own.

Finally, we examine the remaining operators in Java and their place in the prece-
dence hierarchy.

10.1 Additional Control Structures
The switch Statement

The switch statement is a selection control structure for
multiway branches. A switch is similar to nested if state-
ments. The value of a switch expression—an integer
expression—determines which of the branches is exe-
cuted. Look at the following example switch statement:

switch (digit)            // The switch expression is (digit)
{
case 1 : Statement1;    // Statement1 is executed if digit is 1

break;         // Go to Statement5
case 2 :
case 3 : Statement2;    // Statement 2 is executed if digit is 2 or 3

break;         // Go to Statement5
case 4 : Statement3;    // Statement3 is executed if digit is 4

break;         // Go to Statement5
default: Statement4;    // Else execute Statement4 and go to Statement5

}
Statement5;               // Always executed

In this example, digit is the switch expression. The statement means “If digit is
1, execute Statement1 and break out of the switch statement and continue with State-
ment5. If digit is 2 or 3, execute Statement2 and continue with Statement5. If digit
is 4, execute Statement3 and continue with Statement5. If digit is none of the values

Switch expression The expression whose value deter-
mines which switch label is selected. It must be an
integer type other than long.



10.1 Additional Control Structures | 453

previously mentioned, execute Statement4 and continue with Statement5.” Figure 10.1
shows the flow of control through this statement.

The break statement allows control to immediately jump to the statement following
the switch statement. We see shortly what happens if we omit the break statements.

Let’s look at the syntax template for the switch statement; then we look at what
actually happens when it is executed.

The syntax template for the switch statement is

switch ( IntegralExpression )
{
  SwitchLabel...Statement




}

SwitchStatement

...

.
.
.



Statement1; break;

Statement2; break;

Statement3; break;

Statement4;

Statement5;

If digit == 1

If digit == 2 or
   digit == 3

If digit == 4

default

Figure 10.1 Flow of control in the example switch statement



454 | Chapter 10:  Additional Control Structures and Exceptions

IntegralExpression is an expression of one of the types char, byte, short, or int.
The switchLabel in front of a statement is either a case label or a default label:

In a case label, ConstantExpression is an expression of type char, byte, short, or
int, whose operands must be literal or named constants. The following are examples of
constant expressions (where CLASS_SIZE is a named constant of type int):

3
CLASS_SIZE
'A'

The data type of ConstantExpression is converted, if necessary, to match the type of the
switch expression.

In our opening example that tests the value of digit, the following are the case labels:

case 1 :
case 2 :
case 3 :
case 4 :

As that example shows, multiple case labels may precede a single branch.
The value resulting from each ConstantExpression within a switch statement must

be unique. If a value appears more than once among the case labels, a syntax error
results. The compiler simply can’t determine which of the identical cases to branch to.
Also, there can be only one default label in a switch statement.

Be careful: case 1 does not mean the first case. We’ve listed the values in order
because that makes the statement easier to read. But Java allows us to place them in
any order. The following switch statement behaves in exactly the same way as our ear-
lier example.

switch (digit)            // The switch expression is (digit)
{
case 3 :
case 2 : Statement2;    // Statement2 is executed if digit is 2 or 3

break;         // Go to Statement5
case 4 : Statement3;    // Statement3 is executed if digit is 4

break;         // Go to Statement5

case ConstantExpression :

default :

SwitchLabel



10.1 Additional Control Structures | 455

case 1 : Statement1;    // Statement1 is executed if digit is 1
break;         // Go to Statement5

default  : Statement4;  // Else execute Statement4 and go to Statement5
}
Statement5;               // Always executed

The flow of control through a switch statement goes like this. First, the switch
expression is evaluated. Then each expression beside the reserved word case is tested to
see if it matches the switch expression. If the values match, control branches to the
statement associated with that case label (the statement on the other side of the colon).
From there, control proceeds sequentially until either a break statement or the end of
the switch statement is encountered. If the value of the switch expression doesn’t match
any case value, then one of two things happens. If there is a default label, control
branches to the associated statement. If there is no default label, the statements in the
switch are skipped and control simply proceeds to the statement following the entire
switch statement.

The following switch statement prints an appropriate comment based on a student’s
grade (grade is of type char). The switch expression can be char since Java considers
char to be an integral type because it can be converted to type int.

switch (grade)
{
case 'A' :
case 'B' : outFile.print("Good Work");

break;
case 'C' : outFile.print("Average Work");

break;
case 'D' :
case 'F' : outFile.print("Poor Work");

numberInTrouble++;
break;               // Unnecessary, but a good habit

}

Notice that the final break statement is unnecessary. But programmers often include it
anyway. One reason is that it’s easier to insert another case label at the end if a break
statement is already present.

If grade does not contain one of the specified characters, none of the statements
within the switch is executed. It would be wise to add a default label to account for
an invalid grade:

switch (grade)
{
case 'A' :
case 'B' : outFile.print("Good Work");

break;



456 | Chapter 10:  Additional Control Structures and Exceptions

case 'C' : outFile.print("Average Work");
break;

case 'D' :
case 'F' : outFile.print("Poor Work");

numberInTrouble++;
break;

default  : outFile.print(grade + " is not a valid letter grade.");
break;

}

A switch statement with a break statement after each case alternative behaves
exactly like an if-else-if control structure. For example, our switch statement is equiva-
lent to the following code:

if (grade == 'A' || grade == 'B')
outFile.print("Good Work");

else if (grade == 'C')
outFile.print("Average Work");

else if (grade == 'D' || grade == 'F')
{
outFile.print("Poor Work");
numberInTrouble++;

}
else
outFile.print(grade + " is not a valid letter grade.");

Is either of these two versions better than the other? There is no absolute answer to
this question. For this particular example, our opinion is that the switch statement is
easier to understand because of its table-like form. When you are implementing a multi-
way branching structure, our advice is to use the one that you feel is easiest to read.
Keep in mind that Java provides the switch statement as a matter of convenience. Don’t
feel obligated to use a switch statement for every multiway branch.

Finally, we said we would look at what happens if we omit the break statements
inside a switch statement. Let’s rewrite the preceding code statement as if we forgot to
include the break statements, and we can see how it behaves:

switch (grade)    // Wrong version
{
case 'A' :
case 'B' : outFile.print("Good Work");
case 'C' : outFile.print("Average Work");
case 'D' :
case 'F' : outFile.print("Poor Work");

numberInTrouble++;
default  : outFile.print(grade + " is not a valid letter grade.");

}

TE
AM
FL
Y

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

Team-Fly® 



10.1 Additional Control Structures | 457

If grade happens to be 'H', control branches to the statement at the default label
and the output to the file is

H is not a valid letter grade.

Unfortunately, this case alternative is the only one that works correctly. If grade is
'A', all of the branches are executed and the resulting output is this:

Good WorkAverage WorkPoor WorkA is not a valid letter grade.

Remember that after a branch is taken to a specific case label, control proceeds
sequentially until either a break statement or the end of the switch statement is encoun-
tered. Forgetting a break statement in a case alternative is a very common source of
errors in Java programs.

May We Introduce...
Admiral Grace Murray Hopper

From 1943 until her death on New Year’s Day in 1992, Admiral Grace Murray Hopper was
intimately involved with computing. In 1991, she was awarded the National Medal of Tech-
nology “for her pioneering accomplishments in the development of computer programming
languages that simplified computer technology and opened the door to a significantly

larger universe of users.”
Admiral Hopper was born Grace Brewster Murray in New York City on

December 9, 1906. She attended Vassar and received a Ph.D. in mathematics
from Yale. For the next 10 years, she taught mathematics at Vassar.

In 1943, Admiral Hopper joined the U.S. Navy and was assigned to the
Bureau of Ordnance Computation Project at Harvard University as a program-
mer on the Mark I. After the war, she remained at Harvard as a faculty member
and continued work on the Navy’s Mark II and Mark III computers. In 1949, she
joined Eckert-Mauchly Computer Corporation and worked on the UNIVAC I. It

was there that she made a legendary contribution to computing: She discovered the first
computer “bug”—a moth caught in the hardware.

Admiral Hopper had a working compiler in 1952, a time when the conventional wisdom
was that computers could do only arithmetic. Although not on the committee that
designed the computer language COBOL, she was active in its design, implementation, and
use. COBOL (which stands for Common Business-Oriented Language) was developed in the
early 1960s and is still widely used in business data processing.

Admiral Hopper retired from the Navy in 1966, only to be recalled within a year to full-
time active duty. Her mission was to oversee the Navy’s efforts to maintain uniformity in
programming languages. It has been said that just as Admiral Hyman Rickover was the

tcontinued



458 | Chapter 10:  Additional Control Structures and Exceptions

The do Statement

The do statement is a looping control structure in which the loop condition is tested at
the end (bottom) of the loop. This format guarantees that the loop body executes at least
once. The syntax template for the do is this:

As usual in Java, Statement is either a single statement or a block. Also, note that
the do ends with a semicolon.

while ( Expression ) ;

Statement

DoStatement

do

father of the nuclear navy, Rear Admiral Hopper was the mother of computerized data
automation in the Navy. She served with the Naval Data Automation Command until she
retired again in 1986 with the rank of rear admiral. At the time of her death, she was a
senior consultant at Digital Equipment Corporation.

During her lifetime, Admiral Hopper received honorary degrees from more than 40 col-
leges and universities. She was honored by her peers on several occasions, including the
first Computer Sciences Man of the Year award given by the Data Processing Management
Association, and the Contributions to Computer Science Education Award given by the Spe-
cial Interest Group for Computer Science Education, which is part of the ACM (Association
for Computing Machinery).

Admiral Hopper loved young people and enjoyed giving talks on college and university
campuses. She often handed out colored wires, which she called nanoseconds because they
were cut to a length of about one foot—the distance that light travels in a nanosecond (bil-
lionth of a second). Her advice to the young was, “You manage things, you lead people. We
went overboard on management and forgot about leadership.”

When asked which of her many accomplishments she was most proud of, she answered,
“All the young people I have trained over the years.”

Admiral Grace Murray Hopper



10.1 Additional Control Structures | 459

The do statement

do
{
Statement1;
Statement2;
.
.
.
StatementN;

} while (Expression);

means “Execute the statements between do and while as long as Expression still has
the value true at the end of the loop.” This means that you execute the statements
before you test the expression. Because there is the word while at the end of the block,
this statement is sometimes called the do-while statement.

Let’s compare a while loop and a do loop that do the same task: They find the first
period in a file of data. Assume that there is at least one period in the file.

while Solution
inputChar  = (char)dataFile.read();
while (inputChar != '.')
inputChar  = (char)dataFile.read();

do Solution
do
inputChar  = (char)dataFile.read();

while (inputChar != '.');

The while solution requires a priming read so that inputChar has a value before
the loop is entered. This isn’t required for the do solution because the input statement
within the loop is executed before the loop condition is evaluated.

We can also use the do to implement a count-controlled loop if we know in
advance that the loop body should always execute at least once. Below are two versions
of a loop to sum the integers from 1 through n.

while Solution
sum = 0;
counter = 1;
while (counter <= n)
{
sum = sum + counter;
counter++;

}



460 | Chapter 10:  Additional Control Structures and Exceptions

while  (Expression)

Statement

while  (Expression) ;

Statement

do

false true

false true

while Statement do Statement

Figure 10.2 Flow of control: while and do

do Solution
sum = 0;
counter = 1;
do
{
sum = sum + counter;
counter++;

} while (counter <= n);

If n is a positive number, both of these versions are equivalent. But if n is 0 or neg-
ative, the two loops give different results. In the while version, the final value of sum is
0 because the loop body is never entered. In the do version, the final value of sum is 1
because the body executes once and then the loop test is made.

Because the while statement tests the condition before executing the body of the
loop, it is called a pretest loop. The do statement does the opposite and thus is known as
a posttest loop. Figure 10.2 compares the flow of control in the while and do loops.

When we finish introducing new looping constructs, we offer some guidelines for
determining when to use each type of loop.

The for Statement

The for statement is designed to simplify the writing of count-controlled loops. The fol-
lowing statement prints out the integers from 1 through n:

for (count = 1; count <= n; count++)
outFile.println("" + count);

This for statement means “Initialize the loop control variable count to 1. While
count is less than or equal to n, execute the output statement and increment count
by 1. Stop the loop after count has been incremented to n + 1.”



10.1 Additional Control Structures | 461

The syntax template for a for statement is

Expression is the condition that ends the loop and must be of type boolean. Init
can be any of the following: nothing, a local variable declaration, or an expression. Init
can also be a series of local variable declarations and expressions separated by commas.
Update can be omitted, it can be an expression, or it can be a series of expressions sepa-
rated by commas.

Most often, a for statement is written such that Init initializes a loop-control vari-
able and Update increments or decrements the loop-control variable. Here are two loops
that execute the same number of times (50):

for (loopCount = 1; loopCount <= 50; loopCount++)
.
.
.

for (loopCount = 50; loopCount >= 1; loopCount--)
.
.
.

Just like while loops, do and for loops may be nested. For example, the nested for
structure

for (lastNum = 1; lastNum <= 7; lastNum++)
{
for (numToPrint = 1; numToPrint <= lastNum; numToPrint++)
outFile.print("" + numToPrint);

outFile.println();
}

prints the following triangle of numbers.

1
12
123
1234
12345
123456
1234567

     ( Init ; Expression ; Update )

Statement

ForStatement

for





462 | Chapter 10:  Additional Control Structures and Exceptions

Although for statements are used primarily for count-controlled loops, Java allows
you to write any while loop by using a for statement. To use for loops intelligently, you
should know the following facts.

1. In the syntax template, Init and Update are optional. If Update is omitted, the termi-
nation condition is not automatically updated.

2. According to the syntax template, Expression—the termination condition—is
optional. Thus, the following is a valid for statement:

for ( ; ; )
outFile.println("Hi");

If you omit the termination condition, the expression true is assumed, causing an
infinite loop.

3. Init can be a declaration with initialization:

for (int i = 1; i <= 20; i++)
outFile.println("Hi");

Here, the variable i has local scope, even though there are no braces creating a
block. The scope of i extends only to the end of the for statement. Like any local
variable, i is inaccessible outside its scope (that is, outside the for statement).
Because i is local to the for statement, it’s possible to write code like this:

for (int i = 1; i <= 20; i++)
outFile.println("Hi");

for (int i = 1; i <= 100; i++)
outFile.println("Ed");

This code does not generate a compile-time error (such as “MULTIPLY DEFINED
IDENTIFIER”). We have declared two distinct variables named i, each of which is local
to its own for statement.

The syntax for Init and Update allows them to have multiple parts, separated by
commas. All of the parts are executed as if they are a block of statements. For example,
it is sometimes useful to have a second variable in a loop that is a multiple of the itera-
tion counter. The following loop has two variables, one that counts by one and is used
as the loop control variable and another that counts by five.

for (int count = 1, int byFives = 5; count <= n; count++,
byFives = count*5)

outFile.println("Count = " + count + " * 5 = " + byFives);

The output of this loop, if n is 7, is:

Count = 1 * 5 = 5
Count = 2 * 5 = 10
Count = 3 * 5 = 15



10.2 Exception-Handling Mechanism | 463

Count = 4 * 5 = 20
Count = 5 * 5 = 25
Count = 6 * 5 = 30
Count = 7 * 5 = 35

Guidelines for Choosing a Looping Statement

Here are some guidelines to help you decide when to use each of the three looping
statements (while, do, and for).

1. If the loop is a simple count-controlled loop, the for statement is a natural. Concen-
trating the three loop-control actions—initialize, test, and increment/decrement—
into one location (the heading of the for statement) reduces the chances of
forgetting to include one of them.

2. If the loop is an event-controlled loop whose body should execute at least once, a
do statement is appropriate.

3. If the loop is an event-controlled loop and nothing is known about the first execu-
tion, use a while statement.

4. When in doubt, use a while statement.

10.2 Exception-Handling Mechanism
In the last chapter, we defined an exception as an unusual situation that is detected
while a program is running. An exception halts the normal execution of a method.
There are three parts to an exception-handling mechanism: defining the exception, rais-
ing or generating the exception, and handling the exception. We look first at handling
exceptions and then at defining and raising them.

The try-catch-finally Statement

As part of introducing files in Chapter 9, it was necessary to forward an IOException
to the JVM. We noted that the alternative to forwarding is to catch an exception.
Because catching an exception involves a branch in control flow, it’s natural to discuss
it here.

When an error occurs in a method call, it isn’t always possible for the method itself
to take care of it. For example, suppose we ask the user for a file name in a dialog, get
the name from a field, and then we attempt to open the file (prepare it for reading by
calling the FileReader constructor). The constructor discovers that the file doesn’t
exist and is thus unable to open it. Perhaps the file has been deleted, or maybe the user
just mistyped the name. The constructor has no way of knowing that the proper
response to the error is to ask the user to reenter the name. Because the constructor
can’t appropriately deal with this error, it doesn’t even try. It passes the problem on to
the method that called it, such as main.



464 | Chapter 10:  Additional Control Structures and Exceptions

When a call returns with an exception, normal
execution ends and the JVM looks to see if there is
code to take care of the problem. That code is called
an exception handler and is part of a try-catch-finally
statement.

The syntax diagram for a try-catch-finally statement is:

As the diagram shows, the statement has three main parts. The first part is the key-
word try and a block (a { } pair enclosing any number of statements). The second part
is an optional series of catch clauses, each consisting of the keyword catch, a single
parameter declaration enclosed in parentheses, and a block. The last part is also optional
and consists of the keyword finally and a block.

When a statement or series of statements in a program might result in an exception,
we enclose them in the block following try. For each type of exception that can be pro-
duced by the statements, we write a catch clause. Here’s an example:

try
{
. . .       // Statements  that try to open a file

}
catch (IOException except)
{
. . .       // Statements that execute if the file can't be opened

}
finally
{
. . .       // Statements that are always executed

}

The try statement is meant to sound something like the coach telling the gymnast,
“Go ahead and try this move that you’re unsure of, and I’ll catch you if you fall.” We

try
	 Block

catch  (ExceptionType ObjectName)
	 Block

	 
	 
	 
finally
	 Block

.
.
.

TryCatchFinally

Exception handler A section of a program that is
executed when an exception occurs. In Java, an excep-
tion handler appears within a catch clause of a try-
catch-finally control structure.



10.2 Exception-Handling Mechanism | 465

are telling the computer to try executing some operations that might fail, and then
we’re providing code to catch the potential exceptions. The finally clause provides an
opportunity to clean up, regardless of what happens in the try and catch blocks. We
focus on the execution of a try statement without a finally clause (a try-catch statement)
and briefly describe what happens when we add the finally clause.

Execution of try-catch If none of the statements in the try block throws an exception,
then control transfers to the statement following the entire try-catch statement. That is,
we try some statements, and if everything goes according to plan, we just continue on
with the succeeding statements.

When an exception occurs, control is immediately transferred to the block associ-
ated with the appropriate catch. It is important to realize that control jumps directly
from whatever statement caused the exception to the catch block. If there are state-
ments in the try block following the one that caused the exception, they are skipped. If
the catch block completes without causing any new exceptions, then control transfers
to the next statement outside of the try-catch structure.

How does the computer know which catch is appropriate? It looks at the class of
the parameter declared in each one and selects the first one with a class that matches
the thrown exception. Given how Java uses objects for just about everything, it should
come as no surprise that an exception is an object and has a class. We’ve already seen
one such class, IOException; another is ArithmeticException, which is thrown
when we try to execute an invalid arithmetic operation (such as integer division by
zero). Let’s look at an example of a try-catch statement to illustrate this process.

try
{
// Some statements

}
catch (IOException except)
{
// Statements to handle IO errors

}
catch(ArithmeticException except)
{
// Statements to handle division by zero

}

The computer begins by executing the statements within the try block. If one of them
causes an IOException, then control jumps to the first catch block. If instead a state-
ment causes an ArithmeticException, then control jumps to the second catch block.

What if a statement throws an exception that isn’t among the catch clauses? In that
case, the try statement fails to catch the error, and its enclosing method throws the
exception to its caller. If the caller doesn’t have a handler for the error, it throws the
exception to its caller, and so on until the exception is either caught or ends up at the
JVM, which halts the program and displays an error message.



466 | Chapter 10:  Additional Control Structures and Exceptions

The object that is passed to the catch block through its parameter has a value-
returning method associated with it called getMessage. The getMessage method
returns a string containing a message. For example, it might contain the name of the
file that could not be opened. Thus, you could write the following statement in a catch
block to display a message.

catch (IOException except)
{
out.add(new Label("I/O Exception encountered for " +
except.getMessage()));

}

Let’s look at an actual example. Suppose we have prompted the user to enter a file
name into a field, and upon clicking a button an event handler is called to open that file
as a PrintWriter. We could use the following code in the button event handler to try
to open the file. If the file can’t be opened, we display an error message, and clear the
input field so that the user can try again.

filename = fileField.getText();
try
{
outFile = new PrintWriter(new FileWriter(filename));

}
catch (IOException except)
{
errorLabel.setText("Unable to open file " + filename);
fileField.setText("");

}

Execution of try-catch-finally When a finally clause is present in a try statement, the
block following finally is always executed no matter what happens in the try and
catch blocks. Thus, even when a catch causes a new exception, the finally block is
executed. The finally block gives us an opportunity to clean up after a failed catch.
In writing the algorithm for the finally block, however, it is important to realize that
it is always executed, even if the try succeeds.

In this text we use only try-catch statements, and we keep our exception handlers
simple so that they won’t produce additional exceptions. The finally clause is really
only needed when a catch contains statements that might generate a new exception
and we need to undo some of its processing before the exception is thrown.

Generating an Exception with throw

Standard library classes are not the only classes that can generate exceptions. Here we
introduce the throw statement, which is the statement that we use when raising or gen-
erating an exception.

TE
AM
FL
Y

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

Team-Fly® 



10.2 Exception-Handling Mechanism | 467

void caller()
{
  //Some statements
  try
  {
    //Statements
    someMethod();
    //Statements
  }
  catch (SomeException except)
  {
    //Statements to handle exception
  }
    //More statements
}

void someMethod() throws SomeException 
{
    



}

Call

Normal
Return

Return from
Thrown Exception

//Some statements
if (error)
  throw new SomeException("Message.");
//More statements


Figure 10.3 Throwing an Exception to be Caught in a Calling Method

All exceptions are thrown by a throw statement. The syntax of the throw statement
is quite simple.

The ObjectExpression must be either a variable or a value of a class that implements
the Throwable interface. That is, it must be an object of class Throwable or a subclass
of Throwable such as Exception. When an exception is thrown, the JVM goes looking
for a catch statement that can handle that specific type of exception.

The throw statement may be written within a try statement that is intended to catch
it. In that case, control is transferred to the catch clause with the corresponding type.

More often, the throw occurs inside a method that is called from within a try state-
ment, as shown in Figure 10.3. The JVM first looks for a catch within the method. When
it fails to find one, it causes the method to return. The JVM then looks around the point
where the method was called, and finds an appropriate catch clause. The catch is exe-
cuted and control proceeds to the statement following the try-catch.

If the JVM can’t find a matching catch, it causes the method containing the call to
also return. The series of returns can lead all the way back to main. If main fails to
catch the exception, then the JVM handles it by stopping the program and displaying
an error message.

throw  ObjectExpression ;


ThrowStatement



468 | Chapter 10:  Additional Control Structures and Exceptions

As we’ve seen previously, we must handle each class of exception either by catch-
ing it or explicitly forwarding it with a throws clause in the method heading. Thus, an
exception can cause a chain of returns that reaches the JVM only when our code is
written to allow it. We can’t generate an exception that is accidentally uncaught.

We can throw any of the standard exceptions that Java provides. For example,

throw new FileNotFoundException(filename);

It’s actually quite rare to throw one of the predefined exceptions. One situation
where we might do so is when we’ve caught such an exception in a catch clause but
there is some aspect of handling it that must be passed to a higher level method.

Instead of throwing a predefined exception, we typically want to define and throw
a new exception type that is unique to a class. A user of the class must then handle that
type of exception. For example, in our Address class from Chapter 8, we could have
validated the zip code. Basic zip codes are five digits or less. If a zip code is greater than
99,999, we can throw a ZipCodeInvalidException in the constructor for an Address
object as follows.

public Address(String  name, String city, String state, int zipCode)
throws ZipCodeInvalidException

{
if (zipCode <= 99999)
// If valid, store value
this.zipCode = zipCode;    

else 
// If invalid, throw exception
throw new ZipCodeInvalidException("" + zipCode);

.

.

.
}

We would call this method within a try-catch statement.

try
{
myAddress = new Address(myName, Austin, Texas, 7874);

}
catch (ZipCodeInvalidException  zipCode)
{
// Exception handler
// Print bad zip code
System.out.println(zipCode.getMessage()+ " is invalid");

}



10.2 Exception-Handling Mechanism | 469

Whatever method is trying to create an Address object with an invalid zip code is
then responsible for handling the error. But, of course, we also need to define the class
called ZipCodeInvalidException.

Exception Classes

Notice that throw must have an exception object to throw. Exception objects are very
simple to create. Their class name conveys the basic information that tells the JVM what
sort of exception is being thrown. All we typically need to add is an error message or
some other piece of information that helps the catch clause handle the error.

The predefined type Exception implements the Throwable interface and provides a
field for an error message. Thus, all we have to do is extend it with our own class name and
supply a pair of constructors that call super. Here is how we define ZipCodeInvalid-
Exception.

package address;
public class ZipCodeInvalidException extends Exception
{
public ZipCodeInvalidException()
{
super();

}
public ZipCodeInvalidException(String message)
{
super(message);

}
}

Look at the try-catch in the previous section.

try
{
myAddress = new Address(myName, Austin, Texas, 7874);

}
catch (ZipCodeInvalidException  zipCode)
{
// Exception handler
// Print bad area code
System.out.println(zipCode.getMessge() + " is invalid");

}

In the catch clause we use getMessage to retrieve the same string that was used to
instantiate the object of class ZipCodeInvalidException.

Whenever you design a class you should consider whether there are error condi-
tions that cannot be handled strictly within the class. Exceptions are, as their name



470 | Chapter 10:  Additional Control Structures and Exceptions

implies, meant to be used for exceptional situations. We recommend using an exception
only when there is no simple way to handle an error.

10.3 Additional Java Operators
Java has a rich, sometimes bewildering, variety of operators that allow you to manipu-
late values of the primitive data types. Operators you have learned about so far include
the assignment operator (=), the arithmetic operators (+, -, *, /, %), the increment and
decrement operators (++, --), the relational operators (==, !=, <, <=, >, >=), the string
concatenation operator (+), and the conditional (short-circuit evaluation) logical opera-
tors (!, &&, ||). In certain cases, a pair of parentheses is also considered to be an opera-
tor—namely, the type-cast operator

someFloat = (float)someInt;

Java also has many specialized operators that are seldom found in other program-
ming languages. Here is a table of these additional operators. As you inspect the table,
don’t panic—a quick scan will do.

Operator Remarks

Combined-assignment operators
+= Add and assign
–= Subtract and assign
*= Multiply and assign
/= Divide and assign
%= Remainder and assign

Increment and decrement operators
++ Pre-increment Example: ++someVar
++ Post-increment Example: someVar++
-- Pre-decrement Example: --someVar
-- Post-decrement Example: someVar--

Bitwise operators Integer operands only
<< Left shift
>> Right shift with sign extension
>>> Right shift with zero extension
& Bitwise AND
| Bitwise OR
^ Bitwise EXCLUSIVE OR
~ Complement (invert all bits)

(continued)



10.3 Additional Java Operators | 471

Operator Remarks

Boolean full-evaluation operators boolean operands only
& boolean AND
| boolean OR
^ boolean EXCLUSIVE OR

More combined-assignment operators Integer operands only
<<= Shift left and assign
>>= Shift right with sign extension and assign
>>>= Shift right with zero extension and assign
&= Bitwise AND and assign
|= Bitwise OR and assign
^= Bitwise EXCLUSIVE OR and assign

Other operators
instanceof Type comparison object instanceof ClassName
?: Conditional operator Form: Expr1 ? Expr2 : Expr3

The operators in this table, along with those you already know, comprise all of the
Java operators.

Assignment Operators and Assignment Expressions

Java has several assignment operators. The equal sign (=) is the basic assignment opera-
tor. When combined with its two operands, it forms an assignment expression (not an
assignment statement). Every assignment
expression has a value and a side effect,
namely, that the value is stored into the
object denoted by the left-hand side. For
example, the expression

delta = 2 * 12

has the value 24 and the side effect of storing
this value into delta.

In Java, an expression consisting of a
variable and an increment or decrement expression also becomes an expression state-
ment when it is terminated by a semicolon. All three of the following are valid Java
statements:

alpha++;
beta--;
--gamma;

Assignment expression A Java expression with (1) a
value and (2) the side effect of storing the expression
value into a memory location

Expression statement A statement formed by
appending a semicolon to an assignment expression, an
increment expression, or a decrement expression



472 | Chapter 10:  Additional Control Structures and Exceptions

Each of these statements either increments or decrements the given variable.
Because an assignment is an expression, not a statement, you can use it anywhere

an expression is allowed. Here is a statement that stores the value 20 into firstInt,
the value 30 into secondInt, and the value 35 into thirdInt:

thirdInt = (secondInt = (firstInt = 20) + 10) + 5;

Although some Java programmers use this style of coding, we do not recommend it. It
is hard to read and error-prone.

In Chapter 6, we cautioned against the mistake of using the = operator in place of
the == operator:

if (alpha = 12)  // Wrong
.
.
.

The condition in the if statement is an assignment expression, not a relational expres-
sion. The value of the expression is 12, which is not a boolean value, so a compiler
error results.

In addition to the = operator, Java has several combined assignment operators (+=,
*=, and the others listed in our table of operators). These operators have the following
semantics:

Statement Equivalent Statement

i += 5; i = i + 5;

pivotPoint *= n + 3; pivotPoint = pivotPoint * (n + 3);

The combined assignment operators are sometimes convenient for writing a line of
code more compactly, but you can do just fine without them. We do not use them in
this text.

Increment and Decrement Operators

The increment and decrement operators (++ and --) operate only on variables, not on
constants or arbitrary expressions. Suppose a variable someInt contains the value 3.
The expression ++someInt denotes pre-incrementation. The side effect of incrementing
someInt occurs first, so the resulting value of the expression is 4. In contrast, the
expression someInt++ denotes post-incrementation. The value of the expression is 3,
and then the side effect of incrementing someInt takes place. The following code illus-
trates the difference between pre- and post-incrementation:

int1 = 14;
int2 = ++int1;



10.3 Additional Java Operators | 473

// At this point, int1 == 15  and  int2 == 15
int1 = 14;
int2 = int1++;
// At this point int1 == 15  and  int2 == 14

Some people make a game of seeing how much they can do in the fewest key-
strokes possible by using side effects in the middle of larger expressions. But profes-
sional software development requires writing code that other programmers can read and
understand. Use of side effects reduces readability. By far the most common use of ++
and -- is to do the incrementation or decrementation as a separate expression state-
ment:

count++;

Here, the value of the expression is unused, but we get the desired side effect of incre-
menting count.

Bitwise Operators

The bitwise operators listed in the operator table (<<, >>, >>>, &, |, and so forth) are
used for manipulating individual bits within a memory cell. This book does not explore
the use of these operators; the topic of bit-level operations is most often covered in a
course on computer organization and assembly-language programming. However, we
should draw your attention to the fact that three of the bitwise operators, &, |, and ^,
have a second meaning in Java. They can also be used with boolean operands to per-
form logical AND, OR, and EXCLUSIVE OR operations without short-circuit evaluation.

Recall from Chapter 6 that when the first operand of && is false, the second operand
need not be evaluated because the result must be false. When used in combination with
boolean operands, the & operator causes the second operand to be evaluated regardless
of the value of the first operand. Similar rules apply to the | and ^ operators.

Here is an example that illustrates the difference between these logical operators:

// This works OK when i is 0 because m/i isn't evaluated
if (i != 0 && m/i >= 4)
k = 20;

Now consider what happens if we use & in place of &&:

// This fails when i is 0 because of division by zero
if (i != 0 & m/i >= 4)
k = 20;

There are rare cases where full evaluation is useful, but we recommend that you always
use the relational operators && and || in your logical expressions.



474 | Chapter 10:  Additional Control Structures and Exceptions

The ?: Operator

The last operator in our operator table is the ?: operator, sometimes called the condi-
tional operator. It is a ternary (three-operand) operator with the following syntax:

Here’s how it works. First, the computer evaluates Expression1. If the value is true,
then the value of the entire expression is Expression2; otherwise, the value of the entire
expression is Expression3.

A classic example of its use is to set a variable max equal to the larger of two vari-
ables a and b. Using an if statement, we would do it this way:

if (a > b)
max = a;

else
max = b;

With the ?: operator, we can use the following assignment statement:

max = (a > b) ? a : b;

The ?: operator is certainly not an intuitively obvious bit of Java syntax; it’s one of
the unusual features Java inherited from C. We do not recommend its use, but you
should be aware of it in case you encounter it in reading code written by someone else.

Operator Precedence

Following is a summary of operator precedence for the Java operators we have encoun-
tered so far, excluding the bitwise operators. (Appendix B contains the complete list.) In
Table 10.1, the operators are grouped by precedence level, and a horizontal line sepa-
rates each precedence level from the next-lower level.

The column labeled Associativity describes grouping order. Within a precedence
level, most operators group from left to right. For example,

a – b + c

Expression1  ?  Expression2  :  Expression3

ConditionalOperator



10.3 Additional Java Operators | 475

means

(a – b) + c

and not

a – (b + c)

Certain operators, though, group from right to left—specifically, the unary operators, the
assignment operators, and the ?: operator. Look at the unary – operator, for example.
The expression

sum = - -1

Table 10.1 Precedence (highest to lowest)

Operator Associativity Remarks

++ -- Right to left ++ and -- as postfix opera-
tors

++ -- Right to left ++ and -- as prefix operators
Unary + Unary – Right to left
! Right to left
(cast) Right to left

*  /  % Left to right

+  – Left to right
+ Left to right String concatenation

<  <=  >  >= Left to right
instanceof Left to right

==  != Left to right
& Left to right boolean operands

^ Left to right boolean operands

| Left to right boolean operands

&& Left to right

|| Left to right

?: Right to left



476 | Chapter 10:  Additional Control Structures and Exceptions

means

sum = -(–1)

instead of the meaningless

sum = (- -)1

This associativity makes sense because the unary – operation is naturally a right-to-left
operation.

A word of caution: Although operator precedence and associativity dictate the
grouping of operators with their operands, the precedence rules do not define the order
in which subexpressions are evaluated. Java further requires that the left-hand operand
of a two-operand operator be evaluated first. For example, if i currently contains 5, the
statement

j = ++i + i;

stores 12 into j. Let’s see why. There are three operators in the expression statement
above: =, ++, and +. The ++ operator has the highest precedence, so it operates just on i,
not the expression i + i. The addition operator has higher precedence than the assign-
ment operator, giving implicit parentheses as follows:

j = (++i + i);

So far, so good. But now we ask this question: In the addition operation, is the left
operand or the right operand evaluated first? As we just saw, the Java language tells us
that the left-hand operand is evaluated first. Therefore, the result is 6 + 6, or 12. If Java
had instead specified that the right operand comes first, the expression would have
yielded 6 + 5, or 11.

In most expressions, Java’s left-hand rule doesn’t have any effect. But when side-
effect operators like increment and assignment are involved, you need to remember that
the left operand is evaluated first. To make the code clear and unambiguous, it’s best to
write the preceding example with two separate statements:

i++;
j = i + i;

The moral here is that it’s best to avoid unnecessary side effects altogether.

TE
AM
FL
Y

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

Team-Fly® 



Problem-Solving Case Study | 477

Problem-Solving Case Study
Monthly Rainfall Averages

Statement of the Problem Meteorologists have recorded monthly rainfall amounts at several
sites throughout a region of the country. You have been asked to write an application that reads
one year’s rainfall amounts from sites within the region from a file and prints out the average of
the 12 values for each of the sites on a separate file. The first line of a data set is the name of
the site, and the 12 values for the site follow on the next line with exactly one blank in between
each value. The data file is named "rainData.dat".

Brainstorming This problem sounds familiar. We wrote an application in Chapter 5 that took
rainfall amounts from observers and calculated the running average. In that problem we used a
window for input and output; this problem asks for file input and output. Calculating an average
should be the same, but where the calculation takes place is different. In the previous problem the
calculation took place in the handler for the button event. There are no buttons in this problem.

There are other nouns in the problem, but they describe the context like region, country,
and sites, so they are not objects in the solution. So, what are the objects? The application and
the file objects.

Filtering This looks like a very sparse set of classes for a problem that includes calculating a
series of averages. But this problem is one that has a process repeated over different data, but
does not have any objects but numeric values and files. What about error conditions? Well we
can’t determine what they might be at this stage other than to say that the data might have
been entered incorrectly on the file. Let’s add an exception class to our list of classes. Before we
look at the responsibilities of each class, let’s name them. Let’s call the application class
RainFall and the exception class DataSetExcetion.

Scenarios The processing takes place within the application class RainFall: processing a
data set, writing the average, and repeating the process until there are no more data sites.
What happens if an input error occurs while reading the data file? What happens if a data
value contains a non-numeric character? What happens if there is a negative rainfall amount?

RainFall
input file
output file
DataSetException

application
input file
output file



478 | Chapter 10:  Additional Control Structures and Exceptions

These are all error conditions we must handle. For the moment, let’s just say that Rainfall
has the responsibility to throw exceptions if need be.

CRC Cards On the CRC card, we summarize RainFall’s responsibility as Process data.

Responsibility Algorithms Preparing the file for input and output has become so routine,
that we do not need to write the algorithms for these. The third responsibility, Processing data,
is the heart of the problem. At the topmost level of the design, we need a loop to process the
data from all the sites. Each iteration must process one site’s data, then check for a new site
name. The program does not know in advance how many recording sites there are, so the loop
cannot be a count-controlled loop. Although we can make any of for, while, or do work
correctly, we use a do under the assumption that the file definitely contains at least one site’s

Class Name: DataSetException Superclass: Exception Subclasses:

Responsibilities Collaborations

Create itself

Pass message to super Super

Class Name: Rainfall Superclass: Object Subclasses:

Responsibilities Collaborations

Prepare the file for input FileReader, BufferedReader

Prepare the file for output FileWriter, PrintWriter

Process data BufferedReader

Throw exceptions if necessary DataSetException



Problem-Solving Case Study | 479

data. Therefore, we can set up the loop so that it processes the data from a recording site and
then, at the bottom of the loop, decides whether to iterate again.

Process Data Level 1

Processing one site requires another loop to input 12 monthly rainfall amounts and form their
sum. Using the summing technique we are familiar with by now, we initialize the sum to 0
before starting the loop, and each loop iteration reads another number and adds it to the
accumulating sum. A for loop is appropriate for this task, because we know that exactly 12
iterations must occur. How are we going to handle the error conditions brought up in the sce-
narios? We had better put the for loop in a try-catch statement. Once we have the value we
should throw an exception if it is negative.

Process One Site Level 2

Because all of the input values are on one line with a blank in between, we have to extract the
characters that make up one value so we can convert it. We can use the String methods
indexOf and substring to extract a string that represents exactly one floating-point value.

Get Rainfall Amount Level 3

Set index to line.indexOf(‘ ‘)
Set currentValue to line.substring(0, index)
Set line to substring(index+1, line.length())
Set amount to Double.valueOf(currentValue).doubleValue

Set sum to 0.0
try to

Get a line of values
for months going from 1 to 12

Get rainfall amount
if amount is negative

throw DataSetException(“negative value found”)
else

Set sum to sum + amount
Write “Average for “ + data set name + “ is “  + sum/12

catch and handle exceptions

Prepare input file, rainData.dat
Prepare output file, outFile.dat
Read data set name
do

Process one site
Read data set name

while (more data)
Close files



480 | Chapter 10:  Additional Control Structures and Exceptions

Before we go on, we had better hand-simulate this algorithm. Let’s apply it to the follow-
ing input string.

"23.5 5.6 5.44"

index currentValue line amount

4 ”23.5” ”5.6 5.44” 23.5
3 ”5.6” ”5.44” 5.6
error ”5.44”

There is an error in the logic. Unless there is a blank after the last value rather than an end
of line, the indexOf method returns a 21, indicating that there isn’t another blank. We then
use the index in the next statement, producing an error in method substring. We need to
check to be sure that a blank is found. If not, the remaining string is the last value in the line.

Get Rainfall Amount (revised) Level 3

We now need to decide what other errors might occur, how to catch them, and how to
handle them. The file can throw an IOException exception, the conversion operation can
throw a NumberFormatException, and our own code can throw a DataSetExeption.
Let’s catch the IOException, print out the site name, and end the program. For the Num-
berFormatException, let’s print out the site name with an error message, and continue
processing with the next site. We can do the same for DataSetException.

Catch and Handle Exceptions

The only abstract step left is to determine when the outer loop finishes. If we read in a
new site name and there is no more data, line will be null.

catch IOException
Write “I/O Exception with site “ + data set name
exit program

catch NumberFormatException
Write “NumberFormatException with site “ + data set name

catch DataSetException
Write except.getMessage()  + data set name

Set index to line.indexOf(‘ ‘)
if index > 0

Set currentValue to line.substring(0, index)
Set line to substring(index+1, line.length())

else
Set currentValue to line

Set amount to Double.valueOf(currentValue).doubleValue



Problem-Solving Case Study | 481

More Data

Assumptions The file contains data for at least one site.

package rainfall;
// Define an Exception class for signaling data set errors
class DataSetException extends Exception
{
public DataSetException()
{
super();

}
public DataSetException(String message)
{
super(message);

}
}
package rainfall;
import java.io.*;
public class Rainfall
//******************************************************************
// RainFall application
// This program inputs 12 monthly rainfall amounts from a
//  recording site and computes the average monthly rainfall.
// This process is repeated for as many recording sites as
//  the user wishes.
//******************************************************************
{
static void processOneSite(BufferedReader inFile, 
PrintWriter outFile, String dataSetName)

{
int count;                // Loop control variable
double amount;            // Rainfall amount for one month
double sum = 0.0;         // Sum of amounts for the year
String dataLine;          // String to input amount from inFile
String currentValue;      // Floating point string
int index;                // Position of blank

try
{
// Next line could produce an IOException
dataLine = inFile.readLine();

line != null



482 | Chapter 10:  Additional Control Structures and Exceptions

for (count = 1; count <= 12; count++)  // For 12 months
{
index = dataLine.indexOf(' ');       // Find position of blank
if (index > 0)
{ // Blank found
currentValue = dataLine.substring(0, index);  // Extract a number
// Remove current value from string
dataLine =      
dataLine.substring(Math.min(index+1, dataLine.length()), 
dataLine.length());

}
else  // Remaining string is current value
currentValue = dataLine;

// Next line could produce NumberFormatException
// Convert to double
amount = Double.valueOf(currentValue).doubleValue();
if (amount < 0.0)
throw new DataSetException("Negative value in site ");

else
sum = sum + amount;

}
outFile.println("Average for " + dataSetName + " is " + sum/12.0);

}
catch (IOException except)
{
outFile.println("IOException  with site " + dataSetName);
System.exit(0);

}
catch (NumberFormatException except)
{
outFile.println("NumberFormatException in site " +  dataSetName);

}
catch (DataSetException except)
{
outFile.println(except.getMessage() + dataSetName);

}
}
public static void main(String[] args) 
throws FileNotFoundException,IOException

{
String  dataSetName;                   // Name of reporting station
BufferedReader inFile;                 // Data file
PrintWriter outFile;                   // Output file
inFile = new BufferedReader(new FileReader("rainData.dat"));
outFile = new PrintWriter(new FileWriter("outfile.dat"));
dataSetName = inFile.readLine();       // Get name of reporting station



Problem-Solving Case Study | 483

do
{
processOneSite(inFile, outFile, dataSetName);
dataSetName = inFile.readLine();     // Get name of reporting station

} while (dataSetName != null);
inFile.close();
outFile.close();
System.exit(0);

}
}

Testing We should test two separate aspects of the Rainfall program. First, we should
verify that the program works correctly given valid input data. Supplying arbitrary rainfall
amounts of 0 or greater, we must confirm that the program correctly adds up the values and
divides by 12 to produce the average. Also, we should make sure that the program behaves
correctly when it reaches the end of the file.

The second aspect to test is the data-validation code that we included in the program. We
should include negative numbers in the file to ensure that such data sets are not processed.
Similarly, we need to include some values that are improperly formed floating values. Here’s a
sample input file that accomplishes the necessary testing:

Moose Lake
0.0 3.6 1.2 0.5 4.3 0.6 2.2 1.9 6.5 4.0 8.3 1.4
East Duckville
7.4 8.2 6.5 1.9 9.7 6.4 5.5 8.1 4.7 3.9 12.8 10.6
Dry Gulch
0.0 0.0 0.0 0.1 0.2 0.1 0.2 0.0 0.0 0.4 0.0 0.1
Bad Data City
–0.4 10.4 1000.9 21.1 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0
Wrong Number Town
0.0 0.0 0.0 xyz.8 abc def ghi jkl mno pqr stu vwx

And here is the output from running the program on the data file:

Average for Moose Lake is 2.8749999999999996
Average for East Duckville is 7.141666666666667
Average for Dry Gulch is 0.09166666666666667
Negative value in site Bad Data City
NumberFormatException in site Wrong Number Town



484 | Chapter 10:  Additional Control Structures and Exceptions

Testing and Debugging

The same testing techniques we used with while loops apply to do and for loops. There
are, however, a few additional considerations with these loops.

The body of a do loop always executes at least once. Thus, you should try data sets
that show the result of executing a do loop the minimal number of times.

With a data-dependent for loop, it is important to test for proper results when the
loop executes zero times. This occurs when the starting value is greater than the ending
value (or less than the ending value if the loop control variable is being decremented).

When a program contains a switch statement, you should test it with enough different
data sets to ensure that each branch is selected and executed correctly. You should also
test the program with a switch expression whose value is not in any of the case labels.

A program that handles exceptions must be tested to ensure that the exceptions are
generated appropriately and then properly handled. Test cases must be included to cause
exceptions to occur and to specify the expected results from handling them.

Testing and Debugging Hints

1. In a switch statement, make sure there is a break statement at the end of each case
alternative. Otherwise, control “falls through” to the code in the next case alternative.

2. Case labels in a switch statement are made up of values, not variables. They may,
however, include named constants and expressions involving only constants.

3. A switch expression must be one of the types char, byte, short, or int. It cannot
be of type long or a floating-point or string expression.

4. The case constants of a switch statement cannot be of type long, or be floating-
point or string constants.

5. If there is a possibility that the value of the switch expression might not match one
of the case constants, you should provide a default alternative.

6. Double-check long switch statements to make sure that you haven’t omitted any
branches.

7. The do loop is a posttest loop. If there is a possibility that the loop body should be
skipped entirely, use a while statement or a for statement.

8. The for statement heading (the first line) always has three pieces within the paren-
theses. Typically, the first piece initializes a loop-control variable, the second piece
tests the variable, and the third piece increments or decrements the variable. The
three pieces must be separated by semicolons. Any of the pieces can be omitted, but
the semicolons still must be present.

9. Make sure that all exceptions are either caught or forwarded as appropriate.

Summary of Classes

We have not introduced any new classes in the Java library in this chapter, nor have we
designed any classes that should go into a library to use later.



Quick Check | 485

Summary
The switch statement is a multiway selection statement. It allows the program to choose
among a set of branches. A switch containing break statements can always be simulated
by an if-else-if structure. If a switch can be used, however, it often makes the code easier
to read and understand. A switch statement cannot be used with floating-point or string
values in the case labels.

The do is a general-purpose looping statement. It is like the while loop except that its
test occurs at the end of the loop, guaranteeing at least one execution of the loop body.
As with a while loop, a do continues as long as the loop condition is true. A do is con-
venient for loops that test input values and repeat if the input is not correct.

The for statement is also a looping statement and is commonly used to implement count-
controlled loops. The initialization, testing, and incrementation (or decrementation) of the
loop-control variable are centralized in one location, the first line of the for statement.

An exception occurs when an error condition is encountered in a method and the
method cannot directly resolve the problem. The method is said to throw an exception,
which we can catch using a try-catch statement. Catching an exception and handling it
properly enables the program to continue executing, rather than allowing the error to be
passed to the JVM, which halts the program with an error message. Typical exceptions
include IOException, NumberFormatException, and ArithmeticException.

The throw statement gives us the ability to throw exceptions when we detect them.
When we create new classes derived from Exception, we can throw exceptions that are
specific to our classes and methods. Those exceptions can then be caught and handled
in ways that are more appropriate than would be possible if we were restricted to using
the exception types in the Java library.

The for, do, switch, and throw statements are the ice cream and cake of Java. We can
live without them if we absolutely must, but they are very nice to have.

Similarly, the additional operators that Java supplies, such as +=, %=, and ?:, are
sometimes convenient shortcuts. But we can program effectively without them. Often,
the use of the less common operators results in code that is harder to understand and so
we recommend that you avoid them. Even so, you must be aware of their meaning so
that you can interpret them when you encounter code written by a programmer who
values compact syntax over clarity.

Quick Check
1. Given a switch expression that is the int variable nameVal, write a switch

statement that writes the following to PrintWriter file outData: your first
name if nameVal = 1, your middle name if nameVal = 2, and your last name if
nameVal = 3. (pp. 452–455)

2. How would you change the answer to Question 1 so that it writes an error mes-
sage if the value is not 1, 2, or 3? (pp. 452–455)

3. What is the primary difference between a while loop and a do loop? (pp. 459–460)



486 | Chapter 10:  Additional Control Structures and Exceptions

4. A certain problem requires a count-controlled loop that starts at 10 and counts
down to 1. Write the heading (the first line) of a for statement that controls this
loop. (pp. 460–461)

5. What Java looping statement would you choose for a loop that is both count-
controlled and event-controlled and whose body might not execute even once?
(p. 463)

6. What is the difference between an expression and an expression statement in
Java? (pp. 471–472)

7. Write a statement that converts a string to an integer and writes out the string if
a NumberFormatError occurs. (p. 463)

8. What is the super class of most exceptions?

Answers

1. switch (nameVal)
{
case 1 : outData.println("Mary");

break;
case 2 : outData.println("Lynn");

break;
case 3 : outData.println("Smith");

break;   // Not required
}

2. switch (nameVal)
{
case 1  : outData.println("Mary");

break;
case 2  : outData.println("Lynn");

break;
case 3  : outData.println("Smith");

break;
default : outData.println("Invalid name value.");

break;   // Not required
}

3. The body of a do always executes at least once; the body of a while may not exe-
cute at all.

4. for (count = 10; count >= 1; count--)
5. A while (or perhaps a for) statement
6. An expression becomes an expression statement when it is terminated by a

semicolon.

TE
AM
FL
Y

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

Team-Fly® 



Exam Preparation Exercises | 487

7. try
{
intValue = Integer.valueOf("123").intValue();

}
catch(NumberFormatException except)
{
System.out.println(except.getMessage);

}
8. Exception

Exam Preparation Exercises
1. Define the following terms:

switch expression
pretest loop
posttest loop

2. (True or False?) A switch expression may be an expression that results in a value
of type int, float, boolean, or char.

3. (True or False?) The values in case labels may appear in any order, but duplicate
case labels are not allowed within a given switch statement.

4. (True or False?) All possible values for the switch expression must be included
among the case labels for a given switch statement.

5. Rewrite the following code fragment using a switch statement.

if (n == 3)
alpha++;

else if (n == 7)
beta++;

else if (n == 10)
gamma++;

6. What is written by the following code fragment if n equals 3? (Be careful here.)

switch (n + 1)
{
case 2  : outData.println("Bill");
case 4  : outData.println("Mary");
case 7  : outData.println("Joe");
case 9  : outData.println("Anne");
default : outData.println("Whoops!");

}

7. (True or False?) If a while loop whose condition is delta <= alpha is con-
verted into a do loop, the loop condition of the do loop is delta > alpha.



488 | Chapter 10:  Additional Control Structures and Exceptions

8. (True or False?) A do statement always ends in a semicolon.
9. What is written by the following program fragment? (All variables are of type int.)

n = 0;
i = 1;
do
{
outData.print(i);
i++;

} while (i <= n);

10. What is written by the following program fragment? (All variables are of type int.)

n = 0;
for (i = 1; i <= n; i++)
outData.print(i);

11. What is written by the following program fragment? (All variables are of type int.)

for (i = 4; i >= 1; i--)
{
for (j = i; j >= 1; j--)
outData.print (j + " ");

outData.println(i);
}

12. What is written by the following program fragment? (All variables are of type int.)

for (row = 1; row <= 10; row++)
{
for (col = 1; col <= 10 – row; col++)
outData.print("*");

for (col = 1; col <= 2*row – 1; col++)
outData.print(" ");

for (col = 1; col <= 10 – row; col++)
outData.print("*");

outData.println();
}

13. (True or False?) A break statement located inside a switch statement that is
within a while loop causes control to exit the loop immediately.

14. Classify each of the following as either an expression or an expression statement.
a. sum = 0
b. sqrt(x)
c. y = 17;
d. count++

15. Rewrite each statement as described.
a. Using the += operator, rewrite the statement

sumOfSquares = sumOfSquares + x * x;



Programming Warm-Up Exercises | 489

b. Using the decrement operator, rewrite the statement

count = count – 1;

c. Using a single assignment statement that uses the ?: operator, rewrite the
following code segment.

if (n > 8)
k = 32;

else
k = 15 * n;

16. What is the control structure to use if you think an operation might throw an
exception?

17. What is the statement that raises an exception?
18. What part of the try-catch must have a parameter of an exception object?
19. (True or False?) Our code can catch exceptions that it throws, but not exceptions

that the system throws.
20. Mark the following statements True or False. If a statement is false, explain why.

a. There can only be one catch clause for each try.
b. The exception handler is within the catch clause.
c. The finally clause is optional.
d. The finally clause is rarely used.

Programming Warm-Up Exercises
1. Write a switch statement that does the following:

If the value of grade is

‘A’, add 4 to sum
‘B’, add 3 to sum
‘C’, add 2 to sum
‘D’, add 1 to sum
‘F’, print “Student is on probation” on PrintWriter file outData

2. Modify the code for Exercise 1 so that an error message is printed if grade does
not equal one of the five possible grades.

3. Write a program segment that reads and sums integer values from a file until it
has summed 10 data values or until a negative value is read, whichever comes
first. Use a do loop for your solution.

4. Rewrite the following code segment using a do loop instead of a while loop.

response = inData.read();
while (response >= 0 && response <= 127)
{
response = inData.read();

}



490 | Chapter 10:  Additional Control Structures and Exceptions

5. Rewrite the following code segment using a while loop.

inInt = inData.read();
if (inInt >= 0)
do
{
outData.write(inInt);
inInt = inData.read();

} while (inInt >= 0);

6. Rewrite the following code segment using a for loop.

sum = 0;
count = 1;
while (count <= 1000)
{
sum = sum + count;
count++;

}

7. Rewrite the following for loop as a while loop.

for (m = 93; m >= 5; m--)
outData.println( m + " " + m * m);

8. Rewrite the following for loop using a do loop.

for (k = 9; k <= 21; k++)
outData.println( k + " " + 3 * k);

9. Write a value-returning method that accepts two int parameters, base and expo-
nent, and returns the value of base raised to the exponent power. Use a for loop
in your solution.

10. a. Declare an exception of class MyException.
b. Write class MyException.
c. Write the statement that throws an exception of class MyException.

11. Write a try-catch statement that attempts to open file "data.in" for reading
and writes an error message if an exception is thrown.

Programming Problems
1. Develop a Java application that inputs a two-letter abbreviation for one of the

50 states from a field and displays the full name of the state in a label. If the
abbreviation isn’t valid, the program should display an error message and ask
for an abbreviation again. The names of the 50 states and their abbreviations are
given in the following table. Use two buttons: one to enter an abbreviation and
one to quit.



Programming Problems | 491

(Hint: Use nested switch statements, where the outer statement uses the first let-
ter of the abbreviation as its switch expression.)

2. Design and write a Java application that reads a date in numeric form from a set
of three fields and displays it in English within a label. Use appropriate buttons.
For example:

Given the date:

10  27  1942

The program displays:

October twenty-seventh, nineteen hundred forty-two.

State Abbreviation State Abbreviation

Alabama AL Montana MT
Alaska AK Nebraska NE
Arizona AZ Nevada NV
Arkansas AR New Hampshire NH
California CA New Jersey NJ
Colorado CO New Mexico NM
Connecticut CT New York NY
Delaware DE North Carolina NC
Florida FL North Dakota ND
Georgia GA Ohio OH
Hawaii HI Oklahoma OK
Idaho ID Oregon OR
Illinois IL Pennsylvania PA
Indiana IN Rhode Island RI
Iowa IA South Carolina SC
Kansas KS South Dakota SD
Kentucky KY Tennessee TN
Louisiana LA Texas TX
Maine ME Utah UT
Maryland MD Vermont VT
Massachusetts MA Virginia VA
Michigan MI Washington WA
Minnesota MN West Virginia WV
Mississippi MS Wisconsin WI
Missouri MO Wyoming WY



492 | Chapter 10:  Additional Control Structures and Exceptions

Here is another example:

Given the date:

12  10  2010

The program displays:

December tenth, two thousand ten.

The program should display an error message for any invalid date, such as 2 29
1883 (1883 wasn’t a leap year).

3. Write a Java application that reads full names from an input file and writes the
initials for the names to an output file named initials. For example, the input

John James Henry

should produce the output

JJH

The names are stored in the input file first name first, then middle name, then
last name, separated by an arbitrary number of blanks. There is only one name
per line. The first name or the middle name could be just an initial.

4. Write a Java application that converts letters of the alphabet into their corre-
sponding digits on the telephone. The program should let the user enter letters
repeatedly until a ‘Q’ or a ‘Z’ is entered. (Q and Z are the two letters that are not
on the telephone.) An error message should be printed for any nonalphabetic
character that is entered.

The letters and digits on the telephone have the following correspondence.

ABC =  2 DEF =  3 GHI =  4
JKL =  5 MNO =  6 PRS =  7
TUV =  8 WXY =  9

Here is an example:

When the user enters P the program displays:

The letter P corresponds to 7 on the telephone.

When the user enters A the program displays:

The letter A corresponds to 2 on the telephone.

When the user enters D the program displays:

The letter D corresponds to 3 on the telephone.

When the user enters 2 the program displays:

Invalid letter. Enter Q or Z to quit.

When the user enters Z the program quits.



5. Rewrite the Rainfall program so that it asks the user for the input file name
using a Frame, and catches the FileNotFoundException if the name is invalid.
In the case of an invalid file name, the user should be asked to re-enter the file
name until a valid name is entered or they close the Frame (signaling that they
want to stop the program).

Case Study Follow-Up Exercises
1. Rewrite the processOneSite method in the Rainfall application, replacing

the for loop with a do loop.
2. Rewrite the processOneSite method in the Rainfall program, replacing the

for loop with a while loop.
3. Change the do loop in main in the Rainfall program to be a while loop.
4. Could module Get RainFall Amount be made a method? Explain.

Case Study Follow-Up Exercises | 493





                

To be able to differentiate between atomic and com-
posite data types.

To be able to differentiate between unstructured and
structured composite data types.

To be able to declare and instantiate a one-dimen-
sional array object.

To be able to access the individual components in a
one-dimensional array object.

To be able to use an initializer list to instantiate a one-
dimensional array object.

To be able to pass a one-dimensional array object as a
parameter.

To be able to pass an element of a one-dimensional
array object as a parameter.

To be able to manipulate the elements in a one-dimen-
sional array object where the elements are atomic types.

To be able to manipulate the elements in a one-
dimensional array object where the elements are com-
posite types.

To be able to declare, instantiate, and use a one-
dimensional array object with index values that have
semantic content.

To be able to declare, instantiate, and manipulate
components in a one-dimensional array object that is
only partially filled with data.

One-Dimensional
Arrays

G
oals



496 | Chapter 11:  One-Dimensional Arrays

integral

referenceprimitive

byte char short int

floating point

Java data types

float

array interface class

doublelong

boolean

Figure 11.1 Java data types

In Chapter 4, we showed a diagram of Java data types (repeated below as Figure 11.1).
Java data types are broken into primitive and reference types. Recall that Java stores
primitive types directly into the named location, but reference types are stored into the
place whose address is stored in the named location. We have covered classes and prim-
itive types in previous chapters. We extend the discussion of the Java data types in this
chapter by examining the array. However, before we do, we step back and look at data
types from a general perspective rather than from a Java perspective.

11.1 Atomic Data Types
Recall that a data type is a set of data values, along with a set of operations on those
values. The definitions of integer and real numbers come from mathematics. Integer
numbers are the set of whole numbers from negative to positive infinity, and the opera-
tions defined for them are the arithmetic operations, specified by +, -, / (integer divi-
sion), *, and modulus, assignment, and the relational operations.

Real numbers are the set of all numbers from negative to positive infinity, and the
operations are the same as those for the integers except that integer division and modu-
lus are excluded. Because computers are finite, programming languages put limits on
the range of integers and the range and precision of real numbers. Java provides four
different types of integer numbers that differ only in the range of values that they can
represent in memory: byte, short, int, and long. Java has two real types (called
floating-point) that differ only in the range and precision that they can represent:
float and double.

Alphanumeric characters, another simple type, are the symbols that we use in writ-
ten language. These symbols vary from one natural language to another. The same is
true of characters used to represent textual data in a computer. For many years, there
were two main character sets: ASCII and EBCDIC. In these character sets, each character
occupies one byte in memory, giving 256 possible characters. Some of the characters are
nonprintable control characters used by the computer’s hardware. Unicode, a character
set that uses two bytes to represent each character, was developed to include characters
for writing text in many natural languages. Unicode, which Java uses, contains ASCII as
a subset.

TE
AM
FL
Y

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

Team-Fly® 



11.1 Atomic Data Types | 497

The operations defined on alphanumeric characters are the relational operations and
assignment. The ordering used by the relational operators is the collating sequence of
the character set. Although the collating sequence is different for different character
sets, the letters and digits are ordered as we would expect; that is, 'A'<'B'<'C' . . .
and '1'<'2'<'3'. . . .

Characters are treated differently in different programming languages. In Pascal, the
data type for a character is distinct. Arithmetic operations, applied to character data,
cause a compile-time error. In C++, there is no real distinction between characters and
numbers. Arithmetic operations may be applied to character data and often are. The
only difference is that, when character data is printed, the character itself is printed
rather than the numeric representation of the character. In Java, arithmetic operations
applied to character data cause the compiler to insert a cast operation that converts the
character to a numerical value.

Boolean values are another simple data type comprised of the two literals True and
False. The operations allowed on these values are the logical operators AND, OR, NOT,
the relational operations, and assignment operations. Although many languages con-
sider Boolean values to be ordered, Java does not, so only equal and not equal can be
applied to Boolean values in Java. Java calls the Boolean type boolean and the literals
true and false.

Integers, reals, characters, and Booleans have two properties in common. Each is
made up of indivisible, or atomic, elements, and each is ordered. Data types with these
properties are called scalar data types. (Java’s
type boolean is not scalar because they
aren’t ordered.)

When we say that a value is atomic, we
mean that it has no component parts that can
be accessed independently. For example, a single character is atomic, but the string
“Good Morning” is not because it is composed of 12 characters. When we say that the
values are ordered, we mean that exactly one of the relations less than, greater than, or
equal is true for any pair of values. Some examples of ordered relationships are

1 < 2  'C' > 'A' 3.562 < 106.22

Integers, characters, and Booleans have an
additional property: Each value (except the
first) has a unique predecessor and each value
(except the last) has a unique successor. A
type with this property is called an ordinal
data type.

Real numbers are not ordinal because a real value has no unique predecessor or
successor. If one more digit of precision is added, the predecessor and successor change;
that is, 0.52 and 0.520 are the same, but the predecessor of 0.52 is 0.51, and the prede-
cessor of 0.520 is 0.519. Because Java’s type boolean is not ordered, it is not ordinal.

Although the ordinals are a subset of the scalars, they are quite different. Mathe-
maticians make this same distinction; they talk about continuous values versus discrete

Scalar data type A data type in which the values are
ordered and each value is atomic (indivisible)

Ordinal data type A data type in which each value
(except the first) has a unique predecessor and each
value (except the last) has a unique successor



498 | Chapter 11:  One-Dimensional Arrays

values. There are many real-life analogies that demonstrate this distinction as well: the
continuous spectrum of colors in a real rainbow versus the discrete colors in a child’s
crayon drawing of a rainbow or the continuous tone of a violin sliding up the scale ver-
sus the discrete tones of a piano.

Java classifies the scalar types that it represents as “primitive.” “Simple” is another
name for scalar types.

11.2 Composite Data Types
There are times when it is necessary to show a relationship among variables or to store
and reference collections of variables as a group. For this reason we need a way to asso-

ciate an identifier with a collection of values. A data
type made up of a collection of values is called a
composite data type.

Composite data types come in two forms:
unstructured and structured. An unstructured data
type is one in which no relationship exists among
the values in the data type other than that they are
members of the same collection. A structured data
type, on the other hand, is an organized collection
of components, one in which a relationship exists
among the items in the collection. We use this rela-
tionship to access individual items within the collec-
tion as well as manipulate the collection as a whole.

A value in a simple type is a single data item; it cannot be broken down into com-
ponent parts. For example, in Java each int value is a single integer number and can-
not be further decomposed. In contrast, a composite data type is one in which each
value is a collection of component items. The entire collection is given a single name,
yet each component can still be accessed individually.

The class is an example of a composite data type. A class has a name and is com-
posed of named data fields and methods. An instance of a class, including the data
fields and methods, can be passed as a parameter. The data fields and methods can be
accessed individually by name. A class is unstructured because the meaning is not
dependent on the ordering of the data fields or the methods within the source code. That
is, the order in which the members of the class are listed can be changed without chang-
ing the function of the class.

In Java, all composite types are either classes, interfaces, or arrays. Rather than
talking about the type of a composite object, we talk about its class. An example of a
composite object in Java is an instance of the String class, used for creating and
manipulating strings. When you declare a variable myString to be of class String,
myString does not represent just one atomic data value; it represents an entire collec-
tion of characters and the methods that manipulate the characters. But each of the com-
ponents in the string can be accessed individually by using an expression such as
myString.charAt(3), which accesses the char value at position 3. Therefore, the
characters within the string are organized according to their relative positions.

Composite data type A data type that allows a col-
lection of values to be associated with an identifier of
that type.

Unstructured data type A collection of components
that are not organized with respect to one another

Structured data type An organized collection of
components; the organization determines the method
used to access individual components.



11.3 One-Dimensional Arrays | 499

Atomic
Composite

Unstructured
Composite
Structured

Figure 11.2 Atomic (simple) and composite data types

Simple data types are the building blocks for composite types. A composite type
gathers together a set of component values and usually imposes a specific arrangement
on them (see Figure 11.2). If the composite type is a built-in type, the accessing mecha-
nism is provided in the syntax of the language. If the composite type is a user-defined
type, the accessing mechanism is built into the methods provided with the class.

In Chapters 1 through 10, we have discussed control structures and the class, an
unstructured composite type. In the next three chapters we focus on structured compos-
ite data types. Of course, we do not abandon the class, but we focus on having a struc-
tured composite type as a field in a class.

11.3 One-Dimensional Arrays
How we organize our data plays an important role in the design process. If the internal
data representation for a class is a composite type, that is, if it contains more than a
single atomic field, we call the internal repre-
sentation a data structure. The choice of data
structure directly affects the design because it
determines the algorithms used to process the
data. The class gives us the ability to refer to
an entire group of components by one name.
This simplifies the design of many programs.

Many problems, however, have so many components that it is difficult to process
them if each one must have a unique field name. For example, if we use individually
named values to read and print a file in reverse order, all the values must be read and
saved before the last one can be printed. If there are 1,000 values, we must define 1,000
individual variables to hold the values and input and output each value separately—an
incredibly tedious task! An array—the last of Java’s built-in reference types—is the data
type that allows us to program operations of this kind with ease.

Let’s look at how we would have to solve this problem with simple variables.

Data structure The implementation of a composite
data field in a class



500 | Chapter 11:  One-Dimensional Arrays

// Read 1,000 numbers and print them in reverse order.
import java.io.*
public class ReadWrite
{
private static BufferedReader inFile;
private static PrintWriter outFile;
public static void main(String[] args) throws IOException
{
inFile = new BufferedReader(new FileReader("infile.dat"));
outFile = new PrintWriter(new FileWriter("outfile.dat"));

// Declare 1,000 integer values.
int value0;
int value1;
int value2;
.
.
.
int value999;

// Read 1,000 integer values
value0 = Integer.valueOf(inFile.readLine()).intValue();
value1 = Integer.valueOf(inFile.readLine()).intValue();
value2 = Integer.valueOf(inFile.readLine()).intValue();
.
.
.
value999 = Integer.valueOf(inFile.readLine()).integerValue();

// Write out 1,000 values.
outFile.println(value999);
outFile.println(value998);
outFile.println(value997);
.
.
.
outFile.println(value0);
inFile.close();
outFile.close();
System.exit(0);

}
}

This program is over 3,000 lines long, and we have to use 1,000 separate variables. Note
that all the variables have the same name except for an appended number that distin-
guishes them. Wouldn’t it be convenient if we could put the number into a counter vari-
able and use for loops to go from 0 through 999, and then from 999 back down to 0?
For example, if the counter variable were number, we could replace the 2,000 original



11.3 One-Dimensional Arrays | 501

input/output statements with the following four lines of code (we enclose number in
brackets to set it apart from value):

for (number = 0; number < 1000; number++)
value[number] = Integer.valueOf(inFile.readLine()).integerValue();

for (number = 999; number >= 0; number--)
outFile.println(value[number]);

This code fragment is correct in Java if we declare value to be a one-dimensional
array, which is a collection of variables—all of the same type—where the first part of
each variable name is the same, and the last part is an index value enclosed in square
brackets. In our example, the value stored in number is called the index.

The declaration of a one-dimensional array is similar to the declaration of a simple
variable (a variable of a simple data type), with one exception. You must indicate that it
is an array by putting square brackets next to the type.

int[] value;

Because an array is a reference type, it must be instantiated, at which time you specify
how large the array is to be.

value = new int[1000];

value is an array with 1000 components, all of type int. The first component has
index value 0, the second component has index value 1, and the last component has
index value 999.

Here is the program to print out numbers in reverse order using an array. This is
certainly much shorter than our first version of the program.

// Read 1,000 numbers and print them in reverse order.
import java.io.*
public class ReadWrite
{
private static BufferedReader inFile;
private static PrintWriter outFile;
public static void main(String[] args) throws IOException
{ // Open files
inFile = new BufferedReader(new FileReader("infile.dat");
outFile = new PrintWriter(new FileWriter("outfile.dat");
// Declare and instantiate an array variable.
int[] value = new int[1000];
// Read 1000 values
for (int number = 0; number < 1000; number++)
value[number] =
Integer.valueOf(inFile.readLine()).intValue();

// Print 1000 values in reverse order
for (int number = 999; number >= 0; number--)
outFile.println(value[number]);



502 | Chapter 11:  One-Dimensional Arrays

// Close files and exit
inFile.close();
outFile.close();
System.exit(0);

}
}

In general terminology, an array differs from a class in three fundamental ways:

1. An array is a homogeneous data structure (all components in the structure are of the
same data type), whereas classes are heterogeneous types (their components may be
of different types).

2. A component of an array is accessed by its position in the structure, whereas a
component of a class is accessed by an identifier (the field name).

3. Because array components are accessed by position, an array is a structured data type.

Let’s now define Java arrays formally and look at the rules for accessing individual
components.

Declaring an Array

A one-dimensional array is a structured collection of
components (often called array elements) that can be
accessed individually by specifying the position of a
component with a single index value.

Here is a syntax template describing the simplest
form of a one-dimensional array declaration:

In the syntax template, DataType describes what is stored in each component of the
array. The brackets following DataType indicate that this is an array of DataType ele-
ments. Array components may be of almost any type, but for now we limit our discus-
sion to atomic components. We know from Figure 11.1 that the array is a reference
type. ArrayName is a location in memory that holds the address of an array when the
ArrayName is instantiated. For example,

int[] numbers;

declares an array of integers. We tell the compiler how many components the array
contains when we instantiate it.

Creating an Array

You create an array just like you create any object; you use new. Here is the syntax
template for instantiating an array. Notice that arrays don’t need to be initialized, so we

DataType[] ArrayName;

ArrayDeclaration

One-dimensional array A structured collection of
components, all of the same type, that is given a single
name. Each component (array element) is accessed by
an index that indicates the component’s position
within the collection.



11.3 One-Dimensional Arrays | 503

don’t pass a list of arguments. Instead, we put the number of slots to be in the array in
brackets beside the type of the array.

IntExpression is an integer expression that specifies the number of components in the
array. This expression must have a value greater than or equal to 0. If the value is n, the
range of index values is 0 through n 2 1, not 1 through n. For example, the declarations

float[] angle;                  // Declares the array variable
angle = new float[4];           // Instantiates the array object
int[] testScore;                // Declares the array variable
testScore = new int[10];        // Instantiates the array object

instantiate the arrays shown in Figure 11.3. The angle array has four components, each
capable of holding one float value. The testScore array has a total of 10 compo-
nents, all of type int.

new TypeName[IntExpression]

ArrayCreation



angle testScore

  testScore[0]

testScore[1]

testScore[2]

testScore[3]

testScore[4]

testScore[5]

testScore[6]

testScore[7]

testScore[8]

testScore[9]

angle[0]

angle[1]

angle[2]

angle[3]

Figure 11.3 angle and testScore arrays



504 | Chapter 11:  One-Dimensional Arrays

An array can be declared and instantiated in separate statements or the declaration
and creation can be combined into one step as shown here.

// Declared and instantiated in one statement
float[] angle = new float[4];
// Declared and instantiated in one statement
int[] testScore = new int[10];

Because arrays are reference types in Java, they are instantiated at run time, not at compile
time. Therefore, the IntExpression used to instantiate an array object does not have to
be a constant. It can be a value that you have read into the program. For example, if you
have read the value of dataSize from a file, the following declaration is legal:

int[] data = new int[dataSize];

Once instantiated, data always has dataSize components. For example, if dataSize
is 10 when the array object data is instantiated but is later changed to 15, data still
has 10 components.

Java provides an alternate syntax for declaring an array object; the brackets that
signal an array can be placed after the array name as shown below:

char letters[];
char upperCase[];
char lowerCase[];

We do not recommend using this syntactic form, however. It is more consistent—and
safer—to place the brackets with the type of the components. We say it is safer because,
as you may recall from Chapter 2, Java also lets us declare multiple identifiers with a
statement such as this:

char letters[], upperCase[], lowerCase;

Look closely at this example: letters and upperCase are composite variables of type
char[], but lowerCase is a simple variable of type char. If you use the syntax that we
introduced first, you cannot forget to put the brackets on one of the array identifiers:

char[] letters, upperCase, lowerCase;

Declaring and Creating an Array with an Initializer List

Java provides an alternative way to instantiate an array. You learned previously that
Java allows you to initialize a variable in its declaration:

int delta = 25;

The value 25 is called an initializer. You also can initialize an array in its declaration,
using a special syntax for the initializer. You specify a list of initial values for the array
elements, separate them with commas, and enclose the list within braces:

int[] age = {23, 10, 16, 37, 12};



11.3 One-Dimensional Arrays | 505

1Java inherits the notion that type char is a numeric type from C.  The Java language specifications say that
arrays must be indexed by int values but that values of type short, byte, or char may also be used because
they are subjected to unary numeric promotion and become int values. However, for clarity we type cast
char values to int when using them as an index.

In this declaration, age[0] is initialized to 23, age[1] is initialized to 10, and so on.
Notice two interesting things about this syntax. First, the new operator is not used; sec-
ond, the number of components is not specified. When the compiler sees an initializer
list, it determines the size by the number of items in the list, instantiates an array of
that size, and stores the values into their proper places. Of course, the types of the val-
ues in the initializer list must match the type of the array.

What are the values in an array instantiated by using new? If the array components
are primitive types, they are set to their default value. If the array components are refer-
ence types, the components are set to null.

There are only two ways that an object can be created without using new: by using
an array initializer list and by creating a String literal.

Accessing Individual Components

Recall that to access an individual field of a class, we use dot notation—the name of the
class object, followed by a period, followed by the field name. In contrast, to access an
individual array component, we write the array name, followed by an expression
enclosed in square brackets. The expression specifies which component to access. The
syntax template for accessing an array component is

The IndexExpression may be as simple as a constant or a variable name or as complex
as a combination of variables, operators, and method calls. Whatever the form of the
expression, it must result in an integer value. Index expressions can be of type byte,
char, short, or int.1 Using an index expression of type long causes a compile-time
error. The simplest form of index expression is a constant. Using our angle array, the
sequence of assignment statements

angle[0] = 4.93;
angle[1] = –15.2;
angle[2] = 0.5;
angle[3] = 1.67;

fills the array components one at a time (see Figure 11.4).

ArrayName [IndexExpression]

ArrayComponentAccess



506 | Chapter 11:  One-Dimensional Arrays

angle

angle[0]

angle[1]

angle[2]

angle[3]

4.93

—15.2

0.5

1.67

Each array component—angle[2], for instance—can be treated exactly the same as
any simple variable of type float. For example, we can do the following to the individ-
ual component angle[2]:

// Assign it a value
angle[2] = 9.6;

// Read a value into it
angle[2] = Double.valueOf(inFile.readLine()).doubleValue();

// Write its contents
oufFile.println(angle[2]); 

// Pass it as an argument 
y = Math.sqrt(angle[2]);

// Use it in an expression
x = 6.8 * angle[2] + 7.5;

Let’s look at a more complicated index expression. Suppose we declare a 1,000-element
array of int values with the statement

int[] value = new int[1000];

and execute the following statement:

value[counter] = 5;

In this statement, 5 is stored into an array component. If counter is 0, 5 is stored into
the first component of the array. If counter is 1, 5 is stored into the second place in the
array, and so forth. If instead we execute this statement:

if (value[number+1] % 10 != 0)

Figure 11.4 angle array with values

TE
AM
FL
Y

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

Team-Fly® 



11.3 One-Dimensional Arrays | 507



  value[0]

value[1]

value[2]

	 •
	 •
	 •

value[9]
	 
	 •
	 •
	 •

value[25]

	 •
	 •
	 •

value[999]

value[0]. (The index is a constant.)










value[i], where i = 9. (The index is a variable.)






value[7 * j + 4], where j = 3. The index is a more
                                                                   complex expression.

value

Figure 11.5 An index as a constant, a variable, and an arbitrary expression

then the expression number+1 selects an array component. The specific array compo-
nent accessed is divided by 10 and checked to see if the remainder is nonzero. If
number+1 is 0, we are testing the value in the first component; if number+1 is 1, we are
testing the second place; and so on. Figure 11.5 shows the index expression as a con-
stant, a variable, and a more complex expression.

Out-of-Bounds Array Indexes

Given the declaration

float[] alpha = new float[100];

the valid range of index values is 0 through 99. Starting at 0 seems awkward, because
we are used to numbering things beginning with 1. However, you should not be sur-
prised; the positions in a string begin with 0. What happens if we try to execute the
statement

alpha[i] = 62.4;



508 | Chapter 11:  One-Dimensional Arrays

when i is less than 0 or when i is greater than 99? The result is that a memory location
outside the array would be accessed, which causes an error. This error is called an out-
of-bounds error. Some languages, C++ for instance, do not check for this error, but Java
does. If your program attempts to use an index that is not within the bounds of the
array, an ArrayIndexOutOfBoundsException is thrown. Rather than try to catch this
error, you should write your code to prevent it.

In Java, each array that is instantiated has a public instance variable, called
length, associated with it that contains the number of components in the array.

length can be used when processing the components
in the array to keep from having an out-of-bounds
error. Here’s how. Array-processing algorithms often
use for loops to step through the array elements one at
a time. Here is a loop to zero out our 100-element
alpha array:

for (int i = 0; i < alpha.length; i++)
alpha[i] = 0.0;

Use this pattern—initialize your counter to zero, use a less-than test against the size
of the array object—and you can ensure that your counter is within the bounds of the
array. If your program does crash with an ArrayIndexOutOfBoundsException,
immediately check to be sure your relational operator is the less than operator, not the
less than or equal operator.

Aggregate Array Operations

We can assign one array to another and we can compare two arrays for equality—but
we might not get the answer we expect. Arrays, like classes, are reference types. This
means that the value stored in the location assigned to the object name is not the object
itself but the address of where the object is stored. Let’s see what happens when we test
two arrays for equality and assign one array to another.

int[] numbers = {2, 4, 6};
int[] values;
values[0] = 2;
values[1] = 4;
values[2] = 6;

if (numbers == values)
...

numbers = values;
if (numbers == values)
...

The first if expression is false because numbers and values occupy different places in
memory. (See Figure 11.6a.) The next statement takes the contents of values (the

Out-of-bounds error An error caused by an index
value that is either less than 0 or greater than the
array size minus 1.



11.3 One-Dimensional Arrays | 509

numbers values

values[0]

values[1]

values[2]

numbers[0]

numbers[1]

numbers[2]

4

6

2


4

6

2

Figure 11.6 Comparison of array variables

address of where the array is stored) and stores it into numbers. Now the if expression
is true. numbers contains the address in memory of where the array referenced by
values is stored. (See Figure 11.6b.)

You should not be surprised at this example. Assignment for reference types is a
shallow assignment; an equality test for reference types is a shallow test. If you want to
have a deep test, you must write a method to do the comparison, element by element:

int[] numbers = {2, 4, 6, 9};
int[] sameNumbers = new int[numbers.length];
// Deep copy of numbers to someNumbers
for (int index = 0; index < numbers.length; index++)
sameNumbers[index] = numbers[index];

a. Result is false; these are two different arrays.

numbers values

values[0]

values[1]

values[2]

numbers[0]

numbers[1]

numbers[2]

4

6

2

4

6

2

b. Result is true after a shallow copy.



510 | Chapter 11:  One-Dimensional Arrays

boolean compareArrays(int[] one, int[] two)
{
if (one.length != two.length)
return false;

// Compare array objects component by component
boolean result = true;
int index = 0;
while (index < one.length && result)
{
if (one[index] == two[index])
index++;

else
result = false;

}
return result;

}

Now examine these comparisons:

if (numbers == sameNumbers)
...

if (compareArrays(numbers, sameNumbers))
...

The first expression is false. The array objects sameNumbers and numbers contain the
same values, but the equality test is for addresses not values. The second expression is
true because compareArrays is a method that performs a deep comparison.

11.4 Examples of Declaring and Processing Arrays
We now look in detail at some specific examples of declaring and accessing arrays.
These examples demonstrate different applications of arrays in programs.

Occupancy Rates

Here are some declarations that a program might use to analyze occupancy rates in an
apartment building:

final int BUILDING_SIZE = 350; // Number of apartments

int[] occupants = new int[BUILDING_SIZE];
// occupants[i] is the number of occupants in apartment i
int totalOccupants;            // Total number of occupants



11.4 Examples of Declaring and Processing Arrays | 511

occupants

occupants[0]


occupants[1]


occupants[2]

•
•
•


occupants[349]






Figure 11.7 occupants array

occupants is a 350-element array of integers (see Figure 11.7): occupants[0] = 3 if
the first apartment has three occupants; occupants[1] = 5 if the second apartment
has five occupants; and so on. If values have been stored into the array object, then the
following code totals the number of occupants in the building.

totalOccupants = 0;
for (int counter = 0; counter < occupants.length; counter++)
totalOccupants = totalOccupants + occupants[counter];

The first time through the loop, counter is 0. We add the contents of totalOccupants
(that is, 0) and the contents of occupants[0], storing the result into totalOccupants.
Next, counter becomes 1 and the loop test occurs. The second loop iteration adds the
contents of totalOccupants and the contents of occupants[1], storing the result
into totalOccupants. Now counter becomes 2 and the loop test is made. Eventually,
the loop adds the contents of occupants[349] and the sum and increments counter
to 350. At this point, the loop condition is false, and control exits the loop.

Note how we used the named constant BUILDING_SIZE in the array declaration
and occupants.length in the for loop. When a constant is used in this manner,
changes are easy to make. If the number of apartments changes from 350 to 400, we
just need to change the declaration of BUILDING_SIZE. We could also have written

for (int counter = 0; counter < BUILDING_SIZE; counter++)

but we prefer to use the length field because it is specifically associated with the array.
In the future, the program might be changed to use a different constant to set the size of
occupants. Then BUILDING_SIZE would no longer be the correct value to terminate
the loop, but occupants.length is still correct.



512 | Chapter 11:  One-Dimensional Arrays

Sales Figures

Now let’s look at an example where the values stored in the array are sales figures and
the indexes are the product numbers. (The products are gourmet hamburgers.) The prod-
uct numbers range from 1 through 5. We can make the array object contain six compo-
nents and just ignore the 0th position, or we can set up five components and make sure
that we add (or subtract) 1 from the product number to get the proper slot. Let’s use the
latter strategy.

// Declare and instantiate an array with 5 real components.
double[] gourmetBurgers = new double[5];

The data for this example are (hamburger number, day’s sales) pairs. The data file con-
tains a week’s worth of such pairs. The first value is an integer between 1 and 5 that
represents one of the gourmet hamburgers. The next value is the sales amount for that
hamburger for the day. Each value is on a line by itself. The following code segment
reads in a hamburger number, sales figure pair.

inFile = new BufferedReader(new FileReader("infile.dat"));
outFile = new PrintWriter(new FileWriter("outfile.dat"));
int burgerNumber;
double salesAmount;
...

burgerNumber = Integer.valueOf(inFile.readLine()).intValue();
salesAmount = Double.valueOf(inFile.readLine()).doubleValue();

To add the sales amount to the value in the appropriate slot in the array, we use burg-
erNumber–1 as the index into the array gourmetBurgers.

gourmetBurgers[burgerNumber – 1] =
salesAmount + gourmetBurgers[burgerNumber – 1];

If we put our input and processing within a loop, we can process the week’s worth of
sales figures. We can then write the totals out to a file with the following loop.

for (burgerNumber = 0; burgerNumber < gourmetBurgers.length; burgerNumber++)
{
outFile.print("Gourmet Burger # " + (burgerNumber + 1));
outFile.println(": " + gourmetBurgers[burgerNumber]);

}

Figure 11.8 shows the contents of array object gourmetBurgers after the data shown
has been processed. Note that the data is shown all on one line with commas between
pairs to save space.



11.4 Examples of Declaring and Processing Arrays | 513

gourmetBurgers

gourmetBurgers[0]

gourmetBurgers[1]

gourmetBurgers[2]

gourmetBurgers[3]

gourmetBurgers[4]

Data 1 50.25, 2 44.75, 4 100.33, 3 85.12, 5 20.76
3 75.20, 1 50.20, 4 95.12, 5 77.44, 2 44.75
5 12.23, 4 125.12, 3 55.23 2 70.12, 1 44.75
1 55.66, 2 66.67, 3 77.78, 4 200.12, 5 44.75
2 44.75, 3 56.80, 4 120.00, 5 11.12, 1 45.55

246.41

271.04

350.13

640.69

177.42

Figure 11.8 gourmetBurgers array

This example, where the index into the array is one less than the number assigned
to a type of hamburger, is a type of problem where the index has semantic content. That
is, the index has meaning within the problem itself.

Letter Counts

As a final example in this section, let’s use an array to count the number of times each
letter in the English alphabet is used in text, either uppercase or lowercase. We declare an
array of 26 integers, one for each letter.

int[] letterCount = new int[26];

letterCount[0] is the counter for the number of times we see an 'a', letter-
Count[1] is the counter for the number of times we see a 'b', and letterCount[25]
is the number of times we see a 'z'. How do we convert a letter to its position in the
array? Well, we read a character and see if it is a letter. If so, we convert it to uppercase.
The uppercase letter minus 'A' gives us the letter’s place in the array. The following
code fragment accomplishes this conversion:

letter = dataFile.read();
if (((char)letter >= 'A' && (char)letter <= 'Z' || 

((char)letter >= 'a' && (char)letter <= 'z'))

The following statements convert the letter to an index and increment the counter for
the character.



514 | Chapter 11:  One-Dimensional Arrays

index = (int)Character.toUpperCase((char)letter) - (int) 'A';
letterCount[index] = letterCount[index] +1;

The following loop ties these pieces together.

letter = dataFile.read();     // Priming read
while (letter != –1)
{
if (((char)letter >= 'A' && (char)letter <= 'Z') ||

((char)letter >= 'a' && (char)letter <= 'z'))
{
// Convert letter to an index
index = (int)Character.toUpperCase((char)letter) – (int) 'A';
// Increment counter
letterCount[index] = letterCount[index] + 1;

}
letter = dataFile.read();    // Get a character

}

Now all we need is a loop that prints out the values:

for (index = 0; index < letterCount.length; index++)
outFile.println("The number of all " + (char) (index + (int)'A') 
+ letterCount[index]);

11.5 Arrays of Objects
Although arrays with atomic components are very common, many applications require
a collection of composite objects. For example, a business needs a list of parts records,
and a teacher needs a list of students in a class. Arrays are ideal for these applications.
We simply define an array whose components are class objects.

Arrays of Strings

Let’s define an array of strings, each of which is a grocery item. Declaring and creating
the array of objects is exactly like declaring and creating an array where the compo-
nents are atomic types.

String[] groceryItems = new String[10];  // Array of strings

groceryItems is an array of 10 strings. How many characters are there in each string?
We don’t know yet. The array of strings has been instantiated, but the string objects
themselves have not. Another way of saying this is that groceryItems is an array of
references to string objects, which are set to null when the array is instantiated. The
string objects must be instantiated separately. The following code segment reads and
stores 10 strings into groceryItems.



11.5 Arrays of Objects | 515

groceryItems

groceryItems[0]

groceryItems[1]

groceryItems[2]

groceryItems[3]
•
•
•

groceryItems[9]

"cat food"

"rice"

"chicken"

"bib lettuce"
•
•
•

"butter"

Figure 11.9 groceryItems array

inFile = new BufferedReader(new FileReader("infile.dat"));
outFile = new PrintWriter(new FileWriter("outfile.dat"));
...
int index;    // index into groceryItems
String[] groceryItems = new String[10];

// Read and store strings from file inFile
for (index = 0; index < groceryItems.length; index++)
{
groceryItems[index] = inFile.readLine();

}

The readLine method is a value returning method, which instantiates the string, stores
values into it, and returns it. That is, the reference to the string is returned and stored
into groceryItems. Figure 11.9 shows what the array looks like with values in it.

An array name with no brackets is the array object. An array name with brackets is a
component. The component can be manipulated just like any other variable of that type.

Expression Class/Type

groceryItems An array
groceryItems[0] A string
groceryItems[0].charAt(0) A character



516 | Chapter 11:  One-Dimensional Arrays

groceryItems

groceryItems[0]

groceryItems[1]

groceryItems[2]

groceryItems[3]
•
•
•

groceryItems[index –1]

"cat food"

"rice"

"chicken"

"bib lettuce"
•
•
•
"carrots"

groceryItems[9]

•
•
•

Figure 11.10 Partially filled array

How would you read in grocery items if you didn’t know how many you had? You
know that there are no more than 10, but you don’t know exactly how many. You
would have to use a while loop that reads in a grocery item and stores it in the first
place. If there were another item, it would be stored in the second place, and so on. This
means that you must keep a counter of how many items you read in. Here is a code
fragment that would read and store grocery items until 10 had been read or the file is
empty.

// Read and store strings from file inFile.
int index = 0;
String anItem = inFile.readLine();
while (index < groceryItems.length  && anItem != null)
{
groceryItems[index] =  anItem;
index++;
anItem = inFile.readLine();

}
System.out.println(index + " grocery items were read and stored.");

Look carefully at Figures 11.9 and 11.10. In Figure 11.9, every slot in the array is filled
with grocery items. In Figure 11.10, index items have been read in and stored. If index
is equal to 10, then the two figures are the same. To process the items in Figure 11.10,
you use a loop that goes from 0 through index–1.TE

AM
FL
Y

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

Team-Fly® 



11.5 Arrays of Objects | 517

You first saw a reference to an array of strings in Chapter 1. In class Payroll the
following statement appears:

public static void main(String[] args) throws IOException

The parameter for method main is an array of strings, called args by convention. There
are ways of running Java programs that allow you to pass string arguments to method
main. We do not use this feature in our programs, but we still have to list the parameter
on the heading.

Throughout this chapter we have drawn array variables with an arrow to the object
structure to which they refer. An array type is a reference type. When we declare an
array variable with the name groceryItems, one location in memory is assigned to that
name. When the array is instantiated, the
address of the place in memory where the
actual structure begins is stored into location
groceryItems. This address is called the
base address of the array.

If the component type is an atomic type, the values are actually stored in the memory
locations beginning at the base address. If the component type is a reference type, a refer-
ence to the first component is stored in the base address. We have used the arrow in our
drawings as a visual reminder that the contents of a reference variable is the address of
where the object can be found.

Clearly, strings and arrays are related. You can visualize a string as an array of char-
acters. You can visualize an array as a string of values. Because of this similarity, the
String class has methods that transform a string into an array of char and an array of
char (char[]) into a string. Method toCharArray in class String converts a string
value into a char[]. Method valueOf takes a char[] and converts it into a string.

Arrays of User-Defined Objects

In the last example, the components of the array were strings. Now let’s look at an array
of user-defined objects. In Chapter 7, we used the Date class as an example. The follow-
ing code declares and instantiates an array of elements of class Date.

Date[] bigEvents = new Date[10];

and the following shows the types involved and how to access the various components.

Base address The memory address of the first element
of an array

Expression Class/Type

bigEvents An array
bigEvents[0] A Date object
bigEvents[0].month A string
bigEvents[0].day An integer
bigEvents[0].year An integer
bigEvents[0].month.charAt(1) A character



518 | Chapter 11:  One-Dimensional Arrays

11.6 Arrays and Methods
The only observer method provided for arrays is component access, which has its own
special syntax: the array object’s name, followed by an index enclosed in brackets. The
index specifies which of the components to access.

However, when we use an array as a field in a class, we may need to pass an array
object as a parameter to a method or pass a component of an array object to a method.
Recall from Chapter 7 that all parameters in Java are passed by value. That is, a copy of
each parameter is sent to the method. Because an array, like a class, is a reference type,
what is passed to the method is the address of where the object is stored.

Suppose we define a public class method (say, in class Accounting) that takes an
array as an argument and returns the sum of the components in the array:

public static double sumSales(double[] data)
{
double sum = 0.0;
for (int index = 0; index < data.length; index++)
sum = sum + data[index];

return sum;
}

The following statement uses method sumSales to sum the week’s gourmet ham-
burger sales.

outFile.print("This week's sales of gourmet hamburgers: ");
outFile.println(Accounting.sumSales(gourmetBurgers));

What is passed as a parameter to sumSales? It is the base address of gourmetBurgers
(the arrow in Figure 11.8).

There are two cases to consider when passing array components as arguments to a
method: the component is a primitive type, or the component is a reference type. If the
component is a primitive type, the method cannot change the value of its parameter. If
the component is a reference type, the method can change the value of its parameter but
it should not. Changing the value of a parameter is poor style.

11.7 Special Kinds of Array Processing
Two types of problems occur frequently that use arrays as part of the internal data
structure for a class. One problem uses only part of the defined array in which to store
data and the other problem is one in which the index values have specific meaning
within the problem.



Problem-Solving Case Study | 519

Partial (or Sub) Array Processing

The size of an array is the declared number of array components—the number of slots
set aside for the array object in memory. Java has an instance field length associated
with each array object that contains this value. In many problems, however, we do not
know how many data values we actually have, so we declare the array to be as big as it
would ever need to be. This means that we may not fill all of the array components
with values. In order to avoid processing slots into which we have not stored valid
data, we must keep track of how many components are actually filled.

As values are put into the array, we keep a count of how many components are
filled. We then use this count to process only components that have values stored in
them. Any remaining places are not processed. For example, if there are 250 students in
a class, a program to analyze test grades would set aside 250 locations for the grades.
However, some students may be absent on the day of the test. So the number of test
grades must be counted, and that number, rather than 250, is used to control the pro-
cessing of the array. This number becomes part of the internal representation of the
class being defined. Figure 11.10 visualizes this type of processing.

Chapter 12 examines subarray processing in detail.

Indexes with Semantic Content

In some problems, an array index has meaning beyond simple position; that is, the
index has semantic content. An example is the gourmetBurgers array we showed ear-
lier. This array was indexed by the number of the type of hamburger minus 1. That is,
the sales for the hamburger that the company called #1 occupied the 0th position in the
array; hamburger #2 occupied the 1st position in the array; etc.

Problem-Solving Case Study
Comparison of Two Lists

Statement of the Problem You are writing an application that does not tolerate erroneous
input data. Therefore, the data values are prepared by entering them twice into one file. The
file contains two lists of positive integer numbers, separated by a negative number. These two
lists of numbers should be identical; if they are not, then a data-entry error has occurred. For
example, if the input file contains the sequence of numbers 17, 14, 8, 25, 17, 14, 8, then the
two lists of three numbers are identical. However, the sequence 17, 14, 8, 25, 17, 12, 8 shows
a data-entry error.

You decide to write a separate application to compare the lists and print out any pairs of
numbers that are not the same. The exact number of integers in each list is unknown, but each
list has no more than 500.

Brainstorming In all previous problems involving files, we just read and/or wrote them, value
by value. Here we have to compare the first value on the file with the first value following a
negative number; the second value with the second value following a negative number; and so
on. The comparison cannot begin until the values have been read in. We need two container
objects: one to hold the first list and one to hold the second list.



520 | Chapter 11:  One-Dimensional Arrays

Filtering Do we really need two container objects? If we were checking the lists by hand, we
would write the numbers from the first list on a pad of paper, one per line. The line number
would correspond to the number’s position in the list; that is, the first number would be on the
first line, the second number on the second line, and so on. The first number in the second list
would then be compared to the number on the first line, the second number to the number on
the second line, and so forth. We wouldn’t write the second sequence on a sheet of paper in
order to compare the values. So we need only one container object.

Scenarios Let’s call our container class FirstList. What are its responsibilities? It must
create itself by defining a constructor. What does the constructor do? It must set the number
of values read so far to zero. Class FirstList is responsible for reading values from the file
and storing them into the list. And finally, it is responsible for determining if the rest of the file
matches the items on the list.

The application class must prepare the files for input and output, send a message to
FirstList to read in values, and send a message to FirstList to compare itself with the
rest of the file.

Who is responsible for letting the user know the results of the comparison? Since
FirstList is responsible for making the comparison, let’s assign the responsibility of inform-
ing the user of the result to FirstList.

Class Name: FirstList Superclass: Subclasses:

Responsibilities Collaborations

Create itself, Constructor

Input first list, Transformer

Compare first list with rest of file, Observer BufferedReader

FileReader, BufferedReader

Object

input file
output file
container for first list
application class

input file
output file
container for first list
container for second list
application class



Problem-Solving Case Study | 521

Data Representation The by-hand algorithm tells us exactly what the container list must
look like: an array, where each component represents a line on the paper. The only difference
is that humans normally count from 1 and Java counts from zero. We also need a place to
record how many values have been read in.

Responsibility Algorithms for FirstList This class is both reading and writing to files.
Which files? Let’s let the driver pass the files as parameters to the constructor. Now we are
ready to design the algorithms for our class methods.

public  FirstList(in, out)

public readFirstList()

Get first value from dataFile
while value greater than 0

Set firstList[numItems] = value
Increment numItems
Get next value from dataFile

Set numItems to 0
Set dataFile to in
Set dataFile to out

Class Name: DataValidation Superclass: Subclasses:

Responsibilities Collaborations

Prepare the file for input FileReader, BufferedReader

Prepare the file for output FileWriter, PrintWriter

Tell FirstList to input first list FirstList

Tell FirstList to compare first list with rest of file FirstList

Close the files PrintWriter, BufferedReader

Object



522 | Chapter 11:  One-Dimensional Arrays

public compareListWithFile()

Values are not the same Level 2

Print both values Level 2

Responsibility Algorithm for DataValidation

public static void main(String[] args)

Prepare dataFile for reading
Prepare outFile for output
Declare and instantiate checker of type FirstList(dataFile25
, outFile)
checker.readFirstList()
checker.compareListWithFile()

Print “Values at  position “ + (counter + 1) + “: “ + firstList[counter]
+ “ != “ + value

value != firstList[counter]

Set valuesTheSame to true
for counter going from 0 through numItems–1

Get next value from dataFile
if values are not the same

Set valuesTheSame to false
Print both values

if valuestheSame
Print “The two lists are identical.”



Problem-Solving Case Study | 523

package validation;
import java.io.*;
public class FirstList
{
// Constructor
public FirstList(BufferedReader in, PrintWriter out)
{
numItems = 0;
firstList = new int[500]; // Default value for number of items
dataFile = in;
outFile = out;

}
// Transformer
public void readFirstList() throws IOException
// Reads in firstList[0]..firstList[numItems–1] 
{
int value;
value = Integer.valueOf(dataFile.readLine()).intValue();
while (value > 0)
{
firstList[numItems] = value;
numItems++;
value = Integer.valueOf(dataFile.readLine()).intValue();

}
}
// Observer
public  void compareListWithFile() throws IOException
// Compares the two lists and prints the results 
//  on outFile
{
int value;
boolean valuesTheSame = true;
for (int counter = 0; counter < numItems; counter++)
{
value = Integer.valueOf(dataFile.readLine()).intValue();
if (value != firstList[counter])
{
outFile.println("Values at position " + (counter + 1) + ": "
+ firstList[counter] + " != " + value);

valuesTheSame = false;
}

}



524 | Chapter 11:  One-Dimensional Arrays

if (valuesTheSame)
outFile.println("The two lists are identical");

}
// Instance variables
private int[] firstList;
private int numItems;
private BufferedReader dataFile;
private PrintWriter outFile;

}
import validation.*;
import java.io.*;                             // File types
public class DataValidation
// Application DataValidation compares two positive integer data sets on
//  file dataFile, separated by a  negative number.
//  If the data sets are not identical, the pairs that do not match
//  are printed.
{
private static PrintWriter outFile;         // Output data file
private static BufferedReader dataFile;     // Input data file

public static void main(String[] args) throws IOException
{
dataFile = new BufferedReader(

new FileReader("datafile.dat"));    // Prepare input file
outFile = new PrintWriter(

new FileWriter("outfile.dat"));     // Prepare output file

// Declare an object of type FirstList
FirstList checker = new FirstList(dataFile, outFile);

checker.readFirstList();
checker.compareListWithFile();
dataFile.close();
outFile.close();

}
}

Testing The program is run with two sets of data, one in which the two lists are identical and
one in which there are errors. The data and the results from each are shown on the next page.



Problem-Solving Case Study | 525

Data Set 1 Data Set 2
21 21
32 32
76 76
22 22
21 21
–4 –4
21 21
32 32
76 176
22 12
21 21

Output Output
The two lists are identical. Position 2:   76 != 176

Problem-Solving Case Study
Grading True/False Tests

Statement of the Problem Your History teacher gives True/False exams. Knowing that you
are studying Computer Science, she asks you to write a program that grades True/False
questions. The key to the exam is on the first line of data, followed by a line with the student’s
name and a line with the student’s answers. She gives you the following example of the file to
use as a guideline.

TFTFTFTFTTTFFFT
Joe Jones
TFTFTFTFTTTFFTT
Janet Jerome
TFTFTFTFTTTFFFF
Jeff Jubilee
TFTFTFTFTTTFFFT
...

As output, she wants the student’s name followed by the number answered correctly written
on a file, one student per line.

Brainstorming How would you grade these exams by hand? If the student’s answers were
written as a sequence of Ts and Fs, you would probably take a sheet of paper, write down the Ts
and Fs from the key, fold the paper so that the Ts and Fs were on the top, and line up the paper
under a student’s answer. You could then compare them one at a time marking through the
student’s answer that did not agree with the key. So, what are the objects in the problem?



526 | Chapter 11:  One-Dimensional Arrays

We are working with an exam key and a student’s answer, where the student’s answer has
two parts: the name and a series of Ts and Fs. We need a container to hold the key, and a con-
tainer to hold a student’s answer. We also need file objects.

Filtering Let’s look at the key object first. An exam is made up of questions, the answers to
which are either T or F. Therefore, the key is an ordered collection of Ts and Fs that represents
the correct answers to the questions. Let’s call this class TheKey. The student answer contains
the student’s name and a sequence of Ts and Fs. Yes, this set of objects looks complete. Oh, we
forgot the class that contains main, the application class.

Scenarios What are the responsibilities of TheKey class? That is, what operations must the
class perform on the Ts and Fs? The class must create itself, initialize the Ts and Fs to the
correct pattern, and grade a student’s answer.

The second object is a student’s answer. This object contains a student’s name and an
ordered collection of Ts and Fs representing the student’s answers to the exam questions. Let’s
call this class AStudentAnswer. What are the responsibilities of this class? It must create
itself, input a name and a sequence of Ts and Fs, pass the Ts and Fs to the key to be graded,
and print out the student name and the number of correct answers.

At this stage you should step back and see if there is anything missing from the design.
You notice that the sample data your teacher gives you has 15 questions. The test you took
last week had 20 questions. This means that the number of questions varies, so the number of
questions on the exam must be input to the constructor for class TheKey to determine the
number of Ts and Fs. Class AStudentAnswer also needs to know the number of questions.

input file
output file
container for the key
container for the student answer
application class

input file
output file
container for the key
container for the student answer

TE
AM
FL
Y

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

Team-Fly® 



Problem-Solving Case Study | 527

CRC Cards

Data Representation The key and the answer are an ordered collection of Ts and Fs. The
array is the obvious choice for holding the Ts and Fs. The index of an individual answer is the
question number minus 1. Now we are ready to design the algorithms for the three classes.

Class Name: GradeExams Superclass: Object Subclasses:

Responsibilities Collaborations

 

Declare and instantiate variables  

Tell TheKey to get the key TheKey

Process a student answer AStudentAnswer

Prepare the file for input FileReader, BufferedReader

Prepare the file for output FileWriter, PrintWriter

Class Name: AStudentAnswer Superclass: Object Subclasses:

Responsibilities Collaborations

Create itself (number of items), constructor

Read student's name (infile, outfile), constructor BufferedReader, PrintWriter

Read student's answer (infile) BufferedReader

Write student's name PrintWriter

Write number correct (student's Ts/Fs), observer TheKey, PrintWriter

Class Name: TheKey Superclass: Object Subclasses:

Responsibilities Collaborations

Create itself (number of items), Constructor

Read the key, Transformer BufferedReader
Grade a student's answer (student's Ts/Fs), Observer, V–R BufferedReader

return int (number correct) IOException



528 | Chapter 11:  One-Dimensional Arrays

Responsibility Algorithms for TheKey In our by-hand algorithm, we wrote the key so that we
could hold it next to the student answers and compare them, position by position. The operational
verb in the discussion is “compare.” To grade a student’s answer, the operation must compare its
ordered collections of Ts and Fs with the ordered collection of Ts and Fs representing a student’s
answer.  The return value is the number of places where the values match.

public TheKey(int number) Level 1

public void readKey(BufferedReader inFile)

public int numberCorrect(char[] answer)

Responsibility Algorithms for AStudentAnswer

public AStudentAnswer(int number)

public void readStudentName(BufferedReader inFile)

public void readStudentAnswer(BufferedReader inFile)

for counter going from 0 through answer.length – 1
Get next answer
Set answer[counter] to next answer

Read a student name from inFile

Create answer as an array of number characters

Set noCorrect to 0
for counter going from 0 through key.length – 1

if (key[counter] == answer[counter])
Increment noCorrect

return noCorrect

for counter going from 0 through key.length – 1
Get next answer
Set key[counter] to next answer

Create key as an array of number characters



Problem-Solving Case Study | 529

public void writeStudentName(PrintWriter outFile)

public void writeNumberCorrect( PrintWriter outFile, TheKey key)

As is usually true in an object-oriented design, the work is done in the classes. The final algo-
rithm that pulls the pieces together is in the main method of a driver.

public static void main(String[] args)

“Declare...”. We have forgotten something. How do we know how many questions there are on
this exam? The user could enter it from the keyboard as an event or the user could enter the
number of questions on the file on the line immediately before the key. Because this program
does not need the user to be present to enter any other data, putting the number of questions
on the data file is the better choice.

How should the loop be implemented? In the past the looping structure has been within the
method that does the reading. Here the reading is done within a method invoked within the loop.
When reading the student name, readStudentName can determine that there is no more data,
but the algorithm did not do so. What is more, how does that information get back into main to
control the loop? We need to add one more observer, moreData, to class AStudentAnswer,
which checks to see if there was another student’s name on the file.

public boolean moreData()

return name != null

Import TheKey class
Import AStudentAnswer class
Declare key of class TheKey
Declare studentExam of class AStudentAnswer
Prepare file inFile for input
Prepare file outFile for output
key.readKey(inFile)
while more students

studentExam.readStudentName(inFile)
studentExam.readStudentAnswer(inFile)
studentExam.writeStudentName(outFile)
studentExam.writeNumberCorrect(outFile, key)

Close files

Set score to key.numberCorrect(answer)
Print “ number correct  ” + score

Write name 



530 | Chapter 11:  One-Dimensional Arrays

public static void main(String[] args) Revised

Now we are ready to code our solution. Let’s implement the classes first and put them into a
package called grader.

package grader;                     // Package declaration
import java.io.*;                   // Access files
public class TheKey
{ // Private data fields
private char[] key;

// Methods
public TheKey(int number)
{ // Constructor
key = new char[number];         // Instantiate array object

}

public void readKey(BufferedReader inFile) throws IOException
{ // Transformer:  Input Ts and Fs
int datum;
for (int counter = 0; counter < key.length; counter++)
{
datum = inFile.read();
key[counter] = (char) datum;

}
inFile.readLine();              // Read past end of line

}

public int numberCorrect(char[] answer) throws IOException
{ // Observer: Returns the number of correct answers

Import TheKey class
Import AStudentAnswer class
Prepare file for input
Prepare file for output
Get noQuestions
Declare key(noQuestions) of class TheKey
Declare studentExam(noQuestions) of class AStudentAnswer
key.readKey(inFile)
studentExam.readStudentName(inFile)

while studentExam.moreData()
studentExam.readStudentAnswer(inFile)
studentExam.writeStudentName(outFile)
studentExam.writeNumberCorrect(outFile, key)
studentExam.readStudentName(inFile)

Close files



Problem-Solving Case Study | 531

int noCorrect = 0;
for (int counter = 0; counter < key.length; counter++)
if (key[counter] == answer[counter])
noCorrect++;

return noCorrect;
}

} // End of class TheKey

package grader;                     // Package declaration
import java.io.*;                   // Import files

public class AStudentAnswer
{ // Private data fields
private char[] answer;
private String name;
// Methods
public AStudentAnswer(int number)
{ // Constructor
answer = new char[number];

}

public void readStudentName(BufferedReader inFile)
throws IOException

{ // Transformer: Read in a student's name
name = inFile.readLine();

}

public void writeStudentName(PrintWriter outFile)
{
// Observer: Output a name
outFile.print(name);

}
public void readStudentAnswer(BufferedReader inFile)
throws IOException

{ // Transformer: Read in a student's answers
int datum;
for (int counter = 0; counter < answer.length; counter++)
{
datum = inFile.read();
answer[counter] = (char)datum;

}
inFile.readLine();              // Read past end of line

}

public boolean moreData()
{ // Observer: Returns true if there is more data
return (name != null);

}



532 | Chapter 11:  One-Dimensional Arrays

public void writeNumberCorrect(PrintWriter outFile, TheKey key)
throws IOException

{ // Observer: Write out the student name and score
int score;
score = key.numberCorrect(answer);
outFile.println(" number correct " + score);
}

} // End of class AStudentAnswer

// Driver for classes in package grader
import grader.*;
import java.io.*;
public class GradeExams
// Student true/false exams are graded
{
// Variable declarations
private static PrintWriter outFile;
private static BufferedReader inFile;
private static TheKey key;
private static AStudentAnswer studentExam;

public static void main(String[] args) throws IOException
{
int noQuestions;                // Number of questions
// Prepare files for input and output
inFile = new BufferedReader(

new FileReader("datafile.dat"));
outFile = new PrintWriter(

new FileWriter("outfile.dat"));

// Set up key and student answer arrays
noQuestions = Integer.valueOf(inFile.readLine()).intValue();
key = new TheKey(noQuestions);
studentExam = new AStudentAnswer(noQuestions);
key.readKey(inFile);
// Priming read
studentExam.readStudentName(inFile);
while (studentExam.moreData())
{ // Process exams until end of file
studentExam.readStudentAnswer(inFile);
studentExam.writeStudentName(outFile);
studentExam.writeNumberCorrect(outFile, key);
studentExam.readStudentName(inFile);
}
inFile.close();
outFile.close();

}  // End main
} // End of class GradeExams



Problem-Solving Case Study | 533

Testing This program has two classes and a driver. We have been using the word driver to
refer to a simple program class that is used to test a method. Here we are using it in its other
context: the main class in an object-oriented design. The driver in this Case Study is class
GradeExams, the class that contains the main method. Actually, these two definitions are
not dissimilar. In both cases, the driver starts the process. In a regular application, the driver
implements the top-level algorithm, which might start any process. In a test driver, the process
is always the same because its role is strictly to test one or more methods.

Does this mean that we need to design a test driver for this application and import class
GradeExams? No, quite the contrary. We can let class GradeExams test itself by carefully
choosing data sets. That is, we can use a black-box testing strategy.

What are the inputs to the program? There are three: an integer that specifies the number
of questions, a sequence of Ts and Fs that represent the key and a student’s answers, and a
string that represents a student’s name. For the moment, let’s assume that the data is correct
on the file, and concentrate on the main processing: the comparison of the key and a student
exam. The following cases come immediately to mind.

1. The key and the student response match completely (all are correct).
2. The key and the student response do not match at all (all are wrong).
3. The key and the student response partially match (some are correct).

Depending on the number of questions, there could be thousands of cases in the third cate-
gory. How many do we have to try to convince ourselves that the program is correct? The end
cases here would be that they agree in the first and last positions, they do not agree in the
first and last position, they agree somewhere in the middle, and they disagree somewhere in
the middle.

As the algorithm is not dependent on the number of questions, let’s use 5 for our test cases.

Test # Reason for Test Input Expected Output

5
TTTTT

1 All correct Jones Jones
(Also tests same in TTTTT number correct 5
first and last position)

2 All wrong Janes Janes
(Also tests different FFFFF number correct 0
in first and last 
position)

3 Partially correct Julian Julian
TFTFT number correct 3

4 Test ending condition EOF on data file Program ends



534 | Chapter 11:  One-Dimensional Arrays

Provided our input is correct, if the implemented test plan produces the results expected, we
should be fairly confident that the program is correct. Provided our input is correct? We have
built in no error checking into these classes. This is a serious flaw in our design. The Case Study
Follow-Up Exercises ask you to make these classes more robust by adding error checking.

Testing and Debugging

The most common error in processing arrays is an out-of-bounds array index. That is,
the program attempts to access a component using an index that is either less than 0 or
greater than the array size minus 1. For example, given the declarations

char[] line = new char[100];
int  counter;

the following for statement would print the 100 elements of the line array and then try
to print a 101st value.

for (counter = 0; counter <= line.length; counter++)
outfile.print(line[counter]);

This error is easy to detect, because your program will halt with an ArrayIndexOutOf-
BoundsException. The loop test should be counter < line.length. But you won’t
always use a simple for statement when accessing arrays. Suppose we read data into the
line array in another part of the program. Let’s use a while statement that reads to the
newline character:

counter = 0;
infile.read(ch);
while ((char) ch != '\n')
{
line[counter] = (char) ch;
counter++;
infile.read(ch);

}

This code seems reasonable enough, but what if the input line has more than 100 char-
acters? After the hundredth character is read and stored into the array, the loop exe-
cutes one more time and the ArrayIndexOutOfBoundsException is thrown, causing
the program to crash.

The moral is: When processing arrays, give special attention to the design of loop
termination conditions. Always ask yourself if the loop could possibly keep running
after the last array component has been processed.



Testing and Debugging | 535

Whenever an array index goes out of bounds, the first suspicion should be a loop
that fails to terminate properly. The second thing to check is any array access involving
an index that is based on an input value or a calculation. When an array index is input
as data, a data validation check is an absolute necessity.

As we have demonstrated in many examples in the last several chapters, it is possi-
ble to combine data structures in various ways: classes whose components are objects,
classes whose components are arrays, arrays whose components are objects, arrays
whose components are strings, and so forth. When arrays of objects are used, there can
be confusion about precisely where to place the operators for array element selection
([]) and class field selection (.).

To summarize the correct placement of these operators, let’s use a StudentRec
class, where the data fields are defined as:

private static class StudentRec
{
private static String   stuName;       // Student's name
private static float    gpa;           // Student's grade point average
private static int[]    examScores;    // There are four exams
private static char     courseGrade;   // A, B, C, D,  or F
...

};

If we declare a variable of class StudentRec and an array of class StudentRec compo-
nents

StudentRec student;
StudentRec[] members = new StudentRec[100];

the following chart shows how to access the fields of student. Recall that the dot oper-
ator is a binary (two-operand) operator; its left operand denotes a class variable or class
name, and its right operand is a field. The [] operator is a unary (one-operand) opera-
tor; it comes immediately after an expression denoting an array:

Expression Class/Type Meaning

student A StudentRec object A single student
student.stuName A string A name
student.gpa A real number A gpa
student.examScores An array of integers
student.examScores[0] An integer The first exam score
student.examScores[4] Crash!! Index out of range
student.courseGrade A character
members[0].student A StudentRec object The first student
members[0].stuName A string The name of the first student
members[0].gpa A real number The gpa of the first student
members[0].examScores An array of integers The exam scores for the first student
members[0].examScores[1] An integer The second score for the first student



536 | Chapter 11:  One-Dimensional Arrays

Testing and Debugging Hints

1. When an individual component of a one-dimensional array is accessed, the index
must be within the range 0 through the array size minus 1. Attempting to use an
index value outside this range causes your program to crash.

2. The individual components of an array are themselves variables of the component
type. When values are stored into an array, they should either be of the component
type or be explicitly converted to the component type; otherwise, implicit type con-
version occurs.

3. As with all Java’s composite data types, declaring an array variable and instantiat-
ing the variable are separate steps. The size of a one-dimensional array is omitted in
its declaration but must be specified when the array object is being instantiated.

4. When an array is a parameter, the reference to the array object is passed to the
method. The reference cannot be changed by the method, but the elements in the
array can be changed.

5. An individual array component can be passed as an argument. If the component is
a reference type, it can be changed within the method if it is a mutable object. If the
component is an atomic type, it cannot be changed within the method.

6. Although reference types passed as a parameter can be changed if the type is muta-
ble, it is bad style to do so.

7. Subarray processing is used to process array components when the actual number
of data items is not known until the program is executing. The length field of the
array object contains the number of slots in the array; the number of data values
stored into the array may differ.

8. When methods perform subarray processing on a one-dimensional array, the array
name and the number of data items actually stored in the array should be encapsu-
lated together into a class.

9. When a one-dimensional array is instantiated, the constructor for the component
class is called.

10. A one-dimensional array is an object, so a reference to it may be set to null.
11. When processing the components in a one-dimensional array, use a loop that

begins at zero and stops when the counter is equal to the length field associated
with the array object.

Summary of Classes

We have not introduced any new classes in the Java library in this chapter, nor have we
designed any classes that should go into a library to use later.

TE
AM
FL
Y

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

Team-Fly® 



Quick Check | 537

Summary
The one-dimensional array is a homogeneous data structure that gives a name to a
sequential group of like components. Each component is accessed by its relative posi-
tion within the group (rather than by name, as in a class), and each component is a
variable of the component type. To access a particular component, we give the name of
the array and an index that specifies which component of the group we want. The index
can be an expression of any integral type except long, as long as it evaluates to an
integer from 0 through the array size minus 1. Array components can be accessed in
random order directly, or they can be accessed sequentially by stepping through the
index values one at a time.

Quick Check
1. Declare and instantiate a one-dimensional array named quizAnswer that contains

12 components indexed by the integers 0 through 11. The component type is
boolean. (pp. 502–504)

2. Given the declarations

final int SIZE = 30;
char[] firstName = new char[SIZE];

a. Write an assignment statement that stores 'A' into the first component of
array firstName. (pp. 505–506)

b. Write an output statement that prints the value of the 14th component of
array firstName. (pp. 505–506)

c. Write a for statement that fills array firstName with blanks. (p. 511)
3. Declare and instantiate a five-element one-dimensional int array named

oddNums by using an initializer list to contain the first five odd integers, starting
with 1. (pp. 504–505)

4. Give the heading for a void method named someFunc, where someFunc has a
single parameter, a one-dimensional float array, values. (p. 518)

5. Given the declaration

StudentRec[]  gradeBook = new StudentRec[150];
where StudentRec is the class type defined in this chapter, do the following.

a. Write an assignment statement that records the fact that the tenth student
has a grade point average of 3.25. (pp. 515, 535)

b. Write an assignment statement that records the fact that the fourth student
scored 78 on the third exam. (p. 535)

6. Given the declarations in Question 2 and the following program fragment that reads
characters into array firstName until a blank is encountered, write a for statement
that prints out the portion of the array that is filled with input data. (pp. 515–517)



538 | Chapter 11:  One-Dimensional Arrays

n = 0;
letter = (char) infile.read();
while (letter != ' ')
{
firstName[n] = letter;
n++;
letter = (char) infile.read();

}

Answers

1. boolean[] quizAnswer = new boolean[12]; 2. a. firstName[0] = 'A';
b. outFile.println(firstName[13]);
c. for (int index = 0; index < firstName.length; index++)

firstName[index] = ' ';
3. int[] oddNums = {1, 3, 5, 7, 9};
4. public void someFunc(float[] values);
5. a. gradeBook[9].gpa = 3.25;

b. gradeBook[3].examScores[2] = 78;
6. for (int index = 0; index < n; index++)

outFile.print(firstName[index]);

Exam Preparation Exercises
1. (True or False?) Every component in an array must have the same type, and the

number of components is fixed at creation time.
2. (True or False?) The components of an array must be of a primitive type.
3. Declare and instantiate one-dimensional arrays according to the following

descriptions.
a. A 24-element float array
b. A 500-element int array
c. A 50-element double-precision floating-point array
d. A 10-element char array

4. Write a code fragment to do the following tasks:
a. Declare a constant named CLASS_SIZE representing the number of students

in a class.
b. Declare a one-dimensional array quizAvg whose components will contain

floating-point quiz score averages.
c. Instantiate quizAvg of size CLASS_SIZE.

5. Write a code fragment to do the following tasks:
a. Declare a one-dimensional int array birdSightings.
b. Instantiate the array with 20 components.

6. Given the declarations

final int SIZE = 100; 
int[] count = new int[SIZE];



Exam Preparation Exercises | 539

write code fragments to do the following tasks:
a. Set count to all zeros.
b. Read values into the array.
c. Sum the value in the array

7. What is the output of the following code fragment? The data for the program is
given below it.

int[] a = new int[100];
int[] b = new int[100];
int j;
int m;
int sumA = 0;
int sumB = 0;
int sumDiff = 0;
m = Integer.valueOf(inFile.readLine()).intValue();

for (j = 0; j < m; j++)
{
a[j] = Integer.valueOf(inFile.readLine()).intValue();
b[j] = Integer.valueOf(inFile.readLine()).intValue();
sumA = sumA + a[j];
sumB = sumB + b[j];
sumDiff = sumDiff + (a[j] – b[j]);

}
for (j = m – 1; j >= 0; j--)
outFile.println(a[j] + " " + b[j] + " " + (a[j] – b[j]));

outFile.println();
outFile.println(sumA + " " + sumB + " " + sumDiff);
System.exit(0);

Data

5
11
15
19
14
4
2
17
6
1
3



540 | Chapter 11:  One-Dimensional Arrays

8. A person wrote the following code fragment, intending to print 10 20 30 40.

int[] arr = {10, 20, 30, 40};
int index;
for (index = 1; index <= 4; index++)
outFile.println(" " + arr[index]);

Instead, the program halted with a built-in exception. Explain the reason for this
output.

9. Given the declarations

int[] sample = new int[8];
int i;
int k;

show the contents of the array sample after the following code segment is exe-
cuted. Use a question mark to indicate any undefined values in the array.

for (k = 0; k < 8; k++)
sample[k] = 10 – k;

10. Using the same declarations and contents given for Exercise 9, show the con-
tents of the array sample after the following code segment is executed.

for (i = 0; i < 8; i++)
if (i <= 3)
sample[i] = 1;

else
sample[i] = –1;

11. Using the same declarations and contents given for Exercise 9 and the content
stored in Exercise 10, show the contents of the array sample after the following
code segment is executed.

for (k = 0; k < 8; k++)
if (k % 2 == 0)
sample[k] = k;

else
sample[k] = k + 100;

12. What are the two basic differences between a class and an array?
13. If an array is passed as a parameter, can the method change the array?
14. For each of the following descriptions of data, determine which general type of

data structure (array of primitive types, class, array of classes, class containing
classes) is appropriate.
a. A payroll entry with a name, address, and pay rate
b. A person’s address
c. An inventory entry for a part



Programming Warm-Up Exercises | 541

d. A list of addresses
e. A list of hourly temperatures
f. A list of passengers on an airliner, including names, addresses, fare class, and

seat assignment
g. A departmental telephone directory with last name and extension number

15. What happens in Java if you try to access an element that is outside the dimen-
sions of the array?

16. What are the array components initialized to when the array is instantiated
using new?

17. What are the array components initialized to when the array is instantiated
using an initializer list?

Programming Warm-Up Exercises
Use the following declarations in Exercises 1–7. You may declare any other variables that
you need.

final int NUM_STUDENTS = 100;  // Number of students
boolean[] failing = new boolean[NUM_STUDENTS];
boolean[] passing = new boolean[NUM_STUDENTS];
int  grade;
int[] score = new int[NUM_STUDENTS];

1. Write a Java instance method that initializes all components of failing to false.
2. Write a Java instance method that takes score as a parameter. Set the components

of failing to true wherever the corresponding value in score is less than 60.
3. Write a Java instance method that has score as a parameter. Set the components

of passing to true wherever the corresponding value in score is greater than or
equal to 60.

4. Write a Java value-returning instance method passTally that reports how
many components in passing are true.

5. Write a Java value-returning class method error that takes passing and fail-
ing as parameters. error returns true if any corresponding components in
passing and failing are the same.

6. Write a Java value-returning instance method that takes grade as a parameter.
The method reports how many values in score are greater than or equal to grade.

7. Write a Java instance method that takes score as a parameter and reverses the
order of the components in score; that is, score[0] goes into
score[score.length–1], score[1] goes into score[score.length–2],
and so on.

8. Write a program segment to read in a set of part numbers and associated unit
costs. Use an array of classes with two members, number and cost, to represent
each pair of input values. Assume the end-of-file condition terminates the input.



542 | Chapter 11:  One-Dimensional Arrays

Programming Problems
1. The local baseball team is computerizing its records. There are 20 players on the

team, identified by the numbers 1 through 20. Their batting records are coded in
a file as follows. Each line contains four numbers: the player’s identification
number and the number of hits, walks, and outs he or she made in a particular
game. Here is a sample:

3  2  1  1

The example above indicates that during a game, player number 3 was at bat four
times and made 2 hits, 1 walk, and 1 out. For each player there are several lines
in the file. Each player’s batting average is computed by adding the player’s total
number of hits and dividing by the total number of times at bat. A walk does not
count as either a hit or a time at bat when the batting average is being calculated.

Design and implement an application that prints a table showing each
player’s identification number, batting average, and number of walks. (Be care-
ful: The players’ identification numbers are 1 through 20, but Java array indexes
start at 0.)

2. Design, implement, and test a class that calculates the mean and standard devia-
tion of integers stored in a file. The output should be of type float and should
be properly labeled and formatted to two decimal places. The formula for calcu-
lating the mean of a series of integers is to add all the numbers, then divide by
the number of integers. Expressed in mathematical terms, the mean X— of N num-
bers X1, X2, ... XN is

To calculate the standard deviation of a series of integers, subtract the mean
from each integer (you may get a negative number) and square the result, add all
these squared differences, divide by the number of integers minus 1, then take
the square root of the result. Expressed in mathematical terms, the standard
deviation S is

The methods of the class that access the input data should take a file as a para-
meter.

3. One of the local banks is gearing up for a big advertising campaign and
would like to see how long its customers are waiting for service at drive-up
windows. Several employees have been asked to keep accurate records for the

S
X X

N

i
i

N

=
−( )

−
=
∑

2

1
1

X

X

N

i
i

N

= =
∑

1



Programming Problems | 543

12-hour drive-up service. The collected information, which is read from a file,
consists of the time the customer arrived in hours, minutes, and seconds; the
time the customer actually was served; and the ID number of the teller.
Design and implement a class with the following responsibilities:
a. Reads in the wait data.
b. Computes the wait time in seconds.
c. Calculates the mean, standard deviation (defined in Programming Problem 2),

and range.
d. Prints a single-page summary showing the values calculated in part c.

Input
The first data line contains a title.
The remaining lines each contain a teller ID, an arrival time, and a service time.
The times are broken up into integer hours, minutes, and seconds according to a 

24-hour clock.

Processing
Calculate the mean and the standard deviation.
Locate the shortest wait time and the longest wait time for any number of 

records up to 100.

Output
The input data (echo print).
The title.
The following values, all properly labeled: number of records, mean, standard 

deviation, and range (minimum and maximum).

4. Your history professor has so many students in her class that she has trouble
determining how well the class does on exams. She has discovered that you are
a computer whiz and has asked you to write a program to perform some simple
statistical analyses on exam scores. Your program must work for any class size
up to 100. Write and test a computer program that does the following:
a. Reads the test grades from file inData.
b. Calculates the class mean, standard deviation (defined in Programming Prob-

lem 2), and percentage of the test scores falling in the ranges <10, 10–19,
20–29, 30–39, . . . , 80–89, and $90.

c. Prints a summary showing the mean and the standard deviation, as well as a
histogram showing the percentage distribution of test scores.

Input
The first data line contains the number of exams to be analyzed and a title for the

report.
The remaining lines have 10 test scores on each line until the last line, and from 

one to 10 scores on the last. The scores are all integers.



544 | Chapter 11:  One-Dimensional Arrays

Output
The input data as they are read.
A report consisting of the title that was read from the data, the number of scores, 

the mean, the standard deviation (all clearly labeled), and the histogram.

5. Write an application that reads an apartment number and the number of occu-
pants in the apartment. The apartment number is to be used as an index into an
array of apartments. The components in the array represent the number of peo-
ple who live in the apartment. Use the data structure described in the chapter.
Use window input and print the number of people in the building when the user
presses the Quit button.

Case Study Follow-Up Exercises
1. The ValidateData application compares two lists of integers. Exactly what

changes would be necessary for the program to compare two lists of float values?
2. Modify the ValidateData application so that it works even if the lists do not

have the same number of elements. Print an appropriate error message and stop
the comparison if the two lists do not have the same number of elements.

3. The exam grading application contains no error checking.
a. What happens if a letter other than a T or F is entered in the key?
b. What happens if a letter other than a T or F is entered for a student?
c. It is easy to put in a check to be sure that the input values are a T or F, but

what should the program do if an error occurs?
4. Redesign and rewrite the exam grading application to incorporate error checking

based on the answers in Exercise 3.
5. When the authors ran the test plan originally, the names didn’t print and a for-

mat exception occurred. In the original version of the application the following
statement was not included after reading in a series of Ts and Fs:

inFile.readLine();

When this statement was added in two places, the application worked correctly.
Explain.



                

To be able to distinguish between an array and a list.

To be able to insert an item into a list.

To be able to delete an item from a list.

To be able to search for an item in a list.

To be able to sort the items in a list into ascending or
descending order.

To be able to build a list in sorted order.

To be able to search for an item in a sorted list using a
linear search.

To be able to search for an item using a binary search.

To be able to use the Java Comparable interface.

Array-Based Lists
G

oals



546 | Chapter 12:  Array-Based Lists

1At the implementation level, there is also a relationship between the elements, but the physical relationship
may not be the same as the logical one.

Chapter 11 introduced the array, a structured data type that holds a collection of com-
ponents of the same type or class given a single name. In general, a one-dimensional
array is a structure used to hold a list of items. We all know intuitively what a “list” is;
in our everyday lives we use lists all the time—grocery lists, lists of things to do, lists of
addresses, lists of party guests. In computer programs, lists are very useful and common
ways to organize the data. In this chapter, we examine algorithms that build and
manipulate lists implemented using a one-dimensional array to hold the items.

12.1 Lists
From a logical point of view, a list is a homogeneous collection of elements, with a
linear relationship between elements. Linear means that, at the logical level, each ele-

ment in the list except the first one has a unique pred-
ecessor, and each element except the last one has a
unique successor.1 The number of items in the list,
which we call the length of the list, is a property of a
list. That is, every list has a length.

Lists can be unsorted—their elements may be
placed into the list in no particular order—or they can
be sorted in a variety of ways. For instance, a list of
numbers can be sorted by value, a list of strings can
be sorted alphabetically, and a list of addresses could
be sorted by zip code. When the elements in a sorted
list are of composite types, their logical (and often
physical) order is determined by one of the members
of the structure, the key member. For example, a list
of students on a class roll can be sorted alphabetically
by name or numerically by student identification
number. In the first case, the name is the key; in the
second case, the identification number is the key. (See
Figure 12.1.)

If a list cannot contain items with duplicate keys,
it is said to have unique keys. (See Figure 12.2.) This chapter deals with both unsorted
lists and lists of elements with unique keys, sorted from smallest to largest key value. The
items on the list can be of any type, atomic or composite. In the following discussion,
“item,” “element,” and “component” are synonyms; they are what is stored in the list.

Linear relationship Each element except the first has
a unique predecessor, and each element except the last
has a unique successor

Length The number of items in a list; the length can
vary over time

Unsorted list A list in which data items are placed in
no particular order with respect to their content; the
only relationship between data elements is the list
predecessor and successor relationships.

Sorted list A list with predecessor and successor
relationships determined by the content of the keys of
the items in the list; there is a semantic relationship
among the keys of the items in the list.

Key A member of a class whose value is used to
determine the logical and/or physical order of the
items in a list

TE
AM
FL
Y

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

Team-Fly® 



12.1 Lists | 547

001

204

317

801

901

Ziggle

Jones

Applebee

Worton

Gomez 001

204

317

801

901

Ziggle

Jones

Applebee

Worton

Gomez

roll roll

Sorted by ID# Sorted by name

Figure 12.1 List sorted by two different keys

001

201

317

801

901

Applebee

Gomez

Gomez

Ziggle

Ziggle 001

204

317

801

901

Ziggle

Jones

Applebee

Worton

Gomez

roll roll

Duplicate keys Unique keys 

Key Key

Figure 12.2 (a)List with duplicate keys and (b) List with unique keys



548 | Chapter 12:  Array-Based Lists

12.2 List Class
In this section, we design and implement a general-purpose class that represents a list of
items. Let’s think in terms of a to-do list. But before we begin to brainstorm, we must
ask an important question: For whom are we designing the class? We may be designing
it for ourselves to keep in our library of classes. We may be designing it for others to

use in a team project. When we design a class, the
software that uses it is called the client of the class. In
our discussion, we use the terms client and user inter-
changeably, thinking of the client as referring to the
people writing the software that uses the class, rather
than the software itself.

Brainstorming the List Class

Because we are designing a general-purpose class, our brainstorming must be more
speculative. We don’t have a specific problem to solve; we have to think in terms of
what we do with our to-do lists and what other things we might like to do if we could.
Hopefully, we start with an empty list each morning and add things to it. As we accom-
plish a task on the list, we cross it off. We check to see if an item is on the list. We
check to see if there is any way that we can add one more item to the list. We check to
see if the list is empty (we wish!). We go through the list one item at a time. Let’s trans-
late these observations into responsibilities for the list with their responsibility type.

CRC Card

Class Name: List Superclass: Subclasses:

Responsibilities Collaborations

Object

Create itself (maxItems)

Is list full? Observer

    return boolean

Is list empty? Observer

    return boolean

Know length, Observer

    return int

Is an item in the list? Observer

    return boolean

Insert into list (item), Transformer

Delete from list (item), Transformer

Know each item, Iterator					 














None

None



None



None



None



None

None

None 



Client Software that declares and manipulates
objects of a particular class



12.2 List Class | 549

Although we have designed our CRC card for a to-do list, the responsibilities are valid
for any kind of list. For example, if we are creating a list of people to invite to a wedding,
all of these operations are valid. We add names to the list, check whether a name is on the
list, count the names on the list, check to see if the list is full (i.e., the length is equal to the
number of invitations bought), delete names, and review the names one at a time.

To make the rest of the discussion more concrete, let’s assume that the items on the
list are strings. We then show how the items can be made even more general.

Refining the Responsibilities

Let’s go back through the responsibilities, refining them and converting them into
method headings. Because we are designing a general-purpose class, we do not have
any specific scenarios that we can use. Instead, we consider a variety of simplified sce-
narios that are examples of how we believe the class might be employed. Because the
class is intended for widespread use, we should pay special attention to the documenta-
tion right from the design stage.

The observers, testing for full and empty, returning the number of items, and check-
ing to see if an item is in the list, need no further discussion. Here are their method
headings.

public boolean isFull();
// Returns true if no room to add a component; false otherwise

public boolean isEmpty();
// Returns true if no components in the list; false otherwise

public int length();
// Returns the number of components in the list

public boolean isThere(String item);
// Returns true if item is in the list; false otherwise

In designing the transformers, we have to make some decisions. For example, do we
allow duplicates in our list? This has implications for deleting items as well as inserting
items. If we allow duplicates, what do we mean by removing an item? Do we delete just
one or all of them? Because the focus of this chapter is on algorithms, we just make a
decision and design our algorithms to fit. We examine the effect of other choices in the
exercises. Let’s allow only one copy of an item in the list. This decision means that
delete just removes one copy. However, do we assume that the item to be removed is in
the list? Is it an error if it is not? Or does the delete operation mean “delete, if there?”
Let’s use the last meaning.

We now incorporate these decisions into the documentation for the method headings.

public void insert(String item);
// Adds item to the list
// Assumption:  item is not already in the list



550 | Chapter 12:  Array-Based Lists

public void delete(String item);
// item is removed from the list if it is in the list

The iterator allows the user to see each item in the list one at a time. Let’s call the
method that implements the Know each item responsibility getNextItem. The list must
keep track of the next item to return when the iterator is called. The list does this with a
state variable that records the position of the next item to be returned. The constructor ini-
tializes this position to 0, and it is incremented in getNextItem. The client can use the
length of the list to control a loop asking to see each item in turn. As a precaution, the cur-
rent position should be reset after the last item has been accessed. In an application prob-
lem, we might need a transformer iterator that goes through the list applying an operation
to each item; however, for our general discussion we provide only an observer iterator.

What happens if a user inserts or deletes an item in the middle of an iteration?
Nothing good you can be sure! Adding and deleting items changes the length of the list,
making the termination condition of our iteration-counting loop invalid. Depending on
whether an addition or deletion occurs before or after the iteration point, our iteration
loop could end up skipping or repeating items.

We have several choices of how to handle this possibly dangerous situation. The list
can throw an exception, the list can reset the current position when inserting or deleting, or
the list can disallow transformer operations while an iteration is taking place. We choose
the latter here by way of an assumption in the documentation. In case the user wants to
restart an iteration, let’s provide a resetList method that reinitializes the current position.

public void resetList();
// The current position is reset

public String getNextItem();
// Assumption:  No transformers have been called since the iteration began

Before we go to the implementation phase, let’s look at how we might use
getNextItem. Suppose the client program wants to print out the items in the list. The
client program cannot directly access the list items, but it can use getNextItem to iter-
ate through the list. The following code fragment prints the string values in list.

String next;
for (int index = 1; index <= list.length(); index++)
{
next = list.getNextItem();  // Get an item
System.out.println(next + " is still in the list");

}

Now is also the time to look back over the list and see if we need to add any
responsibilities. For example, do we need to provide an equals test? If we want to per-
form a deep comparison of two lists, we must provide equals; however, comparing lists
is not a particularly useful operation, and we provide the client the tools to write a com-
parison operation if necessary. In fact, here is the client code to compare two lists. The



12.2 List Class | 551

algorithm determines if the lengths are the same and, if so, iterates through the lists
checking to see if corresponding items are the same.

We can implement this algorithm without having to know anything about the list. We just use the
instance methods supplied in the interface.

public boolean isDuplicate(List list1, List list2)
// Returns true if the lists are identical
{
if (list1.length() != list2.length())  // Number of items is not the same
return false

else
{
String next1;                        // An item from list1
String next2;                        // An item from list2
int counter = 1;                     // Loop control variable
boolean same = true;                 // True if lists are equal so far
int limit = list1.length();          // Number of items in each list
list1.resetList();                   // Set up for iteration
list2.resetList() ;
while (same && counter <= limit)
{
next1 = list1.getNextItem();       // Get an item from list1
next2 = list2.getNextItem();       // Get an item from list2
same = next1.compareTo(next2) == 0;
counter++;

}

isDuplicate
if lengths are not the same

return false
else

Set counter to 1
Set same to true
Set limit to length of first list
while they are still the same AND counter is less than or equal to limit

Set next1 to next item in the first list
Set next2 to next item in the second list
Set same to result of seeing if next1.compareTo(next2) is 0
Increment counter

return same



552 | Chapter 12:  Array-Based Lists

}
return same;

}

Internal Data Representation

How are we going to represent the items in the list? An array of strings is the obvious
answer. What other data fields do we need? We have to keep track of the number of
items in our list, and we need a state variable that tells us where we are in the list dur-
ing an iteration.

public class List
{
// Data fields
protected String[] listItems;     // Array to hold list items
protected int numItems;           // Number of items in the list
protected int currentPos;         // State variable for iteration
...

}

We introduced the concept of subarray processing in the last chapter and pointed
out that every Java array object has a final field called length that contains the num-
ber of components defined for the array object. The literature for lists uses the identifier
“length” to refer to the number of items that have been put into the list. Faced with this
ambiguity in terminology, we still talk about the length of the list, but we refer to the
field that contains the number of items in the list as numItems.

It is very important to understand the distinction between the array object that contains
the list items and the list itself. The array object is listItems[0]..listItems[list-
Items.length–1]; the items in the list are listItems[0]..listItems[numItems–1].
This distinction is illustrated in Figure 12.3. Six items have been stored into the list, which
is instantiated with the following statement:

List myList = new List(10);

Responsibility Algorithms for Class List

As Figure 12.3 shows, the list exists in the array elements listItems[0] through
listItems[numItems21]. To create an empty list, it is sufficient to set the numItems
field to 0. We do not need to store any special values into the data array to make the list
empty, because only those values in listItems[0] through listItems[numItems21]
are processed by the list algorithms. We explain why currentPos is set to 0 when we
look more closely at the iterator.

public List(int maxItems)
// Instantiates an empty list object with room for maxItems items
{
numItems = 0;



12.2 List Class | 553

myList

listItems

listItems[0]

listItems[1]

••
•

listItems[numItems—1]

••
•

listItems[listItems.length—1]

numItems

currentPos

23

45

••
•

65

?

?

6

0

list

array

Figure 12.3 An instance of class List

listItems = new String[maxItems];
currentPos = 0;

}

Should the class provide a default constructor? Let’s do so as a precaution.

public List()
// Instantiates an empty list object with room for 100 items
{
numItems = 0;



554 | Chapter 12:  Array-Based Lists

listItems = new String[100];
currentPos = 0;

}

The observers isFull, isEmpty, and length are very straightforward. Each is only
one line long, as is so often the case in methods within the object-oriented paradigm.

public boolean isFull()
// Returns true if no room to add a component; false otherwise
{
return (listItems.length == numItems);

}

public boolean isEmpty()
// Returns true if no components in the list; false otherwise
{
return (numItems == 0);

}

public int length()
// Returns the number of components in the list
{
return numItems;

}

We have one more observer to implement: isThere. Because isThere is an
instance method, it has direct access to the items in the list. We just loop through the
items in the list looking for the one specified on the parameter list. The loop ends when
we find the matching item or have looked at all the items in the list. Our loop expres-
sion has two conditions: (1) the index is within the list and (2) the corresponding list
item is not equal to the one for which we are searching. After the loop is exited, we
return the assertion that the index is still within the list. If this assertion is true, then the
search item was found.

isThere
Set index to 0
while more to examine and item not found

Increment index
return (index is within the  list)



12.2 List Class | 555

This algorithm can be coded directly into Java, using the compareTo method of
String.

public boolean isThere(String item)
// Returns true if item is in the list.
{
int index = 0;
while (index < numItems && listItems[index].compareTo(item) != 0)
index++;

return (index < numItems);
}

This algorithm is called a sequential or linear search because we start at the begin-
ning of the list and look at each item in sequence. We stop the search as soon as we
find the item we are looking for (or when we reach the end of the list, concluding that
the desired item is not present in the list).

We can use this algorithm in any program requiring a list search. In the form
shown, it searches a list of String components, but the algorithm works for any class
that has a compareTo method.

Let’s look again at the heading for the operation that puts an item into the list.

public void insert(String item);
// Adds item to the list
// Assumption:  item is not already in the list

Is there anything in the documentation that says where each new item should go? No,
this is an unsorted list. Where we put each new item is up to the implementer. In this
case, let’s put each new item in the easiest place to reach: the next free slot in the array.
Therefore, we can store a new item into listItems[numItems]—and then increment
numItems.

This algorithm brings up a question: Do we need to check that there is room in the
list for the new item? We have two choices. The insert method can test numItems
against listItems.length and throw an exception if there isn’t room, or we can let
the client code make the test before calling insert. Our documentation is incomplete
because it does not specify what occurs in this situation. Let’s make the client code
responsible for checking the isFull operation before an insertion. If the client fails to
do so, the operation fails and the list is unchanged.

This algorithm is so simple, we just go directly to code.

public void insert(String item)
// If the list is not full, puts item in the last position in the list;
//  otherwise list is unchanged.
{
if (!this.isFull())



556 | Chapter 12:  Array-Based Lists

delete
Set index to location of item to be deleted if found
if found

Shift remainder of list up
Decrement numItems

shiftUp
// index is the location of the item to be deleted
Set listItems[index] to listItems[index+1]
Set listItems[index+1] to listItems[index+2]
.
.
.
Set listItems[numItems22] to listItems[numItems21]

{
listItems[numItems] = item;
numItems++;

}
}

Deleting a component from a list consists of two parts: finding the item and remov-
ing it from the list. We can use the same algorithm we used for isThere to look for the
item. We know from the documentation that the item may or may not be in the list. If
we find it, how do we remove it? We shift each item that comes after the one being
deleted up one array slot.

We can implement this algorithm using a for loop.

public void delete(String item)
// Removes item from the list if it is there
{ 

TE
AM
FL
Y

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

Team-Fly® 



12.2 List Class | 557

int index = 0;
boolean found = false;
while (index < numItems && !found)
{
if (listItems[index].compareTo(item) == 0)
found = true;

else
index++;

}
if (found)
{ // Shift remainder of list up to delete item
for (int count = index; count < numItems–1; count++)
listItems[count] = listItems[count+1];

numItems--;
}

}

The resetList method is analogous to the open operation for a file in which the file
pointer is positioned at the beginning of the file, so that the first input operation accesses
the first component of the file. Each successive call to an input operation gets the next
item in the file. Therefore, resetList must initialize currentPos to the first item in the
list. Where is the first item in an array-based list? In the 0th position. The getNextItem
operation is analogous to an input operation; it accesses the current item and then incre-
ments currentPos. When currentPos reaches numItems, we reset it to 0.

public void resetList()
// The iteration is initialized by setting currentPos to 0
{
currentPos = 0;

}

public String getNextItem()
// Returns the item at the currentPos position; increments currentPos;
//  resets current position to first item after the last item is returned
// Assumption:  No transformers have been invoked since last call
{
String next = listItems[currentPos];
if (currentPos == numItems–1)
currentPos = 0;

else
currentPos++;

return next;
}



558 | Chapter 12:  Array-Based Lists

Operation to be Tested Input Expected Observed 
Description of Action Values Output Output

Constructor (4) 0
print length

insert
insert four items and print mary, john, ann, betty mary, john, ann, betty
insert item and print mary, john, ann, betty

isThere
isThere susy and print whether found item is not found
isThere mary and print whether found item is found
isThere ann and print whether found item is found
isThere betty and print whether found item is found

Both of the methods change currentPos. Shouldn’t we consider them transform-
ers? We could certainly argue that they are, but their intention is to set up an iteration
through the items in the list, returning one item at a time to the client.

Test Plan

The documentation for the methods in class List helps us identify the tests necessary
for a black-box testing strategy. The code of the methods determines a clear-box testing
strategy. To test the List class implementation, we use a combination of black-box and
clear-box strategies. We first test the constructor by testing to see if the list is empty (a
call to length returns 0).

The methods length, insert, and delete must be tested together. That is, we
insert several items and delete several items. How do we know that the insert and
delete work correctly? We must write an auxiliary method printList that iterates
through the list using length and getNextItem to print out the values. We call
printList to check the status of the list after a series of insertions and deletions.
To test the isFull operation, we must test it when the list is full and when it is not.
We must also call insert when the list if full to see that the list is returned
unchanged.

Are there any special cases that we need to test for delete and isThere? We look
at the end cases. What are the end cases in a list? The item is in the first position in the
list, the item is in the last position in the list, and the item is the only one in the list. So
we must be sure that our delete can correctly delete items in these positions. We must
check that isThere can find items in these same positions and correctly determine that
values are not in the list.

These observations are summarized in the following test plan. The tests are shown
in the order in which they should be performed.



12.3 Sorting the List Items | 559

Operation to be Tested Input Expected Observed 
Description of Action Values Output Output

isFull
invoke (list is full) list is full
delete ann and invoke list is not full

delete
print mary, john, betty
delete betty and print mary, john
delete mary and print john
delete john and print (empty)

isEmpty yes

But what about testing resetList, and getNextItem? They do not appear explic-
itly in the test plan, but they are tested each time the auxiliary method printList is
called to print the contents of the list. We do however have to add one additional test
involving the iterator. We must print out length plus 1 items to test whether the current
position is reset after the last item is returned.

To implement this test plan, we must construct a test driver that carries out the
tasks outlined in the first column of the plan. We can make the test plan a document
separate from the driver, with the last column filled in and initialed by a person run-
ning the program and observing the screen output. Or we can incorporate the test
plan into the driver as comments and have the output go to a file. The key to properly
testing any software is in the plan: It must be carefully thought out and it must be
written.

12.3 Sorting the List Items
getNextItem presents the items to the user in the order in which they were inserted.
Depending on what we are using the list for, there might be times when we want to
rearrange the list components into a certain order before an iteration. For example, if
we are using the list for wedding invitations, we might want to see the names in alpha-
betic order. Arranging list items into order is
a very common operation and is known in
software terminology as sorting.

If you were given a sheet of paper with a
column of 20 names on it and asked to write
the numbers in ascending order, you would
probably do the following:

1. Make a pass through the list, looking for the lowest name (the one that comes first
alphabetically).

2. Write it on the paper in a second column.

Sorting Arranging the components of a list into order
(for instance, words into alphabetical order or numbers
into ascending or descending order)



560 | Chapter 12:  Array-Based Lists

3. Cross the number off the original list.
4. Repeat the process, always looking for the lowest name remaining in the original list.
5. Stop when all the names have been crossed off.

We could implement this algorithm as a client code, using getNextItem to go
through the list searching for the lowest. When we find it, we could insert it into
another list and delete it from the original. However, we would need two lists—one for
the original list and a second for the sorted list. In addition the client would have
destroyed the original list. If the list is large, we might not have enough memory for two
copies even if one is empty. A better solution is to derive a class from List that adds a
method that sorts the values in the list. Because the data fields in List are protected,
we can inherit them and access them directly. By accessing the values directly, we can
keep from having to have two lists.

Responsibility Algorithms for Class ListWithSort

The constructor takes the maximum number of items and calls the List’s constructor.
None of the other methods need to be overridden.

Going back to our by-hand algorithm, we can search listItems for the smallest
value, but how do we “cross off” a list component? We could simulate crossing off a
value by replacing it with null. We thus set the value of the crossed-off item to
something that doesn’t interfere with the processing of the rest of the components.
However, a slight variation of our hand-done algorithm allows us to sort the compo-
nents in place. We do not have to use a second list; we can put a value into its proper
place in the list by having it swap places with the component currently in that list
position.

We can state the algorithm as follows. We search for the smallest value in the
array  and exchange it with the component in the first position in the array. We search
for the next-smallest value in the array and exchange it with the component in the
second position in the array. This process continues until all the components are in
their proper places.

Class Name: ListWithSort Superclass: List Subclasses: 

Responsibilities Collaborations

Create itself (maxItems), Constructor

Sort the items in the list, Transformer

super

string



12.3 Sorting the List Items | 561

selectSort
for count going from 0 through numItems22

Find the minimum value in listItems[count]..listItems[numItems21]
Swap minimum value with listItems[count]

[0]

[1]

[2]

[3]

[4]

[5]

judy

susy

betty

sarah

ann

june

ann

susy

betty

sarah

judy

june

ann

betty

susy

sarah

judy

june

ann

betty

judy

sarah

susy

june

ann

betty

judy

june

susy

sarah

ann

betty

judy

june

sarah

susy

Figure 12.4 Straight selection sort

Figure 12.4 illustrates how this algorithm works.
Observe that we perform numItems–1 passes through the list because count runs

from 0 through numItems–2. The loop does not need to be executed when count
equals numItems–1 because the last value, listItems[numItems–1], is in its proper
place after the preceding components have been sorted.

This sort, known as the straight selection sort, belongs to a class of sorts called
selection sorts. There are many types of sorting algorithms. Selection sorts are charac-
terized by finding the smallest (or largest) value left in the unsorted portion at each iter-
ation and swapping it with the value indexed by the iteration counter. Swapping the
contents of two variables requires a temporary variable so that no values are lost (see
Figure 12.5).

Class ListWithSort

We are now ready to code our derived class. We need to include in the documentation
that the alphabetic order may be lost with future insertions.

public class ListWithSort extends List
{
// The items in the list are rearranged into ascending order
//  This order is not preserved in future insertions



562 | Chapter 12:  Array-Based Lists

3. Contents of temp
    goes into y

2. Contents of
    y goes into x

1. Contents of x goes into temp

tempy

x

Figure 12.5 Swapping the contents of two variables, x and y

public ListWithSort(int maxItems)
{ // Constructor
super(maxItems);

}

ListWithSort()
{ // Default constructor
super();

}

public void selectSort()
// Arranges list items in ascending order;
//  selection sort algorithm is used.
{
String temp;            // Temporary variable
int passCount;          // Loop control variable for outer loop
int searchIndex;        // Loop control variable for inner loop
int minIndex;           // Index of minimum so far
for (passCount = 0; passCount < numItems – 1; passCount++)
{
minIndex = passCount;
// Find the index of the smallest component
//  in listItems[passCount]..listItems[numItems–1]
for (searchIndex = passCount + 1; searchIndex < numItems;

searchIndex++)
if (listItems[searchIndex].compareTo(listItems[minIndex]) <0)



12.4 Sorted List | 563

minIndex = searchIndex;
// Swap listItems[minIndx] and listItems[passCount]
temp = listItems[minIndex];
listItems[minIndex] = listItems[passCount];
listItems[passCount] = temp;

}
}

} // End of class ListWithSort

Note that with each pass through the outer loop in selectSort, we are looking for
the minimum value in the rest of the array (listItems[passCount] through list-
Items[numItems–1]). Therefore, minIndex is initialized to passCount and the inner
loop runs from searchIndex equal to passCount+1 through numItems–1. Upon exit
from the inner loop, minIndex contains the position of the smallest value. (Note that
the if statement is the only statement in the loop.)

This method may swap a component with itself, which occurs if no value in the
remaining list is smaller than listItems[passCount]. We could avoid this unneces-
sary swap by checking to see if minIndex is equal to passCount. Because this compar-
ison is made in each iteration of the outer loop, it is more efficient not to check for this
possibility and just to swap something with itself occasionally.

This algorithm sorts the components into ascending order. To sort them into
descending order, we must scan for the maximum value instead of the minimum value.
Simply changing the test in the inner loop from less than to greater than accomplishes
this. Of course, minIndex would no longer be an appropriate identifier and should be
changed to maxIndex.

12.4 Sorted List
It is important to note that ListWithSort does not provide the user with a sorted list
class. The insert and delete algorithms do not preserve ordering by value. The
insert operation places a new item at the end of the list, regardless of its value. After
selectSort has been executed, the list items remain in sorted order only until the
next insertion or deletion takes place. Of course, the client could sort the list after
every insertion, but this is inefficient. Let’s now look at a sorted list design in which all
the list operations cooperate to preserve the sorted order of the list components.

Brainstorming Sorted List

There is nothing about order in the design for class List. If we want the list items kept
in sorted order, we need to specify this. Let’s go back to the CRC card design for class
List and indicate that we want the list to be sorted.



564 | Chapter 12:  Array-Based Lists

The first thing to notice is that the observers do not change. They are the same
whether the list is sorted by value or not. The transformers insert and delete and the
iterator now have additional constraints. Rather than designing an entirely new class,
we can derive SortedList from class List, overriding those methods whose imple-
mentations need changing.

Class Name: SortedList Superclass: Subclasses:

Responsibilities Collaborations

List  

Create itself (maxItems)

Insert into list (item) keeping the list sorted,
Transformer
Delete from list (item) keeping the list sorted,
Transformer 

    

None

String



StringLook at each item in sorted order, Iterator

String

Class Name: List Superclass: Subclasses:

Responsibilities Collaborations

Object

Create itself (maxItems)
Is list full? Observer

    return boolean

Is list empty? Observer
    return boolean

Know length, Observer
    return int

Is an item in the list? Observer

Insert into list (item) keeping the list sorted, Transformer

Delete from list (item) keeping the list sorted, Transformer

None
None

None

None

None

String

String

return boolean

Look at each item in sorted order, Iterator String



12.4 Sorted List | 565

Gomez

Gomez Applebee

Gomez

Gomez

Ziggle

Gomez

Norton

Applebee

Gomez

Norton

Gomez

Jones

Norton

Gomez

Norton

Ziggle

 Initial state of list

0 items

1 item

2 items

The state of the list after adding the highlighted item to the
initial list in the appropriate position to keep the list sorted

Figure 12.6 All of the different places where an item can be inserted into a sorted list, starting with 0, 1,
or 2 items already in the list.

Responsibility Algorithms for Class SortedList

Let’s look first at insert. Figure 12.6 illustrates how it should work.
The first item inserted into the list can go into the first position. If there is only

one item, the list is sorted. If a second item being inserted is less than the first item, the
first item must be moved into the second position and the new item put into the first
position. If the second item is larger, it goes into the second position. If we add a third
item that is smaller than the first item, the other two are shifted down one and the
third item goes into the first position. If the third item is greater than the first item but
less than the second, the second is shifted down and the third item goes into the sec-
ond position. If the third item is greater than the second item, it goes into the third
position.

To generalize, we start at the beginning of the list and scan until we find an item
greater than the one we are inserting. We shift that item and the rest of the items in the
list down one position to make room for the new item. The new item goes in the list at
that point.



566 | Chapter 12:  Array-Based Lists

Assuming that index is the place where item is to be inserted, the algorithm for shift-
ing the remainder down is as follows.

insert
if (list is not full)

while place not found AND more places to look
if item > current item in the list

Increment current position
else

Place found
Shift remainder of the list down
Insert item
Increment numItems

shiftDown
Set listItems[numItems] to listItems[numItems21]
Set listItems[numItems21] to listItems[numItems22]
.
.
.
Set listItems[index+1] to listItems[index]

This algorithm is illustrated in Figure 12.7. Like the shiftUp algorithm, shiftDown can be
implemented using a for loop.

This algorithm is based on how we would accomplish the task by hand. Often, such
an adaptation is the best way to solve a problem. However, in this case, further thought
reveals a slightly better way. Notice that we search from the front of the list (people
always do), and we shift down from the end of the list upward. We can combine the
searching and shifting by beginning at the end of the list.

If item is the new item to be inserted, compare item to the value in
listItems[numItems–1]. If item is less, put listItems[numItems–1] into

TE
AM
FL
Y

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

Team-Fly® 



12.4 Sorted List | 567

june

juneInsert susy sarah bobby judy

june

susy

june bobby bobby

sarah

susy

june

sarah

susy

judy

june

sarah

susy

Put susy
at end
of the
list.

Move susy
down and
insert sarah.

Move susy,
sarah, and june
down and
insert bobby.

Move susy,
sarah, and june
down and
insert judy.

Figure 12.7 Inserting into a sorted list

listItems[numItems] and compare item to the value in listItems[numItems–2].
This process continues until you find the place where item is greater than (or equal to
if duplicates are allowed) the list item. Store item directly after it. Here is the algorithm:

insert (revised)
if (list is not full)

Set index to numItems – 1
while index >= 0 & & (item .compareTo( listItems[index]) < 0)

Set listItems[index+1] to listItems[index]
Decrement index

Set listItems[index+1] to item
Increment numItems



568 | Chapter 12:  Array-Based Lists

Notice that this algorithm works even if the list is empty. When the list is empty,
numItems is 0 and the body of the while loop is not entered. So item is stored into
listItems[0], and numItems is incremented to 1. Does the algorithm work if item is
the smallest? The largest? Let’s see. If item is the smallest, the loop body is executed
numItems times, and index is 21. Thus, item is stored into position 0, where it
belongs. If item is the largest, the loop body is not entered. The value of index is still
numItems 2 1, so item is stored into listItems[numItems], where it belongs.

Are you surprised that the general case also takes care of the special cases? This
situation does not happen all the time, but it occurs sufficiently often that we find it
is good programming practice is to start with the general case. If we begin with the
special cases, we may still generate a correct solution, but we may not realize that we
don’t need to handle the special cases separately. So begin with the general case, then
treat as special cases only those situations that the general case does not handle
correctly.

The methods delete and getNextItem must maintain the sorted order—but they
already do! An item is deleted by removing it and shifting all of the items larger than
the one deleted up one position, and getNextItem only returns a copy of an item,
it does not change an item. Only insert needs to be overridden in derived class
SortedList.

public class SortedList extends List
{
public SortedList()
{
super();

}
public SortedList(int maxItems)
{
super(maxItems);

}

public void insert(String item)
// If the list is not full, puts item in its proper place in the
//  list; otherwise list is unchanged
// Assumption:  item is not already in the list
{
if (!this.isFull())
{
int index = numItems – 1;          // Loop control variable
while (index >= 0 && (item.compareTo(listItems[index]) < 0))
{
listItems[index+1] = listItems[index]; // Find insertion point
index--;



12.5 The List Class Hierarchy and Abstract Classes | 569

}
listItems[index+1] = item;        // Insert item
numItems++;                       // Increment number of items

}
}

}

Test Plan

The same test plan can be used for the sorted list that we used for the unsorted version.
The only difference is that in the expected output column, the list items should appear
in sorted order.

12.5 The List Class Hierarchy and Abstract Classes
We have created a hierarchy with class List at the top and two derived classes. We can
visualize the hierarchy as follows:

ListWithSort is a List. SortedList is a List. ListWithSort is not a SortedList,
and SortedList is not a ListWithSort.

We could have organized the hierarchy using an abstract class. Recall from Chapter 8
that an abstract class is a class that is headed by the word abstract and leaves one or
more methods incomplete. An abstract class cannot be instantiated. Another class must
extend the abstract class and implement all of the abstract methods. We could have imple-
mented the observers and iterator in the abstract class and left the implementation of the
transformers to the derived class. Then the unsorted list and the sorted version could both
inherit from the abstract class. The class and method headings would be as follows:
(method implementations are indicated by “{. . .}”; the abstract methods are indicated by
method signatures that end with “;”).

public abstract class List
{
public List() {...}
public List(int maxItems) {...}
public boolean isFull() {...}
public boolean isEmpty() {...}

List

SortedListListWithSort



570 | Chapter 12:  Array-Based Lists

public int length() {...}
public boolean isThere(String item) {...}
public void resetList() {...}
public String getNextItem() {...}
public abstract void delete(String item);
public abstract void insert(String item);

}

public class UnsortedList extends List
{
public UnsortedList() {...}
public UnsortedList(int maxItems) {...}
public void delete(String item) {...}
public void insert(String item) {...}

}

public class SortedList extends List
{
public SortedList() {...}
public SortedList(int maxItems) {...}
public void delete(String item) {...}
public void insert(String item) {...}

}

public class ListWithSort extends UnsortedList
{
public ListWithSort() {...}
public ListWithSort(int maxItems) {...}
public void selectSort() {...}

}

Under these conditions, the class hierarchy looks like this:

List

SortedList

ListWithSort

UnsortedList



12.6 Searching | 571

12.6 Searching
In our SortedList class we overrode the insert method, the only method that had to
be rewritten to keep the list in sorted form. However, if the list is in sorted form, we can
perform a more efficient search. In this section, we look at two searching algorithms
that depend on the list items being in sorted order.

Sequential Search

The isThere algorithm assumes that the list to be searched is unsorted. A drawback to
searching an unsorted list is that we must scan the entire list to discover that the search
item is not there. Think what it would be like if your city telephone book contained peo-
ple’s names in random rather than alphabetical order. To look up Marcus Anthony’s phone
number, you would have to start with the first name in the phone book and scan sequen-
tially, page after page, until you found it. In the worst case, you might have to examine
tens of thousands of names only to find out that Marcus’s name is not in the book.

Of course, telephone books are alphabetized, and the alphabetical ordering makes
searching easier. If Marcus Anthony’s name is not in the book, you discover this fact
quickly by starting with the A’s and stopping the search as soon as you have passed the
place where his name should be. Although the sequential search algorithm in isThere
works in a sorted list, we can make the algorithm more efficient by taking advantage of
the fact that the items are sorted.

How does searching in a sorted list differ from searching in an unordered list?
When we search for an item in an unsorted list, we won’t discover that the item is miss-
ing until we reach the end of the list. If the list is already sorted, we know that an item
is missing when we pass the place where it should be in the list. For example, if a list
contains the values

and we are looking for judy, we need only compare judy with becca, bobby, and june to
know that judy is not in the list.

If the search item is greater than the current list component, we move on to the
next component. If the item is equal to the current component, we have found what we
are looking for. If the item is less than the current component, then we know that it is
not in the list. In either of the last two cases, we stop looking. In our original algorithm,
the loop conditions were that the index was within the list and the corresponding list
item was not the one searched for. In this algorithm, the second condition must be that
the item being searched for is less than the corresponding list item. However, determin-
ing whether the item is found is a little more complex. We must first assert that the

becca
bobby
june
phil
robert
tomas



572 | Chapter 12:  Array-Based Lists

isThere (in a sorted list)
Set index to 0
while index is within the list AND item is greater than listItems[index]

Increment index
return (index is within the list AND item is equal to listItems[index])

index is within the list and, if that is true, assert that the search item is equal to the cor-
responding list item.

Why can’t we just test to see if item is equal to listItems[index] at the end of
the loop? This works on all cases but one. What happens if item is larger than the last
element in the list? We would exit the loop with index equal to numItems. Trying to
access listItems[index] would then cause the program to crash with an index out of
range error. Therefore, we must check on the value of index first.

public boolean isThere(String item)
// Returns true if item is in the list; false otherwise
// Assumption:  List items are in ascending order
{
int index = 0;
while (index < numItems && item.compareTo( listItems[index]) > 0)
index++;

return (index < numItems && item.compareTo(listItems[index])== 0);
}

On average, searching a sorted list in this way takes the same number of iterations
to find an item as searching an unsorted list. The advantage of this new algorithm is
that we find out sooner if an item is missing. Thus, it is slightly more efficient. There is
another search algorithm that works only on a sorted list, but it is more complex: a
binary search. However, the complexity is worth it.

Binary Search

The binary search algorithm on a sorted list is considerably faster both for finding an
item and for discovering that an item is missing. A binary search is based on the princi-
ple of successive approximation. The algorithm divides the list in half (divides by 2—
that’s why it’s called a binary search) and decides which half to look in next. Division of
the selected portion of the list is repeated until the item is found or it is determined that
the item is not in the list.



12.6 Searching | 573

L M

G G 

C C D D

PHONE
BOOK

A–Z



(A–M) 

(A–G) 

(A–C) (D–G)

Figure 12.8 A binary search of the phone book

This method is analogous to the way in which we look up a name in a phone book
(or word in a dictionary). We open the phone book in the middle and compare the name
with one on the page that we turned to. If the name we’re looking for comes before this
name, we continue our search in the left-hand section of the phone book. Otherwise, we
continue in the right-hand section of the phone book. We repeat this process until we
find the name. If it is not there, we realize that either we have misspelled the name or
our phone book isn’t complete. See Figure 12.8.

We start with the whole list (indexes 0 through numItems–1) and compare our
search value to the middle list item. If the search item is less than the middle list item,
we continue the search in the first half of the list. If the search item is greater than the
middle list item, we continue the search in the second half of the list. Otherwise, we
have found a match. We keep comparing and redefining the part of the list in which to



574 | Chapter 12:  Array-Based Lists

Figure 12.9 Binary search

Binary Search
Set first to 0
Set last to numItems 2 1
Set found to false
while search area is not empty and !found

Set middle to (first + last) divided by 2
if (item is equal to listItems[middle])

Set found to true
else if (item is less than listItems[middle])

Set last to middle–1      // Look in first half
else

Set first to middle + 1   // Look in last half

[first]
listItems
[middle] [last]

item

??

look (the search area) until we find the item or the search area is empty. Let’s write the
algorithm bounding the search area by the indexes first and last. See Figure 12.9.

This algorithm should make sense. With each comparison, at best, we find the item
for which we are searching; at worst, we eliminate half of the remaining list from con-
sideration. Before we code this algorithm, we need to determine when the search area is
empty. If the search area is between listItems[first] and listItems[last], then
this area is empty if last is less than first.

Let’s do a walk-through of the binary search algorithm. The item being searched for is
"bat". Figure 12.10a shows the values of first, last, and middle during the first itera-
tion. In this iteration, "bat" is compared with "dog", the value in listItems[middle].



12.6 Searching | 575

ant


cat


chicken


cow


deer


dog


fish


goat


horse


rat


snake

first

middle

last

[0]


[1]


[2]


[3]


[4]


[5]


[6]


[7]


[8]


[9]


[10]

First iteration
bat < dog





ant


cat


chicken


cow


deer


dog


fish


goat


horse


rat


snake

first

middle

last

 [0]


[1]


[2]


[3]


[4]


[5]


[6]


[7]


[8]


[9]


[10]

Second iteration
bat < chicken




ant


cat


chicken


cow


deer


dog


fish


goat


horse


rat


snake

first and middle

last

[0]


[1]


[2]


[3]


[4]


[5]


[6]


[7]


[8]


[9]


[10]

Third iteration
bat > ant



ant


cat


chicken


cow


deer


dog


fish


goat


horse


rat


snake

first, last,
and middle

 [0]


[1]


[2]


[3]


[4]


[5]


[6]


[7]


[8]


[9]


[10]

Fourth iteration
bat < cat



bat cannot be
in this part
of the list
6

6 bat cannot bein this partof the list 6 bat cannot bein this partof the list


ant


cat


chicken


cow


deer


dog


fish


goat


horse


rat


snake

first

middle

last

[0]


[1]


[2]


[3]


[4]


[5]


[6]


[7]


[8]


[9]


[10]

First iteration
bat < dog





ant


cat


chicken


cow


deer


dog


fish


goat


horse


rat


snake

first

middle

last

 [0]


[1]


[2]


[3]


[4]


[5]


[6]


[7]


[8]


[9]


[10]

Second iteration
bat < chicken




ant


cat


chicken


cow


deer


dog


fish


goat


horse


rat


snake

first and middle

last

[0]


[1]


[2]


[3]


[4]


[5]


[6]


[7]


[8]


[9]


[10]

Third iteration
bat > ant



ant


cat


chicken


cow


deer


dog


fish


goat


horse


rat


snake

first, last,
and middle

 [0]


[1]


[2]


[3]


[4]


[5]


[6]


[7]


[8]


[9]


[10]

Fourth iteration
bat < cat



bat cannot be
in this part
of the list
6

6 bat cannot bein this partof the list 6 bat cannot bein this partof the list


Figure 12.10 Walk-through of binary search algorithm

(a) (b)

(c) (d)



576 | Chapter 12:  Array-Based Lists

Terminating
Iteration first last middle listItems[middle] Condition

item: fish
First 0 10 5 dog
Second 6 10 8 horse
Third 6 7 6 fish found is true

item: snake
First 0 10 5 dog
Second 6 10 8 horse
Third 9 10 9 rat
Fourth 10 10 10 snake found is true

item: zebra
First 0 10 5 dog
Second 6 10 8 horse
Third 9 10 9 rat
Fourth 10 10 10 snake
Fifth 11 10 last < first

Because "bat" is less than (comes before) "dog", last becomes middle–1 and first
stays the same. Figure 12.10b shows the situation during the second iteration. This time,
"bat" is compared with "chicken", the value in listItems[middle]. Because "bat"
is less than (comes before) "chicken", last becomes middle–1 and first again stays
the same.

In the third iteration (Figure 12.10c), middle and first are both 0. The item
"bat" is compared with "ant", the item in listItems[middle]. Because "bat" is
greater than (comes after) "ant", first becomes middle+1. In the fourth iteration
(Figure 12.10d), first, last, and middle are all the same. Again, "bat" is com-
pared with the item in listItems[middle]. Because "bat" is less than "cat",
last becomes middle–1. Now that last is less than first, the process stops;
found is false.

The binary search is the most complex algorithm that we have examined so far. The
following table shows first, last, middle, and listItems[middle] for searches of
the items "fish", "snake", and "zebra", using the same data as in the previous
example. Examine the results in this table carefully.

TE
AM
FL
Y

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

Team-Fly® 



12.6 Searching | 577

Notice in the table that whether we searched for "fish", "snake", or "zebra", the
loop never executed more than four times. It never executes more than four times in a
list of 11 components because the list is being cut in half each time through the loop.
The table below compares a sequential search and a binary search in terms of the aver-
age number of iterations needed to find an item.

If the binary search is so much faster, why not use it all the time? It certainly is
faster in terms of the number of times through the loop, but more computations are per-
formed within the binary search loop than in the other search algorithms. So if the num-
ber of components in the list is small (say, less than 20), the sequential search algorithms
are faster because they perform less work at each iteration. As the number of compo-
nents in the list increases, the binary search algorithm becomes relatively more efficient.

Here is the code for isThere that uses the binary search algorithm.

public boolean isThere(String item)
// Returns true if item is in the list; false otherwise
//  Binary search algorithm is used
// Assumption:  List items are in ascending order
{
int first = 0;               // Lowest position in search area
int last = numItems–1;       // Highest position in search area
int middle;                  // Middle position in search area
boolean found = false;
while (last >= first && !found)
{
middle = (first + last)/2;
if (item.compareTo(listItems[middle])==0)
found = true;

else if (item.compareTo(listItems[middle])< 0)
// Item not in listItems[middle]..listItems[last]
last = middle – 1;

else
// Item not in listItems[first]..listItems[middle]
first = middle + 1;

}
return found;

}

Average Number of Iterations

Length Sequential Search Binary Search

10 5.5 2.9
100 50.5 5.8

1,000 500.5 9.0
10,000 5000.5 12.0



578 | Chapter 12:  Array-Based Lists

Theoretical Foundations
Complexity of Searching and Sorting

We introduced Big-O notation in Chapter 9 as a way of comparing the work done by different
algorithms. Let’s apply it to the algorithms that we’ve developed in this chapter and see how
they compare with each other. In each algorithm, we start with a list containing some number
of items, N.

In the worst case, the isThere sequential-search method scans all N components to
locate an item. Thus, it requires N steps to execute. On average, isThere takes roughly N/2
steps to find an item; however, recall that in Big-O notation, we ignore constant factors (as
well as lower-order terms). Thus, method isThere is an order N—that is, an O(N )—algorithm.

What about the algorithm we presented for a sequential search in a sorted list? The num-
ber of iterations is decreased for the case in which the item is missing from the list. However,
all we have done is take a case that would require N steps and reduce its time, on average, to
N/2 steps. Therefore, this algorithm is also O(N ).

Now consider isThere when the binary search algorithm is being used. In the worst
case, it eliminates half of the remaining list components on each iteration. Thus, the worst-
case number of iterations is equal to the number of times N must be divided by 2 to elimi-
nate all but one value. This number is computed by taking the logarithm, base 2, of N
(written log2N ). Here are some examples of log2N for different values of N:

N Log2N
2 1
4 2
8 3

16 4
32 5

1,024 10
32,768 15

1,048,576 20
33,554,432 25

1,073,741,824 30

As you can see, for a list of over 1 billion values, the binary search algorithm takes only 30
iterations. It is definitely the best choice for searching large lists. Algorithms such as the
binary search algorithm are said to be of logarithmic order.

Now let’s turn to sorting. Method selectSort contains nested for loops. The total num-
ber of iterations is the product of the iterations performed by the two loops. The outer loop
executes N 2 1 times. The inner loop also starts out executing N 2 1 times, but steadily

decreases until it performs just one iteration: The inner loop executes N/2 iterations. The

tcontinued



12.7 Generic Lists | 579

12.7 Generic Lists
Generic lists are lists where the operations are defined, but the objects on the list are
not. Although we called the components of our lists “items,” they are Strings. Is it pos-
sible to construct a truly general-purpose list where the items can be anything? For
example, could we have a list of Name objects as defined in Chapter 7 or Address
objects as defined in Chapter 8? Yes, we can. All we have to do is declare the objects on
the list to be Comparable. What is Comparable? It’s an interface. Now, let’s see how
we can use it to make our lists generic.

Comparable Interface

In Chapter 5, we defined the Java construct interface as a model for a class that specifies
the constants (final fields) and instance methods that must be present in a class that imple-
ments the interface. The Comparable interface is part of the standard Java class

total number of iterations is thus

Ignoring the constant factor and lower-order term, this is N 2 iterations, and selectSort is an O(N 2)
algorithm. By contrast, isThere, when coded using the binary search algorithm, takes only 30 itera-
tions to search a sorted array of 1 billion values. Putting the array into order takes selectSort
approximately 1 billion times 1 billion iterations!

The insert algorithm for a sorted list forms the basis for an insertion sort in which values are
inserted into a sorted list as they are input. On average, insert must shift down half of the values
(N/2) in the list; thus, it is an O(N ) algorithm. If insert is called for each input value, we are exe-
cuting an O(N ) algorithm N times; therefore, an insertion sort is an O(N 2) algorithm.

Is every sorting algorithm O(N 2)? Most of the simpler ones are, but O(N 3 log2N ) sorting algo-
rithms exist. Algorithms that are O(N 3 log2N ) are much closer in performance to O(N ) algorithms
than are O(N 2 ) algorithms. For example, if N is 1 million, then an O(N 2) algorithm takes a million
times a million (1 trillion) iterations, but an O(N 3 log2N ) algorithm takes only 20 million iterations—
that is, it is 20 times slower than the O(N ) algorithm but 50,000 times faster than the O(N 2) algo-
rithm.

N N−( ) ×1
2

Complexity of Searching and Sorting



580 | Chapter 12:  Array-Based Lists

library. Any class that implements this interface must implement method compareTo. This
method compares two objects and returns an integer that determines the relative ordering
of the two objects (the instance to which it is applied and the method’s parameter). Consider

intValue = item.compareTo(listItems[index]);

intValue is negative if item comes before listItems[index], is 0 if they are equal,
and is positive if item comes after listItems[index]. We have used this method for
comparing strings in the classes designed in this chapter because String implements
interface Comparable.

To make our List class as generic as possible, we replace String with Compara-
ble throughout the class. This means that any object of a class that implements the
Comparable interface can be passed as a parameter to insert, delete, or isThere.
This change also means that the array must hold Comparable objects and getNext-
Item must return a Comparable object. Here is the complete abstract class List.

public abstract class List
{
protected Comparable[] listItems;      // Array to hold list items
protected  int numItems;               // Number of items in the list
protected  int currentPos;             // State variable for iteration

public List(int maxItems)
// Instantiates an empty list object with room for maxItems items
{
numItems = 0;
listItems = new Comparable[maxItems];
currentPos = 0;

}

public List()
// Instantiates an empty list object with room for 100 items
{
numItems = 0;
listItems = new Comparable[100];
currentPos = 0;

}

public boolean isFull()
// Returns true if there is not room for another component;
//  false otherwise
{
return (listItems.length == numItems);

}



12.7 Generic Lists | 581

public boolean isEmpty()
// Returns true if there are no components in the list;
//  false otherwise
{
return (numItems == 0);

}

public int length()
// Returns the number of components in the list.
{
return numItems;

}

public abstract boolean isThere(Comparable item);
// Returns true if item is in the list; false otherwise

// Transformers
public abstract void insert(Comparable item);
// If list is not full, inserts item into the list;
//  otherwise list is unchanged.
// Assumption:  item is not already in the list

public abstract void delete(Comparable item);
// Removes item from the list if it is there

// Iterator Pair
public void resetList()          // Prepare for iteration
{
currentPos  = 0;

}
public Comparable getNextItem()
// Returns the item at the currentPos position;
//  resets current position to first item after the last item is returned
// Assumption:  No transformers have been invoked since last call
{
Comparable next = listItems[currentPos];
if (currentPos == numItems–1)
currentPos = 0;

else
curentPos++;

return next;
}

}



582 | Chapter 12:  Array-Based Lists

Notice that we have made the isThere method abstract. This way the derived class
can determine which searching algorithm to use.

Polymorphism

We have discussed polymorphism several times as it is one of the major features of
object-oriented programming. In a hierarchy of classes, polymorphism enables us to
override a method name with a different implementation in a derived class. Thus there
can be multiple forms of a given method within the hierarchy (literally, polymorphism
means having multiple forms).

The Java compiler decides which form of a polymorphic instance method to use
by looking at the class of its associated instance. For example, if compareTo is associ-
ated with a String variable, then the version of compareTo defined in class String
is called.

Thus far, this is all straightforward. But consider the case where compareTo is
applied to an object that has been passed as a parameter declared to be Comparable.
The abstract insert method that we defined in the last section is precisely the example
we have in mind.

public abstract void insert(Comparable item);

An instance of any class that implements Comparable can be passed as an argu-
ment to this parameter. The class of the argument object determines which form of
compareTo is actually called within insert. At compile time, however, there is no way
for the Java compiler to determine the class of the argument object. Instead, it must

insert Bytecode that identifies the argument’s class at
run time and then calls the appropriate method. Pro-
gramming language designers call this dynamic bind-
ing. When the compiler can identify the appropriate
form of the method to use, it is called a static bind-
ing.

The practical implication of dynamic binding is
that it allows us to define a generic List class that

works with items that are of any class that implements Comparable. Whenever a
method in the List class needs to compare two items, the appropriate form of com-
pareTo is called, even when the class of the items isn’t known until run time.

The other practical implication of dynamic binding is that it is slower than static
binding. With static binding, the JVM transfers control directly to the appropriate
method. But in dynamic binding, the JVM must first identify the class of the object and
then look up the address of the associated method before transferring control to it.

Dynamic binding Determining at run time which
form of a polymorphic method to call

Static binding Determining at compile time which
form of a polymorphic method to call



Problem-Solving Case Study | 583

Problem-Solving Case Study
Exam Attendance

Problem You are the grader for a U.S. government class of 200 students. The instructor has
asked you to prepare two lists: an alphabetical list of the students taking an exam and an
alphabetical list of the students who have missed it. The catch is that she wants the lists
before the exam is over. You decide to write an application for your notebook computer that
takes each student’s name as the student enters the exam room and prints the lists of
absentees and attendees for your instructor.

Brainstorming The words student, name, and list are sprinkled throughout the problem
statement. The fundamental objects, then, are lists of students, each represented by his or her
name. We need a window object to hold the student names as they enter the exam. We also
need an object that represents the person checking in the students. This object is the driver
class for the application.

Filtering None of these classes overlap, so there is no consolidation that we can do. We may
be missing a class, but we can’t tell yet.

Scenarios Let’s look at a by-hand algorithm to get a better picture of the processing. You
could stand at the door, ask the students their names as they enter, and check off the names
from a master list. After all of the students have entered, you make a list of those that were
not checked off and a list of those that were. Of course! You must have a master list of all
the students in the class.

How do you simulate “ask the students their names”? You type each name on the key-
board of your laptop. How do you simulate “check off”? Your program reads the name and
deletes it from the master list. If you then insert the name into a list of those present, you
have both lists ready for printing as soon as the last student signs in.

You check with your instructor, and she says that the master class list is available on file
“students.dat”. You must add an input file object for reading the master list of students and a
list to store them in. What about an output file? Yes, you need that too. You can write the
two lists to a file and take it down the hall to be printed while the students are taking the
exam. What about the student names? You have class Name that you can use from Chapter 7.

a student name
a master list of all names
a list of names of those present
application
window object for checking in students
input file object
output file object

a student name
a list of names
application
window object



584 | Chapter 12:  Array-Based Lists

CRC Cards This application makes use of two lists: the master list and the list of the
attendees. We do not make a CRC card for this class because we can use one of the list classes
developed in this chapter. Here is the CRC Card for the application class. Let’s call it class
ExamAttendance.

Internal Data Representation Your application must prepare the initial list of students from
the class-roster file, which is ordered by social security number. If you use an unsorted list for
the list of all students, the list must be sorted before printing (class ListWithSort). You
decide to use class SortedList instead. So the internal representation is two sorted lists of
Name objects. The interface for class Name is repeated here.

package name;

public class Name implements Comparable
// This class defines a name consisting of three parts
{
// Constructors
public Name(String firstName, String middleName,

String lastName)
// Initializes a Name object with first, middle, and
//  last name

public String knowFirstName()
public String knowMiddleName()
public String knowLastName()

Class Name: ExamAttendance Superclass: Subclasses:

Responsibilities Collaborations

Object

Frame, Button, Label,
Textfield
Name, BufferedReader, List

Prepare window object

Create master list of students

Get a student name from the window
Delete name from master list

Insert name into present list

Print list of those present
Print list of those absent

Name, Button
List, Name

List, Name

List, Name, PrintWriter

List, Name, PrintWriter



Problem-Solving Case Study | 585

// Additional observers
public String firstLastMid()
public String lastFirstMid()
public boolean equals(Name otherName)
public int compareTo(Name otherName)

}

Responsibility Algorithms Preparing the window object involves setting up the Frame for
the students to enter their names. The names are to be stored in a Name object, which requires
a first name, a middle name, and a last name. This means that the Frame must have three
Labels and three TextFields. There must be a button to signal the name is ready for input
and a button to signal that the last student has entered the exam.

Prepare Window Objects

Because creating Frame objects is second nature to you now, you can code this module
directly.

Creating the master list of students requires preparing the file for input, reading the
names, storing them into a Name object, and inserting the object into the list. Reading the
names requires that you know how the data is written on file “students.dat”. The file format
is first name, middle name or initial, last name, and social security number. There is exactly
one space between each part of the name. If there is an initial rather than a middle name, it
is not followed by a period. We should extend BufferedReader to input this information
and return a Name object. We design this class later.

Create MasterList

The next three responsibilities, getting a student name, deleting the name from the mas-
ter list, and inserting the name in the present list, take place in the event handler for the
“Enter” button.

Prepare file
while more data

Set name to dataFile.getName()
Insert name into masterList

Create three labels
Create three text fields
Create “Enter” button
Create “Quit” button



586 | Chapter 12:  Array-Based Lists

Get a Student name

Delete Name from Master List

Insert Name into Present List

The last two responsibilities, printing the list of those present and printing the list of
those absent, take place within the event handler for the “Quit” button. Because the algo-
rithm for printing a list is identical in both cases, you write it as a helper method that takes
the file name and the list. The event handler can also close the window.

Print List(outFile, list)

Now you need to design the class that does the file input. It is derived from Buffered-
Reader. It must create itself, input a string, and break the string into the first name, middle
name, and last name. It should also have a Boolean method that tells when the file is empty.
Here is its CRC card for class ExamDataReader.

Class Name: ExamDataReader Superclass: Subclasses:

Responsibilities Collaborations

BufferedReader 

Create itself, Constructor
Get name, Observer
    return name
More data? Observer
    return boolean 

None

BufferedReader

BufferedReader 

list.resetList()
for index going from 1 to list.length()

Set name to list.getNextItem()
outFile.println(name.firstLastMid())

presentList.insert(name)

masterList.delete(name)

Set firstName to firstField.getText()
Set middleName to middleField.getText()
Set lastName to lastField.getText()
Set name to new Name(firstName, middleName, lastName)

TE
AM
FL
Y

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

Team-Fly® 



Problem-Solving Case Study | 587

Because the fields of the name are delimited by blanks, you can use the ReadLine
method in BufferedReader to input the entire line. In order to separate out the first,
middle, and last names of a student, you can use the methods provided in the String class.
The indexOf method finds the spaces. The first name begins at the 0th position and ends at
the position before the space. The original line is replaced by the line with the first name
removed. This process is repeated to get the middle name and the last name. The social secu-
rity number can just be ignored. This problem doesn’t need it.

We must be sure to read the first line of data in the constructor and read at the end of get-
Name. The More data responsibility can then check to see if the last line read was null.

Get Name

package exam;
import name.*;
import java.io.*;

public class ExamDataReader extends BufferedReader
{
public static String dataLine;
public ExamDataReader(BufferedReader inFile) throws IOException
{
super(inFile);
dataLine = inFile.readLine();

}
public Name getName() throws IOException
{ 
String firstName;
String middleName;
String lastName;
Name name;
int index;

Set index to dataLine.indexOf(‘ ‘)
Set firstName to dataLine.substring(0, index)
Set dataLine to dataLine.substring(index+1, dataLine.length())
Set index to dataLine.indexOf(‘ ‘)
Set middleName to dataLine.substring(0, index)
Set dataLine to dataLine.substring(index+1, dataLine.length())
Set index to dataLine.indexOf(‘ ‘)
Set lastName to dataLine.substring(0, index)
Set name to new Name(firstName, middleName, lastName)
Set dataLine to this.readLine()

return name



588 | Chapter 12:  Array-Based Lists

// Extract first name
index = dataLine.indexOf(' ');
firstName = dataLine.substring(0, index);
dataLine = dataLine.substring(index+1, dataLine.length());
// Extract middle name
index = dataLine.indexOf(' ');
middleName = dataLine.substring(0, index);
dataLine = dataLine.substring(index+1, dataLine.length());
// Extract last name
index = dataLine.indexOf(' ');
lastName = dataLine.substring(0, index);
name = new Name(firstName, middleName, lastName);
dataLine = this.readLine();  // Get next data line

return name;
}
public boolean moreData()
{
return dataLine != null;

}
} // End of class ExamDataReader

import name.*;                   // Access Name class
import list.*;                   // Access List and SortedList

import exam.*;                   // Access ExamDataReader class
import java.awt.*;               // Access Java events and files
import java.awt.event.*;
import java.io.*;

public class ExamAttendance
{
// Define a button listener
private static class ActionHandler implements ActionListener
{
public void actionPerformed(ActionEvent event)
// Listener for the Enter and Quit buttons events
{
// Declare string variables
String firstName;
String middleName;



Problem-Solving Case Study | 589

String lastName;
Name name;

if (event.getActionCommand().equals("Enter"))
{ // Handles Enter event
firstName = firstText.getText();
middleName = middleText.getText();
lastName = lastText.getText();
name = new Name(firstName, middleName, lastName);
masterList.delete(name);
presentList.insert(name);

firstText.setText("");                    // Clear text fields
middleText.setText("");
lastText.setText("");

}
else
{ // Handles Quit event
outFile.println("Students that took the exam:");
printList(outfile, presentList);
outfile.println("Students that missed the exam:");
printList(outFile, masterList);
outFile.close();
inputFrame.dispose();                     // Close window
System.exit(0);                           // Quit the program

}
}
private void printList(PrintWriter outFile, SortedList list)
{ // Helper method to print a list
Name name;
list.resetList();
int limit = list.length();
for (int index = 1; index <= limit; index++)
{
name = list.getNextItem();
outFile.println(name.firstLastMid());

}
}

} // End of class ActionHandler

// Class variables for class ExamAttendance
private static Frame inputFrame;
private static TextField firstText;            // First name field
private static TextField middleText;           // Middle name field



590 | Chapter 12:  Array-Based Lists

private static TextField lastText;             // Last name field
private static Name name;                      // A name
private static SortedList masterList;          // List of students
private static SortedList presentList;         // List of those present
private static ExamDataReader dataFile ;       // Master file of students
private static PrintWriter outFile;            // File for printing

public static void main(String[] args) throws IOException
{ // Declare local variables
Label firstLabel;                            // Labels for input fields
Label middleLabel;
Label lastLabel;

Button enter;                                 // Enter button
Button quit;                                  // Quit button
ActionHandler action;                         // Declare listener

// Initialize/instantiate variables
inputFrame = new Frame();
firstLabel = new Label("First Name");
firstText = new TextField("", 15);
middleLabel = new Label("Middle Name");
middleText = new TextField("", 15);
lastLabel = new Label("Last Name");
lastText = new TextField("", 15);

// Instantiate/register buttons and button listener
enter = new Button("Enter");
quit = new Button("Quit");
action = new ActionHandler();
enter.addActionListener(action);
quit.addActionListener(action);

// Instantiate files and lists
outFile = new PrintWriter(new FileWriter("exam.out"));
dataFile = new ExamDataReader(new BufferedReader

(new FileReader("students.dat")));
masterList = new SortedList(200);
presentList = new SortedList(200);

// Get the master list of students
while (dataFile.moreData())
{
name = dataFile.getName();



Problem-Solving Case Study | 591

masterList.insert(name);
}

// Add components to frame
inputFrame.setLayout(new GridLayout(4,2));
inputFrame.add(firstLabel);
inputFrame.add(firstText);
inputFrame.add(middleLabel);
inputFrame.add(middleText);
inputFrame.add(lastLabel);
inputFrame.add(lastText);
inputFrame.add(enter);
inputFrame.add(quit);
inputFrame.pack();                               // Pack the frame
inputFrame.show();                               // Show the frame

}
}

Here is a screen shot of the user interface.

Testing This application is made up of five user-defined classes: Name, List,
SortedList, ExamDataReader, and ExamAttendance. Fortunately, three of the five
classes have already been tested. This is one of the main advantages of object-oriented
programming: Classes can be created, tested, encapsulated into a package, and stored in your
library.

We leave the test plan for ExamDataReader and ExamAttendance as a Case Study
Follow-Up Exercise.



592 | Chapter 12:  Array-Based Lists

Testing and Debugging

We have written a test plan for the unsorted list and the sorted list. However, we have
not tested the sort method that was used in class ListWithSort. Method selectSort
takes an array of items and rearranges the items so that they are in ascending order. If
we write a black-box test plan, what are the end cases that we should test in addition to
the general case? These cases fall into two categories based on length of the list of items
and on the order of the items in the original list:

• The list is empty.
• The list contains one item.
• The list contains more than one item.
• The list contains the maximum number of items.
• The list is already sorted in ascending order.
• The list is sorted in descending order.

We leave it as an exercise to convert this list into a complete test plan.

Testing and Debugging Hints

1. Review the Testing and Debugging Hints from Chapter 11.

2. Be sure that any argument to a list method with a Comparable parameter belongs
to a class that has implemented the Comparable interface.

3. Be careful: Primitive types cannot be passed to a method whose parameter imple-
ments the Comparable interface.

4. General-purpose methods should be tested outside the context of a particular pro-
gram, using a test driver.

5. Choose test data carefully so that you test all end conditions and some in the mid-
dle. End conditions are those that reach the limits of the structure used to store
them. For example, in a list, there should be test data in which the number of com-
ponents is 0, 1, and array size, as well as somewhere in between.

Summary of Classes
Package Name Comments

Class Name

java.lang
Comparable (an interface)

Observers:
compareTo(Object obj) Returns 21 if object to which applied comes before 

obj; 0 if equal; +1 otherwise

(continued)



Summary | 593

Summary
This chapter has provided practice in working with lists where the items are stored in a
one-dimensional array. We have examined algorithms that insert, delete, and search
data stored in an array-based unsorted list, and we have written methods to implement
these algorithms. We have also examined an algorithm that takes the array in which the
list items are stored and sorts them into ascending order.

We have examined several search algorithms: sequential search in an unsorted list,
sequential search in a sorted list, and binary search. The sequential search in an
unsorted list compares each item in the list to the one being searched for. All items must
be examined before it can be determined that the search item is not in the list. The
sequential search in a sorted list can determine that the search item is not in the list
when the place where the item belongs has been passed. The binary search looks for the

Package Name

Class Name Comments

List Abstract Class
Constructors:

List() Default with room for 100 items
List(int maxItems) Sets up room for maxItems items

Observers:
isEmpty() Returns true if the list is empty
isFull() Returns true if the list is full
abstract isThere(Comparable item) Returns true if item is in list

Transformers:
abstract insert(Comparable item) Inserts item in the list
abstract delete(Comparable item) Deletes item if it is there

Iterator:
resetList() Resets for another iteration
getNextItem() Returns the next item in the list

UnsortedList and SortedList
Observer:

isThere(Comparable item) Returns true if item is in list
Transformers:

insert(Comparable item) Inserts item in the list
delete(Comparable item) Deletes item if it is there

ListWithSort derived from UnsortedList
selectSort() Sorts the values in the list



594 | Chapter 12:  Array-Based Lists

search item in the middle of the list. If it is not there, then the search continues in the
half where the item should be. This process continues to cut the search area in half until
either the item is found or the search area is empty.

We have examined the insertion algorithm that keeps the items in the list sorted by
value. We generalized the list in an abstract class List, leaving the insert, delete,
and isThere methods abstract. We demonstrated the Comparable interface as a
way to make the list items generic.

Quick Check
1. What is the difference between a list and an array? (pp. 552–553)
2. If the list is unsorted, does it matter where a new item is inserted? (p. 555)
3. The following code fragment implements the “Delete, if it’s there” meaning

for the Delete operation in an unsorted list. Change it so that the other mean-
ing is implemented; that is, there is an assumption that the item is in the list.
(pp. 555–556)

while (index < numItems && !found)
{
if (listItems[index].compareTo(item) == 0)
found = true;

else
index++;

}
if (found)
{
for (int count = index; count < numItems–1; count++)
listItems[count] = listItems[count+1];

numItems--;
}

4. In a sequential search of an unsorted array of 1,000 values, what is the average
number of loop iterations required to find a value? What is the maximum num-
ber of iterations? (pp. 578–579)

5. The following program fragment sorts list items into ascending order. Change it
to sort into descending order. (pp. 560–562)

for (passCount = 0; passCount < numItems – 1; passCount++)
{
minIndex = passCount;
for (searchIndex = passCount + 1; searchIndex < numItems;

searchIndex++)
if (listItems[searchIndex].compareTo(         

listItems[minIndex]) < 0)



Exam Preparation Exercises | 595

minIndex = searchIndex;
temp = listItems[minIndex];               // Swap
listItems[minIndex] = listItems[passCount];
listItems[passCount] = temp;

}

6. Describe how the insert operation can be used to build a sorted list from
unsorted input data. (pp. 578–579)

7. Describe the basic principle behind the binary search algorithm. (pp. 572–575)

Answers

1. A list is a variable-sized structured data type; an array is a built-in type often used to implement a list.
2. No.
3. index = 0;

while (listItems[index].compareTo(item) != 0)
index++;

for (int count = index; count < numItems–1; count++)
listItems[count] = listItems[count+1];

numItems-=;
4. The average number is 500 iterations. The maximum is 1000 iterations. 5. The only required change is to
replace the less than with greater than in the inner loop. As a matter of style, the name minIndex should be
changed to maxIndex. 6. The list initially has a length of 0. Each time a value is read, insert adds the
value to the list in its correct position. When all the data values have been read, they are in the array in sorted
order. 7. The binary search takes advantage of sorted list values, looking at a component in the middle of
the list and deciding whether the search value precedes or follows the midpoint. The search is then repeated
on the appropriate half, quarter, eighth, and so on, of the list until the value is located.

Exam Preparation Exercises
1. The following values are stored in an array in ascending order.

28  45  97  103  107  162  196  202  257

Applying the unsorted linear search algorithm to this array, search for the fol-
lowing values and indicate how many comparisons are required to either find
the number or find that it is not in the list.
a. 28
b. 32
c. 196
d. 194

2. Repeat Exercise 1, applying the algorithm for a sequential search in a sorted list.
3. The following values are stored in an array in ascending order.

29  57  63  72  79  83  96  104  114  136

Apply the binary search algorithm looking for 114 in this list and trace the val-
ues of first, last, and middle. Indicate any undefined values with a U.

4. (True or False?) A binary search is always better to use than a sequential search.



596 | Chapter 12:  Array-Based Lists

5. If resetList initializes currentPos to 21 rather than 0, what corresponding
change would have to be made in getNextItem?

6. We have said that arrays are homogeneous structures, yet Java implements them
with an associated integer. Explain.

7. Why does the outer loop of the sorting method run from 0 through numItems–2
rather than numItems–1?

8. A method that returns the number of days in a month is an example of (a) a
constructor, (b) an observer, (c) an iterator, or (d) a transformer.

9. A method that adds a constant to the salary of everyone in a list is an example
of (a) a constructor, (b) an observer, (c) an iterator, or (d) a transformer.

10. A method that stores values into a list is an example of (a) a constructor, (b) an
observer, (c) an iterator, or (d) a transformer.

11. What Java construct is implemented using the keyword implements?
12. What kind of class cannot be instantiated?
13. What is the interface that contains method compareTo? What does com-

pareTo return?
14. Class List assumes that there are no duplicate items in the list.

a. Which method algorithms would have to be changed to allow duplicates?
b. Would there still be options for the delete operation? Explain.

Programming Warm-Up Exercises
1. Complete the implementation of UnsortedList as a derived class from abstract

class List.
2. Complete the implementation of ListWithSort as a class derived from

UnsortedList.
3. Derive a subclass of UnsortedList that has the following additional methods:

a. A value-returning instance method named occurrences that receives a sin-
gle parameter, item, and returns the number of times item occurs in the list

b. A Boolean instance method named greaterFound that receives a single
parameter, item, and searches the list for a value greater than item. If such a
value is found, the method returns true; otherwise, it returns false.

c. An instance method named component that returns a component of the list
given a position number (pos). The position number must be within the
range 0 through numItems–1.

d. A copy constructor for the List class that takes a parameter that specifies how
much to expand the array holding the items. Implement the copy constructor by
creating a larger array and copying all of the items in the list into the new array.

4. Complete the implementation of SortedList as a derived class from abstract
class List.

5. Derive a subclass of SortedList that has the additional methods outlined in
Exercise 3.

6. Write a Java Boolean method named exclusive that has three parameters:
item, list1, and list2 (both of class List as defined in this chapter). The
method returns true if item is present in either list1 or list2 but not both.

TE
AM
FL
Y

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

Team-Fly® 



Programming Problems | 597

7. The insert method in class SortedList inserts items into the list in ascending
order. Derive a new class from List that sorts the items in descending order.

8. Exam Preparation Exercise 14 asked you to examine the implication of a list with
duplicates.
a. Design an abstract class ListWithDuplicates that allows duplicate keys.
b. How does your design differ from List?
c. Implement your design where the items are unsorted and delete deletes all of

the duplicate items.
d. Implement your design where the items are sorted and delete deletes all of

the duplicate items.
e. Did you use a binary search in part (d)? If not, why not?

9. Rewrite method insert in class SortedList so that it implements the first
insertion algorithm discussed for sorted lists. That is, the place where the item
should be inserted is found by searching from the beginning of the list. When
the place is found, all the items from the insertion point to the end of the list
are shifted down one position.

Programming Problems
1. A company wants to know the percentages of total sales and total expenses

attributable to each salesperson. Each person has a pair of data lines in the input
file. The first line contains his or her name, last name first. The second line con-
tains his or her sales (int) and expenses (float). Write an application that pro-
duces a report with a header line containing the total sales and total expenses.
Following this header should be a table with each salesperson’s name, percent-
age of total sales, and percentage of total expenses, sorted by salesperson’s
name. Use one of the list classes developed in this chapter.

2. Only authorized shareholders are allowed to attend a stockholders’ meeting. Write
an application to read a person’s name from the keyboard, check it against a list
of shareholders, and print a message on the screen saying whether or not the per-
son may attend the meeting. The list of shareholders is in a file owners.dat in
the following format: first name, blank, last name. Use the end-of-file condition
to stop reading the file. The maximum number of shareholders is 1,000.

Design a user interface similar to the one in the Case Study. If the name does
not appear on the list, the program should repeat the instructions on how to
enter the name and then tell the user to try again. A message saying that the
person may not enter should be printed only after he or she has been given a
second chance to enter the name.

3. Enhance the program in Problem 2 as follows:
a. Print a report file showing the number of stockholders at the time of the

meeting, how many were present at the meeting, and how many people who
tried to enter were denied permission to attend.

b. Follow this summary report with a list of the names of the stockholders, with
either Present or Absent after each name.



598 | Chapter 12:  Array-Based Lists

4. An advertising company wants to send a letter to all its clients announcing a
new fee schedule. The clients’ names are on several different lists in the com-
pany. The various lists are merged to form one file, “clients,” but obviously, the
company does not want to send a letter twice to anyone.

Write an application that removes any names appearing on the list more
than once. On each data line there is a four-digit code number, followed by a
blank and then the client’s name. For example, Amalgamated Steel is listed as

0231 Amalgamated Steel

Your program is to output each client’s code and name, but no duplicates should
be printed. Use one of the list classes developed in this chapter.

Case Study Follow-Up Exercises
1. Write a test plan for application ExamAttendance.
2. If the event handler does not delete the name from the class list when a student

arrives, what other algorithm could be used to determine the names of those stu-
dents that did not attend the exam?

3. Redesign the solution to this problem to use ListWithSort.
4. Implement the design in Question 3.



                      

To be able to declare a two-dimensional array.

To be able to perform fundamental operations on a
two-dimensional array:

Access a component of the array.

Initialize the array.

Print the values in the array.

Process the array by rows.

Process the array by columns.

To be able to declare a two-dimensional array as a
parameter.

To be able to view a two-dimensional array as an array
of arrays.

To be able to declare and process a multidimensional
array.

To be able to describe how floating-point numbers are
represented in the computer.

To be able to avoid errors caused by the limited
numeric precision of the computer.

Multidimensional
Arrays and Numeric
Computation

G
oals



600 | Chapter 13:  Multidimensional Arrays and Numeric Computation

The structures that we choose to hold a collection of data objects play an important role
in the design process. In the last two chapters, we have discussed the one-dimensional
array and its use in problems where the logical representation of the data is a list of
objects. The choice of data structure directly affects the design because it determines the
algorithms used to process the data objects. For example, if the data items are stored in
sorted order within the array, we can apply a binary search algorithm rather than a lin-
ear search.

In many problems, however, the relationships between data items are more complex
than can be represented in a simple list. Examples of complex relationships can be
found in simulations of board games such as chess, Tic-Tac-Toe, or Scrabble, in com-
puter graphics, where points on the screen are arranged as a two-dimensional object, or
in matrix operations in mathematics. In this chapter we examine the two-dimensional
array, which is useful when we need to organize data in two dimensions. We usually
call these dimensions rows and columns.

Then we extend the definition of an array to allow arrays with any number of
dimensions, called multidimensional arrays. Each dimension represents a different fea-
ture of the data objects in the structure. For example, we might use a three-dimensional
array to store objects representing sales figures by (1) store number, (2) month, and (3)
item number.

Finally, we take a closer look at the limitations of the computer in doing calcula-
tions, how these limitations can cause numerical errors, and how to avoid such errors.
This discussion relates directly to our Case Study, where we examine arrays as imple-
mentation structures for the mathematical object matrix.

13.1 Two-Dimensional Arrays
A one-dimensional array is used to represent items in a list or a sequence of values. A
two-dimensional array is used to represent items in a table with rows and columns,

provided each item in the table is of the same type or
class. A component in a two-dimensional array is
accessed by specifying the row and column indexes of
the item in the array. This is a familiar task. For
example, if you want to find a street on a map, you
look up the street name on the back of the map to find
the coordinates of the street, usually a number and a
letter. The number specifies a row, and the letter spec-

ifies a column. You find the street where the row and column meet.
Figure 13.1 shows a two-dimensional array with 100 rows and 9 columns. The rows

are accessed by an integer ranging from 0 through 99; the columns are accessed by an
integer ranging from 0 through 8. Each component is accessed by a row—column pair—
for example, [0][5].

Two-dimensional array A collection of components,
all of the same type or class, structured in two dimen-
sions. Each component is accessed by a pair of indexes
that represent the component’s position in each
dimension.



13.1 Two-Dimensional Arrays | 601

Array Declaration and Instantiation

A two-dimensional array variable is declared in exactly the same way as a one-dimen-
sional array variable, except that there are two pairs of brackets. A two-dimensional
array object is instantiated in exactly the same way, except that sizes must be specified
for two dimensions. Below is the syntax template for declaring an array with two
dimensions, along with an example.

The first two lines of the following code fragment would create the array shown in Fig-
ure 13.1, where the data in the table are floating-point numbers.

double[][] alpha;
alpha = new double[100][9];
String[][] beta;
beta = new String[10][10];

TypeName[][] ArrayName;

ArrayDeclaration

Figure 13.1 alpha array

[0] [1] [2] [3] [4] [5] [6] [7] [8]

[0]

[1]

alpha

Row 0, column 5



[3]

[98]

[99]

•
•
•


Row 98, column 2

[2]

•



602 | Chapter 13:  Multidimensional Arrays and Numeric Computation

The first dimension specifies the number of rows, and the second dimension speci-
fies the number of columns. Once the two-dimensional array has been created,
alpha.length and beta.length give the number of rows in each array.

Accessing Individual Components

To access an individual component of the alpha array, two expressions (one for each
dimension) are used to specify its position. We place each expression in its own pair of
brackets next to the name of the array:

The syntax template for accessing an array component is

As with one-dimensional arrays, each index expression must result in an integer value
between 0 and the number of slots in that dimension minus 1.

Let’s look now at some examples. Here is the declaration of a two-dimensional
array with 364 integer components (52 3 7 = 364):

int[][] hiTemp;
hiTemp = new int[52][7];

hiTemp is an array with 52 rows (indexed from 0 to 51) and 7 (indexed from 0 to 6)
columns. Each place in the array (each component) can contain any int value. Our
intention is that the array contains high temperatures for each day in a year. Each row
represents one of the 52 weeks in a year, and each column represents one of the 7 days
in a week. (To keep the example simple, we ignore the fact that there are 365—and
sometimes 366—days in a year.) The expression hiTemp[2][6] refers to the int value
in the third row and the seventh column. Semantically, hiTemp[2][6] is the tempera-
ture for the seventh day of the third week. The code fragment shown in Figure 13.2
would print the temperature values for the third week.

To obtain the number of columns in a row of an array we access the length field for
the specific row. For example, the statement

midYear = hiTemp[26].length;

stores the length of row 26 of array hiTemp, which is 7, into the int variable midYear.

ArrayName [IndexExpression]  [IndexExpression] . . .  

ArrayComponentAccess

alpha[0][5] = 36.4;

Row
number

Column
number



13.1 Two-Dimensional Arrays | 603

Using Initializer Lists

Just as a one-dimensional array can be created with a list of values, a two-dimensional
array can be created with a list of a list of values. For example, the following statement
instantiates a two-dimensional array of hits. This array represents the hits for a five-day
period for your four favorite baseball players.

int[][] hits = {{2, 1, 0, 3, 2}
{1, 1, 2, 3, 4}
{1, 0, 0, 0, 0}
{0, 1, 2, 1, 1}};

As in the case of one-dimensional array, you do not use new with an initializer list.
Now what would happen if one of your favorite players went into a slump, and the
manager gave him a rest for a few days? How could you represent that in your array?
Let’s say that the third player sat out three games. Here is how you would represent it.

int[][] hits = {{2, 1, 0, 3, 2}
{1, 1, 2, 3, 4}
{1, 0}
{0, 1, 2, 1, 1}};

The third row in the table would have only two columns, not five like the others. This
array now is an example of a ragged array, one in which the lengths of the rows are not

Figure 13.2 hiTemp array

[0] [1] [2]   • • •   



[6]

[0]

[1]

[2]

[51]

•
•
•


hiTemp

hiTemp[2][6]

//Print temperature values
// for 3rd week (row 2)

for (day = 0; day < 7; day++)
    outFile.println(hiTemp[2][day]);

•



604 | Chapter 13:  Multidimensional Arrays and Numeric Computation

Figure 13.3 Java implementation of hiTemp array

[0] [1] [2]   • • •   [6]

[0]

[1]

[2]

[51]

•
•
•


hiTemp

hiTemp[2][6]

//Print temperature values
// for 3rd week (row 2)

for (day = 0; day < 7; day++)
  outFile.println(hiTemp[2][day]);

•

•

•

•

•

•
•
•


•
•
•


the same. In fact, we could instantiate the same ragged array as follows:

int[][] hits;
hits = new int[4][];
hits[0] = new int[5];
hits[1] = new int[5];
hits[2] = new int[2];
hits[3] = new int[5];

If we then access the length of the second and third rows with the following code,

one = hits[1].length;
two = hits[2].length;

we would find that variable one has been assigned 5 and variable two contains 2.
The moral here is that in Java each row of a two-dimensional array is itself a one-

dimensional array. Many programming languages directly support two-dimensional
arrays; Java doesn’t. In Java, a two-dimensional array is an array of references to array
objects. Because of the way that Java handles two-dimensional arrays, the drawings in
Figures 13.1 and 13.2 are not quite accurate. Figure 13.3 shows how Java actually
implements the array hiTemp.

From the Java programmer’s perspective, however, the two views are synonymous
in the majority of applications. We typically instantiate arrays with the same number of
columns in every row and rarely create a ragged array. So we continue to use the styl-
ized version.

13.2 Processing Two-Dimensional Arrays
Processing data in a two-dimensional array generally means accessing the array in one
of four patterns: randomly, along rows, along columns, or throughout the entire array.
Each of these may also involve subarray processing.



13.2 Processing Two-Dimensional Arrays | 605

The simplest way to access a component is to look directly in a given location. For
example, a user enters map coordinates that we use as indexes into an array of street
names to access the desired name at those coordinates. This process is referred to as
random access because the user may enter any set of coordinates at random.

There are many cases in which we might wish to perform an operation on all the
elements of a particular row or column in an array. Consider the hiTemp array defined
previously, in which the rows represent weeks of the year and the columns represent
days of the week. If we wanted the average high temperature for a given week, we
would sum the values in that row and divide by 7. If we wanted the average for a given
day of the week, we would sum the values in that column and divide by 52. The former
case shows access by row; the latter case shows access by column.

Now suppose that we wish to determine the average for the year. We must access
every element in the array, sum them, and divide by 364. In this case, the order of
access—by row or by column—is not important. (The same is true if we initialize every
element of an array to a constant.) This is access throughout the array.

There are times when we must access every array element in a particular order,
either by rows or by columns. For example, if we wanted the average for every week, we
would run through the entire array, taking each row in turn. However, if we wanted the
average for each day of the week, we would run through the array a column at a time.

Let’s take a closer look at these patterns of access by considering three common
examples of array processing.

1. Sum the rows.
2. Sum the columns.
3. Initialize the array to some special value.

In the following discussion, we use the generic identifiers row and col, rather than
problem-dependent identifiers, and we look at each algorithm in terms of generalized
two-dimensional array processing. The array that we use is declared and instantiated by
the following statement:

int[][] data = new int[50][30]; // A two-dimensional array

In what follows, we assume that data contains valid information.

Sum the Rows

Suppose we want to sum row number 3 (the fourth row) in the array and print the
result. We can do this easily with a for loop:

int total = 0;
for (int col = 0; col < data[3].length; col++)
total = total + data[3][col];

outFile.println("Row sum: " + total);



606 | Chapter 13:  Multidimensional Arrays and Numeric Computation

This for loop runs through each column of data while keeping the row index fixed at 3.
Every value in row 3 is added to total.

Now suppose we want to sum and print two rows—row 2 and row 3. We can use a
nested loop and make the row index a variable:

for (int row = 2; row <= 3; row++)
{
total = 0;
for (int col = 0; col < data[row].length; col++)

total = total + data[row][col];
outFile.println("Row sum: " + total);

}

The outer loop controls the rows, and the inner loop controls the columns. For each
value of row, every column is processed; then the outer loop moves to the next row. In
the first iteration of the outer loop, row is held at 2 and col goes from 0 through
data[2].length. Therefore, the array is accessed in the following order:

data[2][0]    [2][1]     [2][2]     [2][3]    ...    [2][29]

In the second iteration of the outer loop, row is incremented to 3, and the array is
accessed as follows:

data[3][0]     [3][1]     [3][2]     [3][3]    ...   [3][29]

We can generalize this row processing to run through every row of the array by
having the outer loop run from 0 to data.length. However, if we want to access only
part of the array (subarray processing), given variables declared as

int rowsFilled;   // Data is in 0..rowsFilled–1
int colsFilled;   // Data is in 0..colsFilled–1

then we write the code fragment as follows:

for (int row = 0; row < rowsFilled; row++)
{
// Array is not ragged
total = 0;
for (int col = 0; col < colsFilled; col++)
total = total + data[row][col];

outFile.println("Row sum: " + total);
}

This is an example of subarray processing by row. Figure 13.4 illustrates subarray pro-
cessing by row.

TE
AM
FL
Y

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

Team-Fly® 



13.2 Processing Two-Dimensional Arrays | 607

Sum the Columns

Suppose we want to sum and print each column. The code to perform this task follows.
Again, we have generalized the code to sum only the portion of the array that contains
valid data.

for (int col = 0; col < colsFilled; col++)
{
// Array is not ragged
total = 0;
for (int row = 0; row < rowsFilled; row++)
total = total + data[row][col];

outFile.println("Column sum: " + total);
}

In this case, the outer loop controls the column, and the inner loop controls the row. All
the components in the first column are accessed and summed before the outer loop
index changes and the components in the second column are accessed. Figure 13.5
illustrates subarray processing by column.

Figure 13.4 Partial array processing by row

[0] [1] [2]  • • •   



[colsFilled-1] arr[i].length-1• • •

[0]

[1]

[2]

•
•
•


•
•
•


[rowsFilled-1]

arr.length-1

arr

•



608 | Chapter 13:  Multidimensional Arrays and Numeric Computation

Figure 13.5 Partial array processing by column

arr

[0] [1] [2]  • • •   



[colsFilled-1] arr[i].length-1• • •

[0]

[1]

[2]

•
•
•


•
•
•


[rowsFilled-1]

arr.length-1



•

Initialize the Array

Instantiating an array with initializer lists is impractical if the array is large. For a 100-
row by 100-column array, you don’t want to list 10,000 values. If the values are all differ-
ent, you should store them into a file and input them into the array at run time. If the
values are all the same, the usual approach is to use nested for loops and an assignment
statement. Here is a general-purpose code segment that sets every item in the array to 21:

for (int row = 0; row < data.length; row++)
for (int col = 0; col < data[row].length; col++)
data[row][col] = –1;

In this case, we initialized the array a row at a time, but we could just as easily have run
through each column instead. The order doesn’t matter as long as we access every element.

Almost all processing of data stored in a two-dimensional array involves either pro-
cessing by row or processing by column. The looping patterns for row processing and
column processing are so useful that we summarize them on the following page. To
make them more general, we use minRow for the first row number and minCol for the
first column number. Remember that row processing has the row index in the outer
loop, and column processing has the column index in the outer loop.



13.2 Processing Two-Dimensional Arrays | 609

Row Processing

for (int row = minRow; row < rowsFilled; row++)
for (int col = minCol; col < colsFilled; col++)
// Whatever  processing  is required

Column Processing

for (int col = minCol; col < colsFilled; col++)
for (int row = minRow; row < rowsFilled; row++)
// Whatever  processing  is required

Two-Dimensional Arrays and Methods

Two-dimensional arrays can be parameters to methods, and they can be the return value
type for a method. The syntax and semantics are identical to those for one-dimensional
arrays, except there is an additional pair of brackets. Let’s enclose the array initializa-
tion code fragment within a method.

public static void initialize(int[][] data)
// Set every cell in data to 0
{
for (int row = 0; row < data.length; row++)
for (int col = 0; col < data[row].length; col++)
data[row][col] = 0;

}

Because Java has a field associated with each array that contains the number of slots
defined for the array, we do not have to pass this information as a parameter as we do in
many other languages. This is a consequence of the object orientation of the language.
The array is an object and the information about the object is encapsulated with it.

As an example of a value returning method, let’s design one that returns a copy of
the array passed as a parameter. All the information we need to instantiate the new array
is present in the one passed as a parameter. We just instantiate it and copy in the values.

public static int[][] copy(int[][] data)
// Returns a deep copy of data
{
int[][] copyData = new int[data.length] [data[0].length];
for (int row = 0; row < data.length; row++)
for (int col = 0; col < data[row].length; col++)
copyData[row][col] = data[row][col];

return copyData;
}



610 | Chapter 13:  Multidimensional Arrays and Numeric Computation

13.3 Multidimensional Arrays
Java does not place a limit on the number of dimensions that an array can have. We
can generalize our definition of an array to cover all cases.

You might have guessed that you can have as
many dimensions as you want. How many should you
have in a particular case? Use as many as there are
features that describe the components in the array.

Take, for example, a chain of department stores.
Monthly sales figures must be kept for each item by
store. There are three important pieces of information
about each item: the month in which it was sold, the

store from which it was purchased, and the item number. We can define an array type
to summarize this data as follows:

int[][][] sales;                // Declare array of sales figures
// First dimension represents number of stores;
//  second dimension represents months;
//  third dimension represents items
sales = new int[100][12][10];   // Instantiate array

A graphic representation of the sales array is shown in Figure 13.6.
The number of components in sales is 12,000 (10 3 12 3 100). If sales figures are

available only for January through June, then half the array is empty. If we want to
process the data in the array, we must use subarray processing. The following program
fragment sums and prints the total number of each item sold this year to date by all stores.

int currentMonth = 6;    // Range: 1..12

for (int item = 0; item < sales[0][0].length; item++)
{
numberSold = 0;
for (int store = 0; store < sales.length; store++)
for (int month = 0; month < currentMonth; month++)
numberSold = numberSold + sales[store][month][item];

outFile.println("Item # " + item + " Sales to date = "
+ numberSold);

}

Because item controls the outer for loop, we are summing each item’s sales by
month and store. If we want to find the total sales for each store, we use store to
control the outer for loop, summing its sales by month and item with the inner loops.

Array A collection of components, all of the same
type or class, ordered on N dimensions (N >= 1). Each
component is accessed by N indexes, each of which
represents the component’s position within that
dimension.



13.3 Multidimensional Arrays | 611

int currentMonth = 6;

for (int store = 0; store < sales.length; store++)
{
numberSold = 0;
for (item = 0; item < sales[0][0].length; item++)
for (int month = 0; month < currentMonth; month++)
numberSold = numberSold + sales[store][month][item];

outFile.println("Store # "  + store + " Sales to date = "
+ numberSold);

}

It takes two loops to access each component in a two-dimensional array; it takes
three loops to access each component in a three-dimensional array. The task to be
accomplished determines which index controls the outer loop, the middle loop, and the
inner loop. If we want to calculate monthly sales by store, then month controls the
outer loop and store controls the middle loop. If we want to calculate monthly sales by
item, then month controls the outer loop and item controls the middle loop.

Multidimensional arrays can be passed as parameters and can be the return type of
a method. Just be sure that you have as many brackets as you have dimensions follow-
ing the type name.

Vector Class

We cannot leave the discussion of arrays without mentioning a class that is available in
the java.util package: the Vector class. The functionality of the Vector class is sim-
ilar to that of the array. In fact, the array is the underlying implementation structure
used in the class. In contrast to an array, however, a vector can grow and shrink; its size

Figure 13.6 sales array

item
s

st
or

es

months

••
•

••
•

••
•

••
•

••
•

••
•



612 | Chapter 13:  Multidimensional Arrays and Numeric Computation

is not fixed for its lifetime. The class provides methods to manipulate items at specified
index positions. In many ways, the vector is like the general purpose list classes that we
designed in the last chapter. We explore the Vector class in more detail in the exercises.

13.4 Floating-Point Numbers
We have used floating-point numbers off and on since we introduced them in Chapter
2, but we have not examined them in depth. Floating-point numbers have special prop-
erties when used on the computer. Thus far, we’ve almost ignored these properties, but
now it’s time to consider them in detail.

Representation of Floating-Point Numbers

As we know, Java represents numbers in the binary number system and its different
numeric types use different numbers of bits. But let’s assume, to simplify the following
discussion, that we have a computer in which each memory location is the same size
and is divided into a sign plus five decimal digits. When a variable or constant is
defined, the location assigned to it consists of five digits and a sign. When an integral
variable or constant is defined, the interpretation of the number stored in that place is
straightforward. When a floating-point variable or constant is defined, the number
stored there has both a whole number part and a fractional part, so it must be coded to
represent both parts.

Let’s see what such coded numbers might look like. The range of whole numbers we
can represent with five digits is 299,999 through +99,999:

Our precision (the number of digits we can represent)
is five digits, and each number within that range can
be represented exactly.

What happens if we allow one of those digits (the
leftmost one, for example) to represent an exponent?

+ 8 2 3 4 5

Exponent

+ 9 9 9 9 9 Largest positive number

+ 0 0 0 0 0 Zero

– 9 9 9 9 9 Largest negative number

–99999 through +99999

Precision The maximum number of significant digits



13.4 Floating-Point Numbers | 613

Then +82345 represents the number +2345 3 108. The range of numbers we now can
represent is much greater:

29999 3 109 through 9999 3 109

or

29,999,000,000,000 through +9,999,000,000,000

However, our precision is now only four digits; that is, only four-digit numbers can
be represented exactly in our system. What happens to numbers with more digits? The
four leftmost digits are represented correctly,
and the rightmost digits, or least significant
digits, are lost (assumed to be 0). Figure 13.7
shows what happens. Note that 1,000,000 can
be represented exactly but 24,932,416 can-
not, because our coding scheme limits us to
four significant digits.

To extend our coding scheme to represent
floating-point numbers, we must be able to represent negative exponents. Examples are

7394 3 1022 = 73.94

and

22 3 1024 = .0022

Significant digits Those digits from the first nonzero
digit on the left to the last nonzero digit on the right
(plus any 0 digits that are exact)

Figure 13.7 Coding using positive exponents

Sign Exp

+ 1 9 9 9 9 +99,990
+9999 3 101+99,999

Sign Exp

– 2 9 9 9 9 –999,900
–9999 3 102–999,999

Sign Exp

+ 3 1 0 0 0 +1,000,000
–1000 3 103+1,000,000

Sign Exp

– 3 4 9 3 2 –4,932,000
–4932 3 103–4,932,416

CODED REPRESENTATION VALUEPOWER OF TEN
NOTATION

NUMBER



614 | Chapter 13:  Multidimensional Arrays and Numeric Computation

Figure 13.8 Coding using positive and negative exponents

+ + 9 9 9 9 Largest positive number:  +9999 3 109

– + 9 9 9 9 Largest negative number:  –9999 3 109

+ – 9 0 0 1 Smallest positive number:  +1 3 10–9

– – 9 0 0

9

9

0

0 1 Smallest negative number:  –1 3 10–9

Sign Exp

Sign of
number

Sign of
exponent

Figure 13.9 Coding of some floating-point numbers

0.1032+1032 3 10–40.1032

–5.406–5406 3 10–3–5.4060

–0.0030–3000 3 10–6–0.003

476.0+4760 3 10–1476.0321

CODED REPRESENTATION VALUEPOWER OF TEN
NOTATION

NUMBER

+ – 4 1 3 2

– – 3 5 0 6

– + 9 9 9 9

– – 6 3 0 0

0

4

0

+ – 1 4 6 07

Sign Exp

Because our scheme does not include a sign for the exponent, let’s change it
slightly. The existing sign becomes the sign of the exponent, and we add a sign to the
far left to represent the sign of the number itself (see Figure 13.8).

All the numbers between 29999 3 109 and 9999 3 109 can now be represented
accurately to four digits. Adding negative exponents to our scheme allows us to repre-
sent fractional numbers as small as 1 3 1029.

Figure 13.9 shows how we would encode some floating-point numbers. Note that
our precision is still only four digits. The numbers 0.1032, 25.406, and 1,000,000 can
be represented exactly. The number 476.0321, however, with seven significant digits, is
represented as 476.0; the 321 cannot be represented. (We should point out that some
computers, including all JVMs, perform rounding rather than simple truncation when
discarding excess digits. Using our assumption of four significant digits, rounding



13.4 Floating-Point Numbers | 615

would store 476.0321 as 476.0 but would store 476.0823 as 476.1. We continue our dis-
cussion assuming simple truncation rather than rounding.)

Arithmetic with Floating-Point Numbers

When we use integer arithmetic, our results are exact. Floating-point arithmetic, how-
ever, is seldom exact. To understand why, let’s add three floating-point numbers x, y,
and z using our coding scheme.

First, we add x to y and then we add z to the result. Next, we perform the operations
in a different order, adding y to z and then adding x to that result. The associative law
of arithmetic says that the two answers should be the same—but are they? Let’s use the
following values for x, y, and z:

x = 21324 3 103 y = 1325 3 103 z = 5424 3 100

Here is the result of adding z to the sum of x and y:

Now here is the result of adding x to the sum of y and z:

These two answers are the same in the thousands place but are different thereafter.
The error behind this discrepancy is called representational error.

Because of representational errors, it is
unwise to use a floating-point variable as a
loop-control variable. Because precision may
be lost in calculations involving floating-point
numbers, it is difficult to predict when (or
even if ) a loop-control variable of type float
(or double) equals the termination value. A

= 1330 � 103 (truncated to four digits)

= 6000 � 100� x + ( y + z)

1330 � 103

–1324 � 103
����

6 � 103

1325000 � 100

5424 � 100
����

1330424 � 100

(y)
(z)

(y + z)
(x)

←

3

3

3

3

3

3

3

3

� 1000 × 100

← (x � y ) � z

1000 × 100

5424 × 100
����

6424 × 100

–1324 × 103

1325 × 103
����

1 × 103

(x)

(y)

(x + y)

(z)

Representational error Arithmetic error that occurs
when the precision of the true result of an arithmetic
operation is greater than the precision of the machine



616 | Chapter 13:  Multidimensional Arrays and Numeric Computation

(or double) equals the termination value. A count-controlled loop with a floating-point
control variable can behave unpredictably.

Also because of representational errors, you should never compare floating-point
numbers for exact equality. Rarely are two floating-point numbers exactly equal, and
thus you should compare them only for near equality. If the difference between the two
numbers is less than some acceptable small value, you can consider them equal for the
purposes of the given problem.

Implementation of Floating-Point Numbers in the Computer

All computers limit the precision of floating-point numbers, although modern machines
use binary rather than decimal arithmetic. In our representation, we used only five dig-
its to simplify the examples, and some computers really are limited to only four or five
digits of precision. Some systems provide six significant digits, 15 significant digits, and
19 significant digits, respectively, for three sizes of floating-point types. We have shown
only a single-digit exponent, but most systems allow two digits for the smaller floating-
point type and up to four-digit exponents for a longer type.

Some languages leave the range and precision of floating-point types to each indi-
vidual compiler, but Java states the range and precision in the language specification in
the following formula:

s 3 m 3 2e

where s is + 1 or 21, m is a positive integer less than 224, and e is between 2149 and
104, inclusive, for values of type float. For values of type double, m is less than 253
and e is between 21075 and 970. No, we don’t expect you to calculate this. Each Java
numeric type provides constants MAX_VALUE and MIN_VALUE. One of the exercises asks
you to print out these values for each type.

When you declare a floating-point variable, part of the memory location contains
the exponent, and the number itself (called the mantissa) is assumed to be in the bal-
ance of the location. The system is called floating-point representation because the
number of significant digits is fixed, and the decimal point conceptually is allowed to
float (move to different positions as necessary). In our coding scheme, every number is
stored as four digits, with the leftmost digit being nonzero and the exponent adjusted
accordingly. Numbers in this form are said to be normalized. The number 1,000,000 is
stored as

and 0.1032 is stored as

Normalization provides the maximum precision possible.

+ – 4 1 0 3 2

+ + 3 1 0 0 0

TE
AM
FL
Y

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

Team-Fly® 



13.4 Floating-Point Numbers | 617

In Java, values of type float use 32 bits with an approximate range of 61.4E245
to 63.4E138 with seven significant digits. Values of type double use 64 bits with an
approximate range of 64.9E2324 to 1.7E1308 with 15 significant digits.

Model Numbers Any real number that can be represented exactly as a floating-point
number in the computer is called a model number. A real number whose value cannot
be represented exactly is approximated by the model number closest to it. In our system
with four digits of precision, 0.3021 is a model number. The values 0.3021409,
0.3021222, and 0.30209999999 are examples of real numbers that are represented in
the computer by the same model number. The following table shows all of the model
numbers for an even simpler floating-point system that has one digit in the mantissa
and an exponent that can be 21, 0, or 1.

0.1 3 10–1 0.1 3 10+0 0.1 3 10+1

0.2 3 10–1 0.2 3 10+0 0.2 3 10+1

0.3 3 10–1 0.3 3 10+0 0.3 3 10+1

0.4 3 10–1 0.4 3 10+0 0.4 3 10+1

0.5 3 10–1 0.5 3 10+0 0.5 3 10+1

0.6 3 10–1 0.6 3 10+0 0.6 3 10+1

0.7 3 10–1 0.7 3 10+0 0.7 3 10+1

0.8 3 10–1 0.8 3 10+0 0.8 3 10+1

0.9 3 10–1 0.9 3 10+0 0.9 3 10+1

The difference between a real number and the model number that represents it is a
form of representational error called rounding error. We can measure rounding error in
two ways. The absolute error is the difference between the real number and the model
number. For example, the absolute error in representing 0.3021409 by the model num-
ber 0.3021 is 0.0000409. The relative error is the absolute error divided by the real num-
ber and is sometimes stated as a percentage. For example, 0.0000409 divided by
0.3021409 is 0.000135, or 0.0135%.

The maximum absolute error depends on the model interval—the difference between
two adjacent model numbers. In our example, the interval between 0.3021 and 0.3022 is
0.0001. The maximum absolute error in this system, for this interval, is less than 0.0001.
Adding digits of precision makes the model interval (and thus the maximum absolute
error) smaller.

The model interval is not a fixed number; it varies with the exponent. To see why
the interval varies, consider that the interval between 3021.0 and 3022.0 is 1.0, which is
104 times larger than the interval between 0.3021 and 0.3022. This makes sense,
because 3021.0 is simply 0.3021 times 104. Thus, a change in the exponent of the model
numbers adjacent to the interval has an equivalent effect on the size of the interval. In
practical terms, this means that we give up significant digits in the fractional part in
order to represent numbers with large integer parts. Figure 13.10 illustrates this by
graphing all of the model numbers listed in the preceding table.



618 | Chapter 13:  Multidimensional Arrays and Numeric Computation

We also can use relative and absolute error to measure the rounding error resulting
from calculations. For example, suppose we multiply 1.0005 by 1,000. The correct result
is 1000.5, but because of rounding error, our four-digit computer produces 1000.0 as its
result. The absolute error of the computed result is 0.5, and the relative error is 0.05%.
Now suppose we multiply 100,050.0 by 1,000. The correct result is 100,050,000, but the
computer produces 100,000,000 as its result. If we look at the relative error, it is still a
modest 0.05%, but the absolute error has grown to 50,000. Notice that this example is
another case of changing the size of the model interval.

Whether it is more important to consider the absolute error or the relative error
depends on the situation. It is unacceptable for an audit of a company to discover a
$50,000 accounting error; the fact that the relative error is only 0.05% is not important.
On the other hand, a 0.05% relative error is acceptable in representing prehistoric dates
because the error in measurement techniques increases with age. That is, if we are talk-
ing about a date roughly 10,000 years ago, an absolute error of 5 years is acceptable; if
the date is 100,000,000 years ago, then an absolute error of 50,000 years is equally
acceptable.

Comparing Floating-Point Numbers We have cautioned against comparing floating-
point numbers for exact equality. Our exploration of representational errors in this
chapter reveals why calculations may not produce the expected results even though it
appears that they should. In Chapter 10, we wrote an expression that compares two
floating-point variables r and s for near equality using the floating-point absolute
value method abs:

Math.abs(r – s) < 0.00001

From our discussion of model numbers, you now can recognize that the constant
0.00001 in this expression represents a maximum absolute error. We can generalize this
expression as

Math.abs(r – s) < ERROR_TERM

where ERROR_TERM is a value that must be determined for each programming problem.

Figure 13.10 A graphical representation of model numbers

 0.01 to 0.09

 0.1
 0.2

 0.5
 0  1  2  3  4  5  6  7  8  9



13.4 Floating-Point Numbers | 619

What if we want to compare floating-point numbers with a relative error measure?
We must multiply the error term by the value in the problem that the error is relative to.
For example, if we want to test whether r and s are “equal” within 0.05% of s, we write
the following expression:

Math.abs(r – s) < 0.0005 * s

Keep in mind that the choice of the acceptable error and whether it should be
absolute or relative depends on the problem being solved. The error terms we have
shown in our example expressions are completely arbitrary and may not be appropriate
for most problems. In solving a problem that involves the comparison of floating-point
numbers, you typically want an error term that is as small as possible. Sometimes the
choice is specified in the problem description or is reasonably obvious. Some cases
require careful analysis of both the mathematics of the problem and the representational
limits of the particular computer. Such analyses are the domain of a branch of mathe-
matics called numerical analysis and are beyond the scope of this text.

Underflow and Overflow In addition to representational errors, there are two other
problems to watch out for in floating-point arithmetic: underflow and overflow.

Underflow is the condition that arises when the value of a calculation is too small
to be represented. Going back to our decimal representation, let’s look at a calculation
involving small numbers:

This value cannot be represented in our scheme because the exponent 213 is too small.
Our minimum is 29. One way to resolve the problem is to set the result of the calcula-
tion to 0.0. Obviously, any answer depending on this calculation will not be exact.

Overflow is a more serious problem because there is no logical recourse when it
occurs. For example, the result of the calculation

cannot be stored, so what should we do? To be consistent with our response to underflow,
we could set the result to 9999 3 109 (the maximum representable value in this case). Yet
this seems intuitively wrong. The alternative is to stop with an error message.

In Java, if an overflow occurs, the result is set to signed infinity. If an underflow
occurs, the result is set to a signed zero. No exception is thrown in either case.

9999 3 109
3 1000 3 109

9999000 3 1018 = 9999 3 1021

4210 3 1028
3 2000 3 1028

8420000 3 10216 = 8420 3 10213



620 | Chapter 13:  Multidimensional Arrays and Numeric Computation

Although we are discussing problems with floating-point numbers, integer numbers
also can overflow both negatively and positively. All implementations of Java ignore
integer overflow and underflow. To see how your system handles the situation, try
adding 1 to a byte variable that has been set to 127 and adding 21 to a byte variable
that has been set to 2127.

Sometimes you can avoid overflow by arranging computations carefully. Suppose
you want to know how many different five-card poker hands can be dealt from a deck
of cards. What we are looking for is the number of combinations of 52 cards taken 5 at
a time. The standard mathematical formula for the number of combinations of n things
taken r at a time is

We could write a method factorial and write this formula in an assignment
statement:

hands = factorial(52) / (factorial(5) * factorial(47));

The only problem is that 52! is a very large number (approximately 8.0658 3 1067).
And 47! is also large (approximately 2.5862 3 1059). Both of these numbers are well
beyond the capacity of the JVM to represent exactly (52! requires 68 digits of precision).
Even though these numbers can be represented as floating-point numbers, most of the
precision is still lost. By rearranging the calculations, however, we can achieve an exact
result with any integral type with nine or more digits of precision (with int in Java).
How? Consider that most of the multiplications in computing 52! are canceled when the
product is divided by 47!

So, we really only have to compute

hands = 52 * 51 * 50 * 49 * 48 / Factorial(5);

which means the numerator is 311,875,200 and the denominator is 120. If we have nine
or more digits of precision, we get an exact answer: 2,598,960 poker hands.

Cancellation Error Another type of error that can happen with floating-point numbers
is called cancellation error, a form of representational error that occurs when numbers
of widely differing magnitudes are added or subtracted. Let’s look at an example:

(1 + 0.00001234 2 1) = 0.00001234

52
5 47

52 51 50 49 47 46 45 44
5 4 3 2 1 47 46 45 44

!
! !×

= × × × × × × × ×
× × × ×( ) × × × ×( )

K

K

n

r n r

!
! !−( )



13.4 Floating-Point Numbers | 621

The laws of arithmetic say this equation should be true. But is it true if the computer
does the arithmetic?

To four digits, the sum is 1000 3 1023. Now the computer subtracts 1:

The result is 0, not .00001234.
Sometimes you can avoid adding two floating-point numbers that are drastically

different in size by carefully arranging the calculations. Suppose a problem requires
many small floating-point numbers to be added to a large floating-point number. The
result is more accurate if the program first sums the smaller numbers to obtain a larger
number and then adds the sum to the large number.

1000 3 1023
21000 3 1023

0

100000000 3 1028
1       1234 3 1028

100001234 3 1028

Background Information
Practical Implications of Limited Precision

A discussion of representational, overflow, underflow, and cancellation errors may seem
purely academic. In fact, these errors have serious practical implications in many problems.
We close this section with three examples illustrating how limited precision can have
costly or even disastrous effects.

During the Mercury space program, several of the spacecraft splashed down a consider-
able distance from their computed landing points. This delayed the recovery of the space-
craft and the astronaut, putting both in some danger. Eventually, the problem was traced
to an imprecise representation of Earth’s rotation period in the program that calculated the
landing point.

As part of the construction of a hydroelectric dam, a long set of high-tension cables
had to be constructed to link the dam to the nearest power-distribution point. The
cables were to be several miles long, and each one was to be a continuous unit.
(Because of the high power output from the dam, shorter cables couldn’t be spliced
together.) The cables were constructed at great expense and strung between the two

tcontinued



622 | Chapter 13:  Multidimensional Arrays and Numeric Computation

points. It turned out that they were too short, however, so another set had to be manu-
factured. The problem was traced to errors of precision in calculating the length of the
catenary curve (the curve that a cable forms when hanging between two points).

An audit of a bank turned up a mysterious account with a large amount of money in it.
The account was traced to an unscrupulous programmer who had used limited precision to
his advantage. The bank computed interest on its accounts to a precision of a tenth of a cent.
The hundredths of cents were not added to the customers’ accounts, so the programmer had
the extra tenths for all the accounts summed and deposited into an account in his name.
Because the bank had thousands of accounts, these tiny amounts added up to a large amount
of money. And because the rest of the bank’s programs did not use as much precision in their
calculations, the scheme went undetected for many months.

The moral of this discussion is twofold: (1) The results of floating-point calculations are
often imprecise, and these errors can have serious consequences; and (2) if you are work-
ing with extremely large numbers or extremely small numbers, you need more information
than this book provides and should consult a numerical analysis text.

Practical Implications of Limited Precision

Software Engineering Tip
Choosing a Numeric Data Type

A first encounter with all the numeric data types of Java may leave you feeling over-
whelmed. To help in choosing an alternative, you may even feel tempted to toss a coin. You
should resist this temptation because each data type exists for a reason. Here are some guide-
lines:

1. In general, int is preferable. As a rule, you should use floating-point types only when
absolutely necessary—that is, when you definitely need fractional values. Not only is float-
ing-point arithmetic subject to representational errors, it also is significantly slower than
integer arithmetic on most computers.

2. For ordinary integer data, use int instead of byte or short. It’s easy to make overflow
errors with these smaller data types.

3. Use long only if the range of int values is too restrictive. Compared to int, the long
type requires twice the memory space.

4. double is the default floating type in Java and should be used unless you are certain that
a problem can be solved with the lower precision of the float type.

By following these guidelines, you’ll find that the simple types you use most often are int
and double, along with char for character data and boolean for Boolean data. Only
rarely do you need the longer or shorter variations of these fundamental types.



Problem-Solving Case Study | 623

Problem-Solving Case Study
MatrixManipulation

Problem Many mathematical problems, such as rotations in graphics, require the addition,
subtraction, and multiplication of two matrices. Design and implement a general-purpose
Matrix class that provides the operations addition, subtraction, and multiplication for real
matrices.

Brainstorming You reach for your algebra book to refresh your memory on what matrices are
and how matrix addition, subtraction, and multiplication are defined. You find that a matrix is
just like an array data type—well, not exactly. A matrix is a mathematical object; an array is a
structured data type. A more accurate statement is that an array is a perfect structure to
implement a matrix.

Before we start to design the user interface for the Matrix class, we review what the
operations on matrices mean. To add two matrices, you add the values in the corresponding
positions: result[i][j] = A[i][j] + B[i][j]. To subtract one matrix from another, you subtract the
values in the corresponding positions: result[i][j] = A[i][j] 2 B[i][j]. A + B and A 2 B are only
defined on matrices with the same dimensions.

Matrix multiplication is slightly more complex. If matrix E is the result of multiplying
matrix C and matrix D, then

E[i][j] = C[i][1]*D[1][j] + C[i][2]*D[2][j] + ... + C[i][n]*D[n][j].

Why didn’t we use the same matrices, A and B, for multiplication that we used for addition
and subtraction? Well, matrices A and B cannot be multiplied. Look carefully at the formula:
The first row of C is being multiplied item by item by the first column of D and the values

A

5 0 1 4
2 1 3 2
1 1 0 0
1 2 3 4
2 3 1 0

= B

1 1 1 2
2 1 0 3
1 2 4 1
0 0 4 5
0 0 1 1

=

A B+

6 1 2 6
4 2 3 5
2 3 4 1
1 2 7 9
2 3 2 1

= A B–

4 1– 0 2
0 0 3 1–
0 1– 4– 1–
1 2 1– 1–
2 3 0 1–

=



624 | Chapter 13:  Multidimensional Arrays and Numeric Computation

summed. Therefore, the number of columns in C must be equal to the number of rows in D in
the preceeding formula. Here is an example.

The sum of multiplying a row by a column is called the dot product. Another way of stating
multiplications is that for any position i, j in E

E[i][j] = dot product of row i and column j

Now that we understand the semantics of the operations, we are ready to determine the
responsibilities.

Scenario If we were the users of the class, what facilities would we need? First, of course,
we would need to create the matrix itself by telling it how many rows and columns there
should be. Next, we would need a way to put values into the slots of the matrix. We would
probably want to print out the matrix after it is constructed to be sure the values were correct.
At that point, we would be ready to apply one of the binary operations, say, addition. We send
the message to one matrix to add itself to the matrix in the message parameter and return the
result to us. We follow the same process for subtraction and multiplication.

Are there any states of the matrix object we might want to know about? Well, it might be
useful to view the value at a particular matrix position, so let’s add that to the list of responsi-
bilities. We also might want to access the number of rows and columns in a matrix.

What about error conditions? Matrix addition and subtraction require that the matrices
have the same dimensions, and matrix multiplication requires that the number of columns in
the first matrix must be equal to the number of rows in the second matrix. It makes sense for
the matrix that is being told to perform an operation to check to be sure the operation is legal
before complying with the request. If the operation is not legal, the matrix can throw an
exception.

C
1 2 3 4
0 2 1 3
1 1 0 0

= D

1 1
0 1
1 3
4 2

=

C *D
20 20
13 11
1 2

=



Problem-Solving Case Study | 625

CRC Card We can summarize our observations in a CRC card.

Internal Data Representation We said earlier that an array is the ideal implementation
structure for a matrix. In many languages, we would have to include the number of rows and
number of columns as data fields in the Matrix class, but Java provides them for us as
instance fields in the array object. Let’s represent the numeric values in the matrices as
double; this allows us to handle the largest range of values.

public class Matrix
{
// Private data field
private  double[][] matrix;
...

}

Class Name: Matrix Superclass: Subclasses:

Responsibilities Collaborations

Object

Create itself (rows, columns), Constructor






None

None

None

None

None

None

None

Know value at (row, col)
    return double

Know number of rows, Observer				 

return int

Know number of columns, Observer

return int

Set a value at [row, col] (row, col, value), Transformer

Print matrix, Observer

Add self to (two), Transformer, Constructor

    return Matrix

Subtract (two) from self, Transformer, Constructor

return Matrix

Multiply self times (two), Transformer, Constructor

return Matrix

PrintWriter



626 | Chapter 13:  Multidimensional Arrays and Numeric Computation

Responsibility Algorithms To create itself, we need a constructor that takes the number of
rows and the number of columns as parameters and creates the array.

public Matrix(int rows, int columns)
// Create empty matrix
{
matrix = new double[rows][columns];

}

The next method simply asks the object to return a copy of an item at a particular slot in
the array.

public double knowValueAt(int row, int col)
// Returns the value at matrix[row][col]
{
return matrix[row][col];

}

The next two observer methods return the number of rows and the number of columns.
Because Java implements a two-dimensional array as an array of references to arrays and each
one-dimensional array object has an instance field that contains the number of slots in the
array, we have direct access to this information. The length field of the two-dimensional
array gives the number of rows; the length of each row gives the number of columns in that
row. We do not need to worry about ragged arrays because of the way that we have imple-
mented the constructor.

public int knowRows()
// Returns the number of rows in matrix
{
return matrix.length;

}

public int knowColumns()
// Returns the number of columns in matrix
{
return matrix[0].length;

}

The main transformer method takes a value and a row and column number. The value is
stored in the matrix at the [row][col] position.

public void setValue(double dataItem, int row, int col)
// Sets matrix[row][col] to dataItem
{
matrix[row][col] = dataItem;

}

TE
AM
FL
Y

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

Team-Fly® 



Problem-Solving Case Study | 627

The remaining observer is printMatrix. The matrix is to be printed by row. We have a
pattern that we can follow exactly for our general discussion about arrays. Because we don’t
know how many columns the matrix has, we should print a blank line between rows.

public void printMatrix(PrintWriter outFile)
// Matrix is written on outFile by row
{
for (int row = 0; row < matrix.length; row++)
{
for (int col = 0; col < matrix[0].length; col++)
outFile.print(matrix[row][col] + "  ");

outFile.println();
}

}

The last three methods are what this problem is all about: adding, subtracting, and multi-
plying matrices. One matrix is the one to which the method is applied and the other matrix is a
parameter.

add (two)

Each of these steps is concrete. Determining if the addition is legal is a matter of checking
the dimensions of this against the dimensions of the parameter. The string that goes with
the exception can simply state that the addition is not legal.

public Matrix add(Matrix two) throws MatException
// Returns the sum of this and two
{
if (matrix.length != two.matrix.length ||

matrix[0].length != two.matrix[0].length)
throw new MatException(new String("Illegal matrix addition."));

else
{
Matrix result = new Matrix(matrix.length, matrix[0].length);
for (int row = 0; row < matrix.length; row++)

if the addition is not legal
throw MatException

else
Create result matrix with the same dimensions as this
for row going from 0 through matrix.length21

for col going from 0 through matrix[0].length21
Set result[row][col]  to matrix[row][col] + two.matrix[row] [col]

return result



628 | Chapter 13:  Multidimensional Arrays and Numeric Computation

for (int col = 0; col < matrix[0].length; col++)
result.matrix[row][col] = matrix[row][col] +
two.matrix[row][col];

return result;
}

}

sub (two)

public Matrix sub(Matrix two) throws MatException
// Returns two subtracted from this
{
if (matrix.length != two.matrix.length ||

matrix[0].length != two.matrix[0].length)
throw new MatException(new String("Illegal matrix subtraction."));

else
{
Matrix result = new Matrix(matrix.length, matrix[0].length);
for (int row = 0; row < matrix.length; row++)
for (int col = 0; col < matrix[0].length; col++)
result.matrix[row][col] = matrix[row][col] -
two.matrix[row][col];

return result;
}

}

if the subtraction is not legal
throw MatException

else
Create result matrix with the same dimensions as this

for row going from 0 through matrix.length21
for col going from 0 through matrix[0].length21

Set result[row][col] to matrix[row][col] 2 two.matrix[row] [col]
return result



Problem-Solving Case Study | 629

multiply (two)

dotProduct(row, col, two)

Let’s make dotProduct a helper function.

public Matrix multiply(Matrix two)  throws MatException
// Returns this times two
{
if (matrix[0].length != two.matrix.length)
throw new MatException(new String("Illegal matrix multiplication."));

else
{
Matrix  result = new Matrix(matrix.length, two.matrix[0].length);
for (int row = 0; row < matrix.length; row++)
for (int col = 0; col < two.matrix[0].length; col++)
result.matrix[row][col] = dotProduct(row, col, two);

return result;
}

}

private double dotProduct(int row, int col, Matrix two)
// Returns the dot product of row of this and column of two
{
double total = 0;
for (int index = 0; index < two.matrix.length; index++)
total = total + matrix[row][index]*two.matrix[index][col];

return total;
}

Set total to 0
for index going from 0 through number of columns of matrix

Set total to matrix[row][index] * two.matrix[index][col]+ total

if multiplication is not legal
throw MatException

else
Create result matrix with number of rows in this and number of columns in two
for row going from 0 through matrix.length 2 1

for col going from 0 through two.matrix[0].length 2 1
Set result[row][col] to dot product of row of matrix

and column of two.matrix



630 | Chapter 13:  Multidimensional Arrays and Numeric Computation

Before we collect these methods into a complete class, have we forgotten anything? The
class creates itself, has three observer methods that return its state variables, has a trans-
former that sets a value in a specified row and column—what happens if the specified row and
column are not within the bounds of the matrix? The class should check for this error and
throw an exception. The same is true for the operation that returns a value at a specified posi-
tion. What about the binary matrix operations? We know that these numeric operations can
cause underflow and overflow. If there is underflow, the values are automatically set to zero,
but if there is overflow, the values are set to a signed infinity. If overflow occurs, the operation
should throw an exception. The Double class has a boolean class method isInfinite that
we can use to determine if there has been overflow. In the following class, overflow is checked,
but the other error conditions are left to a Case Study Follow-Up Exercise.

package matrix;
public class MatException extends Exception
{
public MatException()
{
super();

}

public MatException(String message)
{
super(message);

}
} // End of class MatException

package matrix;
import java.io.*;

public class Matrix
{
// Private data field
private  double[][] matrix;

public Matrix(int rows, int columns)
// Create empty matrix
{
matrix = new double[rows][columns];

}

public double knowValueAt(int row, int col)
// Returns the value at matrix[row][col]
{
return matrix[row][col];

}



Problem-Solving Case Study | 631

public int knowRows()
// Returns the number of rows in matrix
{
return matrix.length;

}

public int knowColumns()
// Returns the number of columns in matrix
{
return matrix[0].length;

}

public void setValue(double dataItem, int row, int col)
// Sets matrix[row][col] to dataItem
{
matrix[row][col] = dataItem;

}

public void printMatrix(PrintWriter outFile)
// Matrix is written on outFile by row
{
for (int row = 0; row < matrix.length; row++)
{
for (int col = 0; col < matrix[0].length; col++)
outFile.print(matrix[row][col] + "  ");

outFile.println();
}

}

public Matrix add(Matrix two)  throws MatException
// Returns the sum of this and two
// Throws MatException if the matrices cannot be added or overflow occurs
{
if (matrix.length != two.matrix.length ||

matrix[0].length != two.matrix[0].length)
throw new MatException(new String("Illegal matrix addition."));

else
{
Matrix result = new Matrix(matrix.length, matrix[0].length);
for (int row = 0; row < matrix.length; row++)
for (int col = 0; col < matrix[0].length; col++)
{
result.matrix[row][col] = matrix[row][col] + two.matrix[row,col];



632 | Chapter 13:  Multidimensional Arrays and Numeric Computation

if (Double.isInfinite(result.matrix[row][col]))
throw new MatException(new String("Addition overflow"));

}
return result;

}
}

public Matrix sub(Matrix two) throws MatException
// Returns two subtracted from this
// Throws MatException if the matrices cannot be subtracted
//   or overflow occurs

{
if (matrix.length != two.matrix.length ||

matrix[0].length != two.matrix[0].length)
throw new MatException(new String("Illegal matrix subtraction."));

else
{
Matrix result = new Matrix(matrix.length, matrix[0].length);
for (int row = 0; row < matrix.length; row++)
for (int col = 0; col < matrix[0].length; col++)
{
result.matrix[row][col] = matrix[row][col] -

two.matrix[row, col];
if (Double.isInfinite(result.matrix[row][col]))
throw new MatException(new String("Subtraction overflow"));

}
return result;

}
}

public Matrix multiply(Matrix two)  throws MatException
// Returns this times two
// Throws MatException if the matrices cannot be multiplied
//   or overflow occurs

{
if (matrix[0].length != two.matrix.length)
throw new MatException(new String("Illegal matrix multiplication."));

else
{
Matrix  result = new Matrix(matrix[0].length, two.matrix.length);
for (int row = 0; row < matrix.length; row++)



Testing and Debugging | 633

for (int col = 0; col < two.matrix[0].length; col++)
{
result.matrix[row][col] = dotProduct(row, col, two);
if (Double.isInfinite(result.matrix[row][col]))
throw new MatException(new String("Multiplication overflow"));

}
return result;

}
}

private double dotProduct(int row, int col, Matrix two)
// Returns the dot product of row of this and column of two
{
double total = 0;
for (int index = 0; index < two.matrix.length; index++)
total = total + matrix[row][index]*two.matrix[index, col];

return total;
}

} // End of class Matrix

Testing Because the branching statements check for errors and throw exceptions only if they
occur, a clear or white-box testing strategy is appropriate. The end cases for addition and
subtraction would be for dimensions of one by one and something larger. For multiplication,
the outer dimensions should be one and the inner dimensions something else, the inner
dimensions should be one and the outer dimensions something else. Then the error conditions
must all be checked. A complete test plan is left as a Case Study Follow-up Exercise.

Testing and Debugging

Errors with multidimensional arrays usually fall into two major categories: index expres-
sions that are out of order and index range errors. We have been very careful to use an
array object’s own length value in loop expressions to minimize range errors. However,
inadvertent switching of indexes can cause index range errors. Take a look at the code for
dotProduct. What happens if the indexes are reversed in the following statement?

total = total + matrix[row][index]*two.matrix[index][col];

That is, what happens if the statement is coded as follows?

total = total + matrix[index][row]*two.matrix[col][index];



634 | Chapter 13:  Multidimensional Arrays and Numeric Computation

If the first matrix is a 3 3 5 and the second is a 5 3 2, index goes from 0 through
4 while row and col remain at 0. matrix[0][0] and two.matrix[0][0] are
accessed; then matrix[1][0] and two.matrix[0][1] are accessed; then
matrix[2][0] and two.matrix[0][2] are accessed. This last access causes an
IndexOutOfBoundsException to be thrown: two.matrix[0][2] doesn’t exist.

How can you avoid such errors? There is no simple answer. You just have to be
careful and thoroughly test your code.

Testing and Debugging Hints

1. With multidimensional arrays, use the proper number of indexes when referencing
an array component and make sure the indexes are in the correct order.

2. In loops that process multidimensional arrays, double check the upper and lower
bounds on each index variable to be sure they are correct for that dimension of
the array.

3. When declaring a multidimensional array as a parameter, be sure that you have the
proper number of brackets beside the type on the parameter list.

4. When passing an array object as an argument, be sure that is has the same number
of dimensions as the parameter of the method to which it is being passed.

5. Be aware of representational, cancellation, overflow, and underflow errors. If possi-
ble, try to arrange calculations in your program to keep floating-point numbers
from becoming too large or too small.

6. If your program increases the value of a positive integer and the result suddenly
becomes a negative number, you should suspect integer overflow.

7. Avoid mixing data types in expressions, assignment operations, argument passing,
and the return of a method value. If you must mix types, explicit type casts can
prevent unwelcome surprises caused by implicit type coercion.

Summary of Classes
Package Name Comments

Class Name

matrix
Matrix

Constructor: Matrix(int, int) Number of rows, number of columns
Matrix add(Matrix) Returns result of matrix addition
Matrix sub(Matrix) Returns result of matrix subtraction
Matrix multiply(Matrix) Returns result of matrix multiplication

(continued)



Summary  | 635

Package Name Comments

Class Name

Transformer: setValue(double, int, int) Sets [row][col] to double value
Observers: double knowValueAt(int, int) Returns value at [row][col]

int knowRows() Returns the number of rows
int knowColumns() Returns number of columns
printMatrix(PrintWriter) Prints matrix by row on file

Summary
Two-dimensional arrays are useful for processing information that is represented natu-
rally in tabular form. Processing data in two-dimensional arrays usually takes one of
two forms: processing by row or processing by column. Java implements a two-dimen-
sional array as an array of references to one-dimensional arrays. Associated with each
two-dimensional array is a final instance variable length that contains the number of
rows. Associated with each row of the table is a final instance variable length that
contains the number of items in the row (the column length). The number of items in a
row is usually the same for each row, but does not need to be. If the rows are uneven,
the array is called a ragged array.

A multidimensional array is a collection of like components that are ordered on more
than two dimensions. Each component is accessed by a set of indexes, one for each
dimension, which represents the component’s position on the various dimensions. Each
index may be thought of as describing a feature of a given array component.

The floating-point types built into the Java language are float and double. Float-
ing-point numbers are represented in the computer with a fraction and an exponent.
This representation permits numbers that are much larger or much smaller than those
that can be represented with the integral types. Floating-point representation also
allows us to perform calculations on numbers with fractional parts.

However, there are drawbacks to using floating-point numbers in arithmetic cal-
culations. Representational errors, for example, can affect the accuracy of a pro-
gram’s computations. When using floating-point numbers, keep in mind that if two
numbers are vastly different from each other in size, adding or subtracting them can
produce the wrong answer. Remember, also, that the computer has a limited range of
numbers that it can represent. If a program tries to compute a value that is too large
or too small, the result is unusual or unexpected values.



Quick Check
1. Declare a two-dimensional array named plan and create an array object with 30

rows and 10 columns. The component type of the array is float. (pp. 600–602)
2. Given the array created in Question 1, answer the following questions.

a. Assign the value 27.3 to the component in row 13, column 7 of the array
plan from Question 1. (pp. 602–604)

b. Nested for loops can be used to sum the values in each row of array plan. What
range of values would the outer for loop count through to do this? (pp. 605–607)

c. Nested for loops can be used to sum the values in each column of array plan.
What range of values would the outer for loop count through to do this?
(p. 607)

d. Write a program fragment that initializes array plan to all ones. (p. 608)
e. Write a program fragment that prints the contents of array plan, one row per

line of output. (pp. 606–609)
3. Suppose array plan is passed as an argument to a method in which the corre-

sponding parameter is named someArray. What would the declaration of
someArray look like in the parameter list? (p. 609)

4. Given the declarations

final  int SIZE = 10;
char[][][][] quick = new[SIZE][SIZE][SIZE][SIZE–1];

a. How many components does array quick contain? (p. 610)
b. Write a program fragment that fills array quick with blanks. (pp. 610–611)

5. Why is it inappropriate to use a variable of a floating-point type as a loop-con-
trol variable? (p. 618)

6. If a computer has four digits of precision, what would be the result of the fol-
lowing addition operation? (pp. 620–621)

400400.000 + 199.9

Answers

1. float[][] plan;
plan = new float[30][10];

2. a. plan[13][7] = 27.3;
b. for (row = 0; row < 30; row++)
c. for (col = 0; col < 10; col++)
d. for (row = 0; row < 30; row++)

for (col = 0; col < 10; col++)
plan[row][col] = 0.0;

e. for (row = 0; row < 30; row++)
{
for (col = 0; col < 10; col++)
outFile.print(plan[row][col]);

outFile.println();
}

636 | Chapter 13:  Multidimensional Arrays and Numeric Computation

TE
AM
FL
Y

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

Team-Fly® 



Exam Preparation Exercises | 637

3. float[][] someArray
4. a. Nine thousand (10 3 10 3 10 3 9)

b. for (dim1 = 0; dim1 < SIZE; dim1++)
for (dim2 = 0; dim2 < SIZE; dim2++)
for (dim3 = 0; dim3 < SIZE; dim3++)
for (dim4 = 0; dim4 < SIZE – 1; dim4++)

quick[dim1][dim2][dim3][dim4] = ' ';

5. Because representational errors can cause the loop-termination condition to be evaluated with
unpredictable results. 6. 400500.000 (Actually, 4.005E+5)

Exam Preparation Exercises
1. Given the declarations

final int NUM_SCHOOLS = 10;
final int NUM_SPORTS = 3;
int[][]  kidsInSports = new int[NUM_SCHOOLS][NUM_SPORTS];
double[][] costOfSports = new double[NUM_SPORTS][NUM_SCHOOLS];

answer the following questions:
a. What is the number of rows in kidsInSports?
b. What is the number of columns in kidsInSports?
c. What is the number of rows in costOfSports?
d. What is the number of columns in costOfSports?
e. How many components does kidsInSports have?
f. How many components does costOfSports have?
g. What kind of processing (row or column) would be needed to total the

amount of money spent on each sport?
h. What kind of processing (row or column) would be needed to total the num-

ber of children participating in sports at a particular school?
2. Given the following code segments, draw the arrays and their contents after the

code is executed. Indicate any undefined values with the letter U.
a. int[][] exampleA;

exampleA =  new int[4][3];
int i, j;
for (i = 0; i < 4; i++)
for (j = 0; j < 3; j++)
exampleA[i][j] = i * j;

b. int[][] exampleB;
exampleB = new int[4][3];
int i, j;
for (i = 0; i < 3; i++)
for (j = 0; j < 3; j++)

exampleB[i][j] = (i + j) % 3;



638 | Chapter 13:  Multidimensional Arrays and Numeric Computation

c. int[][] exampleC;
exampleC = new int[8][2];
int i, j;
exampleC[7][0] = 4;
exampleC[7][1] = 5;
for (i = 0; i < 7; i++)
{
exampleC[i][0] = 2;
exampleC[i][1] = 3;

}
3. a. Define an int variable teamType and an int variable resultType.

b. Define a two-dimensional array variable outcome.
c. This array is to be used to keep track of the wins and losses for the baseball

season. teamType represents the classes, freshman (0), sophomore (1), junior
(2), and senior (3). resultType represents whether they won (0), tied (1), or
lost (2). Instantiate the array object referenced by outcome.

d. Write a code fragment that increases the number of freshman wins by 1.
e. Write a code fragment that determines which class won the most games.
f. Write a code fragment that determines the total number of wins for all classes.

4. (True or False?) The number of rows in the array must be specified on the
parameter list of a method that takes the array as a parameter.

5. Declare and instantiate the two-dimensional arrays described below.
a. An array with five rows and six columns which contains Boolean values.
b. An array, indexed from 0 through 39 and 0 through 199, which contains

double values.
c. An array, indexed from 0 through 3 and 0 through 2, which contains char

values.
6. A logging operation keeps records of 37 loggers’ monthly production for pur-

poses of analysis, using the following array structure:

final int NUM_LOGGERS = 37;
int logsCut[NUM_LOGGERS][12];  // Logs cut per logger per month
int monthlyHigh;
int[][] logsCut;  // Logs cut per logger per month
logsCut = new int[NUM_LOGGERS][12];
int yearlyTotal;
int high;
int month;
int bestMonth;
int logger;
int bestLogger;

a. (True or False?) The following statement assigns the January log total for
logger number 7 to monthlyTotal.

monthlyTotal = logsCut[7][0];



Exam Preparation Exercises | 639

b. (True or False?) The following statements compute the yearly total for logger
number 11.

yearlyTotal = 0;
for (month = 0; month < NUM_LOGGERS; month++)
yearlyTotal = yearlyTotal + logsCut[month][10];

c. (True or False?) The following statements find the best logger (most logs cut)
in March.

monthlyHigh = 0;
for (logger = 0; logger < NUM_LOGGERS; logger++)
if (logsCut[logger][2] > monthlyHigh)
{
bestLogger = logger;
monthlyHigh = logsCut[logger][2];

}

d. (True or False?) The following statements find the logger with the highest
monthly production and the logger’s best month.

high = –1;
for (month = 0; month < 12; month++)
for (logger = 0; logger < NUM_LOGGERS; logger++)
if (logsCut[logger][month] > high)
{
high = logsCut[logger][month];
bestLogger = logger;
bestMonth = month;

}

7. Declare and instantiate the double array variables described below.
a. A three-dimensional array in which the first dimension is indexed from 0

through 9, the second dimension is indexed from 0 through 6 representing
the days of the week, and the third dimension is indexed from 0 through 20.

b. A four-dimensional array in which the first two dimensions are indexed from
0 through 49, and the third and fourth have 20 and 30 slots, respectively.

8. If a system supports 10 digits of precision for floating-point numbers, what are
the results of the following computations?
a. 1.4E+12 + 100.0
b. 4.2E–8 + 100.0
c. 3.2E–5 + 3.2E+5

9. Define the following terms:

significant digits
exponent
representational error
overflow
underflow



640 | Chapter 13:  Multidimensional Arrays and Numeric Computation

Programming Warm-Up Exercises
1. Using the declarations in Exam Preparation Exercise 1, write code fragments to

do the following tasks.
a. Determine which school spent the most money on football.
b. Determine which sport the last school spent the most money on.
c. Determine which school had the most students playing basketball.
d. Determine in which sport the third school had the most students participating.
e. Determine the total amount spent by all the schools on volleyball.
f. Determine the total number of students who played any sport. (Assume that

each student played only one sport.)
g. Determine which school had the most students participating in sports.
h. Determine which was the most popular sport in terms of money spent.
i. Determine which was the most popular sport in terms of student participation.

2. Examine the following class declaration.

public class TwoDimensions
{
// Private data
private int[][] data;
private int rowsUsed;      // Number of rows that contain data
private int columnsUsed;   // Number of columns that contain data
// Methods
public TwoDimensions(int maxRows, int maxColumns)
// Constructor: Creates a maxRows  x maxColumns array
public void inputData(BufferedReader inFile)
// Reads data into the array
// Data is on the file as follows:
// First line: number of rows (rowsUsed)
// Second line: number of columns (columnsUsed)
// The data is stored one value per line in row order.  That is, 
//  the first columnsUsed values go into row 0; the next 
//  columnsUsed values go into row 1; etc.
public void print(PrintWriter outFile)
// Prints the values in the array on outFile, one row per line
public int maxInRow(int row)
// Returns the maximum value in the specified row
public int maxInCol(int column)
// Returns the maximum value in the specified column
public int maxInArray()
// Returns the maximum value in the entire array
public int sum()
// Returns the sum of the values in the array
public int sumInRow(int row)



Programming Warm-Up Exercises | 641

// Returns the sum of the values in the specified row
public int sumInCol(int column)
// Returns the sum of the values in the specified column
public boolean allPlus()
// Returns true if all the values are positive; false otherwise

a. Write the code for method TwoDimensions.
b. Write the code for method inputData.
c. Write the code for method print.
d. Write the code for method maxInRow.
e. Write the code for method maxInCol.
f. Write the code for method maxInArray.
g. Write the code for method sum.
h. Write the code for method sumInRow.
i. Write the code for method sumInCol.
j. Write the code for method allPlus.

3. Write a code segment that finds the largest value in a two-dimensional double
array of 50 rows and 50 columns.

4. Given the following declarations

final int NUM_DEPTS = 100;
final int NUM_STORES = 10;
final int NUM_MONTHS = 12;

a. Declare an array variable sales that is indexed by number of departments,
number of stores, and number of months and contains double values.

b. Instantiate the array object referenced by sales.
c. What values do the variables in sales have after it is created?
d. Write a code segment to calculate the sum of the sales for January.
e. Write a code segment to calculate the sum of the sales for store 2.
f. Write a code segment to calculate the sum of the sales for department 33.

5. In a program you are writing, a double variable beta potentially contains a
very large number. Before multiplying beta by 100.0, you want the program to
test whether it is safe to do so. Write an if statement that tests for a possible
overflow before multiplying by 100.0. Specifically, if the multiplication would
lead to overflow, print a message and don’t perform the multiplication; other-
wise, go ahead with the multiplication.

6. Write an application to print out MAX_VALUE and MIN_VALUE for types
float and double.

7. The Vector class in java.util provides a functionality very similar to that of
an array. In fact, the underlying data structure is an array. The advantage of a
Vector is that it can grow and shrink; the disadvantage is that this capability is
time consuming. To grow beyond the initial size requires the system to create a
larger array and move the objects into it. Listed below are some of the useful
methods in the Vector class and the corresponding array operations.



642 | Chapter 13:  Multidimensional Arrays and Numeric Computation

a. Run an experiment to determine how many slots are added to a Vector
object when you add one more item than you originally stated should be in
the vector.

b. Make a chart like the one shown above showing five other useful methods in
the class.

Programming Problems
1. Write an application that plays Tic-Tac-Toe. Represent the board as a 3 3 3

char array. The array is initialized to blanks and each player is asked in turn to
input a position. The first player’s position is marked on the board with an O,
and the second player’s position is marked with an X. Continue the process until
a player wins or the game is a draw. To win, a player must have three marks in a
row, in a column, or on a diagonal. A draw occurs when the board is full and no
one has won.

Each player’s position should be input as indexes into the Tic-Tac-Toe
board—that is, a row number and a column number. Make the program user-
friendly.

After each game, print out a diagram of the board showing the ending posi-
tions. Keep a count of the number of games each player has won and the num-
ber of draws. Before the beginning of each game, ask each player if he or she
wishes to continue. If either player wishes to quit, print out the statistics and
stop. Use buttons as appropriate.

2. Photos taken in space by the Galileo spacecraft are sent back to earth as a stream of
numbers. Each number represents a level of brightness. A large number represents
a high brightness level, and a small number represents a low level. Your job is to
take a matrix (a two-dimensional array) of the numbers and print it as a picture.

One approach to generating a picture is to print a dark character (such as a $)
when the brightness level is low, and to print a light character (such as a blank
or a period) when the level is high. Unfortunately, errors in transmission some-

Method Array equivalent/Explanation

Vector myVector; Object[] myVector;
myVector = new Vector(10); myVector = new Object[10];
myVector.setElementAt(item, 9); myVector[9] = item;
item = myVector.elementAt(5); item = myVector[5];
myVector.addElement(item); myVector[numItems] = item;

numItems++;
int myVector.size(); Returns the number of items in myVector
int capacity() myVector.length



Programming Problems | 643

times occur. Thus, your program should first attempt to find and correct these
errors. Assume a value is in error if it differs by more than 1 from each of its
four neighboring values. Correct the erroneous value by giving it the average of
its neighboring values, rounded to the nearest integer.

Example:
5 The 2 would be regarded as an error and would be given

4 2 5 a corrected value of 5.
5

Note that values on the corners or boundaries of the matrix have to be processed
differently than the values on the interior. Your application should print an
image of the uncorrected picture and then an image of the corrected picture.

3. The following diagram represents an island surrounded by water (shaded area).

Two bridges lead off of the island. A mouse is placed on the black square. Write
a program to make the mouse take a walk across the island. The mouse is
allowed to travel one square at a time, either horizontally or vertically. A ran-
dom number from 1 through 4 should be used to decide which direction the
mouse is to take. The mouse drowns when he hits the water; he escapes when he
enters a bridge. You may generate a random number up to 100 times. If the
mouse does not find his way by the hundredth try, he will die of starvation.
Restart the mouse in a reinitialized array and go back and repeat the whole
process. Count the number of times he escapes, drowns, and starves.

Input
First input line—the size of the array, including border of water and bridges

(not larger than 20 3 20).
Next N input lines—the rows of the two-dimensional array, where the positions

containing negative numbers represent the water, the positions in the edge
containing a 0 represent the bridges, the position containing a 1 represents
the starting position of the mouse, and all other positions contain 0s.

Output
A line stating whether the mouse escaped, drowned, or starved
A line showing the mouse’s starting position and the position of the two bridges
A map showing the frequency of the mouse’s visits to each position

Water

Bridge

Bridge

Starting position
of mouse

A mouse in this position
has not yet escaped.



644 | Chapter 13:  Multidimensional Arrays and Numeric Computation

You should print the items above (double spaced between trips) for each trip by the
mouse.

4. In competitive diving, each diver makes three dives of varying degrees of diffi-
culty. Nine judges score each dive from 0 through 10 in steps of 0.5. The total
score is obtained by discarding the lowest and highest of the judges’ scores,
adding the remaining scores, and then multiplying the scores by the degree of
difficulty. The divers take turns, and when the competition is finished, they are
ranked according to score. Write a program to calculate the outcome of a com-
petition, using the following input and output specifications.

Input
Number of divers
Diver’s name (10 characters), difficulty (double), and judges’ ratings (nine

doubles)
There is a line of data for each diver for each dive. All the data for Dive 1 are

grouped together, then all for Dive 2, then all for Dive 3.

Output
The input data, echo printed in tabular form with appropriate headings—for

example,

Name Difficulty Judge’s number (1–9)

A table that contains the following information:

Name Dive 1 Dive 2 Dive 3 Total

where Name is the diver’s name; Dive 1, Dive 2, and Dive 3 are the total points
received for a single dive, as described above; and Total is the overall total.

5. You are to test what happens when overflow occurs. Write a simple application
that does the following tasks:

Calculates the factorial of an integer number.
Embeds the factorial in a loop that goes from 1 to 100.
Prints out the result of each factorial within the loop.

Run your application with the factorial calculated using each of the integer
types. Record the results of each run.

Redo the experiment taking the factorial of a real number. Record the results of
each run.

Write a report describing what you have learned about overflow and Java.
6. Implement the Exam Attendance problem from Chapter 12 using the Vector class.



Case Study Follow-Up Exercises | 645

Case Study Follow-Up Exercises
1. There are no checks for row and column parameters being in bounds in the Matrix

Manipulation Case Study. List the methods in which this error might occur.
2. Implement checks for this error and recode the solution.
3. Design a test plan for class Matrix as modified in Case Study Follow-Up Exer-

cise 2.
4. The java.math package contains the BigInteger and BigDecimal classes that

allow you to work with arbitrary-size and arbitrary-precision integers and float-
ing-point values. How would you have to change class Matrix to define the
operations using BigInteger rather than double?



TE
AM
FL
Y

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

Team-Fly® 



            

To be able to identify the base case(s) and the gen-
eral case in a recursive definition.

To be able to identify the size of the problem that
must decrease.

To be able to write a recursive algorithm for a prob-
lem involving only simple variables.

To be able to write a recursive algorithm for a problem
involving structured variables.

Recursion
G

oals



648 | Chapter 14:  Recursion

In Java, any method can call another method. A method can even call itself! When a
method calls itself, it is making a recursive call. The word recursive means “having the

characteristic of coming up again, or repeating.” In
this case, a method call is being repeated by the
method itself. Recursion is a powerful technique that
can be used in place of iteration (looping).

Recursive solutions can be less efficient than iter-
ative solutions to the same problem. However, some

problems lend themselves to simple, elegant, recursive solutions and are exceedingly
cumbersome to solve iteratively. Some programming languages, such as early versions
of FORTRAN, BASIC, and COBOL, do not allow recursion. Other languages are especially
oriented to recursive algorithms—LISP is one of these. Java lets us take our choice: We
can implement both iterative and recursive algorithms.

Our examples are broken into two groups: problems that use only simple variables
and problems that use structured variables. If you are studying recursion before reading
Chapter 11 on structured data types, then cover only the first set of examples and leave
the rest until you have completed the chapters on structured data types.

Rather than one large Case Study at the end of the chapter, there are several small
problems solved using recursion throughout the chapter.

14.1 What Is Recursion?
You may have seen a set of gaily painted Russian dolls that fit inside one another.
Inside the first doll is a smaller doll, inside of which is an even smaller doll, inside of
which is yet a smaller doll, and so on. A recursive algorithm is like such a set of Russian
dolls. It reproduces itself with smaller and smaller examples of itself until a solution is
found—that is, until there are no more dolls. The recursive algorithm is implemented by
using a method that makes recursive calls to itself.

Power Function Definition

Let’s examine a method that calculates the result of raising an integer to a positive
power. If x is an integer and n is a positive integer,

xn = x * x * x * x * . . . * x        

n times

Recursive call A method call in which the method
being called is the same as the one making the call



14.1 What Is Recursion? | 649

We could also write this formula as

or even as

In fact, we can write the formula most concisely as

xn = x * xn21

This definition of x n is a classic recursive definition—that is, a definition given in
terms of a smaller version of itself.

xn is defined in terms of multiplying x times xn21. How is xn21 defined? Why, as x
times xn22, of course! And xn22 is x times
xn23, xn23 is x times xn24, and so on. In this
example, “in terms of smaller versions of
itself” means that the exponent is decre-
mented each time.

When does the process stop? It ends when
we have reached a case for which we know
the answer without resorting to a recursive
definition. In this example, it is the case
where n equals 1: x1 is x. The case (or cases)
for which an answer is explicitly known is
called the base case. The case for which the
solution is expressed in terms of a smaller
version of itself is called the recursive or gen-
eral case. A recursive algorithm is an algorithm that expresses the solution in terms of a
call to itself, a recursive call. A recursive algorithm must terminate; that is, it must have
a base case.

Power Function Implementation

The code uses an if statement to determine which case is being executed. Here is a
method that implements the power function with the general case and the base case
marked in the comments.

public static int power(int x, int n)
// Returns x raised to the power n
// Assumption:  x is a valid integer and n is greater than 0
// Note: Large exponents may result in integer overflow

xn = x * x * (x * x * . . . * x)     

(n22 times)

xn = x * (x * x * x * . . . * x)     

(n21 times)

Recursive definition A definition in which something
is defined in terms of smaller versions of itself

Base case The case for which the solution can be
stated nonrecursively

General case The case for which the solution is
expressed in terms of a smaller version of itself; also
known as the recursive case

Recursive algorithm A solution that is expressed in
terms of (a) smaller instances of itself and (b) a base
case



650 | Chapter 14:  Recursion

{
if (n == 1)
return x;                   // Base case

else
return x * power(x, n – 1); // Recursive call

}

Each recursive call to power can be thought of as creating a completely new copy
of the method, each with its own copies of the parameters x and n. The value of x
remains the same for each version of power, but the value of n decreases by 1 for each
call until it becomes 1.

Let’s trace the execution of this recursive method with the following initial call.

xToN = power(2, 3);

We use a new format to trace recursive routines: We number the calls and then dis-
cuss what is happening in paragraph form. This trace is also summarized in Figure 14.1,
where each box represents a call to the power method. The values for the parameters for
that call are shown in each box. Look at the figure as you are working through the trace
in paragraph form.

Call 1: power is called with the number equal to 2 and the exponent equal to 3.
Within power, the parameters x and n are initialized to 2 and 3, respectively. Because n
is not equal to 1, power is called recursively with x and n – 1 as arguments. Execution
of Call 1 pauses until an answer is sent back from this recursive call.

Call 2: x is equal to 2 and n is equal to 2. Because n is not equal to 1, the method
power is called again, this time with x and n – 1 as arguments. Execution of Call 2
pauses until an answer is sent back from this recursive call.

Figure 14.1 Execution of power(2, 3)

first
0

last
4



x n
2 3

first
0

last
4



x n
2 2

x n
2 1

power(2,3)

Call 1:

Call 2:

Call 3:

Returns 8.

Returns 4.

Returns 2.



14.2 More Examples with Simple Variables | 651

Call 3: x is equal to 2 and n is equal to 1. Because n equals 1, the value of x is to be
returned. This call to the method has finished executing, and the method return value
(which is 2) is passed back to the place in the statement from which the call was made
in Call 2.

Call 2: This call to the method can now complete the statement that contained the
recursive call because the recursive call has returned. Call 3’s return value (which is 2) is
multiplied by x. This call to the method has finished executing, and the method return
value (which is 4) is passed back to the place in the statement from which the call was
made in Call 1.

Call 1: This call to the method can now complete the statement that contained the
recursive call because the recursive call has returned. Call 2’s return value (which is 4) is
multiplied by x. This call to the method has finished executing, and the method return
value (which is 8) is passed back to the place in the statement from which the call was
made. Because the first call (the nonrecursive call) has now completed, this is the final
value of the method power.

What happens if there is no base case?
We have infinite recursion, the recursive
equivalent of an infinite loop. For example, if
the condition

if (n == 1)

were omitted, power would be called over and over again. Infinite recursion also occurs
if power is called with n less than or equal to 0.

In actuality, recursive calls can’t go on forever. Here’s the reason. When a method is
called, either recursively or nonrecursively, the computer system creates temporary stor-
age for the parameters and the method’s local variables. This temporary storage is a
region of memory called the run-time stack. When the method returns, its parameters
and local variables are released from the run-time stack. With infinite recursion, the
recursive method calls never return. Each time the method calls itself, a little more of
the run-time stack is used to store the new copies of the variables. Eventually, all the
memory space on the stack is used. At that point, the program crashes with an error
message such as “RUN-TIME STACK OVERFLOW” (or the computer may simply hang).

14.2 More Examples with Simple Variables
For some people thinking recursively is intuitive; for others it is a mysterious process
verging on the supernatural. The objective of the rest of the chapter is to de-mystify the
recursive process by working through a collection of examples.

Calculating the Factorial Function

Let’s look at another example: calculating a factorial. The factorial of a number n (written
n!) is n multiplied by n 2 1, n 2 2, n 2 3, and so on. Another way of expressing factorial is

n! = n * (n 2 1)!

Infinite recursion The situation in which a method
calls itself over and over endlessly



652 | Chapter 14:  Recursion

This expression looks like a recursive definition. (n 2 1)! is a smaller instance of
n!—that is, it takes one less multiplication to calculate (n 2 1)! than it does to calculate
n! If we can find a base case, we can write a recursive algorithm. Fortunately, we don’t
have to look too far: 0! is defined in mathematics to be 1.

This algorithm can be coded directly in the following method.

public static int factorial (int number)
// Returns the factorial of number
// Assumption: number is greater than or equal to 0
// Note: Large values of number may cause integer overflow
{
if (number == 0)
return 1;                              // Base case

else
return number * factorial(number – 1); // General case

}

Let’s trace this method with an original number of 4.
Call 1: number is 4. Because number is not 0, the else branch is taken. The

return statement cannot be completed until the recursive call to factorial with
number – 1 as the argument has been completed.

Call 2: number is 3. Because number is not 0, the else branch is taken. The
return statement cannot be completed until the recursive call to factorial with
number – 1 as the argument has been completed.

Call 3: number is 2. Because number is not 0, the else branch is taken. The
return statement cannot be completed until the recursive call to factorial with
number – 1 as the argument has been completed.

Call 4: number is 1. Because number is not 0, the else branch is taken. The
return statement cannot be completed until the recursive call to factorial with
number – 1 as the argument has been completed.

Call 5: number is 0. Because number equals 0, this call to the method returns,
sending back 1 as the result.

Call 4: The return statement in this copy can now be completed. The value to be
returned is number (which is 1) times 1. This call to the method returns, sending back 1
as the result.

factorial
if number is 0

return 1
else

return number * factorial(number 2 1)



14.2 More Examples with Simple Variables | 653

Figure 14.2 Execution of factorial(4)

factorial(4)

first
0

last
4



n
4

first
0

last
4



n
3

first
0

last
4



n
2

first
0

last
4



n
1

first
0

last
4



n
0

Call 1:

Call 2:

Call 3:

Call 4:

Call 5:

Returns 24.

Returns 6.

Returns 2.

Returns 1.

Returns 1.

Call 3: The return statement in this copy can now be completed. The value to be
returned is number (which is 2) times 1. This call to the method returns, sending back 2
as the result.

Call 2: The return statement in this copy can now be completed. The value to be
returned is number (which is 3) times 2. This call to the method returns, sending back 6
as the result.

Call 1: The return statement in this copy can now be completed. The value to be
returned is number (which is 4) times 6. This call to the method returns, sending back 24 as
the result. Because this is the last of the calls to factorial, the recursive process is over.
The value 24 is returned as the final value of the call to factorial with an argument of 4.
Figure 14.2 summarizes the execution of the factorial method with an argument of 4.

Let’s organize what we have done in these two solutions into an outline for writing
recursive algorithms.

1. Understand the problem. (We threw this in for good measure; it is always the first step.)
2. Determine the base case(s). A base case is one to which you know the answer. It

does not involve any further recursion.

3. Determine the recursive case(s). A recursive case is one in which you can express
the solution in terms of a smaller version of itself.

We have used the factorial and the power algorithms to demonstrate recursion
because they are easy to visualize. In practice, one would never want to calculate either
of these methods using the recursive solution. In both cases, the iterative solutions are
simpler and much more efficient because starting a new iteration of a loop is a faster



654 | Chapter 14:  Recursion

operation than calling a method. Let’s compare the code for the iterative and recursive
versions of the factorial problem.

Iterative Solution
public static int factorial(int number)
{
int factor;
int count;

factor = 1;
for (count = 2; count <= number; count++)
factor = factor * count;

return factor;
}

Recursive Solution
public static int factorial(int number )
{
if (number == 0)
return 1;

else
return number * factorial(number – 1);

}

The iterative version has two local variables, whereas the recursive version has
none. There are usually fewer local variables in a recursive routine than in an iterative
routine. Also, the iterative version always has a loop, whereas the recursive version
always has a selection statement—either an if or a switch. A branching structure is the
main control structure in a recursive routine. A looping structure is the main control
structure in an iterative routine.

Converting Decimal Integers to Binary

You enter integer data in decimal form, and the computer converts these decimal num-
bers to binary for use within a program. Do you know how decimal integers are con-
verted to binary? The algorithm for this conversion is as follows:

1. Take the decimal number and divide it by 2.
2. Make the remainder the rightmost digit in the answer.
3. Replace the original dividend with the quotient.
4. Repeat, placing each new remainder to the left of the previous one.
5. Stop when the quotient is 0.

This is clearly an algorithm for a calculator and paper and pencil. Expressions such
as “to the left of” certainly cannot be implemented in Java as yet. Let’s do an example—
convert 42 from base 10 to base 2—to get a feel for the algorithm before we try to write a
computer solution. Remember, the quotient in one step becomes the dividend in the next.



14.2 More Examples with Simple Variables | 655

The answer is the sequence of remainders from last to first. Therefore, the decimal
number 42 is 101010 in binary.

It looks as though the problem can be implemented with a straightforward iterative
algorithm. Each remainder is obtained from the remainder operation (% in Java), and
each quotient is the result of the / operation.

Step 1 Step 2

0

2�1�

0
�

1

1

2�2�

2
�

0

2

2 �5�
4

�

1

5

2 �1�0�
10
�

0

10

2 �2�1�

2
�

1

0
�

1

21

2 �4�2�

4
�

2

2
�

0

← Quotient

← Remainder

← Remainder

← Remainder

← Remainder

← Remainder

← Remainder

← Quotient

← Quotient ← Quotient

← Quotient ← Quotient

Step 3 Step 4

Step 5 Step 6

Let’s do a walk-through to test this algorithm.

Number Remainder

42 0
21 1
10 0
5 1
2 0
1 1
Answer: 0 1 0 1 0 1
(remainder from step 1 2 3 4 5 6)

convert
while number > 0

Set remainder to number % 2
Print remainder
Set number to number / 2



656 | Chapter 14:  Recursion

The answer is backwards! An iterative solution (using only simple variables) doesn’t
work. We need to print the last remainder first. The first remainder should be printed
only after the rest of the remainders have been calculated and printed.

In our example, we should print 42 % 2 after (42 / 2) % 2 has been printed. But
this, in turn, means that we should print (42 / 2) % 2 after ((42 / 2) / 2) % 2 has been
printed. Now this begins to look like a recursive definition. We can summarize by say-
ing that, for any given number, we should print number % 2 after (number / 2) % 2 has
been printed. What is the base case? We know the answer when number is zero: We
have finished and there is nothing left to do. What is the recursive case? Convert num-
ber divided by 2. When this conversion is complete, print the remainder of number
divided by 2 (number % 2). This becomes the following algorithm:

If number is 0, we have called convert as many times as we need to and can begin
printing the answer. The base case is simply when we do nothing. The recursive solution
to this problem is encoded in the convert method.

public static void convert(int number)
// Converts number to binary and prints it.
// Assumption:  number >= 0.
{
if (number > 0)
{
convert(number / 2);   // Recursive call
outFile.print(number % 2);

}
// Empty else-clause is the base case

}

Let’s do a code walk-through of convert(10). We pick up our original example at
Step 3, where the dividend is 10.

Call 1: convert is called with an argument of 10. Because number is not equal to
0, the then-clause is executed. Execution pauses until the recursive call to convert with
an argument of (number / 2) has completed.

Call 2: number is 5. Because number is not equal to 0, execution of this call pauses
until the recursive call with an argument of (number / 2) has completed.

Call 3: number is 2. Because number is not equal to 0, execution of this call pauses
until the recursive call with an argument of (number / 2) has completed.

convert  (Recursive)
if number > 0

convert(number /2)
Print number % 2

TE
AM
FL
Y

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

Team-Fly® 



14.2 More Examples with Simple Variables | 657

Call 4: number is 1. Because number is not equal to 0, execution of this call pauses
until the recursive call with an argument of (number / 2) has completed.

Call 5: number is 0. Execution of this call to convert is complete. Control returns
to the preceding call.

Call 4: Execution of this call resumes with the statement following the recursive
call to convert. The value of number % 2 (which is 1) is printed. Execution of this call
is complete.

Call 3: Execution of this call resumes with the statement following the recursive
call to convert. The value of number % 2 (which is 0) is printed. Execution of this call
is complete.

Call 2: Execution of this call resumes with the statement following the recursive
call to convert. The value of number % 2 (which is 1) is printed. Execution of this call
is complete.

Call 1: Execution of this call resumes with the statement following the recursive
call to convert. The value of number % 2 (which is 0) is printed. Execution of this call
is complete. Because this is the nonrecursive call, execution resumes with the statement
immediately following the original call.

Figure 14.3 shows the execution of the convert method with the values of the
parameters.

In the next section, we examine a more complicated problem—one in which the
recursive solution is not immediately apparent.

Figure 14.3 Execution of convert(10)

first
0

last
4



number
10

first
0

last
4



number
5

first
0

last
4



number
2

first
0

last
4



number
1

first
0

last
4



number
0

convert(10)

Call 1:

Call 2:

Call 3:

Call 4:

Call 5:

Prints 0.

Prints 1.

Prints 0.

Prints 1.



658 | Chapter 14:  Recursion

Towers of Hanoi

One of your first toys may have been a disk with three pegs with colored circles of dif-
ferent diameters. If so, you probably spent countless hours moving the circles from one
peg to another. If we put some constraints on how the circles or discs can be moved, we
have an adult game called the Towers of Hanoi. When the game begins, all the circles
are on the first peg in order by size, with the smallest on the top. The object of the game
is to move the circles, one at a time, to the third peg. The catch is that a circle cannot be
placed on top of one that is smaller in diameter. The middle peg can be used as an aux-
iliary peg, but it must be empty at the beginning and at the end of the game.

To get a feel for how this might be done, let’s look at some sketches of what the
configuration must be at certain points if a solution is possible. We use four circles or
discs. The beginning configuration is:

To move the largest circle (circle 4) to peg 3, we must move the three smaller circles to
peg 2. Then circle 4 can be moved into its final place:

Let’s assume we can do this. Now, to move the next largest circle (circle 3) into place, we
must move the two circles on top of it onto an auxiliary peg (peg 1 in this case):

To get circle 2 into place, we must move circle 1 to another peg, freeing circle 2 to be
moved to its place on peg 3:

1 2 3

3
42 1

2
3
41

1 2 3

1 2 3

43
1
2

3
4

1
2

1 2 3

1 2 3

4

1
2
3 4

1
2
3

1 2 3

1 2 3

1
2
3
4



14.2 More Examples with Simple Variables | 659

The last circle (circle 1) can now be moved into its final place, and we are finished:

2
3
41

1 2 3 1 2 3

1
2
3
4

This algorithm certainly sounds simple; surely there must be more. But this really is all
there is to it.

Let’s write a recursive method that implements this algorithm. We can’t actually
move discs, of course, but we can print out a message to do so. Notice that the begin-
ning peg, the ending peg, and the auxiliary peg keep changing during the algorithm. To
make the algorithm easier to follow, we call the pegs beginPeg, endPeg, and auxPeg.
These three pegs, along with the number of circles on the beginning peg, are the param-
eters of the method.

We have the recursive or general case, but what about a base case? How do we
know when to stop the recursive process? The clue is in the expression “Get n circles
moved.” If we don’t have any circles to move, we don’t have anything to do. We are
finished with that stage. Therefore, when the number of circles equals 0, we do nothing
(that is, we simply return).

public static void doTowers(
int circleCount,    // Number of circles to move
int beginPeg,       // Peg containing circles to move
int auxPeg,         // Peg holding circles temporarily
int endPeg      )   // Peg receiving circles being moved

// Moves are written on file outFile
{
if (circleCount > 0)
{
// Move n – 1 circles from beginning peg to auxiliary peg
doTowers(circleCount – 1, beginPeg, endPeg, auxPeg);
outFile.println("Move circle from peg " + beginPeg

+ " to peg " + endPeg);

Get n Circles Moved from Peg 1 to Peg 3
Get n21 circles moved from peg 1 to peg 2
Move nth circle from peg 1 to peg 3
Get n21 circles moved from peg 2 to pet 3



660 | Chapter 14:  Recursion

// Move n – 1 circles from auxiliary peg to ending peg
doTowers(circleCount – 1, auxPeg, beginPeg, endPeg);

}
}

It’s hard to believe that such a simple algorithm actually works, but we’ll prove it to
you. We enclose the method within a driver class that invokes the doTowers method.
Output statements have been added so you can see the values of the arguments with
each recursive call. Because there are two recursive calls within the method, we have
indicated which recursive statement issued the call.

// Driver class for doTowers method
// Reads the number of circles from a file and calls doTowers
import java.io.*;              // File types

public class Towers
{
private static PrintWriter outFile;    // Output data file
private static BufferedReader inFile;  // Input data file

public static void main(String[] args) throws IOException
{
// Prepare files
inFile = new BufferedReader(

new FileReader("datafile.dat"));
outFile = new PrintWriter(

new FileWriter("outfile.dat"));
int circleCount;    // Number of circles on starting peg
circleCount = Integer.valueOf(inFile.readLine()).intValue();

outFile.println("Input number of circles: " + circleCount);
outFile.println("OUTPUT WITH " + circleCount + " CIRCLES";
outFile.println("From original: ");
doTowers(circleCount, 1, 2, 3);

}

public static void doTowers(
int circleCount,    // Number of circles to move
int beginPeg,       // Peg containing circles to move
int auxPeg,         // Peg holding circles temporarily
int endPeg      )   // Peg receiving circles being moved

// Moves are written on file outFile
//  This recursive method moves circleCount circles from beginPeg
//  to endPeg.  All but one of the circles are moved from beginPeg
//  to auxPeg, then the last circle is moved from beginPeg to
//  endPeg, and then the circles are moved from auxPeg to endPeg.



14.2 More Examples with Simple Variables | 661

//  The subgoals of moving circles to and from auxPeg are what
//  involve recursion
{
outFile.println("#circles: " + circleCount + " Begin: " +
beginPeg + " Auxil: " + auxPeg + " End: " + endPeg);

if (circleCount > 0)
{
// Move n – 1 circles from beginning peg to auxiliary peg
outFile.print("From # first:   ");
doTowers(circleCount – 1, beginPeg, endPeg, auxPeg);
outFile.println("Move circle " + circleCount + "from "

+ beginPeg + "to " + endPeg);

// Move n – 1 circles from auxiliary peg to ending peg
outFile.println("From second:  ");
doTowers(circleCount – 1, auxPeg, beginPeg, endPeg);

}
}

}

The output from a run with three circles follows. “Original” means that the parame-
ters listed beside it are from the nonrecursive call, which is the first call to doTowers.
“From first” means that the parameters listed are for a call issued from the first recursive
statement. “From second” means that the parameters listed are for a call issued from the
second recursive statement. Notice that a call cannot be issued from the second recur-
sive statement until the preceding call from the first recursive statement has completed
execution.

OUTPUT WITH 3 CIRCLES
From original: #circles: 3 Begin: 1 Auxil: 2 End: 3
From  first:   #circles: 2 Begin: 1 Auxil: 3 End: 2
From  first:   #circ1es: 1 Begin: 1 Auxil: 2 End: 3
From  first:   #circ1es: 0 Begin: 1 Auxil: 3 End: 2
Move circle 1 from 1 to 3
From second:   #circ1es: 0 Begin: 2 Auxil: 1 End: 3
Move circle 2 from 1 to 2
From second:   #circ1es: 1 Begin: 3 Auxil: 1 End: 2
From  first:   #circ1es: 0 Begin: 3 Auxil: 2 End: 1
Move circle 1 from 3 to 2
From second:   #circ1es: 0 Begin: 1 Auxil: 3 End: 2
Move circle 3 from 1 to 3
From second:   #circ1es: 2 Begin: 2 Auxil: 1 End: 3
From  first:   #circ1es: 1 Begin: 2 Auxil: 3 End: 1
From  first:   #circ1es: 0 Begin: 2 Auxil: 1 End: 3
Move circle 1 from 2 to 1
From second:   #circ1es: 0 Begin: 3 Auxil: 2 End: 1



662 | Chapter 14:  Recursion

Move circle 2 from 2 to 3
From second:   #circ1es: 1 Begin: 1 Auxil: 2 End: 3
From  first:   #circ1es: 0 Begin: 1 Auxil: 3 End: 2
Move circle 1 from 1 to 3
From second:   #circ1es: 0 Begin: 2 Auxil: 1 End: 3

14.3 Recursive Algorithms with Structured Variables
In our definition of a recursive algorithm, we said there were two cases: the recursive or
general case, and the base case for which an answer can be expressed nonrecursively. In
the general case for all our algorithms so far, an argument was expressed in terms of a
smaller value each time. When structured variables are used, the recursive case is often
in terms of a smaller structure rather than a smaller value; the base case occurs when
there are no values left to process in the structure.

Printing the Values in an Array

Let’s write a recursive algorithm for printing the contents of a one-dimensional array of
n elements to show what we mean. What is the base case? It occurs when there are no
elements left to print. What is the general case? It is to print the item in the first posi-
tion in the array and print the rest of the items.

The recursive case is to print the values in an array that is one element “smaller”;
that is, the size of the array decreases by 1 with each recursive call. The base case is
when the size of the array becomes 0—that is, when there are no more elements to print.

Our arguments must include the index of the first element (the one to be printed).
How do we know when there are no more elements to print (that is, when the size of the
array to be printed is 0)? We know we have printed the last element in the array when
the index of the next element to be printed is beyond the index of the last element in
the array. Therefore, the index of the last array element must be passed as an argument.
We call the indexes first and last. When first is greater than last, we are fin-
ished. The name of the array is data.

Print Array
if more elements

Print the item in the first position
Print the rest of the array



14.3 Recursive Algorithms with Structured Variables | 663

public static void printArray(int[] data,   // Array to be printed
int first,    // Index of first element
int last  )   // Index of last element

// Prints an array
{
if (first <= last)
{                                         // Recursive case
outFile.println(data[first]+ " ");
printArray(data, first + 1, last);

}
// Empty else-clause is the base case

}

Here is a code walk-through of the method call

print(data, 0, 4);

using the pictured array.

Call 1: first is 0 and last is 4. Because first is less than last, the value in
data[first] (which is 23) is printed. Execution of this call pauses while the array
from first + 1 through last is printed.

Call 2: first is 1 and last is 4. Because first is less than last, the value in
data[first] (which is 44) is printed. Execution of this call pauses while the array
from first + 1 through last is printed.

Call 3: first is 2 and last is 4. Because first is less than last, the value in
data[first] (which is 52) is printed. Execution of this call pauses while the array
from first + 1 through last is printed.

Call 4: first is 3 and last is 4. Because first is less than last, the value in
data[first] (which is 61) is printed. Execution of this call pauses while the array
from first + 1 through last is printed.

Call 5: first is 4 and last is 4. Because first is equal to last, the value in
data[first] (which is 77) is printed. Execution of this call pauses while the array
from first + 1 through last is printed.

[0]

[1]

[2]

[3]

[4]





23

44

52

61

77



data

•



664 | Chapter 14:  Recursion

Call 6: first is 5 and last is 4. Because first is greater than last, the execu-
tion of this call is complete. Control returns to the preceding call.

Call 5: Execution of this call is complete. Control returns to the preceding call.
Calls 4, 3, 2, and 1: Each execution is completed in turn, and control returns to the

preceding call.
Notice that once the deepest call (the call with the highest number) was reached, each

of the calls before it returned without doing anything. When no statements are executed
after the return from the recursive call to the method,
the recursion is known as tail recursion. Tail recursion
often indicates that the problem could be solved more
easily using iteration. We used the array example
because it made the recursive process easy to visualize;
in practice, an array should be printed iteratively.

Figure 14.4 shows the execution of the print
method with the values of the parameters for each call. Notice that the array gets
smaller with each recursive call (data[first] through data[last]). If we want to
print the array elements in reverse order recursively, all we have to do is interchange
the two statements within the if statement.

Binary Search

Do you remember the binary search in Chapter 12? Here is the description of the algo-
rithm. “The algorithm divides the list in half (divides by 2—that’s why it’s called a binary
search) and decides which half to look in next. Division of the selected portion of the
list is repeated until the item is found or it is determined that the item is not in the list.”
There is something inherently recursive about this description.

Though the method that we wrote in Chapter 12 was iterative, this really is a recur-
sive algorithm. The solution is expressed in smaller versions of the original problem: If
the answer isn’t found in the middle position, perform a binary search (a recursive call)
to search the appropriate half of the list (a smaller problem). In the iterative version we
kept track of the bounds of the current search area with two local variables, first and
last. In the recursive version we call the method with these two values as parameters.
The recursive binary search method must be called from the isThere method of the
SortedList class rather than being written as part of it.

private boolean binIsThere(int first, int last, int item)
// Returns true if item is in the list
{
if (first > last)     // Base case 1
return false;

else
{
int midPoint;
midPoint = (first + last) / 2;

Tail recursion A recursive algorithm in which no
statements are executed after the return from the
recursive call



14.3 Recursive Algorithms with Structured Variables | 665

if (item < listItems[midPoint])
return binIsThere(first, midPoint–1, item);

else if (item == listItems[midPoint])
return true;    // Base case 2

else
return binIsThere(midPoint+1, last, item);

}
}

Figure 14.4 Execution of print(data, 0, 4)

first
0

last
4



first
0

last
4

 first

0
last
4



first
1

last
4

 first

0
last
4



first
2

last
4

 first

0
last
4



first
3

last
4

 first

0
last
4



first
4

last
4

 first

0
last
4



first
5

last
4



data, which is the array, is not shown in the boxes.

print(data, 0, 4)

Call 1:

Call 2:

Call 3:

Call 4:

Call 5:

Call 6:

data[0]
is printed.



data[1]
is printed.

data[2]
is printed.

data[3]
is printed.

data[4]
is printed.



666 | Chapter 14:  Recursion

public boolean isThere(int item)
// Returns true if item is in the list.
{
return binIsThere(0, numItems–1, item);

}

14.4 Recursion or Iteration?
Recursion and iteration are alternative ways of expressing repetition in a program.
When iterative control structures are used, processes are made to repeat by embedding
code in a looping structure such as a while, for, or do. In recursion, a process is made to
repeat by having a method call itself. A selection statement is used to control the
repeated calls.

Which is better to use—recursion or iteration? There is no simple answer to this
question. The choice usually depends on two issues: efficiency and the nature of the
problem being solved.

Historically, the quest for efficiency, in terms of both execution speed and memory
usage, has favored iteration over recursion. Each time a recursive call is made, the sys-
tem must allocate stack space for all parameters and local variables. The overhead
involved in any method call is time-consuming. On early, slow computers with limited
memory capacity, recursive algorithms were visibly—sometimes painfully—slower than
the iterative versions. However, studies have shown that on modern, fast computers, the
overhead of recursion is often so small that the increase in computation time is almost
unnoticeable to the user. Except in cases where efficiency is absolutely critical, then, the
choice between recursion and iteration more often depends on the second issue—the
nature of the problem being solved.

Consider the factorial and power algorithms we discussed earlier in the chapter. In
both cases, iterative solutions were obvious and easy to devise. We imposed recursive
solutions on these problems only to demonstrate how recursion works. As a rule of
thumb, if an iterative solution is more obvious or easier to understand, use it; it is
probably more efficient. However, there are problems for which the recursive solution
is more obvious or easier to devise, such as the Towers of Hanoi problem. (It turns out
that the Towers of Hanoi problem is surprisingly difficult to solve using iteration.)
Computer science students should be aware of the power of recursion. If the definition
of a problem is inherently recursive, then a recursive solution should certainly be
considered.

Testing and Debugging

Recursion is a powerful technique when used correctly. Improperly used, recursion can
cause errors that are difficult to diagnose. The best way to debug a recursive algorithm
is to construct it correctly in the first place. To be realistic, however, we give a few hints
about where to look if an error occurs.

TE
AM
FL
Y

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

Team-Fly® 



Quick Check | 667

Testing and Debugging Hints

1. Be sure there is a base case. If there is no base case, the algorithm continues to issue
recursive calls until all memory has been used. Each time the method is called,
either recursively or nonrecursively, stack space is allocated for the parameters and
automatic local variables. If there is no base case to end the recursive calls, the run-
time stack eventually overflows. An error message such as “STACK OVERFLOW”
indicates that the base case is missing.

2. Be sure you have not used a while structure. The basic structure in a recursive algo-
rithm is the if statement. There must be at least two cases: the recursive case and
the base case. If the base case does nothing, the else clause is omitted. The selection
structure, however, must be there. If a while statement is used in a recursive algo-
rithm, the while statement usually should not contain a recursive call.

3. Use your system’s debugger program (or use debug output statements) to trace a
series of recursive calls. Inspecting the values of parameters and local variables
often helps to locate errors in a recursive algorithm.

Summary
A recursive algorithm is expressed in terms of a smaller instance of itself. It must
include a recursive case, for which the algorithm is expressed in terms of itself, and a
base case, for which the algorithm is expressed in nonrecursive terms.

In many recursive problems, the smaller instance refers to a numeric argument that is
being reduced with each call. In other problems, the smaller instance refers to the size of
the data structure being manipulated. The base case is the one in which the size of the
problem (value or structure) reaches a point for which an explicit answer is known.

In the conversion of decimal integers to binary, the size of the problem is the number
to be converted. When this number is 0, the conversion is finished. In the Towers of
Hanoi game, the size of the problem was the number of discs to be moved. When there
was only one left on the beginning peg, it could be moved to its final destination.

In the example for printing an array using recursion, the size of the problem was the
size of the array being printed. When the array size became 1, the solution was known.
In the binary search algorithm, the size of the problem was the size of the search area.
There are two base cases in this algorithm: when the search item is found or when the
search area becomes empty and you know that the search value is not there.

Quick Check
1. What distinguishes the base case from the recursive case in a recursive algo-

rithm? (p. 649)
2. What is the size of the problem in the recursive power algorithm? (pp. 649–650,

667)
3. What is the base case in the Towers of Hanoi algorithm? (pp. 658–661)
4. In working with simple variables, the recursive case is often stated in terms of a

smaller value. What is typical of the recursive case in working with structured
variables? (p. 662)

5. In the binary search algorithm, what is the base case? (pp. 664–665)



668 | Chapter 14:  Recursion

Answers
1. The base case is the simplest case, the case for which the solution can be stated nonrecursively.
2. The size of the problem is the power to which the number is taken. It is decreased by one in
each call. 3. When there are no more circles left to move. 4. It is often stated in terms of a
smaller structure. 5. When the search area is empty.

Exam Preparation Exercises
1. Recursion is an example of

a. selection
b. a data structure
c. repetition
d. data-flow programming

2. (True or False?) A void method can be recursive, but a value-returning
method cannot.

3. (True or False?) When a method is called recursively, the arguments and local
variables of the calling version are saved until its execution is resumed.

4. Given the recursive formula F(N) = 2F(N 2 2), with base case F(0) = 1, what are
the values of F(4), F(6), and F(5)? (If any of the values are undefined, say so.)

5. What algorithm error(s) leads to infinite recursion?
6. What control structure appears most commonly in a recursive method?
7. If you develop a recursive algorithm that employs tail recursion, what should you

consider?
8. A recursive algorithm depends on making something smaller. When the algo-

rithm works on a data structure, what might become smaller?
a. Distance from a position in the structure
b. The data structure
c. The number of variables in the recursive method

9. What is the name of the memory area used by the computer system to store a
method’s parameters and local variables?

10. Given the following input data (where \n denotes the newline character):

ABCDE\n

what is the output of the following method?

public static void rev()
{
char ch;

ch = (char)inFile.read();
if (ch != '\n’)
{
rev();
outFile.print(ch);

}
}



Programming Warm-Up Exercises | 669

11. Repeat Exercise 10, replacing the rev method with the following version:

public static void rev()
{
char ch;

ch = (char)inFile.read();
if (ch != '\n’)
{
outFile.print(ch);
rev();

}
}

12. Given the following input:

15
23
21
19

what is the output of the following method?

public static void printNums()
{
int n;
String line;
line = inFile.readLine();
if (line != null)                // If not EOF...
{
n = Integer.valueOf(line).intValue();
outFile.print(n + " ");
printNums();
outFile.print(n + " ");

}
}

Programming Warm-Up Exercises
1. Write a Java value-returning method that implements the recursive formula 

f (n) = f (n 2 1) + f (n 2 2) with base cases f (0) = 1 and f (1) = 1.
2. Add whatever is necessary to fix the following method so that func(3) equals 10.

public static int func(int n )
{
return func(n – 1) + 3;

}



670 | Chapter 14:  Recursion

3. Rewrite the following doubleSpace method without using recursion.

public static void doubleSpace()
{
char ch;
int data;
data = inFile.read();
if (data != –1)           // If not EOF...
{
ch = (char) data;
outFile.print(ch);
if (ch == '\n’)
outFile.println();

doubleSpace();
}

}

4. Rewrite the following printSquares method using recursion.

public static void printSquares()
{
int count;
for (count = 1; count <= 10; count++)
outFile.println(count + " " + count * count);

}

5. Modify the factorial method of this chapter to print its parameter and
returned value indented two spaces for each level of call to the method. The call
factorial(3) should produce the following output on System.out:

3
2
1
0
1

1
2

6

6. Write a recursive value-returning method that sums the integers from 1 through n.
7. Rewrite the following method so that it is recursive.

public static void printSqRoots(int n )
{
int i;

for (i = n; i > 0; i--)
outFile.println(i + " " + Math.sqrt((double)i));

}



Programming Problems | 671

8. The printArray method of this chapter prints the contents of an array from
first element to last. Write a recursive method that prints from last element to
first.

9. Write an isThere method that takes an array as a parameter and performs a
recursive linear search.

10. Rewrite the power method using another base case.
11. Rewrite the power method using the following formula.

if n == 0, return 1
if n = 1, return x
if n is even, return power (x*x, n/2)
else return x*power(x, n–1)

Programming Problems
1. Use recursion to solve the following problem.

A palindrome is a string of characters that reads the same forward and back-
ward. Write a program that reads in strings of characters and determines if each
string is a palindrome. Each string is on a separate input line. Print each string
on an output file, followed by “Is a palindrome” if the string is a palindrome or
“Is not a palindrome” if the string is not a palindrome. For example, given the
input string

Able was I, ere I saw Elba.

the program would print “Is a palindrome.” In determining whether a string is a
palindrome, consider uppercase and lowercase letters to be the same and ignore
punctuation characters.

2. Write a program to place eight queens on a chessboard in such a way that no
queen is attacking any other queen. This is a classic problem that lends itself to a
recursive solution. The chessboard should be represented as an 8 3 8 Boolean
array. If a square is occupied by a queen, the value is true; otherwise, the value
is false. The status of the chessboard when all eight queens have been placed is
the solution.

3. A maze is to be represented by a 10 3 10 array of three characters: P (for path),
H (for hedge), and E (for Exit). There is one exit from the maze. Write a pro-
gram to determine if it is possible to exit the maze from a given starting point.
You may move vertically or horizontally in any direction that contains P; you
may not move to a square that contains H. If you move into a square that con-
tains E, you have exited.

The input data consists of two parts: the maze and a series of starting points.
The maze is entered as 10 lines of 10 characters (P, H, and E). Each succeeding
line contains a pair of integers that represents a starting point (that is, row and
column numbers). Continue processing entry points until end-of-file occurs.





  

Appendix A

Java Reserved Words

abstract
boolean
break
byte
case
catch
char
class
const
continue
default

do
double
else
extends
false
final
finally
float
for
goto

if
implements
import
instanceof
int
interface
long
native
new
null

package
private
protected
public
return
short
static
strictfp
super
switch

synchronized
this
throw
throws
transient
true
try
void
volatile
while



      

Appendix B

Operator Precedence

Precedence (highest to lowest)

Operator Assoc.* Operand Type(s) Operation Performed

. LR object, member object member access
[] LR array, int array element access
( args ) LR method, arglist method invocation
++, -- LR variable post-increment, decrement
++, -- RL variable pre-increment, decrement
+, - RL number unary plus, unary minus
~  RL integer bitwise complement
! RL boolean boolean NOT
new RL class, arglist object creation
( type ) RL type, any cast (type conversion)
*, /, % LR number, number multiplication, division, remainder
+, - LR number, number addition, subtraction
+ LR string, any string concatenation
<< LR integer, integer left shift
>> LR integer, integer right shift with sign extension
>>> LR integer, integer right shift with zero extension
<, <= LR number, number less than, less than or equal
>, >= LR number, number greater than, greater than or equal
instanceof LR reference, type type comparison
== LR primitive, primitive equal (have identical values)
!= LR primitive, primitive not equal (have different values)
== LR reference, reference equal (refer to the same object)
!= LR reference, reference not equal (refer to different objects)
& LR integer, integer bitwise AND
& LR boolean, boolean boolean AND
^ LR integer, integer bitwise XOR
^ LR boolean, boolean boolean XOR

674 | Appendix B

In the following table, the operators are grouped by precedence level (highest to lowest), and a horizontal line
separates each precedence level from the next-lower level.



Precedence (highest to lowest)

Operator Assoc.* Operand Types(s) Operation Performed

| LR integer, integer bitwise OR
| LR boolean, boolean boolean OR
&& LR boolean, boolean conditional AND 

(short circuit evaluation)

|| LR boolean, boolean conditional OR 
(short circuit evaluation)

?: RL boolean, any, any conditional (ternary) operator
= RL variable, any assignment
*=, /=, %=, +=, -=, <<=,
>>=, >>>=, &=, ^=, |= RL variable, any assignment with operation

*LR means left to right associativity; RL means right to left associativity.

Appendix C

Primitive Data Types

Type Value Stored Default Value Size Range of Values

char Unicode character Character code 0 16 bits 0 to 65535
byte Integer value 0 8 bits 2128 to 127
short Integer value 0 16 bits 232768 to 32767
int Integer value 0 32 bits 22147483648 to 2147483647
long Integer value 0 64 bits 29223372036854775808 to 

9223372036854775807
float Real value 0.0 32 bits 61.4E-45 to 

63.4028235E+38
double Real value 0.0 64 bits 64.9E-324 to

61.7976931348623157E+308
boolean true or false false 1 bit NA

Appendix C | 675



         

676 | Appendix D

Appendix D

ASCII Subset of Unicode
The following chart shows the ordering of characters in the ASCII (American Standard Code for Information
Interchange) subset of Unicode. The internal representation for each character is shown in decimal. For exam-
ple, the letter A is represented internally as the integer 65. The space (blank) character is denoted by a “®”.

Right ASCII
Left Digit

Digit(s) 0 1 2 3 4 5 6 7 8 9

0 NUL SOH STX ETX EOT ENQ ACK BEL BS HT
1 LF VT FF CR SO SI DLE DC1 DC2 DC3
2 DC4 NAK SYN ETB CAN EM SUB ESC FS GS
3 RS US ® ! “ # $ % & ´
4 ( ) * + , – . / 0 1
5 2 3 4 5 6 7 8 9 : ;
6 < = > ? @ A B C D E
7 F G H I J K L M N O
8 P Q R S T U V W X Y
9 Z [ \ ] ^ _ ` a b c
10 d e f g h i j k l m
11 n o p q r s t u v w
12 x y z { | } ~ DEL

Codes 00–31 and 127 are the following nonprintable control characters:

NUL Null character VT Vertical tab SYN Synchronous idle
SOH Start of header FF Form feed ETB End of transmitted block
STX Start of text CR Carriage return CAN Cancel
ETX End of text SO Shift out EM End of medium
EOT End of transmission SI Shift in SUB Substitute
ENQ Enquiry DLE Data link escape ESC Escape
ACK Acknowledge DC1 Device control one FS File separator
BEL Bell character (beep) DC2 Device control two GS Group separator
BS Back space DC3 Device control three RS Record separator
HT Horizontal tab DC4 Device control four US Unit separator
LF Line feed NAK Negative acknowledge DEL Delete

TE
AM
FL
Y

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

Team-Fly® 



Appendix D | 677

Right EBCDIC
Left Digit

Digit(s) 0 1 2 3 4 5 6 7 8 9

6 ®
7 ¢ . < ( + |
8 &
9 ! $ * ) ; ¬ – /
10 ^ , % _
11 > ?
12 ` : # @ ´ = “ a
13 b c d e f g h i
14 j k l m n
15 o p q r
16 ~ s t u v w x y z
17 \ { }
18 [ ]
19 A B C D E F G
20 H I J
21 K L M N O P Q R
22 S T U V
23 W X Y Z
24 0 1 2 3 4 5 6 7 8 9

In the EBCDIC table, nonprintable control characters—codes 00–63, 250–255, and those for
which empty spaces appear in the chart—are not shown.



      

Appendix E

Decimal Format Type

To give more precise control over the formatting of numbers, Java provides a class
called DecimalFormat that is part of a package called java.text. The DecimalFor-
mat class allows us to create patterns that can be used to format numbers for output.
These patterns are in the form of strings, made up of characters that represent the parts
of a formatted number. For example, the pattern

"###,###"

indicates that a number should be formatted with up to six decimal digits, and when
there are more than three digits in the number, a comma should be used to separate the
thousands from the rest of the number.

There are four steps we must follow to use DecimalFormat patterns to format
numbers:

• import java.text.*;
• Declare an object of type DecimalFormat for each number format we wish to use.
• Give the object a value of type DecimalFormat that contains the pattern.
• Format the number using the format method associated with each of the Deci-

malFormat variables.

Let’s examine each of these steps in turn. You are familiar with writing import declara-
tions, so all you need to do for the first step is remember to put the declaration at the
start of your program. Declaring objects of type DecimalFormat is done in the same
way as declaring objects of type String or Frame. For example:

DecimalFormat dollar; // Format for dollar amounts
DecimalFormat percent; // Format for percentages
DecimalFormat accounting; // Format for negative values in ()

678 | Appendix E



The third step involves using new and the DecimalFormat constructor to create a value
that we can assign to the object. The call to the constructor contains the string repre-
senting the pattern. Here are statements that assign patterns to each of the variables
declared previously. Don’t be concerned yet with trying to interpret the specific patterns
shown; we explain them below.

dollar = new DecimalFormat("$###,##0.00");
percent = new DecimalFormat("##0.00%");
accounting = new DecimalFormat("$###,##0.00;($###,##0.00)");

The last step is to format the number using a method called format, which is a value
returning method associated with each of the DecimalFormat objects. The format
method takes as its parameter a numerical value and returns a value of type String
that contains the formatted number. For example, if we write

out.add(new Label(dollar.format(2893.67));

then a label is added to the frame called out, which contains a string of the form

$2,893.67

Now that we have seen the process for using patterns to format numeric values, let’s
look at how to write the patterns themselves. The following table shows the characters
that can appear in a pattern string and their meanings.

Appendix E | 679

Character Meaning

0 Display one digit here. If no digit is present in this place, display a zero.
# Display one digit here. If no digit is present in this place, display nothing here (not

even a blank).
, If there are digits on both sides of this place, insert a comma to separate them. The

comma is only meaningful in the integer part of the pattern (the part to the left of
the decimal point).

. Put the decimal point here. If the pattern doesn’t have any digits (0 or #) to the
right of the period, and the number doesn’t have a fractional part, don’t insert the
decimal point.

% When used anywhere to the right of the rightmost digit in the pattern, this indi-
cates that the number is a percentage. Multiply it by 100 before displaying it, and
put the % sign here.

; The pattern to the left of ; is for positive numbers. The pattern to the right is for
negative numbers.

‘ The character following is one of the special pattern characters, but should be
printed literally (For example, use ‘# to show a # in the formatted number.)

other Anything else is inserted exactly as it appears.



Now we can interpret the patterns we assigned to the DecimalFormat variables.
The pattern we gave to dollar is "$###,##0.00", which means the number should
have a decimal point with at least two fractional digits and one digit in the integer part.
When the integer part has more than three digits, use a comma as a separator. The num-
ber should start with a dollar sign to the left of the first digit.

We use the pattern "##0.00%" to tell format that the number is a percentage that
should first be multiplied by 100. After that, it is formatted with at least two fractional
digits and one digit in the integer part. The percent sign is to be placed to the right of
the last digit.

The third pattern, "$###,##0.00;($###,##0.00)", is the most complex of the
three, but is really just a minor variation on the dollar format. The semicolon indicates
that the pattern on the left, which is the same as the pattern we gave to dollar, is to be
used when the number is positive. The pattern on the right (the same pattern but in
parentheses) is to be used when the number is negative.

Here is a code segment that shows the definition and use of these patterns. Note that
we are also using Label.RIGHT to align the numbers to the right within their labels.

dollar = new DecimalFormat("$###,##0.00");
percent = new DecimalFormat("##0.00%");
accounting = new DecimalFormat("$###,##0.00;($###,##0.00)");

out.add(new Label(dollar.format(2893.67), Label.RIGHT));
out.add(new Label(dollar.format(–2893.67), Label.RIGHT));
out.add(new Label(dollar.format(4312893.6), Label.RIGHT));
out.add(new Label(dollar.format(0), Label.RIGHT));
out.add(new Label(percent.format(0.23679), Label.RIGHT));
out.add(new Label(percent.format(1), Label.RIGHT));
out.add(new Label(accounting.format(2893.67), Label.RIGHT));
out.add(new Label(accounting.format(–2893.67), Label.RIGHT));

Let’s take a closer look at each of the labels in this frame. The first label demon-
strates what happens when a positive floating-point value is formatted with the dollar
format. Only as many digits are used as are necessary, and the dollar sign is immedi-
ately adjacent to the leftmost digit. The second label shows the result of formatting a
negative number. The format is the same as in the first case, but a minus sign precedes
the dollar sign.

The third label is an example of formatting a number with more digits than the pat-
tern specifies. Notice that the pattern is expanded to fit. The separation between the
decimal point (or the rightmost digit, in the case of an integer) and the comma closest to
it are used as a guide to the placement of additional commas. In this case, the comma is
three places to the left of the decimal point, so additional commas are inserted every
three places. We can’t split up the fractional part of a number with a separator character
such as comma or period. If you try to use a comma in the fractional part, it simply
ends up being pushed to the right end of the number. It is also interesting to compare

680 | Appendix E



the value in the code segment with the value displayed—this is a perfect example of
what we said earlier about the kind of minor inaccuracies you often encounter with
floating-point numbers!

The fourth label demonstrates that an integer value can be formatted to look like a
floating-point value. It also shows that placing a zero in the pattern forces a zero to
appear in the resulting string when there is no corresponding digit in the number.

The fifth label shows the use of the percent format. Notice that the value is multi-
plied by 100 before it is formatted. This example also shows that when there are more
digits of precision in the fractional part than in the pattern, it is not expanded to show
the additional fractional digits. The sixth label shows the application of the percent
format to an integer.

The last two labels in the frame demonstrate the use of the pattern we assigned to
accounting. When the number is positive, it is formatted normally, and when it is neg-
ative, it is enclosed in parentheses. Using two different patterns separated by a semi-
colon suppresses the automatic insertion of the minus sign and allows us to use other
characters to indicate that the number is negative. As a safeguard, however, if we mis-
takenly use the same pattern on both sides of the semicolon, format ignores the semi-
colon and reverts to using the minus sign.

DecimalFormat gives us a powerful mechanism to format numbers in the patterns
we typically use in our programs. However, it has some limitations. For example, when
printing a dollar amount on a check, it is typical to fill the extra space around the num-
ber with asterisks or dashes to prevent tampering. DecimalFormat doesn’t enable us to
do this directly. However, because the format method returns its value as a string, we
can store a formatted number into a String variable and then use string operations to
further refine its formatting.

Suppose we write the assignments

dollar = new DecimalFormat("###,##0.00");
value = 8239.41;

then the expression

dollar.format(value)

has the value "8,239.41". Further suppose that we want to display this in a fixed
space of thirteen character positions, where the first character is the dollar sign and the
spaces between the dollar sign and the first digit are filled with stars:
"$****8,239.41". If the number has more digits, fewer stars are needed, and if it has
fewer digits then more stars must be concatenated. The number of stars to add is

12 – dollar.format(value).length

because the dollar sign takes up one of the thirteen character positions. The maximum
value of this expression is 8, because the format requires at least three decimal digits

Appendix E | 681



and a decimal point. Thus, if we use a string constant called stars that contains eight
stars, we can write

stars.substring(0, 12 – dollar.format(value).length)

to get a string with the proper number of stars. All we have left to do is to concatenate
the pieces to form the desired string.

"$" + stars.substring(0, 12 – dollar.format(value).length) +
dollar.format(value)

Look closely at this expression to be certain that you understand how it works.
Many programming problems require that output values be precisely formatted. In such
cases, you may need to use complex combinations of the string operations that Java
provides. Breaking an output format into its component pieces and deciding how to for-
mat each piece before concatenating them together is a common strategy for dealing
with this complexity.

682 | Appendix E



      

Appendix F

Program Style, Formatting, and Documentation

Useful programs have very long lifetimes, during which they must be modified and
updated. Good style and documentation are essential if another programmer is to under-
stand and work with your program.

General Guidelines

Style is of benefit only for a human reader of your programs—differences in style make
no difference to the computer. Good style includes the use of meaningful identifiers,
comments, and indentation of control structures, all of which help others to understand
and work with your program. Perhaps the most important aspect of program style is
consistency. If the style within a program is not consistent, it then becomes misleading
and confusing.

Comments

Comments are extra information included to make a program easier to understand. You
should include a comment anywhere the code is difficult to understand. However, don’t
overcomment. Too many comments in a program can obscure the code and be a source
of distraction.

In our style, there are four basic types of comments: headers, declarations, in-line,
and sidebar.

Header comments appear at the top of a class, method, or package and should
include your name, the date that the code was written, and its purpose. It is also useful
to include sections describing the input, output, and assumptions that form the basis for
the design of the code. The header comments serve as the reader’s introduction to your
program. Here is an example:

// This method computes the sidereal time for a given date and solar
//  time
// 
// Written by: Your Name
// 
// Date completed: 4/8/02
// 
// Input: java.util.calendar object for the date and solar time
// 

Appendix F | 683



// Output: a java.util.calendar object containing the corresponding
//  sidereal time
// 
// Assumptions: Solar time is specified for a longitude of 0 degrees

Declaration comments accompany the field declarations in a class. Anywhere that
an identifier is declared, if is helpful to include a comment that explains its purpose. For
example:

//Class constants
static final String FIRST  = "Herman";     // Person’s first name
static final String LAST   = "Herrmann";   // Person’s last name
static final char   MIDDLE = 'G';          // Person’s middle initial
// Instance variables
Frame outputDisplay;                       // Declare frame object
String firstLast;                          // Name in first-last format
String lastFirst;                          // Name in last-first format
int studentCount;                          // Number of students
int sumOfScores;                           // Sum of their scores
long sumOfSquares;                         // Sum of squared scores
double average;                            // Average of the scores
float deviation;                           // Standard deviation of scores
char grade;                                // Student’s letter grade
String stuName;                            // Student’s name

Notice that aligning the comments gives the code a neater appearance and is less dis-
tracting.

In-line comments are used to break long sections of code into shorter, more compre-
hensible fragments. It is generally a good idea to surround in-line comments with blank
lines to make them stand out. In this text we save space by printing the in-line com-
ments in color rather than using blank lines. Some editors also color comments automat-
ically, which makes it easier to spot them on the screen. However, blank lines are still
helpful because code is often printed on paper in black and white. Here is an example:

//Instantiate labels and input field

resultLabel = new Label("Result:");
register = new Label("0.0", Label.RIGHT);
entryLabel = new Label("Enter #:");
inputField = new TextField("", 10);

//Instantiate button objects

add = new Button("+");
subtract = new Button("-");
clear = new Button("Clear");

684 | Appendix F



//Name the buttons

add.setActionCommand("add");
subtract.setActionCommand("subtract");
clear.setActionCommand("clear");

//Register the button listeners

add.addActionListener(operation);
subtract.addActionListener(operation);
clear.addActionListener(clearOperation);

Even if comments aren’t needed, blank lines can be inserted wherever there is a logical
break in the code that you would like to emphasize.

Sidebar comments appear to the right of executable statements and are used to shed
light on the purpose of the statement. Sidebar comments are often just pseudocode
statements from your responsibility algorithms. If a complicated Java statement requires
some explanations, the pseudocode statement should be written to its right. For exam-
ple:

while ((line = dataFile.readLine()) != null ) // Get a line if not EOF

Because the page of a textbook has a fixed width, it is sometimes difficult to fit a side-
bar comment next to a long line of code. In those cases, we place the sidebar comment
before the statement to which it refers. Most computer screens can now display more
characters on a line than fit across a page, so this situation is less common in practice.
However, if lines of code become too long, they are hard to read. It is then better to
place the sidebar comment before the line of code.

In addition to the four main types of comments that we have discussed, there are
some miscellaneous comments that we should mention. Although we do not do this in
the text, to conserve space, we recommend that classes and methods be separated in a
compilation unit file by a row of asterisks.

//*********************************************************************

Programmers also sometimes place a comment after the right brace of a block to indi-
cate which control structure the block belongs to. This is especially helpful in a package
file where there may be multiple classes. Indicating where a class or long method ends
helps readers keep track of where they are looking in scanning the code.

return noCorrect;
}

} // End of class TheKey

Appendix F | 685



Identifiers

The most important consideration in choosing a name for a field or method is that the
name convey as much information as possible about what the field is or what the
method does. The name should also be readable in the context in which it is used. For
example, the following names convey the same information, but one is more readable
than the other:

datOfInvc     invoiceDate

Although an identifier may be a series of words, very long identifiers can become quite
tedious and can make the program harder to read. The best approach to designing an
identifier is to try writing out different names until you reach an acceptable compro-
mise—and then write an especially informative declaration comment next to the decla-
ration.

Formatting Lines and Expressions

Java allows you to break a long statement in the middle and continue onto the next
line. The split can occur at any point where it would be possible to insert spaces without
affecting the behavior of the code. When a line is so long that it must be split, it’s
important to choose a breaking point that is logical and reasonable. Compare the read-
ability of the following code fragments:

outFile.println(" for a radius of " + radius + "the diameter of the cir"
+ "cle is " + diameter);

outFile.println(" for a radius of " + radius +
" the diameter of the circle is " + diameter);

When writing expressions, keep in mind that spaces improve readability. Usually
you should include one space on either side of the == operator as well as most other
operators. Occasionally, spaces are left out to emphasize the order in which operations
are performed. Here are some examples:

if (x+y > y+z)
maximum = x + y;

else
maximum = y + z;

hypotenuse = Math.sqrt(a*a + b*b);

Indentation

The purpose of indenting statements in a program is to provide visual cues to the reader
and to make the program easier to debug. When a program is properly indented, the
way the statements are grouped is immediately obvious. Compare the following two
program fragments:

686 | Appendix F

TE
AM
FL
Y

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

Team-Fly® 



while (count <= 10)
{
num = Integer.valueOf(in.readLine()).intValue();
if (num == 0)
{
count++;
num = 1;
}
out.println(num);
out.println(count);
}

while (count <= 10)
{

num = Integer.valueOf(in.readLine()).intValue();
if (num == 0)
{
count++;
num = 1;

}
out.println(num);
out.println(count);

}

As a basic rule in this text, each nested or lower level item is indented by two spaces.
Exceptions to this rule are parameter declarations and statements that are split across
two or more lines. Indenting by two spaces is a matter of personal preference. Some
people prefer to indent by more spaces.

In this text, we prefer to place the braces on separate lines so that it is easy to scan
down the left edge of a block of code and find them. Placing them on separate lines also
reminds us to consider whether the beginning or the end of a block would benefit from
an in-line comment and automatically gives us a place to write one. This is just one
style of placement, and you will encounter other styles as you encounter code written
by other programmers.

As we noted at the beginning of this appendix, the most important aspect of code
formatting is consistency. You may frequently find it necessary to adopt the style of
another programmer in order to update their code in a consistent manner. Even when
you believe your own favorite style to be superior, resist the temptation to mix your
style with a different, existing style. The mixture is likely to be more confusing than
either style alone.

Appendix F | 687



     

Appendix G

Applets

In this text we write all of our programs as Java applications. That is, we write a class
that contains a method called main to act as the driver for whatever set of scenarios our
objects support. Java provides a second type of program called an applet. As its name
implies, it is intended to be a small application.

Applets are used as elements of web pages. Most web browsers include a special
JVM that can execute the bytecode contained in an applet. When the browser encoun-
ters a link to an applet bytecode file, it copies the file into memory and calls its JVM to
execute the bytecode.

The ability for a browser to execute applets means that we can create web pages
that are as sophisticated as almost any program we can write in Java. We say almost
because applets are subject to certain limitations that Java applications are not. For
example, you would not want your browser to run an applet that destroys the files on
your computer. Thus, applets are prohibited from accessing files.1 Likewise, an applet
cannot send messages to other computers from your computer (except the one from
which it was loaded). These security restrictions are included in Java to prevent the cre-
ation of harmful applets by malicious programmers.

From an educational viewpoint, we thus present only applications in this text
because they enable us to use all of Java’s features. They also do not require the use of a
browser or a separate program (called an applet viewer) to run compiled code.

Creating an applet instead of an application is reasonably straightforward. Like an
application, an applet resides in a class and has specially named methods that are called
by the JVM. Whereas an application is a class derived from Object, however, an applet
is written in a class derived from a class called Applet. Thus the beginning of any
applet must contain statements similar to these:

import java.applet.Applet;

public class SomeName extends Applet
{

The Applet class provides several methods that we can override with our derived
class. One of these is called init.

688 | Appendix G

1Later versions of Java ease this restriction to allow special cases of file access when a user permits it.



Because of the way that applets are executed, they should not have constructors.
Instead, the operations that we would normally place into a constructor (such as initial-
izing fields or setting up the user interface) should be written in the applet’s init
method. When a browser first downloads an applet, its JVM executes this method. The
init method is equivalent to main in an application. It contains the main block of code
that begins the work of the applet.

The applet class contains additional methods called start, stop, and destroy that
are used with more sophisticated applets that employ features of Java that we do not
cover in this text. For example, if an applet is showing a graphics animation, we may
want it to stop when the user moves to a different web page and resume (start) when
the user returns to the page with the applet.

The Applet class is derived from Container, as is Frame. Thus, they share much
in common. However, in our applications, we had to instantiate a Frame into which we
added our user interface components. Because an applet is itself a container, we simply
call methods such as add and setLayout directly. All of the components we have
introduced in the text can be used with applets. Thus, to demonstrate how an applet is
written, we present the code for the Calculator application of Chapter 6, rewritten
into the form of an applet. In rewriting the code we have condensed the event handlers
into a single ActionListener to illustrate that an applet can directly implement a lis-
tener. We have also added exception handling (see Chapter 10) to check for an improp-
erly formatted input value.

import java.applet.Applet;                          // Applet class
import java.awt.event.*;                            // Event handling classes
import java.awt.*;                                  // User interface classes

public class Calculator extends Applet implements ActionListener
{

// Define action listener for numeric buttons
public  void actionPerformed(ActionEvent event)
// Handles events from the buttons in calcFrame
{
double secondOperand;                           // Holds input value
String whichButton;                             // Holds the button's name
// Get the operand, checking for numeric format error
try
{
secondOperand = Double.valueOf(inputField.getText()).doubleValue();

}
catch (NumberFormatException except)
{
secondOperand = 0.0;                          // If error, set to zero

}

Appendix G | 689



whichButton = event.getActionCommand();         // Get the button's name

if (whichButton.equals("add"))                  // When the name is "add"
result = result + secondOperand;              //  add the operand

else  if (whichButton.equals("subtract"))       // When "subtract"
result = result – secondOperand;              //  subtract the operand

else                                            // Otherwise
result = 0.0;                                 // Clear result to zero

register.setText("" + result);                  // Display result
inputField.setText("");                         // Clear input

}

private static TextField inputField;              // Data field
private static Label register;                    // Result shown on screen
private static double result;                     // Keeps current value

public void init()
{
Label resultLabel;                              // Indicates output area
Label entryLabel;                               // Label for input field
Button add;                                     // Add button
Button subtract;                                // Subtract button
Button clear;                                   // Clear button
result = 0.0;                                   // Initialize result

// Instantiate labels and initialize input field
resultLabel = new Label("Result:");
register = new Label("0.0", Label.RIGHT);
entryLabel = new Label("Enter #:");
inputField = new TextField("", 10);

// Instantiate button objects
add = new Button("+");
subtract = new Button("-");
clear = new Button("Clear");

// Name the button events
add.setActionCommand("add");
subtract.setActionCommand("subtract");
clear.setActionCommand("clear");

// Register the button listeners
add.addActionListener(this);
subtract.addActionListener(this);

690 | Appendix G



clear.addActionListener(this);

// Add interface elements to applet
setLayout(new GridLayout(4,2));                  // Set the layout manager
add(resultLabel);
add(register);
add(entryLabel);
add(inputField);
add(add);
add(subtract);
add(clear);

}
}

Appendix G | 691



     

692 | Appendix H

1Java 1.2 is sometimes also confusingly referred to as Java 2 because at the same time, Sun released version
two of their Java software development tools. The version of the language at that time was 1.2, so technically,
Java 1.2 was part of the Java Software Development Kit version 2, which many people shorten to just Java 2.

Appendix H

Converting from AWT to Swing

With the release of Java 1.21, Sun introduced a new package for writing graphical user
interfaces. Called Swing, this package replaces the functionality of AWT, which we have
used throughout this book. Although Swing offers many new features, most of them are
not essential for learning to program. The new features permit the creation of more
sophisticated user interfaces than our programs require. At the time of this writing,
Swing is still not fully supported under all operating systems. However, if you would
like to explore its use, this Appendix presents the essential differences between Swing
and AWT and the changes that you must make to your programs to substitute Swing for
AWT. The process is relatively easy because Swing implements nearly all of the same
basic classes that are in AWT.

As you might expect, the first change is to import the Swing packages. The import
statements you need are:

import javax.swing.*;
import.javax.swing.event.*;

If you’re converting an AWT program, you may still need to import java.awt.* and
java.awt.event.*. For example, Swing provides a new set of layout managers, and
Swing is also compatible with our old layout manager friends flowLayout and grid-
Layout, which are part of AWT. So if you want to make use of the AWT layout man-
agers, you must still import the AWT package.

Next, you must change all of the AWT class names to the corresponding Swing
classes. To do so, just add the letter J to the front of the AWT class name:

Frame � JFrame
Button � JButton
Label 	 JLabel
TextField 
 JTextField

The next step is somewhat more complicated. With a Frame object, we add components
such as Buttons directly to the Frame. But with a JFrame there is another layer that we
must go through. A JFrame object consists of multiple parts that affect its appearance



on the screen (we could select a different style of window to display, for example). The
part to which we add our components is called the content pane (as in a pane of glass in
a window). Once we instantiate a JFrame, we must ask it to return a reference to its
content pane. The content pane is an object of class Container, which is the superclass
for Frame, JFrame, and all other user interface classes that can contain components. So
we may write:

private static JFrame calcFrame;
private static Container calcPane;

calcFrame = new JFrame();
calcPane = calcFrame.getContentPane();

Then we can add components to the content pane. For example:

calcPane.setLayout(new GridLayout(4,2));
calcPane.add(new JLabel("Result:"));

Two methods from AWT that are not implemented by Swing are Pack and Show.
Instead, we set the size of a JFrame and then set its visibility to true. The size is speci-
fied in terms of the number of horizontal and vertical pixels on the screen. Here is an
example that sets the calcFrame to 300 pixels wide by 200 pixels high and then shows
it on the screen.

calcFrame.setSize(300, 200);
calcFrame.setVisible(true);

You may need to experiment with different sizes to get a window that is just right for
your needs.

With AWT we needed to use a WindowAdapter to define an event handler method
for closing a window. In all of our programs, we merely disposed of the frame and
exited the program. In Swing, we no longer need to do this. A single method tells the
JFrame what to do when its window is closed, as long the action is one of a small set of
common choices. The JFrame class provides the following class constants that name
these choices:

JFrame.DISPOSE_ON_CLOSE
JFrame.DO_NOTHING_ON_CLOSE
JFrame.HIDE_ON_CLOSE

These are passed to an instance method called setDefaultCloseOperation. Here is
an example:

calcFrame.setDefaultCloseOperation(JFrame.DO_NOTHING_ON_CLOSE);

Appendix H | 693



The example tells calcFrame not to click on the window’s close button, which is the
usual behavior of a Frame if we fail to specify an event handler.

There is one additional choice, which does not have a named constant. If we pass
the integer 3 to setDefaultCloseOperation, then the program disposes of the win-
dow and exits (just what we’ve always done). Here’s how that call would look:

calcFrame.setDefaultCloseOperation(3); //Exit program on closing window

So that you can see how all of this works in the context of a real program, we present
below the code for program Calculator in Chapter 6. Compare this to the code on pages
267—269 to see the differences. We’ve marked the lines that have changed significantly
by starting their comments with a + sign. (Some of the changes are simply a result of
introducing a new variable name, because of the need to provide a container for the
content pane. We haven’t marked these changes.)

import javax.swing.*;                  //+User interface classes
import javax.swing.event.*;                  //+Event handling classes
import java.awt.*;                       //Older interface classes
import java.awt.event.*;                    //Older event classes

public class SwingCalculator
{
//Define action listener for numeric buttons
private static  class NumericHandler implements ActionListener         
{
public void actionPerformed(ActionEvent event)
//Handles events from the buttons in calcPane
{
double secondOperand;                 //Holds input value
String whichButton;                   //Holds the button's name
//Get the operand
secondOperand =
Double.valueOf(inputField.getText()).doubleValue(); 

whichButton = event.getActionCommand();//Get the button's name

if (whichButton.equals("add"))         //When the name is "add"
result = result + secondOperand;   //  add the operand

else                                  //Otherwise
result = result - secondOperand; //  subtract the operand

register.setText("" + result);       //Display result
inputField.setText("");              //Clear input

} 
}

694 | Appendix H



private static class ClearHandler implements ActionListener
{
public void actionPerformed(ActionEvent event)
//Handles events from the Clear button in calcPane
{
result = 0.0;                        //Set result back to zero
register.setText("0.0");               //Reset result in register
inputField.setText("");                //Clear input
}

}

private static JTextField inputField;      //+Data field
private static JLabel register;           //+Result shown on screen
private static JFrame calcFrame;           //+Declare a frame
private static Container calcPane;       //+Container to hold

//  content pane of frame
private static double result;              //Keeps current value

public static void main(String[] args)
{
NumericHandler operation;              //Declare numeric listener
ClearHandler clearOperation;            //Declare clear listener
JLabel resultLabel;                      //+Indicates output area
JLabel entryLabel;                      //+Label for input field
JButton add;                          //+Add button
JButton subtract;                        //+Subtract button
JButton clear;                           //+Clear button

operation = new NumericHandler();       //Instantiate operation
clearOperation = new ClearHandler();     //Instantiate clear
result = 0.0;                            //Initialize result

//Instantiate labels and initialize input field
resultLabel = new JLabel("Result:");         //+
register = new JLabel("0.0", JLabel.RIGHT);  //+
entryLabel = new JLabel("Enter #:");        //+
inputField = new JTextField("", 10);         //+

//Instantiate button objects
add = new JButton("+");                      //+
subtract = new JButton("-");                //+
clear = new JButton("Clear");              //+

Appendix H | 695



//Name the button events
add.setActionCommand("add");
subtract.setActionCommand("subtract");
clear.setActionCommand("clear");

//Register the button listeners
add.addActionListener(operation);
subtract.addActionListener(operation);
clear.addActionListener(clearOperation);

//Add interface elements to calcFrame
calcFrame = new JFrame();                //+Give the frame a value
calcPane = calcFrame.getContentPane();  //+Get the content pane
calcPane.setLayout(new GridLayout(4,2)); //Set the layout manager
calcPane.add(resultLabel);
calcPane.add(register);
calcPane.add(entryLabel);
calcPane.add(inputField);
calcPane.add(add);
calcPane.add(subtract);
calcPane.add(clear);
calcFrame.setSize(300, 200);            //+Specify size of frame
calcFrame.setVisible(true);             //+Show the frame
calcFrame.setDefaultCloseOperation(3);   //+Set close op to exit

}
}

And here is the Swing JFrame that is displayed when the program runs:

696 | Appendix H

TE
AM
FL
Y

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

Team-Fly® 



     

abstract a modifier of a class or field that indicates that it is incomplete and must
be fully defined in a derived class

abstract data type  (ADT) a class of data objects with a defined set of properties
and a set of operations that process the data objects while maintaining the prop-
erties

abstract step an algorithmic step for which some implementation details remain
unspecified

abstraction a model of a complex system that includes only the details essential to
the perspective of the viewer of the system; the separation of the logical proper-
ties of data or actions from their implementation details; the separation of the
logical properties of an object from its implementation

abstraction (in OOD) the essential characteristics of an object from the viewpoint
of the user

aggregate operation an operation on a data structure as a whole, as opposed to an
operation on an individual component of the data structure

algorithm a logical sequence of discrete steps that describes a complete solution to
a given problem computable in a finite amount of time; instructions for solving
a problem or subproblem in a finite amount of time using a finite amount of
data; a verbal or written description of a logical sequence of actions

allocate to assign memory space at run time for use by an object
ALU see arithmetic/logic unit
anonymous class a class that does not have an identifier (a name) associated with

it
argument a variable, constant, or expression listed in the call to a method
arithmetic/logic unit (ALU) the component of the central processing unit that per-

forms arithmetic and logical operations



array a collection of components, all of the same type, ordered on n dimensions 
(n >= 1); each component is accessed by n indices, each of which represents the
component’s position within that dimension

assembler a program that translates an assembly language program into machine
code

assembly language a low-level programming language in which a mnemonic repre-
sents each of the machine language instructions for a particular computer

assertion a logical proposition that is either true or false
assignment expression a Java expression with (1) a value and (2) the side effect of

storing the expression value into a memory location
assignment statement a statement that stores the value of an expression into a vari-

able
asynchronous not occurring at the same moment in time as some specific operation

of the computer; in other words, not synchronized with the program’s actions
atomic data type a data type that allows only a single value to be associated with an

identifier of that type
auxiliary storage device a device that stores data in encoded form outside the com-

puter’s memory
binary operator an operator that has two operands
base address the memory address of the first element of an array
base case the case for which the solution can be stated nonrecursively
base class the class being inherited from
big-O notation a notation that expresses computing time (complexity) as the term in

a function that increases most rapidly relative to the size of a problem
binary expressed in terms of combinations of the numbers 1 and 0 only
binary search a search algorithm for sorted lists that involves dividing the list in half

and determining, by value comparison, whether the item would be in the upper or
lower half; the process is performed repeatedly until either the item is found or it is
determined that the item is not on the list

bit short for binary digit; a single 1 or 0
block a group of zero or more statements enclosed in braces
body the statement(s) to be repeated within the loop; the executable statement(s)

within a function
boolean a data type consisting of only two values: true and false
boolean expression an assertion that is evaluated as either true or false, the only val-

ues of the boolean data type
boolean operators operators applied to values of the type boolean; in Java these are

the special symbols &&, ||, and !
booting the system the process of starting up a computer by loading the operating

system into its main memory
branch a code segment that is not always executed; for example, a switch statement

has as many branches as there are case labels
branching control structure see selection control structure

698 | Glossary



brainstorming (in OOD) the beginning phase of an object-oriented design in which
possible classes of objects in the problem are identified

button a component of a frame that fires an event (called a button event)  when the
user clicks on it with the mouse

byte eight bits
Bytecode a standard machine language into which Java source code is compiled 
CRC Cards index cards on which a class name is written along with its super and sub-

classes and a listing of the class’s responsibilities and collaborators; Class, Respon-
sibility, Collaboration

call the point at which the computer begins following the instructions in a subpro-
gram is referred to as the subprogram call

cancellation error a form of representational error that occurs when numbers of
widely differing magnitudes are added or subtracted

catch the processing of a thrown exception by a section of code called an exception
handler

central processing unit (CPU) the part of the computer that executes the instructions
(program) stored in memory; consists of the arithmetic/logic unit and the control
unit

char data type whose values consist of one alphanumeric character (letter, digit, or
special symbol)

character set a standard set of alphanumeric characters with a given collating
sequence and binary representation

class (general sense) a description of the behavior of a group of objects with similar
properties and behaviors

class (Java construct) a pattern for an object
class data data that is associated with a class and accessible by all objects of that class
class method a method that is associated with a class but not with a specific object; it

is called by writing the name of the class followed by a period and then the name
of the method and its parameter list

client software that declares and manipulates objects of a particular class
code data type specifications and instructions for a computer that are written in a pro-

gramming language
code walk-through a verification process for a program in which each statement is

examined to check that it faithfully implements the corresponding algorithmic step
coding translating an algorithm into a programming language; the process of assign-

ing bit patterns to pieces of information
collating sequence the ordering of the elements of a set or series, such as the charac-

ters (values) in a character set
compiler a program that translates a high-level language (such as C++, Pascal, or

Java) into machine code
compiler listing a copy of a program into which have been inserted messages from

the compiler (indicating errors in the program that prevent its translation into
machine language if appropriate)

Glossary | 699



complexity a measure of the effort expended by the computer in performing a compu-
tation, relative to the size of the computation

composite data type a data type that allows a collection of values to be associated
with an object of that type

composition (containment) a mechanism by which an internal data member of one
class is defined to be an object of another class type

computer  (electronic) a programmable device that can store, retrieve, and process
data

computer program data type specifications and instructions for carrying out opera-
tions that are used by a computer to solve a problem

computer programming the process of specifying the data types and the operations
for a computer to apply to data in order to solve a problem

concrete step a step for which the implementation details are fully specified
conditional test the point at which the boolean expression is evaluated and the deci-

sion is made to either begin a new iteration or skip to the first statement following
the loop

constant an item in a program whose value is fixed at compile time and cannot be
changed during execution

constant time an algorithm whose big-O work expression is a constant
constructor an operation that creates a new instance of a class; a method that has the

same name as the class type containing it, which is called whenever an object of
that type is instantiated 

container class a class into which you can add other elements
control abstraction the separation of the logical properties of a control structure from

its implementation
control structure a statement used to alter the normally sequential flow of control
control unit the component of the central processing unit that controls the action of

other components so that instructions (the program) are executed in sequence
conversion function a function that converts a value of one type to another type so

that it can be assigned to a variable of the second type; also called transfer function
or type cast

copy constructor an operation that creates a new instance of a class by copying an
existing instance, possibly altering some or all of its state in the process

count-controlled loop a loop that executes a predetermined number of times
counter a variable whose value is incremented to keep track of the number of times a

process or event occurs
CPU see central processing unit
crash the cessation of a computer’s operations as a result of the failure of one of its

components; cessation of program execution due to an error
data information that has been put into a form a computer can use
data abstraction the separation of a data type’s logical properties from its implemen-

tation
data encapsulation the separation of the representation of data from the applications

that use the data at a logical level; a programming language feature that enforces
information hiding

700 | Glossary



data representation the concrete form of data used to represent the abstract values of
an abstract data type

data structure a collection of data elements whose organization is characterized by
accessing operations that are used to store and retrieve the individual data ele-
ments; the implementation of the composite data members in an abstract data type;
the implementation of a composite data field in an abstract data type

data type the general form of a class of data items; a formal description of the set of
values (called the domain) and the basic set of operations that can be applied to it

data validation a test added to a program or a function that checks for errors in the
data

debugging the process by which errors are removed from a program so that it does
exactly what it is supposed to do

deallocate to return the storage space for an object to the pool of free memory so that
it can be reallocated to new objects

decision see selection control structure
declaration a statement that associates an identifier with a field, a method, a class, or

a package so that the programmer can refer to that item by name
deep copy an operation that not only copies one class object to another but also

makes copies of any pointed-to data
demotion (narrowing) the conversion of a value from a “higher” type to a “lower”

type according to a programming language’s precedence of data types;  demotion
may cause loss of information

derived class a class that is created as an extension of another class in the hierarchy
desk checking tracing an execution of a design or program on paper
development environment a single package containing all of the software required

for developing a program
dialog a style of user interface in which the user enters data and then performs a sep-

arate action (such as clicking a button) when the entered values are ready to be
processed by the program

direct execution the process by which a computer performs the actions specified in a
machine language program

documentation the written text and comments that make a program easier for others
to understand, use, and modify

down a descriptive term applied to a computer when it is not in a usable condition
driver a simple dummy main program that is used to call a method being tested; a

main method in an object-oriented program
dynamic allocation allocation of memory space for a variable at run time (as opposed

to static allocation at compile time)
dynamic binding determining at run time which form of a polymorphic  method to

call; the run-time determination of which implementation of an operation is appro-
priate

dynamic memory management the allocation and deallocation of storage space as
needed while an application is executing

Glossary | 701



echo printing printing the data values input to a program to verify that they are
correct

editor an interactive program used to create and modify source programs or data
encapsulation (in OOD)   the bundling of data and actions in such a way that the logi-

cal properties of the data and actions are separated from the implementation
details; the practice of hiding a module implementation in a separate block with a
formally specified interface; designing a class so that its implementation is pro-
tected from the actions of external code except through the formal interface

evaluate to compute a new value by performing a specified set of operations on given
values

event an action, such as a mouse click, that takes place asynchronously with respect
to the execution of the program

event counter a variable that is incremented each time a particular event occurs
within a loop control structure

event handler a method that is part of an event listener and is invoked when the lis-
tener receives a corresponding event

event handling the process of responding to events that can occur at any time during
execution of the program

event listener an object that is waiting for one or more events to occur
event loop The repetative calling of an event handler to respond to a series of events

until some condition causes the application to exit the cycle
event-controlled loop a loop control structure that terminates when something hap-

pens inside the loop body to signal that the loop should be exited
exception an unusual situation that is detected while a program is running; throwing

an exception halts the normal execution of the method
exception handler a section of a program that is executed when an exception occurs;

in Java, an exception handler appears within a catch clause of a try-catch-finally
control structure

executing the action of a computer performing as instructed by a given program
execution trace going through the program with actual values and recording the state

of the variables
expression an arrangement of identifiers, literals, and operators that can be evaluated

to compute a value of a given type
expression statement a statement formed by appending a semicolon to an expression
external file a file that is used to communicate with people or programs and is stored

externally to the program
external representation the printable (character) form of a data value 
fetch-execute cycle the sequence of steps performed by the central processing unit for

each machine language instruction
field a component of a frame in which the user can type a value; the user must first

place the cursor in the field by clicking inside the field; a named place in memory
that holds a data value or a reference to an object

file a named area in secondary storage that is used to hold a collection of data; the
collection of data itself

702 | Glossary



filtering (in OOD) the phase in an object-oriented design in which the proposed
classes of objects from the brainstorming phase are refined and overlooked ones are
added.

finite state machine an idealized model of a simple computer consisting of a set of
states, the rules that specify when states are changed, and a set of actions that are
performed when changing states

firing an event an event source generates an event
flag a Boolean variable that is set in one part of the program and tested in another to

control the logical flow of a program
flat implementation the hierarchical structure of a solution written as one long

sequence of steps; also called inline implementation
floating  point  number the value stored in a type float or double variable, so

called because part of the memory location holds the exponent and the balance of
the location the mantissa, with the decimal point floating as necessary among the
significant digits

flow of control the order of execution of the statements in a program
formatting the planned positioning of statements or declarations and blanks on a line

of a program; the arranging of program output so that it is neatly spaced and
aligned

forward when a method calls another method that throws an exception, it may pass
the exception to its own caller rather than catch the exception

free pool (heap) an area of memory, managed by the JVM, which is used to provide
storage space for objects

functional decomposition a technique for developing software in which the problem
is divided into more easily handled subproblems, the solutions of which create a
solution to the overall problem

garbage the set of currently unreachable objects
garbage collection the process of finding all unreachable objects and destroying them

by deallocating their storage space
general (recursive) case the case for which the solution is expressed in terms of a

smaller version of itself
hardware the physical components of a computer
heuristics assorted problem-solving strategies
hide to provide a field in a derived class that has the same name as a field in its

superclass; to provide a class method that has the same form of heading as a class
method in its superclass; the field or class method is said to hide the corresponding
component of the superclass 

hierarchy (in OOD) structuring of abstractions in which a descendant object inherits
the characteristics of its ancestors

high-level programming language any programming language in which a single
statement translates into one or more machine language instructions

homogeneous a descriptive term applied to structures in which all components are of
the same data type (such as an array)

identifier a name associated with a package, class, method, or field and used to refer
to them

Glossary | 703



immutable an object whose state cannot be changed once it is created
implementation phase the second set of steps in programming a computer: translat-

ing (coding) the algorithm into a programming language; testing the resulting pro-
gram by running it on a computer, checking for accuracy, and making any
necessary corrections; using the program

implementing coding and testing an algorithm
implementing a test plan running the program with the test cases listed in the test

plan
implicit matching see positional matching
in place describes a kind of sorting algorithm in which the components in an array

are sorted without the use of a second array
index a value that selects a component of an array
infinite loop a loop whose termination condition is never reached and which therefore

is never exited without intervention from outside of the program
infinite recursion the situation in which a subprogram calls itself over and over con-

tinuously
information any knowledge that can be communicated
information hiding the practice of hiding the details of a class with the goal of con-

trolling access to them; the programming technique of hiding the details of data or
actions from other parts of the program

inheritance a design technique used with a hierarchy of classes by which each
descendant class acquires the properties (data and operations) of its ancestor class;
a mechanism that enables us to define a new class by adapting the definition of an
existing class; a mechanism by which one class acquires the properties – the data
fields and methods – of another class

inline implementation see flat implementation
input the process of placing values from an outside data set into variables in a pro-

gram; the data may come from either an input device (keyboard) or an auxiliary
storage device (disk or tape)

input prompts messages printed by an interactive program, explaining what data is to
be entered

input transformation an operation that takes input values and converts them to the
abstract data type representation

input/output (i/o) devices the parts of a computer that accept data to be processed
(input) and present the results of that processing (output)

inspection a verification method in which one member of a team reads the program or
design line by line and the others point out errors

instance data data that is associated with a specific object
instance method a method that is associated with an object of a given type; it is

called by writing the name of the object followed by a period and then the name of
the method and its parameter list

instantiate to create an object based on the description supplied by a class
instantiation creating an object, an instance of a class
integer  number a positive or negative whole number made up of a sign and digits

(when the sign is omitted, a positive sign is assumed)

704 | Glossary



interactive system a system that allows direct communication between the user and
the computer

interface a connecting link (such as a keyboard) at a shared boundary that allows
independent systems (such as the user and the computer) to meet and act on or
communicate with each other; the formal definition of the behavior of a subpro-
gram and the mechanism for communicating with it; a Java construct that specifies
method headings and constants to be included in any class that implements it

interpretation the translation, while a program is running, of non-machine-language
instructions (such as Bytecode) into executable operations

interpreter a program that inputs a program in a high-level language and directs the
computer to perform the actions specified in each statement; unlike a compiler, an
interpreter does not produce a machine language version of the entire program

invoke to call on a subprogram, causing the subprogram to execute before control is
returned to the statement following the call

iteration an individual pass through, or repetition of, the body of a loop
iteration counter a counter variable that is incremented with each iteration of a loop
iterator an operation that allows us to process–one at a time–all the components in an

object
key a member of a class whose value is used to determine the logical and/or physical

order of the items in a list
layout manager a method in the Frame class that automatically manages the place-

ment of display elements within this particular style of window on the screen
length the number of items in a list; the length can vary over time
lifetime for a variable, constant, or object, the portion of an application’s execution

time during which it is assigned storage space in the computer’s memory
linear relationship each element except the first has a unique predecessor, and each

element except the last has a unique successor
linear time for an algorithm, when the big-O work expression can be expressed in

terms of a constant times n, where n is the number of values in a data set
listing a copy of a source program, output by a compiler, containing messages to the

programmer
literal value any constant value written in a program
local variable a variable declared within a block; it is not accessible outside of that

block
local data data that is associated with a specific call to a method
logarithmic order for an algorithm, when the big-O work expression can be expressed

in terms of the logarithm of n, where n is the number of values in a data set
logical order the order in which the programmer wants the statements in the program

to be executed, which may differ from the physical order in which they appear
loop a method of structuring statements so that they are repeated while certain condi-

tions are met
loop control variable (lcv) a variable whose value is used to determine whether the

loop executes another iteration or exits
loop entry the point at which the flow of control first passes to a statement inside a

loop

Glossary | 705



loop exit that point when the repetition of the loop body ends and control passes to
the first statement following the loop

loop test the point at which the loop expression is evaluated and the decision is made
either to begin a new iteration or skip to the statement immediately following the
loop

machine language the language, made up of binary-coded instructions, that is used
directly by the computer

mainframe a large computing system designed for high-volume processing or for use
by many people at once

maintenance the modification of a program, after it has been completed, in order to
meet changing requirements or to take care of any errors that show up

maintenance phase period during which maintenance occurs
mantissa with respect to floating point representation of real numbers, the digits rep-

resenting a number itself and not its exponent
member a field or method declaration within a class
memory unit internal data storage in a computer
metalanguage a language that is used to write the syntax rules for another language
method a subprogram that defines one aspect of the behavior of a class; a subprogram

in Java
microcomputer see personal computer
mixed type expression an expression that contains operands of different data types;

also called a mixed mode expression
modifiability the property of an encapsulated class definition that allows the imple-

mentation to be changed without having an effect on code that uses it (except in
terms of speed or memory space)

modular programming see top-down design
modularity (in OOD) meaningful packaging of objects
module a self-contained collection of steps that solves a problem or subproblem; can

contain both concrete and abstract steps
mutable an object whose state can be changed after it is created
name precedence the priority treatment accorded a local identifier in a block over a

global identifier with the same spelling in any references that the block makes to
that identifier

named constant a location in memory, referenced by an identifier, where a data value
that cannot be changed is stored

narrowing conversion a type conversion that may result in a loss of some informa-
tion, as in converting a value of type double to type float

nested control structure a program structure consisting of one control statement
(selection, iteration, or subprogram) embedded within another control statement

nested if an if statement that is nested within another if statement
nested loop a loop that is within another loop
new an operator that takes a class name and returns an object of the class type
object a collection of data values and associated operations
object (general sense) an entity or thing that is relevant in the context of a problem

706 | Glossary

TE
AM
FL
Y

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

Team-Fly® 



object (Java) an instance of a class
object code a machine language version of a source code
object-oriented design a technique for developing software in which the solution is

expressed in terms of objects—self-contained entities composed of data and opera-
tions on that data that interact by sending messages to one another

object  program the machine-language version of a source program
object-based programming language a programming language that supports abstrac-

tion and encapsulation, but not inheritance 
observer an operation that allows us to observe the state of an instance of an abstract

data type without changing it
one-dimensional array a structured collection of components of the same type given

a single name; each component is accessed by an index that indicates its position
within the collection

operating system a set of programs that manages all of the computer’s resources
ordinal data type a data type in which each value (except the first) has a unique

predecessor and each value (except the last) has a unique successor                          
out-of-bounds array index an index value that is either less than 0 or greater than

the array size minus 1
output transformation an operation that takes an instance of an abstract data type

and converts it to a representation that can be output
overflow the condition that arises when the value of a calculation is too large to be

represented
overloading the repeated use of a method name with a different signature
override to provide an instance method in a derived class that has the same form of

heading as an instance method in its superclass; the method in the derived class
redefines (overrides) the method in its superclass; we cannot override class methods

package a named collection of program building blocks or components in Java that
can be imported by a class

parameter a variable declared in a method heading
parameter passing the transfer of data between the arguments and parameters in a

method call
pass by address a parameter-passing  mechanism in which the memory address of the

argument is passed to the parameter; also called pass by reference (not used in
Java)

pass by reference see pass by address
pass by value a parameter-passing mechanism in which a copy of an argument’s

value is passed to the parameter (used in Java)
password a unique series of letters assigned to a user (and known only by that user)

by which that user identifies himself or herself to a computer during the logging-on
procedure; a password system protects information stored in a computer from being
tampered with or destroyed

path a combination of branches that might be traversed when a program or function
is executed

path testing a testing technique whereby the tester tries to execute all possible paths
in a program or function

Glossary | 707



pc see personal computer
peripheral device an input, output, or auxiliary storage device attached to a computer
personal computer (pc) a small computer system (usually intended to fit on a desktop)

that is designed to be used primarily by a single person
polymorphic an operation that has multiple meanings depending on the class of

object to which it is bound
polymorphism the ability to determine which of several operations with the same

name is appropriate;  a combination of static and dynamic binding
positional matching a method of matching arguments and parameters by their rela-

tive positions in the two lists; also called relative or implicit matching
postfix operator an operator that follows its operand(s)
precision a maximum number of significant digits
prefix operator an operator that precedes its operand(s)
priming read an initial reading of a set of data values before entry into an event-con-

trolled loop in order to establish values for the variables
problem-solving phase the first set of steps in programming a computer: analyzing

the problem; developing an algorithm; testing the algorithm for accuracy
procedural abstraction the separation of the logical properties of an action from its

implementation
programming planning, scheduling, or performing a task or an event; see also com-

puter programming
programming language a set of rules, symbols, and special words used to construct a

program
pseudocode a mixture of English statements and Java-like control structures that can

easily be translated into a programming language
public interface the members of a class that can be accessed outside of the class,

together with the modes of access that are specified by other modifiers
range of values the interval within which values must fall, specified in terms of the

largest and smallest allowable values
real number a number that has a whole and a fractional part and no imaginary part
recursion the situation in which a subprogram calls itself
recursive call a subprogram call in which the subprogram being called is the same as

the one making the call
recursive case see general case
recursive definition a definition in which something is defined in terms of a smaller

version of itself
registering the listener adding the listener to an event source object’s list of interested

listeners
relational operators operators that state that a relationship exists between two values;

in Java, symbols that cause the computer to perform operations to verify whether
or not the indicated relationship exists

representational error arithmetic error caused when the precision of the true result of
arithmetic operations is greater than the precision of the machine

reserved word a word that has special meaning in a programming language; it cannot
be used as an identifier

708 | Glossary



responsibility algorithms the algorithms for the class methods in an object-oriented
design; the phase in the design process where the algorithms are developed

return the point at which the flow of control comes back from executing a method
reuse the ability to import a class into any program without additional modification

to either the class or the program; the ability to extend the definition of a class
right-justified placed as far to the right as possible within a fixed number of charac-

ter positions
robust a descriptive term for a program that can recover from erroneous inputs and

keep running
scalar data type a data type in which the values are ordered and each value is atomic

(indivisible) 
scenarios (in OOD) the phase in an object-oriented design in which responsibilities

are assigned to the classes
scope of access (scope) the region of program code where it is legal to reference (use)

an identifier
scope rules the rules that determine where in a program an identifier may be refer-

enced, given the point where the identifier is declared and its specific access modi-
fiers

secondary storage device see auxiliary storage device
selection control structure a form of program structure allowing the computer to

select one among possible actions to perform based on given circumstances; also
called a branching control structure

self-documenting code a program containing meaningful identifiers as well as judi-
ciously used clarifying comments

semantics the set of rules that gives the meaning of instruction written in a program-
ming language

sentinel a special data value used in certain event-controlled loops as a signal that the
loop should be exited

sequence a structure in which statements are executed one after another
shallow copy an operation that copies one class object to another without copying

any pointed-to data
short-circuit (conditional) evaluation evaluation of a logical expression in left-to-

right order with evaluation stopping as soon as the final boolean value can be
determined

side effect any effect of one function on another that is not part of the explicitly
defined interface between them

signature the distinguishing features of a method heading the combination of the
method name with the number and type(s) of its parameters in their given order

significant digits those digits from the first nonzero digit on the left to the last
nonzero digit on the right (plus any 0 digits that are exact)

simulation a problem solution that has been arrived at through the application of an
algorithm designed to model the behavior of physical systems, materials, or
processes

size (of an array) the physical space reserved for an array

Glossary | 709



software computer programs; the set of all programs available on a computer
software engineering the application of traditional engineering methodologies and

techniques to the development of software
software life cycle the phases in the life of a large software project including require-

ments analysis, specification, design, implementation, testing, and maintenance
software piracy the unauthorized copying of software for either personal use or use

by others
sorted list a list with predecessor and successor relationships determined by the con-

tent of the keys of the items in the list; there is a semantic relationship among the
keys of the items in the list

sorting arranging the components of a list into order (for instance, words into alpha-
betical order or numbers into ascending or descending order)

source program a program written in a high-level programming language
stable sort a sorting algorithm that preserves the order of duplicates
standardized made uniform; most high-level languages are standardized, as official

descriptions of them exist
state the current values contained within an object
static binding determining at compile time which form of a polymorphic method to

call
string (general sense) a sequence of characters, such as a word, name, or sentence,

enclosed in double quotes
string (Java construct) an object, an instance of the String class
structured data type an organized collection of components; the organization deter-

mines the method used to access individual components 
stub a dummy  method that assists in testing part of a program; it has the same func-

tion that would actually be called by the part of the program being tested, but is
usually much simpler

style the individual manner in which computer programmers translate algorithms into
a programming language

subprogram see method
supercomputer the most powerful class of computers
switch expression the expression whose value determines which switch label is

selected; it must be an integer type other than long
syntax the formal rules governing how valid instructions are written in a program-

ming language
system software a set of programs—including the compiler, the operating system, and

the editor—that improves the efficiency and convenience of the computer’s process-
ing

tail recursion a recursive algorithm in which no statements are executed after the
return from the recursive call

team programming the use of two or more programmers to design a program that
would take one programmer too long to complete

termination condition the condition that causes a loop to be exited
test driver see driver
test plan a document that specifies how a program is to be tested

710 | Glossary



test plan implementation using the test cases specified in a test plan to verify that a
program outputs the predicted results

testing checking a program’s output by comparing it to hand-calculated results; run-
ning a program with data sets designed to discover any errors

text file a file in which each component is a character; each numeric digit is repre-
sented by its code in the collating sequence

throw the act of signaling that an exception has occurred; throwing an exception is
said to abnormally terminate execution of a method

transformer an operation that builds a new value of an ADT, given one or more pre-
vious values of the type

traverse a list to access the components of a list one at a time from the beginning of
the list to the end

two-dimensional array a collection of components, all of the same type, structured in
two dimensions; each component is accessed by a pair of indices that represent the
component’s position within each dimension

type casting (type conversion) the explicit conversion of a value from one data type
to another

type coercion an automatic conversion of a value of one type to a value of another
type, called type conversion in Java

unary operator an operator that has just one operand 
underflow the condition that arises when the value of a calculation is too small to be

represented
unreachable a condition of an object wherein there is no way to refer to it
unstructured data type a collection consisting of components that are not organized

with respect to one another
user  name the name by which a computer recognizes the user, and which must be

entered to log on to a machine
value-returning method a method that returns a single value to its caller and is

invoked from within an expression
variable a location in memory, referenced by an identifier, that contains a data value

that can be changed
virtual machine a program that makes one computer act like another
virus a computer program that replicates itself, often with the goal of spreading to

other computers without authorization, possibly with the intent of doing harm
visible accessible; a term used in describing a scope of access
void method a method that is called as a separate statement; the method does not

return a value
walk-through a verification method in which a team performs a manual simulation of

the program or design
widening conversion a type conversion that does not result in a loss of information
word a group of 16, 32, or 64 bits; a group of bits processed by the arithmetic-logic

unit in a single instruction
work a measure of the effort expended by the computer in performing a computation

Glossary | 711





            

Chapter 1 Exam Preparation Exercises

1. The steps keep repeating forever, because there is no way for the algorithm to stop. (Also,
it is a poor algorithm because the last action is lathering—you wouldn’t want to leave the
lather in your hair.) Corrected algorithm:

1. Wet hair
2. Lather
3. Rinse
4. Repeat steps 2 and 3 once

3. In the following recipe for chocolate pound cake, the statements that are branches, loops,
or subalgorithm references are marked.

Preheat the oven to 350 degrees
Line the bottom of a 9-inch tube pan with wax paper
Sift 2 3� 4 c flour, 3� 4 t cream of tartar, 1 2 t baking soda, 1 1� 2 t salt, and 1 3� 4 c sugar into a large bowl
Add 1 c shortening to the bowl
If [BRANCH] using butter, margarine, or lard, then

add 2� 3 c milk to the bowl,
else

(for other shortenings) add 1 c minus 2 T of milk to the bowl
Add 1 t vanilla to the mixture in the bowl
If [BRANCH] mixing with a spoon, then

see [SUBALGORITHM REFERENCE] the instructions in the introduction to the chapter on cakes,
else

(for electric mixers) beat the contents of the bowl for 2 minutes at medium speed, scraping the
bowl and beaters as needed

Add 3 eggs plus 1 extra egg yolk to the bowl
Melt 3 squares of unsweetened chocolate and add to the mixture in the bowl
Beat the mixture for 1 minute at medium speed
Pour the batter into the tube pan



Put the pan into the oven and bake for 1 hour and 10 minutes
Perform [SUBALGORITHM REFERENCE] the test for doneness described in the introduction to the 

chapter on cakes
Repeat [LOOP] the test once each minute until the cake is done
Remove the pan from the oven and allow the cake to cool for 2 hours
Follow [SUBALGORITHM REFERENCE] the instructions for removing the cake from the pan, given in 

the introduction to the chapter on cakes
Sprinkle powdered sugar over the cracks on top of the cake just before serving

5. Hardware: disk drive, memory, arithmetic/logic unit, and central processing unit
Software: compiler, editor, operating system, object program, and Java Virtual Machine

7. One approach to finding a job, using the divide-and-conquer strategy, is reflected in the
following algorithm.

Main Algorithm

Find information on available jobs
Apply for jobs

Find information on available jobs

Check newspaper
Call employment service

Apply for jobs

Write resume
Submit resume to potential employers
Arrange interviews
Attend interviews
Make follow-up calls after promising interviews

Each of these steps can be further subdivided.

Chapter 1 Programming Warm-Up Exercises

2. Algorithm for making a peanut butter and jelly sandwich

Open refrigerator door by pulling on door handle.
Remove bread bag, jelly jar, and peanut butter jar from refrigerator.
Place bread bag, jelly jar, and peanut butter jar on counter.
Close refrigerator door.
Open bread bag by removing twist-tie.
Remove 2 bread slices from bread bag.
Place 2 bread slices on counter.
Close bread bag using twist-tie.
Open jelly jar by unscrewing lid.
Place jelly jar lid on counter.
Open drawer under counter.
Remove knife from drawer.

714 | Answers to Selected Exercises



Close drawer.
Use knife blade to scoop desired amount of jelly out of jar.
Spread jelly on face-up side of one slice of bread.
Close jelly jar by screwing on lid.
Open peanut butter jar by unscrewing lid.
Place peanut butter jar lid on counter.
Use knife blade to scoop out desired amount of peanut butter.
Spread peanut butter on face-up side of other slice of bread.
Close peanut butter jar by screwing on lid.
Place face-up sides of bread slices together so that their edges align.
Open refrigerator door by pulling on door handle.
Place bread bag, jelly jar, and peanut butter jar in refrigerator.
Close refrigerator door.

Chapter 1 Case Study Follow-Up Exercises

1. A divide-and-conquer diagram for a Company Payroll.

3. The starting point is the set of data values; the end is the payroll for the week.

Chapter 2 Exam Preparation Exercises

1. Valid: data, y, PAY_DAY, num5
Invalid: item#1, 3Set, bin–2, Sq Ft

3. program (15), algorithm (14), compiler (3), identifier (1), compilation phase (12), execu-
tion phase (10), variable (11), constant (2), memory (13), syntax (6), semantics (8), 
block (7)

5. False; reserved words cannot be used as variable names.
7. a. s1 = blues2 = bird

b. Result:bluebird
c. Result:  bluebird
d. Result:  blue bird

8. A rollingstonegathersnomoss

Company Payroll

Calculate Overtime PayCalculate Regular Pay

Get the Data Compute the Wages Output the Wages Output the Totals

Answers to Selected Exercises | 715



9. Only one character can be stored into a variable of type char.
11. False; a variable of type String can not be assigned to a variable of type char.
13. The identifier computer is used to name something, such as an application or a variable.

"computer" is the character string made up of the characters: 'c', 'o', 'm', 
'p', 'u', 't', 'e', and 'r'.

Chapter 2 Programming Warm-Up Exercises

2. System.out.println("The moon "));
System.out.println("is ");
System.out.println("blue."));

4. System.out.println("Make: " + make);
System.out.println("Model: " + model);
System.out.println("Color: " + color);
System.out.println("Plate type: " + plateType);
System.out.println("Classification: " + classification);

6. a. System.out.println("Four score ");
System.out.println("and seven years ago ");

b. System.out.println("Four score ");
System.out.println("and seven ");
System.out.println("years ago");

c. System.out.println("Four score ");
System.out.println("and ");
System.out.println("seven ");
System.out.println("years ago ");

d. System.out.println("Four ");
System.out.println("score ");
System.out.println("and ");
System.out.println("seven ");
System.out.println("years ");
System.out.println("ago ");

Chapter 2 Case Study Follow-Up Exercises

2. The string stored in constant MONTH_NUMBER, the symbol "/", the string stored in con-
stant DAY, the symbol "/", and the string stored in constant YEAR are all concatenated
together and stored into the String variable third.

Chapter 3 Exam Preparation Exercises

1. Add a label to the frame; show the frame; pack the frame.
3. Frame out = new Frame;
5. class methods, instance methods, helper methods
7. print, println
9. A parameter list contains information that a method needs to do its job.

11. The add method adds an object to a frame.

716 | Answers to Selected Exercises

TE
AM
FL
Y

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

Team-Fly® 



13. Constructors must be spelled exactly like the name of the class, and class names begin
with uppercase letters.

15. a. The setLayout method tells the Frame object how to arrange the items in the frame.
b. FlowLayout and GridLayout. FlowLayout leaves the placement of items up to the

class. GridLayout allows the user to determine the number of columns and rows in
the window.

16. The second parameter is a constant that determines the placement of the first parameter
within the label. The constants are Label.LEFT, Label.CENTER, and Label.RIGHT.

18. An event handler is the code within an event listener that takes care of the event.
20. An event source is an object that can fire an event.
21. Registering an event listener means adding a listener object to the event source’s list of

listeners. In the Frame class, the method to register a listener is addWindowListener.
When the event is fired, control passes to the appropriate method within the listener
object.

25. 1425B Elm St. Amaryllis , Iowa
26. This program may be corrected in several ways. Here is one correct version.

// This program is full of errors
import java.awt.*;
public class LotsOfErrors

{
private static final String FIRST = "Martin";
private static final String MID = "Luther";
private static final String LAST = "King";
private static Frame outputDisplay;

public static void main (string[] args)
{

outputDisplay = new Frame();
outputDisplay.setLayout(new FlowLayout());
String name;
char initial;

name = FIRST + ' ' + MID + ' ' + LAST;
outputDisplay.add(new Label("Name = " + name + " Jr."));
outputDisplay.pack();
outputDisplay.show();

}
}

Chapter 3 Programming Warm-Up Exercises

1. display.add(new Label("Nell Dale"));
2. display.add(new Label("The moon "));

display.add(new Label("is "));
display.add(new Label("blue."));

Answers to Selected Exercises | 717



4. auto.add(new Label("Make: " + make));
auto.add(new Label("Model: " + model));
auto.add(new Label("Color: " + color));
auto.add(new Label("Plate type: " + plateType));
auto.add(new Label("Classification: " + classification));

6. private static Frame address;
address = new Frame();
address.setLayout(new FlowLayout());

8. Hello world. Hello world. Hello world. is written in the window.
10. outDisplay.setLayout(new GridLayout(0,3));
11. outDisplay.add(new Label("Hello world.", Label.CENTERED));

Chapter 3 Case Study Follow-Up Exercises

2. The string stored in constant MONTH_NUMBER, the symbol "/", the string stored in con-
stant DAY, the symbol "/", and the string stored in constant YEAR are all concatenated
together and stored into the String variable third.

3. The changed statements are as follows:

third = MONTH_NUMBER + "-" + DAY + "-" + YEAR; // Create mm/dd/yyyy format
fourth = DAY + "-" + MONTH_NUMBER + "-" + YEAR;// Create dd/mm/yyyy format

Chapter 4 Exam Preparation Exercises

2. a. 27 b. 13 c. 5 d. 0 e. 3 f. 8 g. 3
3. All expressions are legal. The real values are shown with decimal points.

a. 13.333 b. 2 c. 5 d. 13.750 e. 24 f. 1 g. 0.33
4. a. 3 b. 4 c. 37 d. 22 e. 23 f. 5

7.

8. a. 0.235294 b. 2.25 c. 44.20 d. 5 e. 0 f. 21 g. 8 h. 5 i. 1 j. 3
10. a. 9.1 b. 7.0 c. 24 d. 16.0 e. 5.0 f. 3.0
12. False; incorrect formatting does not cause an error when running the program, but it

may cause the person reading the program to make an error.

Chapter 4 Programming Warm-Up Exercises

1. The following statement is the only one that must be changed: LBS must be set to 15
instead of 10.

final int LBS = 15;

2. int sum;
sum = n*(n+1)/2;

− ± −b b ac
a

2 4
2

718 | Answers to Selected Exercises



3.
a. x / y – 3 b. (x + y) * ( x – y)
c. 1.0 / (x + y) d. 1.0 / x + y
e. (float)  i / (float) j f. i / j
g. (((x + y) / 3) -((x – y) / 5)) / (4 * x)

6. This is a laboratory exercise for the student and requires no answer here.
9. (sentence.indexOf("res")) The first occurrence of the string "res" occurs at posi-

tion 12.
10. saveSentence = substring(0, sentence.length());  // save original

position = sentence.indexOf("res");
out.add(new Label("first occurrence is at position " + position));
sentence = substring(position + 2, sentence.length());
position = sentence.indexOf("res");
out.add(new Label("second occurrence is at position " + position));
sentence = substring(position + 2, sentence.length());
position = sentence.indexOf("res");
out.add(new Label("third occurrence is at position" + position));
sentence = substring(position + 2, sentence.length());

Chapter 4 Case Study Follow-Up Exercises

1. The advantage of using named constants over literal values is that if we decide to change
the values, we only need to change the program in one place, where the constants are
declared, thus reducing the effort and the chance of error.

3. The round-off factor should be a constant because it does not change throughout the
entire program.

Chapter 5 Exam Preparation Exercises

1. A label, a button, and a field
3. The text to be displayed in the label
5. The frame never appears on the screen.
7. Declare the button variable and assign it a value with new.
8. Declare a variable of the listener class, instantiate the listener class, register it with the

event.
10. A model for an object type that specifies the fields and methods that must be present in

any class that implements the type.
12. Any class that implements ActionListener must be declared and contained within an

application class and must contain a method called actionPerformed rather than a
method main. An application class uses the modifier public; the ActionListener class
uses the modifiers private static and must have the clause implements Action-
Listener following the name of the class.

14. Declare a variable of the event listener class, give the object a value with new, and call
the addActionListener method associated with the button, passing it an object of the
listener type.

Answers to Selected Exercises | 719



16. The person interacting with the application. If the person is not familiar with computers,
the prompts must be more detailed. If the person is familiar with computers, less infor-
mation is necessary.

17. We must enter a number as a string and convert it to the appropriate numeric type, using
methods from Java’s library.

19. An instance method is a method associated with an object of a class and is always
applied to an object. A class method is a method associated with a class and is always
applied to a class.

21. Functional design
23. A concrete step is one in which all the implementation details are fully specified. An

abstract step is one in which some details are not fully specified.
25. Refining the responsibility algorithms.

Chapter 5 Programming Warm-Up Exercises

2. a. Button stop;
b. stop = new button("Stop");
c. stop.setActionCommand("stop");
d. ButtonListener action;

action = new ButtonListener();
// ButtonListener implements ActionListener

e. stop.addActionListener(action);
f. dataFrame.add(stop);

4. a. The type of this expression is Integer (not int).
b. In part (a), valueOf is a class method; it is applied to class Integer.
c. The method intValue applied to an object of class Integer converts the object to an

instance of type int.
7. a. Brainstorming The objects in the problem are all numeric values, which are built

into the language. If the input and output are from the screen, you need a frame
object. If the input and output are from different sources, you need a screen object
and a file object. You also need an application class.

Filtering You decide to make the input screen-oriented and use System.out for the
output. The final objects are a window object, an application class, and System.out.

Scenarios The processing is in the button handler. Two values are input, two formu-
las are calculated, and two answers are written to the screen.

720 | Answers to Selected Exercises



CRC cards

Prepare Window

Declare, instantiate, and add label for first value
Declare, instantiate, and add label for second value
Declare, instantiate, and add label for third value
Declare, instantiate, and add text field for first value
Declare, instantiate, and add text field for second value
Declare, instantiate, and add text field for third value
Declare, instantiate, and add enter button
Declare, instantiate, and register ButtonHandler as the button listener

Handle inputs are taken care of in the ButtonHandler class

Handle Window Closing

Dispose of the frame
Exit the program

Get Three Values

Get first value from text field
Get second value from text field
Get third value from text field

Class Name: ButtonHandler Superclass: Subclassess:

Responsibilities

Get the three input values

Calculate the formula

Display the output

TextField, Label, String, Buttons

System.out

Collaborations

Class Name: Quadratic Superclass: Subclassess:

Responsibilities

Prepare the window for input

Handle input events (using buttons)

Handle window closing

TextField, Label, String, Buttons

Buttons, Button handler class

Frame

Collaborations

Answers to Selected Exercises | 721



Calculate Formula

Set root1 to ((2second + Math.sqrt(second*second 2 4*first*third)) /( first+first)
Set root2 to ((2second 2 Math.sqrt(second*second 2 4*first*third)) /( first+first)

Display Output

System.out.println(“root1 is “ + root1)
System.out.println(“root2 is “ + root2)

b. For the functional decomposition version, screen input and file output is used.

Main Module

Prepare window
Open file
Get three input values
Calculate two Real solutions
Write solutions to output file

Prepare window

Prepare labels
Prepare text fields

Open file

Open file OutQuad for output

Get three input values

Get first value from text field
Get second value from text field
Get third value from text field

Calculate two Real solutions

First solution  S1 = (2B + Math.sqrt(Sqr(B) 2 4*A*C))/(2*A)
Second solution S2 = (2B 2 Math.sqrt(Sqr(B) 2 4*A*C))/(2*A)

Write solutions to file

Write S1 to file OutQuad
Write S2 to file OutQuad

c. The object-oriented design determined the objects and their responsibilities. The func-
tional design created a hierarchy of tasks that the main module must accomplish.
Each task was further refined. The tasks in the functional design were distributed in
the object-oriented design between the application, the frame object, and the button
handler.

722 | Answers to Selected Exercises



Chapter 5 Case Study Follow-Up Exercises

1. No, the application doesn’t crash. If the window is closed before any values have been
entered, the window disappears and the program halts normally. Of course, no output is
generated.

3. A second button (call it Quit) could be added to the display. The user could press the Quit
button to stop processing.

Chapter 6 Exam Preparation Exercises

3. Expression Meaning in English

one == two The value stored in variable one is equal to the value stored in variable
two.

one != two The value stored in variable one is not equal to the value stored in vari-
able two.

one > two The value stored in variable one is greater than the value stored in vari-
able two.

one < two The value stored in variable one is less than the value stored in variable
two.

one >= two The value stored in variable one is greater than or equal the value
stored in variable two.

one <= two The value stored in variable one is less than or equal the value stored in
variable two.

4. a. T b. T c. T d. F
5. a. Ok as is; == has higher precedence than ||.

b. Ok as is; relational operators have higher precedence than Boolean operators and &&
has higher precedence than ||.

c. Ok as is; true or not true is always true.
d. !(q && q)

7. a. xy
xy

b. The value of x is 3
c. 3

7
6
z (Despite the indention, the final output statement is not part of the else clause.)

9. a. 4 b. 2 c. 5 d. 3 e. 1
12. a. if-else. There are two alternative actions.

b. if. There is one action to be taken or not taken.
c. if. There is one action to be taken or not taken.
d. if-else. There are two alternative actions.

Answers to Selected Exercises | 723



14. if (typeA || typeB)
{
if (typeA && typeB)
out.add(new Label("Type AB"));

}
else

out.add(new Label("Type O"));

15. Data Set ch1, ch2, ch3 Expected Output

Set 1 A, A, A All initials are the same.
Set 2 A, A, B First two initials are the same.
Set 3 B, A, A Last two initials are the same.
Set 4 A, B, A First and last initials are the same.
Set 5 A, B, C All initials are different.

18. a. The String class provides methods that can be used to compare two strings.
b.

Method Name Parameter Returns English Description

equals String boolean Returns true if two strings are equal;
false otherwise.

compareTo String int Returns 0: two strings are equal
Returns <0: object comes before
parameter

Returns >0: object comes after 
parameter

toUpperCase none String Returns object string in all uppercase
letters.

toLowerCase none String Returns object string in all lowercase
letters.

20. One string is displayed with the button in the window; one string names the button
within the system.

Chapter 6 Programming Warm-Up Exercises

1. boolean eligible;
eligible = true;

2. available = (numberOrdered <= (numberOnHand – numberReserved));
An if statement could have been used, but it isn’t necessary.

724 | Answers to Selected Exercises



6. if (year % 4 == 0)
out.add(new Label(year + " is a leap year."));

else
{
year = year + 4 - year % 4;
out.add(new Label(year + " is the next leap year."));

}

8. The wrong operator is used in the if condition: = is used in place of ==.
10. if (x1 == x2)

out.add(new Label("Slope undefined."));
else
{
m = (y1 - y2) / (x1 - x2);
out.add(new Label("the slope is " + m));

}

13. a. private static Button1Handler action1;
private static Button2handler action2;
private static Button enter;
private static Button quit;

b. enter = new Button("Enter");
quit = new Button("Quit");
action1 = new Button1Handler;
action2 = new Button2Handler;

c. enter.setActionCommand("enter");
quit.setActionCommand("quit");

d. outDisplay.add(enter);
outdisplay.add(quit);

e. enter.addActionListener(action1);
quit.addActionListener(action2);

f. private static class Button1Handler implements ActionListener
{
public void actionPerformed(ActionEvent event)
{
String name;
name = event.getActionCommand();
if (name.equal("enter"))
out.add(new Label("Enter was pressed."));

else
out.add(newLabel("An unexpected event occurred.")):

}
}

Answers to Selected Exercises | 725



private static class Button2Handler implements ActionListener
{
public void actionPerformed(ActionEvent event)
{
String name;
name = event.getActionCommand();
if (name.equal("quit"))

out.add(new Label("Quit was pressed."));
else

out.add(newLabel("An unexpected event occurred.")):
}

}

Chapter 6 Case Study Follow-Up Exercises

2. private static class ClearHandler implements ActionListener
{
public void actionPerformed(ActionEvent event)
{
result = 0.0;
register.setText("0.0");
inputField.setText("");

}
}

Class ClearHandler is the listener for the Clear button. When the Clear button is
pressed, result is set to 0.0, register is set to 0.0, and the inputField is set to blank.

Button clear;
Declares a button variable named clear.

clear = new Button("Clear");
Instantiates the button.

clear.setActionCommand("clear");
Names the button event.

clear.addActionListener(clearOperation);
Registers the button listener.

calcFrame.add(clear);
Adds the button event to the frame.

726 | Answers to Selected Exercises

TE
AM
FL
Y

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

Team-Fly® 



4. Data Set Command Operand Observed Output

Set 1 add 12.5 12.5
Set 2 subtract 12.5 0.0
Set 3 add 5.5 5.5
Set 4 multiply 10.0 55.0
Set 5 divide 5.0 11.0
Set 6 clear

add 212.5 212.5
Set 7 subtract 212.5 0.0
Set 8 add 21.0 21.0
Set 9 multiply 5.0 25.0
Set 10 divide 2.0 22.5
Set 11 divide 0.0 exception thrown

Chapter 7 Exam Preparation Exercises

2. Encapsulation is the basis of abstraction, and abstraction is how we handle complexity in
programming.

3. Modifiability and reuse
5. A class can be imported into a program without having to change either the class or the

program.
7. Sequence, selection, loop, method call, and asynchronous event
8. Constructors have the same name as the class and do not have a return type or void.

10. a. Data abstraction is the separation of the logical properties of data from their imple-
mentation.

b. Control abstraction is the separation of the logical properties of operations from their
implementation.

c. An object is a collection of values and a set of operations. Data abstraction refers to
an object’s data representation, and control abstraction refers to an object’s operations
(methods).

12. A class method has the static modifier. It is applied with the name of the class, dot,
and the method name. An instance method does not have the static modifier. It is
applied with the name of an instance, dot, and the method name.

15. a. A reference to the object b. Yes c. No, the reference is not changed, but the
object to which it refers can be changed.

17. At the logical level, a constructor creates a new instance of a class. In Java, the operator
new creates the new instance and the constructor performs initializations. For example,

String myName = new String("Nell");

creates a new String that contains the string “Nell".

Answers to Selected Exercises | 727



18. a. A transformer changes the state of an object. For example, changeColor and decre-
mentTimeRemaining in class TrafficLight are transformers.

b. An observer allows us to observe the state of an object without changing it. For
example, knowCurrentColor and knowTimeRemaining are observers.

19. a. An iterator allows the user to process the components in an object one at a time.
b. An observer iterator views the components one at a time; a transformer iterator

changes each component as it processes it.
20.

Types of Data Lifetime of Data From where Data is Accessible

Instance Data Lifetime of the instance Instance data is accessible to methods applied to 
object in which it is defined. the object.

Class Data Lifetime of class data is the Class data is accessible to all objects of that type.
entire execution of the 
program in which the class 
is defined.

Local Data Lifetime of local data is Local data is accessible from within the block in 
the execution of the which it is defined.
method in which it is 
defined.

21. Class data has the modifier static preceding field.
26. An immutable object is an object that cannot be changed after it is created. A mutable

object is one in which the values may be changed. If an object has transformer opera-
tions, it is mutable. If an object does not have transformer operations, it is immutable.

28. a. You cannot. You must create a new object that has the same values as the previous
one except for the one you want to change.

b. Write a copy constructor. A copy constructor creates a new instance of the class by
copying the existing instance, possibly altering some or all of its state in the process.

Chapter 7 Programming Warm-Up Exercises

2. public AddressLabel(AddressLabel oldLabel, String newAddress)
// Creates an AddressLabel object with the same name, and
//  state as oldLabel, but with the address set to newAddress.

4. public AddressLabel(String  name, String address, String city, 
String state, long zipCode, String country)

// Creates an AddressLabel object with its name, address, state,
//  zipCode  and country set to the values in the corresponding
//  parameters.

728 | Answers to Selected Exercises



6. package somePackage;
public class AddressLabel {...}
class PrintLabel {...}

8. Different Java systems do it different ways. Check the documentation of the system you
are using.

10. public int myExample()

11. return 1066;

13. private float returnFloat(TextField data)
{
return Float.valueOf(data.getText()).floatValue();

}

Chapter 7 Case Study Follow-Up Exercises

2.
Class Method Test # Reason for Test Input Values Expected Output

Name Name 4 Iterator ”John”, “Kirk”, “Herrel”
Name knowNext 4 Iterator ”John”
Name knowNext 5 Iterator ”Kirk”
Name knowNext 6 Iterator ”Herrel”
Name knowNext 7 Iterator ”John”

Chapter 8 Exam Preparation Exercises

1. a. Internal scope and external scope
b. No. Internal scope does not depend on the access modifiers.
c. Internal scope refers to the scope within a class. Any identifier in a class can be used

anywhere within the class.
d. You can’t use a class variable to initialize another before it has been defined. A local

identifier overrides a class member with the same name.
e. Name precedence is a scope rule that specifies that a local identifier hides the class

identifier with the same name.
f. Yes

2. Derived classes, members of the same package, and code external to the package
4. a. Protected members

b. They are automatically part of the interface.
7. Object
9. Data fields and methods that are public or protected.

10. super
12. The derived method overrides the method in its superclass.
14. Overriding refers to instance methods; hiding refers to data fields and class method.

Answers to Selected Exercises | 729



16.

Situation Hiding Overriding Overloading
A class method has the same name and 
signature of a superclass method. X

An instance method has the same name 
and signature of a superclass instance method. X

A class has two methods with the same 
name but different signatures. X

A field in a derived class has the same 
name as a field in its superclass. X

An instance method has the same name 
but a different signature of a superclass 
instance method. X

A method declares a field with the same 
name as a field in the class. X

A method has a formal parameter with 
the same name as a field in the class. X

17. Constructors and any component declared with the private or package (default) modifiers.

Chapter 8 Programming Warm-Up Exercises

1. public MyClass()
public MyClass(String name)
public MyClass(int name)

5. a. public void someMethod()
b. int someMethod()
c. private int someMethod()

6. public static class someClass
{
public static int var;             // Class member
public static final int const;     // Class member const
public static void someMethod(int param)
{
int var;                         // Local variable
var = param * const;
final int const = 10;
{
var = 5;                        // Local variable
label1.setText(" " + this.var); // Class member

}
}

}

730 | Answers to Selected Exercises



Chapter 8 Case Study Follow-Up Exercises

1. You would need three new methods: getfloat, setfloat, and getSelectedfloat.
3.

Chapter 9 Exam Preparation Exercises

2. The parameter is a string that names the file on the disk. It binds the external name for
the file with the internal name in the application.

4. Write the material in the buffer immediately.
6. a. read returns a character converted to its int value.

b. readLine returns a string.
c. An empty string is a string with no characters. A null string is a unique value in Java

that does not correspond to any valid data value.
8. The loop prints the integers 2 through 11, one number per line.

10. Six iterations are performed.
13. a. The output is BCDE, followed by an echo of the newline character. The A that is input

by the priming read is discarded.
b. inChar = (char)infile.read();

while (inChar != ' \n' )
{
outfile.write(inChar);
inChar = (char)infile.read();

}

15. Many different values can be used as a sentinel if telephone numbers are read as long
integers. In the United States, a standard telephone number is a positive seven-digit num-
ber (ignoring area code) and cannot start with 0, 1, 411, or 911. Therefore, any negative
value, a value greater than 9999999, or a value less than 2000000 would be good sen-
tinels.

17. The output is 1 3 6 10 15.
18. Written

Class Name: FloatField Superclass: Subclassess:

Responsibilities

Create itself, default


Create itself (float value, int columns)

TextField

Collaborations

Create itself (int columns) TextField

TextField

Get float, Observer return float TextField

TextField

TextField

Set float (float value), Transformer

Get selected float, Observer return float

NumericField

Answers to Selected Exercises | 731



20. a. Count-controlled and event-controlled
b. A count-controlled loop executes a predetermined number of times. An event-con-

trolled loop executes as long as an event is true and exits the loop when the event
becomes false.

c. The loop runs forever (or until the program is manually terminated by the operating
system).

d. The loop runs forever (or until the program is manually terminated by the operating
system).

e. Sentinel-controlled, end-of-file-controlled, and flag-controlled
21. An iteration counter keeps track of the number of times a loop is executed; an event

counter keeps track of the number of times an event occurs.

Chapter 9 Programming Warm-Up Exercises

1. infile = new FileReader("infile.dat");
3. outfile = new PrintWriter(new FileWriter("outfile.dat"));
5. W

88   What letter comes next?

6. private static char first;
private static char first;
private static char second;
private static int digit;
digit = fileIn.read();
first = (char)digit;
digit = fileIn.read();
second = (char)digit;

8. fileOut.close();
fileOut = new FileWriter("dataOut.dat");

11. count28 = 0;
loopCount = 1;
while (loopCount <= 100)
{
number = Integer.valueOf(inFile.readLine()).intValue();
if (number == 28)
count28++;

loopCount++;
}

13. count = 0
sum = 0;
scoreLine = scoreFile.readLine();
while (scoreLine != null)
{
score = Integer.valueOf(scoreLine).intValue();
sum = sum + score;

732 | Answers to Selected Exercises



count++;
scoreLine = scoreFile.readLine();

}
if (count > 0)
average = (float)sum / (float)count;

15. sum = 0;
evenInt = 16;
while (evenInt <= 26)
{
sum = sum + evenInt;
evenInt = evenInt + 2;

}

17. hour = 1;
minute = 0;
am = true;
done = false;
while (!done)
{
timeOut.print(hour + ":");
if (minute < 10)
timeOut.print('0');

timeOut.print(minute);
if (am)
timeOut.println(" A.M.");

else
timeOut.println(" P.M.");

minute++;
if (minute > 59)
{
minute = 0;
hour++
if (hour == 13)
hour = 1;

else if (hour == 12)
am = !am;

}
done = (hour == 1 && minute == 0 && am);

}

Chapter 9 Case Study Follow-Up Exercises

2. To test the modified program Incomes, we use four test files. The first file tests the case
where there are no females in the data set; the second file tests the case where there are
no males in the data set; the third file tests the case where there are no errors in the file;
and the fourth file tests for the handling of the various data errors that may occur.

Answers to Selected Exercises | 733



Test File 1: This data set does not contain any females.

M 10000.00
M 20000.00

Expected output:

For 0 Females, the average income is 0.0
For 2 Males, the average income is 15000.00
There were 0 bad data sets in the file.

Test File 2: This data set does not contain any males.

F 30000.00
F 40000.00
F 50000.00

Expected output:

For 3 females, the average income is 40000.00
For 0 males, the average income is 0.0.
There were 0 bad data sets in the file.

Test File 3: This data set does not contain any errors

M 10000.00
F 30000.00
M 20000.00
F 50000.00

Expected output:

For 2 females, the average income is 40000.00
For 2 Males, the average income is 15000.00
There were 0 bad data sets in the file.

Test File 4: This data set contains many data errors. Note that the program only prints
that there were two errors in the data file, because the only type of error that is to be
counted is an incorrect code. However, no entries with any type of error are used in the
calculation of the averages.

M 10000.00
m 20000.00
F 20000.00
c 20000.00
M –20000.00

Expected output:

Letter other than F or M in file.
Negative value in file.
For 1 females, the average income is 20000.00
For 1 Males, the average income is 10000.00
There were 2 bad data sets in the file.

734 | Answers to Selected Exercises



4. Write a helper function that takes the original value and converts it to a string.

private String format(double value)
{
String stringForm;
int index;
stringForm = new String(String.valueOf(value));
index =  stringForm.indexOf(".");
return stringForm.substring(0, index+3);

}

Chapter 10 Exam Preparation Exercises

1. A switch expression is the expression in a switch statement whose value determines
which case label is selected.

A pretest loop is a loop in which the test occurs before the body of the loop. If the
loop expression is false, the loop body is not executed.

A posttest loop is a loop in which the test occurs after the loop body. Therefore, a
posttest loop always executes at least once.

3. True
4. False
6. MaryJoeAnneWhoops!
8. True
9. 1

11. 4 3 2 1 4
3 2 1 3
2 1 2
1 1

12. ********* *********
********   ********
*******     *******
******       ******
*****         *****
****           ****
***             ***
**               **
*                 *

14. a. expression
b. expression
c. expression statement
d. expression

16. Use a try-catch statement.
20. a. False. There can be many catch clauses as long as they each have a different parame-

ter object.

Answers to Selected Exercises | 735



b. True
c. True
d. True

Chapter 10 Programming Warm-Up Exercises

2. switch (grade)
{

case 'A' : sum = sum + 4;
break;

case 'B' : sum = sum + 3;
break;

case 'C' : sum = sum + 2;
break;

case 'D' : sum++;
break;

case 'F' : System.out.println("Student is on probation");
break;

default  : System.out.println("Invalid letter grade");
break;    // Not required

}
4. response = inData.read();

if(response >= 0 && response <= 127)
do
{
response = inData.read();

} while (response >= 0 && response <= 127);

6. sum = 0;
count = 1;
for (count = 1; count <= 1000; count++)
sum = sum + count;

8. Rewrite the following for loop using a do loop.

k = 9;
do
{
outData.println(k + " " + 3 * k);
k++;

} while (k <= 21);

10. a. MyException. anException;

736 | Answers to Selected Exercises

TE
AM
FL
Y

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

Team-Fly® 



b. public class MyException extends Exception
{

public MyException()
{

super();
}
public MyException(String message)
{

super(message);
}

}

c. throw new MyException("Error somewhere.");

Chapter 10 Case Study Follow-Up Exercises

4. Module Get Rainfall Amount has two outputs: the rainfall amount and the changing line.
The only way we could make it a method would be to bind the two values into a class
and make the class the return value of the method.

Chapter 11 Exam Preparation Exercises

2. False
4. a. static final int CLASS_SIZE = 30;

b. float[] quizAverage;
c. quizAvg = new float[CLASS_SIZE];

6. a. Because the array is of type int, the values are automatically set to 0 by the con-
structor.

b. for (int index = 0; index < count.length; count++)
count[index] =

Integer.valueOf(inFile.readLine()).intValue();

c. int sum = 0;
for (int index = 0; index < count.length; count++)
sum = sum + count[index];

7. 1  3 –2
17  6 11
4  2  2
19 14  5
11 15 –4

52 40 12

Answers to Selected Exercises | 737



8. The exception was thrown because the last array access is out of bounds. The loop should
go from 0 through 3. If the ending condition is written arr.length rather than an inte-
ger literal, the problem would not have happened. Of course, if the initial value isn’t
changed to 0, only part of the data would be printed.

12. A class is a heterogeneous, unstructured type in which the components are accessed by
name; an array is a homogeneous, structured type in which the components are accessed
by position.

14. For each of the following descriptions of data, determine which general type of data
structure (array of primitive types, class, array of classes) is appropriate.
a. class containing classes
b. class
c. class
d. array of classes
e. array of primitive types
f. array of classes containing classes
g. array of classes

15. An ArrayOutOfBounds exception is thrown.
17. The values in the initializer list

Chapter 11 Programming Warm-Up Exercises

1. public void setToFalse()
{
for (int index = 0; index <= failing.length; index++)
failing[index] = false;

}

3. public void setPassing(int[] score)
{
for (int index = 0; index <= passing.length; index++)
if (score[index] >= 60)
passing[index] = true;

}

5. public static boolean error(boolean[] passing, boolean[] failing)
{
for (int index = 0; index <= failing.length; index++)
if (passing[index] == failing[index])
return true;

return false;
}

738 | Answers to Selected Exercises



7. public void reverse(int[] score)
{
int tempScore;
int halfLength = score.length/2;
for (int index = 0; index < halfLength; index++)
{
tempScore = score[index];
score[index] = score[score.length – (index + 1)];
score[score.length – (index + 1)] = tempScore;

}
}

Chapter 11 Case Study Follow-Up Exercises

1. The following changes would be necessary:

firstList must be made a double array
value must be declared double (two places)
the input line must be converted to double rather than int (two places)

3. a. If a letter other than a T or F is entered in the key, each student answer is checked
against that erroneous letter.

b. If a letter other than a T or F is entered for a student, that answer is incorrect unless,
by some chance, the same erroneous letter was entered in the same spot for the key.

c. If an error occurs in the key, the application should be aborted. If an error occurs in a
student’s answer, the processing of that student should be halted and the application
should continue with the next student.

5. Because we are reading one character at a time from the file using read, we must explic-
itly read past the end of line.

Chapter 12 Exam Preparation Exercises

3.

item first last middle result

114 0 9 4
5 9 7
8 9 8 found is true

4. False
6. At the logical level, an array is a homogeneous data type. Java implements an array with

an extra integer variable that contains the number of cells in the array.

Answers to Selected Exercises | 739



7. In this sorting algorithm, if the items in 0 through numItems–2 are sorted, then the
remaining item must be the largest one and is therefore in its proper place.

10. Transformer
13. The Comparable interface has only one method, named compareTo. compareTo returns

a value less than 0 if the object comes before the parameter, 0 if the object and the
parameter are equal, and a value greater than 0 if the parameter comes first.

Chapter 12 Programming Warm-Up Exercises

2. public class ListWithSort extends UnsortedList
{
// The items in the list are rearranged into ascending order.
//  This order is not preserved in future insertions

public ListWithSort()
{
super();

}

public ListWithSort(int maxItems)
{ // Constructor
super(maxItems);

}

public void selectSort()
// Arranges list items in ascending order;
//  selection sort algorithm is used.
{
Comparable temp;        // Temporary variable
int passCount;          // Loop control variable for outer loop
int searchIndex;        // Loop control variable for inner loop
int minIndex;           // Index of minimum so far

for (passCount = 0; passCount < numItems – 1; passCount++)
{
minIndex = passCount;
// Find the index of the smallest component
//  in listItems[passCount]..listItems[numItems–1]
for (searchIndex = passCount + 1; searchIndex < numItems;

searchIndex++)
if (listItems[searchIndex].compareTo( listItems[minIndex]) <0)

minIndex = searchIndex;

740 | Answers to Selected Exercises



// Swap listItems[minIndx] and listItems[passCount]
temp = listItems[minIndex];
listItems[minIndex] = listItems[passCount];
listItems[passCount] = temp;

}
}

}

5. The code does not have to be changed because the list is sorted. All you have to do is
change the extends clause from UnsortedList to SortedList and change the names of
the constructors.

6. public boolean exclusive(int item, List list1, List list2)
{
if (list1.isThere(item))
{
if (list2.isThere(item))
return false;

else
return true;

}
return list2.isThere(item);

}

7. All you have to do is change the direction of the relational operator in the comparison in
the implementation and change the names of the constructors and the class.

9. public void insert(String item)
// If the list is not full, puts item in its proper position in the
//  list; otherwise list is unchanged.
{
boolean placeFound = false;
int index = 0;
while (!placeFound && index < numItems)
if (item.compareTo(listItems[index]) > 0)
index++;

else
placeFound = true;

for (int count = numItems; count > index; count--)
listItems[count] = listItems[count – 1];

listItems[index] = item;
numItems++;

}

Answers to Selected Exercises | 741



Chapter 12 Case Study Follow-Up Exercises

2. If the event handler does not delete the name from the list when a student arrives, two
other algorithms could be used:

• As the list of those present is being printed, each name could be removed from the
master list, or

• You could iterate through the master list and print those names that are not in the list
of those present.

3. The unsorted list could be used rather than the sorted list. The master list and the list of
those present could be sorted before they are written to the file to be printed.

Chapter 13 Exam Preparation Exercises

1. a. 10 b. 3 c. 3 d. 10 e. 30 f. 30 g. row h. row
6. a. True b. False c. True d. True

10. A
B
413 is the value of n
21.8 is the value of y

Chapter 13 Programming Warm-Up Exercises

2. a. public TwoDimensions(int maxRows, int maxColumns)
// Creates a maxRows  x maxColumns array
{
data = new int[maxRows][maxColumns];

}
b. public void inputData(BufferedReader inFile)

// Reads data into the array.
// Data is on the file as follows:
//  First line: number of rows (rowsUsed)
//  Second line: number of columns (columnsUsed)
// The data is stored one value per line in row order.  That is,
//  the first columnsUsed values go into row 0; the next
//  columnsUsed values go into row 1; etc.
{
rowsUsed = Integer.valueOf(inFile.readLine()).intValue();
columnsUsed = Integer.valueOf(inFile.readLine()).intValue();
for (int row = 0; row < rowsUsed; row++)
for (int column = 0; column < columnsUsed; column++)
data[row][column] =
Integer.valueOf(inFile.readLine()).intValue();

}

742 | Answers to Selected Exercises



c. public void print(PrintWriter outFile)
// Prints the values in the array on outFile, one row per line
{
for (int row = 0; row < rowsUsed; row++)
{
for (int column = 0 ; column < columnsUsed; column++)
outFile.print(data[row][col]+ " ");

outfile.println();
}

}

d. public int maxInRow(int row)
// Returns the maximum value in the specified row
{
int maxSoFar = 0;
for (int column = 1; column < columnsUsed; column++)
if (data[row][column] > data[row][maxSoFar])
maxSoFar = column;

return data[row][maxSoFar];
}

e. public int maxInCol(int column)
// Returns the maximum value in the specified column
{
int maxSoFar = 0;
for (int row = 1; row < rowsUsed; row++)
if (data[row][column] > data[maxSoFar][column])
maxSoFar = row;

return data[maxSoFar][column];
}

f. public int maxInArray()
// Returns the maximum value in the entire array
{
int maxValue = data[0][0];
for (int row = 0; row < rowsUsed; row++)
for (int column  = 0; column < columnsUsed; column++)
if (data[row][column] > maxValue)
maxValue = data[row][column];

return maxValue;
}

Answers to Selected Exercises | 743



g. public int sum()
// Returns the sum of the values in the array
{
int sum = 0;
for (int row = 0; row < rowsUsed; row++)
for (int column == 0; column < columnsUsed; column++)
sum = sum + data[row][column];

return sum;
}

h. public int sumInRow(int row)
// Returns the sum of the values in the specified row
{
int sum = data[row][0]
for (int column = 1; column < columnsUsed; column++)

sum = sum + data[row][column];
return sum;

}

i. public int sumInCol(int column)
// Returns the sum of the values in the specified column
{
int sum = 0;
for (int row = 0; row < rowsUsed; row++)
sum = sum + data[row][column];

return sum;
}

j. public boolean allPlus()
// Returns true if all the values are positive; false otherwise
{
for (int row = 0; row < rowsUsed; row++)
for (int column == 0; column < columnsUsed; column++)
if (data[row][column] <= 0)
return false;

return true;
}

5. Include the following statement before multiplying:

if (beta > Double.MAX_VALUE/100.0)
System.out.println(" " +  beta + " is too large to multiply" +
" by 100.");

else
someFloat = beta*100.0;

744 | Answers to Selected Exercises



7. a. This question asks you to run an experiment. We do not give the answer away here.

b. Method Array Equivalent/Explanation

myVector.insertElementAt(Object Insert object at the index position in the array
obj, int index)

myVector.firstElement() Return myVector[0]
myVector.removeElementAt(int index) Delete the element at the index position and close up

the array

myVector.lastElement() Return myVector[numItems–1]
myVector.removeAllElements() Remove all the elements, setting numItems to 0

Chapter 13 Case Study Follow-Up Exercises

1. This error might occur in knowValueAt and setValue.

Chapter 14 Exam Preparation Exercises

2. False
4. F(4) = 1, F(6) = 21, and F(5) is undefined
6. if or switch are the control structures used in recursion.
8. In a recursive algorithm on a data structure, either the distance from a position in the

structure or the size of the data structure can get smaller.
12. 15 23 21 19 19 21 23 15

Chapter 14 Programming Warm-Up Exercises

1. public static int f(int n)
{
if (n == 0 || n == 1)
return 1;

else
return f(n – 1) + f(n – 2);

}

3. public static void doubleSpace()
{
char ch;
int data;
data = inFile.read();
while (data != -1)          // While not EOF...

Answers to Selected Exercises | 745



{
ch = (char) data;
outFile.print(ch);
if (ch == '\n')
outFile.println();

data = inFile.read();
}

}

5. public static int factorial(int n, int level)
{
int tempFactorial;
int loopCount;
for (loopCount = 1; loopCount <= level; loopCount++)
System.out.print("  ");

System.out.println(n);
if (n == 0)
tempFactorial = 1;

else
tempFactorial = n * factorial(n - 1, level + 1);

for (loopCount = 1; loopCount <= level; loopCount++)
System.out.print("  ");

System.out.println(tempFactorial);
return tempFactorial;

}

7. public static void printSqRoots(int n )
{
if (n > 0)
{
outFile.println(n + " " + Math.sqrt((double)n));
printSqRoots(n - 1);

}
}

9. public static boolean isThere(
int[] data,   // Array to be searched
int first,    // Index of first element
int last,     // Index of last element
int item )    // Item to be searched for

746 | Answers to Selected Exercises

TE
AM
FL
Y

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

Team-Fly® 



{
if (first <= last)
{                             // Recursive case
if (data[first] == item)
return true;

else
return isThere(data, first + 1, last, item);

}
return false;

}

Answers to Selected Exercises | 747





      

A
Absolute error, 617, 618
Abstract

defined, 346
Abstract classes, 377

and List class hierarchy, 569-570
Abstraction, 293, 332

control, 296-297, 332
data, 296-297, 332
defined, 294
levels of, 11
object state, 297

abstract keyword, 348
abstract method

heading for, 310
abstract modifier, 348
Abstract step, 225

defined, 210
Abstract window toolkit. See AWT
Access modifiers, 58
ActionEvent type, 259
ActionEvent value, 278
ActionHandler class, 372
ActionHandler listener, 216
ActionListener class, 262

implementation of, 185, 186
ActionListener interface, 185, 216, 217, 222, 225
actionPerformed method, 185, 186, 187, 217, 258, 259,

260, 261, 265, 372
Ada, 10

addActionListener method, 184, 187, 222, 225, 258
add instance method, 98
Addition, 131

matrix, 623, 624, 627
Addition (+) operator, 162, 476
add method, 99, 117
Address

of memory location, 125
Address class

CRC card for, 344
Addresses, 55
Address object hierarchy, 345
addWindowListener method, 108, 109, 114, 116, 117
Aggregate array operations, 508-510
Algol, 101, 102
Algorithmic problem solving, 33
Algorithms, 14, 5, 6, 9, 16, 41

analysis of, 424-429
for company payroll program, 36
defined, 4
designing, 27
different translations for, 7
polishing, 6
walk-throughs, 231, 278

Allocation, 304
alpha array, 601
Alphabetical order

testing for, 276
and string comparison, 239

alpha.length, 602



Alphanumeric characters, 496
ALU. See Arithmetic/logic unit
American Standard Code for Information Interchange. See

ASCII
Analogy, 29

problem solving by, 28-29, 41
Analysis, 195
AND operator, 239, 240, 241, 242, 246, 497
angle array, 503

with values, 506
An Investigation of the Laws of Thought (Boole), 243
Anonymous inner class, 208
Anonymous objects, 180
Application, 71
Architects, 340, 342
Arguments

defined, 310
types of, 331

Arithmetic calculations
floating-point numbers in, 635

ArithmeticException class, 465, 485
Arithmetic expressions, 123, 140-141, 162

compound, 136-143
program using, 134-135
simple, 131-136

Arithmetic/logic unit, 19, 41
defined, 20

Arithmetic operations, 496, 497
multiple, 162

Arithmetic operators, 131-133, 137, 162, 470
Array components

passing as arguments to method, 518
Array elements, 502, 535
ArrayIndexOutOfBoundsException, 508, 534
Array processing

algorithms, 508
initializing array to some special value, 605, 608
partial, by row, 607
print array, 605
special kinds of, 518-519
sum the columns, 605, 607
sum the rows, 605-606

Array(s), 545, 546
accessing individual components, 505-507
angle and testScore, 503
base address of, 517
classes versus, 502
composite types as, 498

creating, 502-504
declaring, 502
declaring and creating with initializer list, 504-505
defined, 610
examples of declaring/processing, 510-514
initializing, 608
instantiating, 504
and methods, 518
partial, by column, 608
partially filled, 516
passed as parameter, 609
printing values in, 662-664
ragged, 603, 604, 635
of strings, 514-517
of user-defined objects, 517

Array types, 517
Array variables

comparison of, 509
declaring, 536
instantiating, 536

Artificial intelligence, 353
ASCII, 9n1, 56, 496
Assembler

defined, 10
Assembly language, 12

defined, 10
Assertions, 233, 234, 240
Assignment compatibility rules, 339
Assignment expressions, 411, 471
Assignment operations, 496, 497
Assignment operators, 65, 83, 133, 237, 244, 470,

471-472
Assignment statements, 64, 82, 131, 138, 160, 411

syntax template for, 65
Associated groups, 244
Association for Computing Machinery, 458
Associative law, 615
Associativity, 137

and operator precedence, 474, 476
Asterisks, 82

and import declarations, 95
Asynchronous, 40
Asynchronous control, 16, 17, 105
Atomic data types, 495, 499, 517
Automatic type conversion, 162
Auxiliary storage devices, 19, 21, 41
Averages

calculating, 430

750 | Index



AWT package, 95, 116
awt.event package, 116

B
Babbage, Charles, 353
Backslash, 56, 59
Backup copies, 77
Backus, John, 49
Backus-Naur Form, 49, 50
Base address

defined, 517
Base case, 647, 659, 662, 667

defined, 649
BASIC, 101, 648
Basic Combined Programming Language. See

BCPL
Batch processing, 195
Batch systems, 22
BCPL, 101, 102
beta.length, 602
Big-O notation, 428, 578
Binary

decimal integers converted to, 654-657, 667
Binary code, 9, 10
Binary form, 8, 9
Binary numbers/number system, 8, 40, 612
Binary operator, 535

defined, 132
Binary representation of data, 8-9
Binary search, 545, 572-577, 574, 576, 577, 578,

579, 593, 600, 664-666
Binary search algorithm, 667

walk-through of, 574, 575
Binary (two-operand) operators, 240
Bit, 8, 612
Bitwise operators, 470, 473
Black-box testing, 272, 533, 558
Blocks, 73-75, 251

syntax template for, 73
BNF. See Backus-Naur Form
Body 

of class, 58
of loop, 403

Booch, Grady, 213
Boole, George, 234n1, 242-243, 352
Boolean Algebra, 352
boolean expressions, 231, 234, 242, 406
Boolean full-evaluation operators, 471

boolean operands 
bitwise operators used with, 473

boolean type, 54, 125, 234, 461, 497, 622
logical operators applied to variables of, 241

boolean value, 236, 497
boolean variable, 235, 243
BoxAddress

CRC card for, 343, 345
Braces, 251, 254, 276

in syntax templates, 51, 52
Brackets

for array objects, 504
Brainstorming, 202, 203, 207, 210, 213

for average income by gender case study, 429
for comparison of lists case study, 519
for exam attendance case study, 583
for extending TextField for numeric

input/output, 367
for grading true/false tests case study, 525-526
for List class, 548
for matrix manipulation case study, 623-624
for rainfall averages case study, 477
for simple calculator case study, 262
for Sorted List class, 563-564

Branches/branching, 16, 74, 425
case labels preceding, 454
and testing, 272

break statements, 453, 455, 456, 457, 484, 485
Buffer, 391
BufferedReader class, 388, 397, 437, 440, 441

extending file I/O with, 393-398
and IOException, 399
relationship between FileReader and, 394

Bugs, computer
history behind, 457. See also Errors

Building-block approach, 31, 35, 40
Button class, 182
ButtonDemo class, 186
Button event

handling, 188-191
Button event listener

creating and registering, 184-187
Button events

handling multiple, 258-261
ButtonHandler class, 186, 187

and ActionListener implementation, 197
ButtonHandler listener object, 258
Button listener, 178

Index | 751



Buttons
creating, 182-184
defined, 177
frame with two, 259
naming, 260

Byron, Anna Isabella, 352
Byron, Augusta Ada. See Lovelace, Ada
Byron, Lord (George Gordon), 352
Byte, 8, 9
Bytecode, 1, 12, 13, 14, 40, 76, 582

compilation and interpretation of, 15
defined, 12
instructions, 72
Java compiler production of, 13

byte type, 126, 127, 242, 496, 505

C
C, 102
C++, 10, 102
Calculator

history behind, 144
Calculator application

test plan for, 274
Calculator class

coding of program, 267-269
responsibilities for, 264-266

Calculator program, 289-291
Calculator (simple) case study, 262-270
Calculus

development of, 144
Call

defined, 96
Calling method, 96

throwing exception to be caught in, 467
Call statement, 96

syntax template for, 97
Cambridge Mathematical Journal, 242
Cancellation error, 620-621
Capitalization, 81

and button creation, 182
of constructor names, 99
of identifiers, 54, 63-64. See also Style

Case labels, 454
in switch statement, 484

Case-sensitivity, 54, 81, 116
Case studies. See Problem-solving case studies
Cast operation, 139
Casts, 139n1

Catch
defined, 399

Catching an expression, 463
CD-ROM, 21
Cells, 55
Central processing unit, 41

defined, 20
Character class, 193
Characters, 54
Character set, 55
charAt method, 432
char literal, 391
char type, 47, 55-56, 58, 505, 622
char values, 236
Checked exceptions, 399
Chief architect, 220
circumference method, 355
class composite type, 499
Class data, 305-306

defined, 304
Class declaration, 71, 83

syntax template for, 351
template for, 308

Class definitions, 210
Class(es), 56-59

arrays versus, 502
composite types as, 498
defined, 19
encapsulation of, 294
headings for, 72
identifying, 202-204
and methods, 94-101
and objects, 196-199
in packages, 333
relationship between variable, object, and, 198
syntax diagram for, 57
testing in package, 293. See also Packages; Summary of

classes
Classes, Responsibilities, and Collaborations (CRC), 200
Class field, 177

lifetime of, 293
Class field selection

operator placement for, 535
Class hierarchy

reading, 346-351
Class identifier, 363
Class interface design, 299-302

public field values, 300-301

752 | Index



public interface design, 300-302
responsibilities as methods, 301-302

class (Java construct), 57
Class members

levels of access for, 357
Class method, 97, 146, 194, 199

defined, 193
Class names

and capitalization, 64
Class responsibilities, 293

categories of, 332
Class syntax, 307-308
Clear button event

handling, 266
Clear-box testing, 272
Client

defined, 548
CLOS, 197
close method, 392
Closing files, 392
COBOL, 101, 457, 648
Code

coverage, 272
defined, 6
walk-through, 271

Code trace, 421
Coding, 8, 9, 40

algorithms, 6
Coercions, 139n1
Collating sequence, 56
Column index, 608
Column processing, 609
Columns, 600, 602, 624, 626

headings for, 104
partial array processing by, 608
sum for, 605, 607

Combinations of branches
testing, 272

Combinations of n things
formula for number of, 620

Combined-assignment operators, 470, 471
Comments, 37, 61, 63, 72, 95

adding to program, 70-71
delimiting, 82

CompanyAddress
CRC card for, 344

Company payroll program, 33-40
Comparable interface, 545, 579-582, 594

compareTo method, 580
Comparison expression, 239
Compilation, 76-77

process, 1
relationship of, to interpretation and execution,

14-15
tests performed during, 274-275
units, 321

Compiler, 1, 11, 41, 55, 76
defined, 10
and polymorphism, 351

Complexity
in algorithms, 425, 428
defined, 425

Component access
syntax for, 518

Component class, 346
Object extended by, 348, 349

Component objects
hierarchy of, 347

Components
individual, for alpha array, 602
place of, on lists, 560
position of, within multidimensional arrays,

635
sorting into ascending/descending order, 

563
Component types, 536
Composite data types, 495, 499

defined, 498
Compound arithmetic expressions, 136-137
Computer

basic components of, 20, 41
defined, 2
described, 19-22
and floating-point numbers, 635
implementing floating-point numbers in,

616-621
limitations of, in doing calculations, 600
operations performed by, 16
programming of, 3

Computer graphics, 600
Computer program, 1, 5

defined, 3
Computer programming, 40

defined, 3
Computer resources

use of, 25-26

Index | 753



Computer science
founders of, 243

Computing profession
ethics and responsibilities in, 22-27

Concatenation, 66-68, 83
expression, 82
operators, 141-143

Concrete step
defined, 210

Conditional branches, 273
Conditional (short-circuit evaluation) logical operators,

470
Conditional (?:) operator, 474
Conditions, 231

and logical expressions, 234-246
Confidentiality, 25, 41
Consecutive ranges of values

branches arranged in, 256
Constant declaration, 355

comments in, 71
syntax template for, 63

Constant expressions, 428, 454
Constants, 62-63, 83, 131, 612
Constant-time complexity, 425
Constructors, 99, 301, 318-319, 330, 331, 332, 333, 379

for class, 293
copy, 365-366
defined, 99, 293
in derived classes, 361
effect of calling, for character stream file object, 389
implementing new, 360
for instantiating object, 93
public modifier taken by, 331
from TextField class, 367, 368-369

Constructs, 48
Container class

defined, 98
Continuous values, 497
Contributions to Computer Science Education Award, 458
Control abstraction, 296, 332

data and, 296-297
defined, 297

Control structure, 16, 254
defined, 232

Control unit, 19, 41
defined, 20

Control variable, 441
convert algorithm 

iterative and recursive solutions for, 655-656

convert method 
code walk-through of, 656-657
execution of, 657

Copy constructor, 365-366
defined, 298

CopyHandler class, 260, 261
Copyright laws

and software piracy, 24
CopyString class

event handler extended in, 260
CopyString program, 189-191
Count-controlled loops, 406-407, 416, 435, 438, 441

defined, 405
do loop for implementing, 459
test plans for, 437

Count down, 416
Counters, 406
Counting, 417, 441

for incomes case study, 433
loops, 385, 412-413

CPU. See Central processing unit
CRC card design, 340

for subclass and its superclass, 360
and inheritance, 346

CRC cards, 200, 201, 207, 210, 225, 296
for Address class, 344
blank, 202
for Book class, 207
for BoxAddress, 343, 345
for CompanyAddress class, 344
for DataSetException class, 478
for DataValidation class, 521
enhancing with additional information, 208-210, 209
for Entry class, 206
for exam attendance case study, 584
for FirstList class, 520
for GradeExams class, 527
for HomeAddress class, 343, 345
for Incomes class, 430
with initial responsibilities, 205
for List class, 548, 564
for ListWithSort class, 560
for Matrix class, 625
for Name class, 299, 302, 322
for NumericField class, 368
for Rainfall class, 214, 478
for simple calculator case study, 263
for SortedList class, 564
for Spectrum class, 301

754 | Index



for StudentAnswer class, 527
for TheKey class, 527
for WorkAddress class, 342, 344

Cubic expressions, 428
Cubic formula, 427

D
Data, 10, 18, 40

binary representation of, 8-9
defined, 3
entering, using fields in a frame, 177-179
getting into programs, 176
input into programs, 224
in memory unit, 19
privacy of, 41
separating from program, 176

Data abstraction, 332
defined, 296

data array, 662, 663
Data coverage, 272
Data entry field, 177

creating, 179-180
Data entry process, 178
Data lifetime, 304-306
dataLine, 397
Data Processing Management Association, 458
DataSetException, 480
Data storage, 55
Data structure

defined, 499
design and choice of, 600

Data types, 54-56, 83, 496
defined, 3
mixing in comparison, 236
mixing within expression, 140
overview of Java, 124-126

Date class, 303
DateFormats class, 80
Dates

displaying in multiple formats, 78-81, 112-116
datum, 391, 392
Deallocation, 305
Debugger, 438

programs, 436, 667
Debugging, 8, 154

DateFormats, 115-116
process, 77
program, 6. See also Testing and debugging

Debugging and testing, 81-82

Debug output statements, 438
Decimal floating-point values, 129
Decimal integers

converting to binary, 654-657, 667
Decimal number system, 8
Decision, 16
Declarations, 59-63, 83

array, 601-602
array variables, 536
defined, 59
method, 308-319
for numeric types, 129-131
of one-dimensional array, 501
variable, 60

Decrementation, 485
Decrement operation (—), 162
Decrement operators, 135-136, 470, 472-473
Deep copy/deep copying, 364, 366

defined, 365
Deepest calls, 664
Deep tests, 509-510
default labels, 454, 455
Default value, 177, 178
delete algorithm, 563
delete method, 568, 594

testing, 558
Deleting

components/items from list, 545, 549, 550, 556
DeMorgan, Augustus, 352
DeMorgan’s law, 240n2
Derived class, 339, 340, 378

accessing overridden and hidden methods and
fields, 363-364

constructors in, 361
declaring, 379
defined, 346
hiding, 350
implementing, 360-364
overloading and method signatures, 361-363
syntax for, 351-352

DerivedClass class, 358
Descartes, René, 144
Design, 195

class, 548
and data structure choice, 600

Desk checking, 271
defined, 270

Dialog
defined, 179

Index | 755



Digit
templates for, 52

Digital computers
origins of, 243

Digital Equipment Corporation, 458
Digits, 51
Direct execution, 13
Discrete values, 497
Disk drives, 21
Disks

for file storage, 386
Display screens, 69
dispose method, 110, 363, 364
Divide-and-conquer approach, 30

for company payroll program, 34, 36
Division(/), 162
Documentation, 212-213

defined, 8
Dollar sign, 53
do loops, 484

nested, 461
testing for, 484
and while loops, 459-460

DoneHandler class, 260, 261
do statement, 451, 452, 458-460, 463, 485
Dot operator, 535
Dot product, 624
dotProduct function, 629
Double class, 193

public interface for, 199
Double object, 194
Double quotes, 59, 81
double type, 55, 123, 128, 129, 162, 192, 194, 496, 617,

622
conversion from Class Double to, 193
literals of, 162

double value, 128, 246
doubleValue method, 194, 224
Doubly nested loop, 423

algorithm with, 427
Drivers

defined, 327
in grading true/false tests, 533
to test Name class in name package, 329
to test NumericField class, 371, 373-377

Duplicate keys, 546
list with, 547

DVD-RAM, 21

DVD-ROM, 21
Dynamic binding

defined, 582
Dynamic memory management, 305

E
EBCDIC, 496
Echo printing, 192
Eckert-Mauchly Computer Corporation, 457
EditLine program, 400-401
Editor, 22, 41, 75-76, 387

display screen for, 76
quitting, 77

Eiffel, 197
Electronic computer, 3
Elements

adding to frame, 98
in list, 546

Ellipses, 100
Else-clause, 247, 276
Empty files, 437
Empty lists, 552
Empty methods

calling, 109
Empty strings, 59, 140, 143, 410
Empty values, 435
Encapsulated classes, 340
Encapsulation, 293, 294-299, 300, 330, 332, 351, 360

abstraction, 296-297
benefit of, 331
defined, 294
exposed implementation versus, 295

Encryption, 25
End-of-file (EOF), 387

condition, 385
controlled loops, 410-412, 416, 420, 435, 441

End-of-line (EOL) mark, 388, 390, 391, 395, 396, 398
English statements

logical expressions changed into, 245-246
EOF. See End-of-file
Equality

testing floating-point numbers near, 246
“Equals-equals” relational operator, 237
Equivalent expressions, 240
Error checking, 534
Error messages, 76, 81, 133, 248, 399

and constructors in derived classes, 361
Errors, 26, 40, 77, 154, 221, 274, 457

756 | Index

TE
AM
FL
Y

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

Team-Fly® 



avoiding, 599, 600
and exceptions, 469-470
with multidimensional arrays, 633
out-of-bounds, 508
of precision, 621-622
in recursive algorithms, 667
representational, 615, 616
and reuse, 377
and robust programs, 435
scope-related, 356
syntax, 48, 56
and type mixing, 139. See also Testing and

debugging
Escape sequence, 56
Ethics, 22-27, 41
Evaluate

meaning of, 65
Evaluating assertion, 234
Event, 117

defined, 106
Event-controlled loops, 407-412, 441

constructing with while statement, 385
defined, 405
end-of-file controlled loops, 410-412
sentinel-controlled loops, 407-410
test plans for, 437

Event counter
defined, 414

Event-driven output, 93-122
classes and methods, 94-102
event-handler methods, 108-112
event handling, 105-106
formatting output, 103-104
registering event listener, 106-108
testing and debugging, 115-116

Event handler, 117, 175, 178, 232, 278
defined, 106
methods, 108-112
subprograms, 18

Event handling, 105-106
defined, 106

Event listener, 93
button creation and registering of, 182
defined, 106
event handler added to, 110
registering, 106-108, 222, 224
registering for button, 216
registering for Clear button, 265

registering for numeric buttons, 265
registering with event source, 110

Event loop
defined, 179

Event object, 107
Event source, 108, 117, 175

defined, 106
event listener registered with, 110
registering button event handler with, 187

Exam attendance case study, 583-591
ExamAttendance class, 588-591, 591
ExamDataReader class, 591
ExamDataReader extends BufferedReader class,

587-591
Exception class, 451, 469-470
Exception handler

defined, 464
Exception handling

and testing, 484
Exception-handling mechanism, 463-470

try-catch-finally statement, 463-466
Exception objects, 469
Exceptions, 195

catching, 463, 484
defined, 399
with input/output, 398-400
throwing, 451, 484, 485

Executable statements, 64-75, 72, 74
blocks, 73-75
comments added to program, 70-71
fields, 68
output, 68-70
program construction, 71-73
string expressions, 66-68

“Executing a Java program,” 15
Executing program, 6
Execution

compilation related to, 14-15
tests performed during, 274-275

Execution trace, 278
defined, 271

Exiting
loops, 418, 442

Explicit casting, 276
Explicit conversions, 139n1
Explicit type casting, 123, 140, 160, 236
Explicit type conversion, 141, 391
Exponential class algorithms, 429

Index | 757



Expressions, 68, 146, 461
with arithmetic operators/values, 132-133
defined, 65

Expression statement
defined, 471

extends clause, 351
Extensibility, 18
External access

levels of, 379
External documentation, 213
External scope, 357-360, 379

package access, 358-359
private access, 359
protected access, 357-358
public access, 357
rules, 359

F
Factorial class algorithms, 429
Factorial function

calculating, 651-654
factorial method, 652

execution of, 653
Factorial problem

iterative and recursive versions of, 654
false literal, 497
false value, 234, 235, 247, 278
Fermat, Pierre de, 144
Fetch-execute cycle, 21
Field declaration, 68
Fields, 59, 68, 83

accessing overridden or hidden, 363-364
changing contents of, 181
creating, 179-180
defined, 52, 177
inheriting through hierarchy, 350
value extracted from, 180-182

File classes
types of, in Java, 440

File identifiers
declaring, 388, 393

File input/output, 386-402
for average income by gender case study, 430
example program using files, 400-402
exceptions with input/output, 398-400
extending file I/O with PrintWriter and Buffere-

dReader, 393-398
files, 386-387

using files, 387-393
Filename, 82
File objects

instantiating, 388, 393
methods used with, to read/write data, 389-392

File-oriented systems, 22
File pointer, 387, 388, 389, 391, 392, 393
FileReader class, 388, 393, 424, 437, 440, 441

and I/OException, 399
read method in, 391
relationship between BufferedReader and, 394

File(s)
closing, 392
defined, 75
saving, 77
using, 441

File storage
disks used for, 386

FileWriter class, 388, 390, 393, 437, 440, 441
flush method in, 391
and IOException, 399
relationship between PrintWriter and, 394

Filtering
for comparison of lists case study, 520
for exam attendance case study, 583
for extending TextField for numeric input/output,

367-368
for grading true/false tests case study, 526
for rainfall averages case study, 477

Filtering classes, 202-204, 214
final modifier, 63, 68, 73, 199
Firing an event

defined, 106
FirstList program, 523-524
Flag, 441
Flag-controlled loops, 414, 416-417, 438, 441
Flag controls, 414
Flag variables

initializing/updating, 416, 417
Flat implementation, 217
Floating-point division, 131, 132, 141
Floating-point numbers, 162, 599, 612, 635

arithmetic with, 615-616
coding of, 614
comparing, 618-619
implementing in computer, 616-621
and near equality, 616
representation of, 612-615

758 | Index



Floating-point types (or floating types), 126-128,
248, 276

relational operators with, 246
Floating-point values, 138, 140

rounding off, 139
Floating-point variables

declaring, 616
Floating types, 125
float type, 55, 128, 129, 192, 496, 622
float value, 128, 246
Floor types

hierarchy of, 341
FlowLayout() constructor, 99
FlowLayout manager, 98, 103, 116
Flow of control, 210, 232-233

for calculating pay, 249
defined, 232
designing for loops, 415-417
if, 253
if-else, 248
and if statement, 247
through switch statement, 455
while and do, 460
while statement, 404

Fluid dynamics
Pascal’s contribution to, 144

flush method, 391
for loops, 479, 484, 556

nested, 461
sum the rows in array and, 605, 606
testing for, 484

Formatting
numeric types, 153-154
program, 146-149, 162, 225

for statement, 452, 460-463, 485
syntax template for, 461

FORTRAN, 77, 99, 101, 102, 648
FORTRAN II, 102
FORTRAN IV, 102
Forward

defined, 399
Fractional parts

of floating-point variables/constants, 612
Frame, 94-96

button added to, 182
data entered using fields in, 177-179
displaying on screen, 100
label added to, 98-99

layout managers for, 222
with one TextField, 181
with two buttons, 259

Frame class, 94, 95, 96, 116, 117, 146
importing, 98

Frame() constructor, 99, 116
Frame object, 94, 95
Frame type

declaring variable of, 95
Frame variable

declaring outside of main, 112
Free-format language, 162
Free format statements, 146
Free pool (heap), 304
Full evaluation of logical expressions, 241
Functional decomposition, 175, 176, 196,

210-213, 217, 225, 423

G
Galileo, 144
Games, 2
Garbage, 305
Garbage collecting, 293
Garbage collection, 305
Garbage collector

and objects, 333
Gender, average income by, 429-435
General case, 647, 659, 662

defined, 649
special case taken care of by, 568

Generating exceptions, 466
Generic list items, 594
Generic lists

Comparable interface, 579-582
polymorphism, 582

getActionCommand, 260, 278
getint, 373
getMessage method, 466
getNextItem method, 550, 559, 560, 568
getSelectedint, 373
getSelectedText method, 367
getText method, 180, 224, 367, 398, 400
Gosling, James, 102
gourmetBurger array, 513
Grading tests case study, 525-534
Graphical user interface, 69, 102
GridLayout, 113, 116, 156

for tabular output, 103-104

Index | 759



groceryItems array, 515
Grouping order, 137
GUI. See Graphical user interface

H
Hardware, 1, 41

defined, 21
Heading, of class, 58
Heap, 304
helper method, 97, 156
Hiding, 342, 350, 352, 360, 361, 363, 378

and class methods, 377
defined, 350

Hierarchical solution tree, 211
Hierarchies, 378

studying, 377
High-level programming languages, 1, 10, 40, 101

advantages of, 55
and programs compiled on different systems, 12

High Performance FORTRAN, 102
hiTemp array, 602, 603, 605

Java implementation of, 604
HomeAddress class

CRC card for, 343, 345
Homogeneous data structure, 502
Hopper, Admiral Grace Murray, 457-458
Hyperexponential class algorithms, 429

I
IBM, 221
Identifier(s), 49, 52-54, 58, 59, 81, 83

capitalization of, 63-64
in concatenation expressions, 67
declaring, 60
examples of, 53
meaningful, readable, 54 
for memory locations, 55
overloading, 362
syntax diagrams defining, 50

if-else flow of control, 248
if-else form, 247-249
if-else-if structure, 255, 257, 260, 485
if-else statement, 231, 248, 250, 278, 452
if flow of control, 253
if form, 247, 252-254
if statement, 231, 232, 247-254, 276, 278, 402

blocks (compound statements), 249-250
and case execution, 649
if-else form, 247-249

if form, 252-254
in Incomes program, 435
nested, 418
in recursive algorithm, 667
while statement versus, 404, 405

If-then-else-if control structure, 372
Immutable objects, 293, 297, 331, 333
Implementation phase, 3, 6, 8, 40, 56, 195, 197, 208

defined, 185
differences in, 7
steps in, 4
and testing, 270

Implicit type conversion, 123, 140, 236
import declaration, 57, 82, 160

and compilation units, 321
syntax diagram for, 95

import keyword, 95
import statement, 57
Income, by gender, 429-435
Incomes class program

code for, 433-435
Incrementation, 485
Incrementing loop control variable, 406
Increment operation (++), 102, 162, 407
Increment operators, 135-136, 470, 472-473
Indentation, 162

with blocks, 74
and nested if statements, 255

Index(es), 501
for accessing array components, 537
for components in multidimensional arrays, 635
as a constant, a variable, and an arbitrary expression,

507
with semantic content, 519

Index expressions, 505
indexOf method, 150-151, 587
Index range errors, 633
Index value, 501, 502, 518, 536
Indirect tests, 436
infile.dat, 400
inFile, 391
Infinite loops, 5, 407, 415, 438
Infinite recursion

defined, 651
Infinity, 133
Information

defined, 3
Inheritance, 28, 208, 339, 340-346, 342, 350, 352, 378

analogy for, 340, 342

760 | Index



defined, 208, 346
and object-oriented design process, 342-346

Initializer, 504
Initializer list

declaring/creating array with, 504-505
using, 603-604

Initializing
arrays, 608
conditions, 416, 422, 423, 431
loop control variable, 406

Inline implementation, 217
Input, 176
Input devices, 16, 19, 41, 176
Input/output

devices, 21
interactive, 191-192, 225
noninteractive, 195, 225

Input prompts, 191
Input values

displaying, 192
insert algorithm, 563, 566, 567, 579, 594
Inserting

items from list, 545, 550
insert method, 555, 594

overriding in SortedList, 568, 571
testing, 558

Inspections, 271
Instance data

defined, 304
Instance identifier, 363
Instance methods, 97, 199

defined, 193
headings, 310
and hiding, 377
and overriding, 350, 377
superclass instance methods overridden by, 378

Instance of class, 57
Instance responsibilities

categories of, 298
Instantiation, 19, 96, 57, 536

of arrays, 601-602
of objects within parameter lists, 98

int data type, 126, 127, 162
Integer arithmetic, 615
Integer class, 193

instance of, 199
Integer division, 131, 132, 141, 160
Integer numbers, 54, 496
Integer overflow, 127, 160

Integer quotient, 132
Integer values, 138
Integral constant, 612
Integral types, 126-128, 162
Integral variable, 612
Interactive input/output, 191-192, 225, 385
Interactive programs

prompting labels for, 175
Interactive system, 22
interface construct, 579
Interface(s), 198, 199

defined, 22, 185
design of, 210
composite types as, 498
Java support for, 94
user/computer, 23

Internal data representation, 302-307
data lifetime, 304-306
exam attendance case study, 584
example of, 307
for matrix manipulation case study, 625
of subclass interface, 360, 361

Internal documentation, 213
Internal scope, 354-357

name precedence, 355-356
order of definition, 354-355
rules, 379
using, to overcome name precedence, 356

Internet, 102
Interpretation, 13

compilation related to, 14-15
process, 1

Interpreters, 1
int literal, 160
int type, 55, 123, 129, 192, 242, 496, 505, 622
int value, 128, 248, 498
intValue method, 195
Invalid identifiers, 53
I/O devices. See Input/Output devices
IOException class, 399, 400, 465, 480, 485
isDuplicate method, 551
isEmpty observer, 554
isFull observer, 554
isFull operation, 555, 558
isThere algorithm, 571
isThere method, 558, 572, 577, 582, 594
isThere observer, 554
Iteration, 438

and adding/deleting items from list, 550

Index | 761



Iteration (continued)
defined, 404
or recursion?, 666

Iteration counter, 415
defined, 413

Iterative algorithms, 648
Iterative solutions, 666
Iterator, 301, 332

defined, 298

J
Java, 10, 12, 18, 40, 41, 197, 351

case-sensitivity of, 81
character set for, 55
Comparable interface in, 579
framing for output in, 94
identifiers in, 49
integral types in, 127
origins of, 101-102
precedence of operators in, 244
and recursion, 648
reserved words in, 53
syntax diagram defining identifier in, 50
two-dimensional arrays handled by, 604

Java.awt.event package, 116
ActionEvent class within, 277

java.awt package, 116, 224
Java compiler, 22
Java data types, 496

overview of, 124-126
javadoc program, 70, 82
Java field, 177
java.io package

BufferedReader throws IOException within, 439-440
importing, 387-388, 437

java.lang package, 82, 161, 223, 592
Math class within, 146
String class within, 277, 439

Java operators, 470-476, 485
assignment operators, 471-472
bitwise, 473
conditional, 474
increment/decrement, 472-473
operator precedence for, 474-476

java package, 95
Java programming language, 6
java.util package 

Vector class within, 611

Java Virtual Machine, 12, 13, 14-15, 22, 40, 41, 55, 72,
76, 110, 177, 178, 189

compilation and interpretation of, 15
and dynamic/static binding, 582
and forwarding exceptions, 399
objects instantiated by, 304
and polymorphism, 351
and thrown exceptions, 467, 468

Julian day, 286, 296-279, 302, 303, 306, 357
JVM. See Java Virtual Machine

K
Kepler, Johannes, 144
Keyboard, 21, 22, 176
Key(s)

defined, 546
list sorted by two different, 547

knowFirstName observer, 318

L
Label class

constants imported with, 104
Label constructor, 116
Label field, 180
Label object, 99, 179

and TextField object, 181, 182
Labels, 98

text alignment within, 104
Label type, 179
Lardner, Dionysius, 353
Layout managers, 93, 96, 97, 222
LCD. See Liquid crystal display
Length, of list, 546, 550, 552
length field, 536, 626
length method, 149-150, 558
length observer, 554
length variable, 508, 635
Letter

templates for, 52
Letter counts, 513-514
Lifetime

of categories of data, 306
defined, 304

Limited precision
practical implications of, 621-622

Linear algorithms, 428
Linear expressions, 428

762 | Index



Linear relationship
defined, 546

Linear search, 545, 555, 600
Linear-time complexity, 426
Liquid crystal display, 21
LISP, 101, 648
List class, 548-559, 580-581, 591, 592-593, 594

brainstorming for, 548
CRC card for, 548
instance of, 553
internal data representation for, 552
refining responsibilities for, 549-552
responsibility algorithms for, 552-558
SortedList derived from, 564
test plan for, 558-559

List class hierarchy
and abstract classes, 569-570

Listener class, 117
Listeners, 117

registering, 117
listItems, 566, 567
Lists, 545, 546-547, 593

with duplicate keys, 547
sorted by two different keys, 547
with unique keys, 547

Lists comparison case study, 519-525
ListWithSort class, 561-563

responsibility algorithms for, 560-561
Literal constants

passing as arguments, 313
Literals

named constants used instead of, 130
of type double, 162

Literal strings, 81
in concatenation expression, 67

Literal value, 62
Local data

defined, 304
Local field declaration, 74
Local fields, 73
Logarithmic order, 578
Logarithmic-time algorithms, 429
Logging off, 77
Logging on, 75
Logical expressions, 278

checking, 275
and conditions, 234-246
English statements changed into, 245-246

relational operators in, 473
short-circuit evaluation of, 242

Logical operators, 239-241
and precedence of operators, 243-244

Logical order, 402
Logic errors, 77, 275
long data type, 55, 126, 127, 129, 192, 242, 496,

622
Long word, 9
Loop control variable, 406
loopCount, 406, 407, 421, 422, 423
Loop entry

defined, 404
Loop exit

defined, 405
Looping, 402-424

execution phases, 404-405
and flow of control design, 415-417
subtasks, 412-415
and while statement, 403-404. See also Recur-

sion
Looping statements

guidelines for choosing, 463
Looping structure, 74

in iterative routine, 654
Loops, 16, 40

and algorithms, 425
body of, 403
count-controlled, 406-407, 416, 435, 437, 441
and counting, 412-413
defined, 402
designing, 415, 442
designing nested, 422-424
designing process within, 417-418
EOF-controlled, 416, 441
event-controlled, 407-412, 437, 441
exiting, 418, 442
flag-controlled, 414, 416-417, 441
infinite, 407, 415, 438
nested, 418-422
pretest/posttest, 460
sentinel-controlled, 416, 424, 437, 441
and summing, 413-415
testing strategy for, 435-436
test plans involving, 436-437
while statement used by, 405-406

Loop termination conditions
and arrays processing, 534

Index | 763



Loop test
defined, 405

Lovelace, Ada, 352-353
Lovelace, Lord William, 353
Lowercase letters, 54, 63

M
Machine code, 1, 10, 40
Machine-independent code, 12
Machine language, 12, 13

code, 55
defined, 10

Magnetic tape drive, 21
main method, 71, 72, 83, 372, 376, 438
Maintenance phase, 8, 40

steps in, 4
Mantissa, 616, 617
Map measurements, 155-160
MatException class, 630
Math class, 145-146

value-returning class methods, 161
Mathematical Analysis of Logic, The (Boole), 243
Mathematical methods, 145-146 
math.sqrt method, 146
Matrix class, 630, 634-635

CRC card for, 625
Matrix manipulation case study, 623-633
Matrix operations, 600
Maximum absolute error, 618
Maximum value, 563
maxIndex, 563
Means-ends analysis, 29-30, 32, 34, 41, 302
Measurement class, 306
Memory, 16, 20, 55

cells, 19
locations, 19

Memory unit, 41
defined, 19

Menabrea, Luigi, 353
Mental blocks, 32, 41
Mercury space program, 621
Merging solutions, 41
Messages

on window on screen, 93
Metalanguage, 49-51, 83

defined, 48
Method call, 98

event-handling versus, 106

Method declaration, 73
syntax template for, 71

Method heading, 72, 309, 310, 331, 333
Method name, 97
Method(s), 57, 59, 83

accessing overridden or hidden, 363-364
and arrays, 518
and capitalization, 64
and classes, 94-101
declaring, 308-319
defined, 52
event-handler, 108-112
implementing responsibility as, 316-318
invoking, 93, 96
overloading, 377
parameters passed to, 96
responsibilities as, 301-302
signatures of, 361-363
testing, 371
testing application with, 272
and two-dimensional arrays, 609

Minimum complete coverage, 272
Minimum value, 563
minIndex, 563
Mixed type expression, 140
Mnemonic form

in assembly language, 10
Model interval, 617, 618
Model numbers, 617-618

graphical representation of, 618
Modifiability

defined, 294
Modification

of program, 8
Modifiers, 58, 61
Modular programming, 210
Modula series, 102
Module, 225

defined, 210
structure chart, 210
writing, 211-212

Modulus, 131, 132, 133
Modulus operation, 496
Mouse, 21, 22, 176, 105-106
Multidimensional arrays, 600, 610-611

errors with, 633
passing as parameters, 611

Multiple arithmetic operations, 162

764 | Index



Multiple button events
handling, 258-261

Multiple compilation units, 321
Multiplication (*), 131, 162

matrix, 623, 624, 627, 629
Multiway branch, 254
Murray, Grace Brewster. See Hopper, Admiral

Grace Murray
Mutable objects, 293, 297, 333
myChar, 60, 61
myString method, 152

N
Name class, 303, 307, 332, 591

code for driver to test, 329-330
CRC card for, 299, 302
implementing, 322-327
and responsibilities, 300
testing and debugging, 328-330

Named constants, 62, 68
declarations, 129
using instead of literals, 130

NameFileReader class, 424
Name implements Comparable, 584-585
name object 

two possible implementations of, 323
Name package, 332

code for, 326-327
code for driver to test Name class in, 329-330

Name precedence, 355-356
defined, 355
using this to overcome, 356

Narrowing conversion, 139
National Medal of Technology, 457
Naur, Peter, 49
Naval Data Automation Command, 458
Negation, 162
Negative exponents

coding using, 614
and floating-point numbers, 613

Negative integer, 126
Nested control structures, 254
Nested for loops

and initializing arrays, 608
Nested if statements, 231, 254-258

dangling else, 257-258
Nested loops, 418-424

designing, 422-424, 442

general pattern for simple, 419-422
while loops, 385

Nesting calls, 402
new operator, 57, 112, 115, 198, 304, 319
Noninteractive input/output, 195, 225, 385, 440
Nonterminal symbols, 49, 51
Normalized numbers, 616
Not a Number (NaN), 133
NOT operator, 239, 240, 241, 497
Null statement, 74
null String, 410
NumberFormatException, 265, 480, 485
Numerical analysis, 619

cornerstones of, 243
Numeric button events

handling, 266
Numeric data types, 126-129, 162

choosing, 622
floating-point types, 128-129
integral types, 126-128

NumericField class, 346
CRC card for, 368
testing and debugging, 371-377

NumericField extends TextField class,
370-371

numericField package, 370
NumericField extends TextField within, 378

NumericHandler class, 265
Numeric input/output

extending TextField for, 367-371
Numeric types, 175

declarations for, 129-131
formatting, 153-154

Numeric values
strings converted to, 192-195, 224

Numeric variables
declaring, 130

numItems field, 552

O
Oak, 102
Object-based design, 31
Object class, 57, 346, 349, 378
Object-oriented design, 175, 176, 200-210, 217,

225
defined, 196
inheritance and, 342-346
and reusability, 377

Index | 765



Object-oriented design problem-solving
CRC cards enhanced with additional information,

208-210
first scenario walk-through, 204-207
identifying classes, 202-204
inheritance, 208
initial responsibilities, 204
subsequent scenarios, 207-208

Object-oriented languages, 378
Object-oriented problem solving, 201
Object-oriented programming, 102

advantages of, 591
languages, 18-19, 31, 197
polymorphism in, 582

Object-Pascal, 197
Objects, 41, 56-59

arrays of, 514-517
and classes, 196-199
code, 11
creating for given class, 97
defined, 18
general sense, defined, 57
Java, 57
lifetime of, 293
and public interface, 200
relationships between class, variable, and, 198
in simple Calculator case study, 267
unreachable, 304, 305

Object state, 297
Object types, 346

and built-in types, 193
Observer, 301, 332

defined, 298
Occupancy rates, 510-512
occupants array, 511
One-dimensional array objects, 495

passing of, as parameters, 495
One-dimensional arrays, 495-537, 546, 600, 626

array creation, 502-504
atomic data types, 496-498
components processed in, 536
composite data types, 498-499
declaring arrays, 502
defined, 502
instantiating, 536

OOD. See Object-oriented design
Operating system, 22, 41
Operations

on matrices, 623, 624, 627, 629

Operator precedence, 474-476, 475
Operators, 131, 485

addition, 162, 476
arithmetic, 131-133, 137, 162, 470
assignment, 65, 83, 133, 237, 244, 470, 471-472
binary, 132
bitwise, 470, 473
boolean full-evaluation, 471
concatenation, 141-143
increment, 135-136
logical, 239-241
OR, 239, 240, 241, 242, 497
postfix, 136
precedence of, in Java, 244
relational, 235-237, 243-244, 273, 470
string concatenation, 396, 470
type-cast, 470
unary, 132, 135, 162, 475, 476, 535

Ordered values, 497
Order of magnitude, 427
Ordinal data type, 497
OR operator, 239, 240, 241, 242, 497
OS/360, 221
otherObj, 359
outfile.dat, 400, 402
outFile, 392
Out-of-bounds array indexes, 507-508
Out-of-bounds error, 508
Output, 68-70, 83, 117

devices, 16, 19, 41
formatting, 103-105
Java support for, 94

outputDisplay method, 95, 96, 98
outputDisplayFrame object, 108
outputDisplay.pack, 100
outputDisplay.show, 100
Overflow, 620, 621, 622, 630
Overloading, 339, 363, 379

defined, 362
of identifiers, 362
and signatures, 361-363, 377

Overriding, 342, 350, 352, 360, 363, 378
defined, 350
and instance methods, 377

P
Package access, 310, 358-359
Package(s), 19, 95, 320-321

classes in, 293, 333

766 | Index

TE
AM
FL
Y

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

Team-Fly® 



with compilation units, 321
defined, 57
syntax for, 320-321
testing classes in, 293. See also Classes

package statements, 333
pack method, 117
Palindrome, 671
Parameter, 161, 311-314, 331, 333, 536

array passed as, 609
defined, 96, 310
multidimensional array passed as, 611
one-dimensional array object passed as, 495
simple type passed as, 311
two-dimensional array declared as, 599. See

also Graphical user interface
Parameter passing, 310

analogy, 315-316
paramString method, 348, 350

and polymorphism, 350, 351
Parentheses, 309, 331

checking, 275-276
and Java operators, 470
and operator precedence, 244-245, 476
for overriding precedence rules, 162
and precedence rules, 137
and for statement heading, 484
and string conversion, 143

Partial (or sub) array processing, 519
Pascal, 10, 102

characters in, 497
Pascal, Blaise, 144-145
Pascal, Etienne, 144
Pascal’s box, 144
Pascal’s law, 144
Pascal’s theorem, 144
Pascal’s triangle, 144
Password system, 75
Payroll class, 37
Payroll program, 233

possible data entry frame for, 177
Peripheral device, 21
PersonDriver

output file from, 330
Phone book

binary search of, 573
Physical order, 402
Piracy

of data, 24-25
software, 24

PL/1, 101
Plagiarism, 24
Plus sign (+), 83
Polymorphism, 339, 350-351, 352, 582

defined, 351
Polynomial expressions, 428
Polynomial time, 429
Polynomial-time algorithms, 429
Portability

slower execution and increase in, 13
Portable code, 12
Position

array components accessed by, 502
Positive exponents

coding using, 613, 614
Postfix operators, 136
Post-incrementation, 472
Posttest loop, 460
Power function definition, 648-649
Power function implementation, 649-651
power method 

execution of, 650
Precedence of operators, 243-245
Precedence rules, 136-137, 142, 143, 160, 162
Precision, 612, 613, 614, 620

and normalization, 616
practical implications of limited, 621-622

Prefix operators, 136
Pre-incrementation, 472
Preparing the user interface, 214
Pretest loop, 460
Priming read, 422

adding to loop, 408
for counting, 413
and nested loops, 419
for sentinel-controlled loops, 416
for while solution, 459

Primitive integral types, 125
Primitive types, 124, 125, 496, 518
Print(data.0.4)

execution of, 665
Printers, 21
printList method, 557, 558, 559
println method, 69, 70, 83, 96, 395, 396, 397,

398, 400
printMatrix observer, 627
print method, 69, 83, 96, 395, 396, 437
PrintName program, 73

event handler fitting into, 110

Index | 767



PrintName program (continued)
registering listener in, 107

PrintWriter class, 388, 440, 441
extending file I/O with, 393-398
relationship between FileWriter and, 394

PrintWriter methods, 399
Privacy of data, 24-25
private access, 359, 379
private class method, 310
Private members of class, 198
private modifier, 58, 62, 72, 112, 199, 359
Problem-solving case studies

average income by gender, 429-435
averaging rainfall amounts, 213-220
company payroll program, 33-40
date display in multiple formats, 78-81, 112-116
exam attendance, 583-591
extending TextField for numeric input/output,

367-371
grading true/false tests, 525-534
implementing Name class, 322-327
lists comparison, 519-525
map measurements, 155-160
matrix manipulation, 623-633
rainfall averages (monthly), 477-483
simple calculator, 262-270

Problem-solving phase, 3, 4, 8, 40, 41, 56, 195, 197
steps in, 4
testing in, 270

Problem-solving techniques, 27-33
algorithmic, 33
ask questions, 27-28
building-block approach, 31
divide and conquer, 30
look for familiar things, 28
means-ends analysis, 29-30
mental blocks: fear of starting, 32
merging solutions, 31
solving by analogy, 28-29

Procedural languages, 18
Processing two-dimensional arrays, 604-609

by column, 609, 635
initializing array, 608
methods and two-dimensional arrays, 609
by row, 609, 635
sum the columns, 607
sum the rows, 605-606

Program class
execution of, 83

Program entry, 75-76
Programmer-defined types, 54
Programmers, 3

loop design and responsibilities of, 407
and mental block, 32
teams of, 271

Programming
description of, 2-3
at many scales, 220-221
overview of, 2-9
writing programs, 3-8

Programming in the large, 220, 221
Programming in the small, 220
Programming language(s), 9, 40, 48

basic control structures of, 17
defined, 6
history of, 101
kinds of instructions written in, 16-19
object-oriented, 18-19. See also High-level program-

ming languages
Programming process, 4
Programming style, 6
Programs

compiling/running, 76-77
construction of, 71-73
data input into, 176, 224
data separated from, 176
direct execution versus interpretation of, 13
finishing up, 77-78
formatting, 146-149, 162, 225
lifecycle of, 8
reliable, 436
robust, 435
testing, 436, 438
understanding before changing, 154, 161

Project director, 220
Prompting message, 222
protected access, 357-358, 377, 379
protected member, 357, 358
protected modifier, 348
protected responsibility, 360
Provincial Letters (Pascal), 145
Pseudocode, 212
public access modifier, 310, 357, 377
public classes 

implementing with multiple compilation units, 321
Public fields

declared in classes, 301
Public field values, 300-301

768 | Index



Public interface design, 300-302
public member, 198 

accessing, 357
public modifier, 58, 72, 110, 199

for constructors, 331
public value-returning class method, 310
PUNCT, 324
Punctuation

and internal representation example, 307

Q
Quadratic expressions, 428
Quadratic formula, 427
Quotes, 58, 59, 81

characters enclosed in, 56
mismatched, 81

R
Ragged arrays, 603, 604, 635
Rainfall amounts problem-solving case study,

213-220
Rainfall averages case study, 477-483
Rainfall class, 218-220
Rainfall program, 481-483

testing, 483
Raising exceptions, 466
RAM. See Random-access memory
Random access, 605
Random-access memory, 19n3
Reading data into variables, 176
readLine method, 397, 398, 410, 515, 587
read method, 391, 410, 441

and end-of-file controlled loops, 410
ReadWrite class, 501-502
Real numbers, 54, 496, 497
Recursion

description of, 648-651
or iteration?, 666
power function definition, 648-649
power function implementation, 649-651. See

also Looping
Recursive algorithms, 647, 648, 664, 666, 667

defined, 649
with structured variables, 662-666

Recursive calls
and base case, 667
defined, 648

Recursive case, 659, 662, 667
Recursive definition, 649

Recursive solutions, 666
Reference type parameter

effect of assigning new value to, 313
effect of changing fields of, 314

Reference types, 124, 125, 311, 312, 331, 496,
509, 518, 536

arrays as, 508
array types as, 517
passing, 312

Registering listeners with events, 117
Registering the listener

defined, 106
Registration

event listener, 182
Relational expressions, 235
Relational operations, 496, 497
Relational operators, 235-237, 470

with floating-point types, 246
in logical expressions, 473
logical operators combined with, 240
and precedence of operators, 243-244
verifying, 273

Relative error, 617, 618
Reliable programs, 436
Remainder (%), 132, 162
Representational errors, 616, 621, 622

defined, 615
with floating-point numbers in arithmetic cal-

culations, 635
Reserved words, 61, 81, 83, 234

defined, 53
resetList method, 550, 557, 559
Responsibilities, 333

method mechanisms for implementing, 316,
317, 318

as methods, 301-302
Responsibility algorithms

for AStudentAnswer, 528-529
for average income by gender case study, 430
for comparison of lists case study, 521-522
for data validation, 522
for exam attendance case study, 585-587
for extending TextField for numeric

input/output, 368
for List class, 552-558
for matrix manipulation case study, 626
for Name class implementation, 324-325
for rainfall averages case study, 478-479
for simple calculator case study, 264

Index | 769



Responsibility algorithms (continued)
for SortedList class, 565-569
for TheKey class, 528

Return statement, 331, 333
Reuse, 19, 295, 296, 340, 377

defined, 294
Reverse apostrophe, 81
Rickover, Admiral Hyman, 457
Ritchie, Dennis, 102
Robust programs, 435
Rotations in graphics, 623
Rounding, 614
Rounding error, 617, 618
Row index, 608
Rows, 600, 602, 605, 624, 626, 627

partial array processing by, 607
processing of, 609
sum of, 605

Running, program, 76-77
Run-time stack, 651

S
sales array, 610, 611
Sales figures, 512-513
Saving and backing up, 77
Scalar data types, 497
Scenarios

for average income by gender case study, 429
for comparison of lists case study, 520
for exam attendance case study, 583
for grading true/false tests case study, 526
for matrix manipulation case study, 624
for rainfall averages case study, 477-478
for simple calculator case study, 263

Scientific notation, 162
floating-point numbers in, 128

Scope of access, 353-360
external scope, 357-360
internal scope, 354-357

Scope rules, 379
defined, 354

Scope (scope of access)
defined, 354

Scrabble, 600
Screen, 22

frames displayed on, 100
Searching, 571-577, 593

binary, 572-577, 593

complexity of, 578-579
sequential, 571-572, 593

Secondary storage, 16
Secondary storage device, 21
Selection, 16, 40
Selection (or branching) control structure, 16, 233
Selection sorts, 561
selectSort method, 561

nested for loops in, 578
Self-contained objects, 225
Self-documenting code, 175

defined, 213
Semantic errors, 275
Semantics

defined, 48
Semicolons, 74, 82, 95, 146, 249, 250, 276, 331

and do statements, 458
in expression statements, 471
and infinite loops, 438

Sentinel-controlled loops, 407-410, 416, 424, 437, 441
Sentinels, 385
Sentinel values, 408, 437
Sequence, 16, 40
Sequence of statements, 249-250
Sequential search, 555, 571-572, 577, 578, 593
setActionCommand method, 183, 222, 224, 258, 259
setint, 372, 373
setLayout method, 96, 97, 98, 104
setText method, 181, 367
Shallow copy

defined, 365
Shallow copying, 364, 366
Shallow tests, 509
Shickard, Wilhelm, 144
shiftDown algorithm, 566
shiftUp algorithm, 566
Short-circuit evaluation, 241-242
short type, 126, 127, 242, 496, 505
Short word, 9
show method, 115, 117
Side-effect errors, 331
Side effects, 314

and assignment expressions, 471
avoiding unnecessary, 476

Signature of method, 362, 363
Signatures, 379

defined, 362
and overloading, 377

770 | Index



Significant digits, 614, 616
defined, 613

Simple truncation, 614, 615
Simple types, 311, 331

passing, 312
“Sketch of the Analytical Engine, The” (Lovelace),

353
skip method, 392
Skipping, 437

and loop testing, 436
Slashes, 70
Smalltalk, 197
Software, 1, 22, 41

defined, 21
testing, 559

Software design strategies, 195-196
Software engineering, 26-27, 221
Software engineering tips

documentation, 212-213
English statements changed into logical expres-

sions, 245-246
named constants used instead of literals, 130
numeric data type choices, 622
understanding before changing, 154

Software piracy, 24
SomeClass class, 358, 359

and name precedence, 355, 356
SomeDouble, 193
someObj, 359
Sorted list

defined, 546
insert algorithm for, 579
inserting into, 567
places where items inserted into, 565
searching in, 571

SortedList class, 563-569, 591
brainstorming for, 563-564
CRC card for, 564
responsibility algorithms for, 565-569
test plan for, 569

Sorting
algorithms, 561
complexity of, 578-579
defined, 559

Sorting list items, 559-563
Source code, 11
Spacing

in numeric type formatting, 153

Special case
and general case, 568

Standard (built-in) type, 54
Standardized high-level languages, 10, 11
starCount, 421, 422, 423
State

defined, 297
Statements

structuring in programming languages, 16
syntax templates for, 74

Static binding
defined, 582

static fields, 305
static modifier, 112, 305
Steps, 425
Stepwise refinement, 210
Stirling’s formula, 288-289
Storage

data, 55
Straight selection sort, 561
String class, 47, 55, 58, 83, 125, 396, 398, 498,

517
charAt method provided by, 432
immutability of, 313
value-returning class methods, 161

String comparison, 237
String concatenation operator, 396, 470
String constants, 67, 72
String conversion, 141-143
String expressions, 66-68
String literals, 81, 237, 505
String operations

additional, 149-153
Strings

arrays of, 514-517
comparing, 237
converting to numeric values, 192-195, 224

String type, 123, 124, 180
String values, 222
String variable, 72, 82, 237
Strongly typed languages, 61
Stroustrup, Bjarne, 102
Structured composite data types, 495
Structured data types, 499

defined, 498
Structured design, 210
Structured variables

recursive algorithms with, 662-666

Index | 771



Style
braces and blocks, 251
capitalization of identifiers, 63-64
identifiers, 54
program formatting, 146-149
program writing, 6

Subarrays, 552
processing of, 536, 604, 606

Subclass, 202, 204, 208
defined, 344
designing/implementing interface, 360

Subproblems, 225
and merging solutions, 31

Subprograms, 16-17, 40
substring method, 151-153, 323
Subtasks

solutions for, 28
Subtraction (-), 131, 162

of matrices, 623, 624, 627
Summary of classes

ActionEvent class, 277
BufferedReader throws IOException class, 439-440
Comparable (an interface), 592
Double class, 223 
Float class, 223
Frame class, 224
Integer class, 223
List class, 592-593
Long class, 223
Matrix class, 634-635
Name Class, 332
NumericField class, 378
String class, 277, 439
TextField class, 224

Summing, 417, 442
for incomes case study, 433
loops, 385, 413-415

Sun Microsystems, 102
Superclass, 202, 203, 204

constructor, 361
defined, 344
extending, 360
hiding, 350

super.dispose() method, 364
super keyword, 339, 379
Swapping

contents of two variables, 561, 562
switch expressions, 454, 455, 484

defined, 452
SwitchLabel, 454

switch statement, 451, 452-457, 484, 485
flow of control in example of, 453
syntax template for, 453

Symbolic constant, 62
Symbols

in Java, 49
for logical operators, 239-240

Syntactic errors, 274
Syntax, 83

for component access, 518
for declaring array object, 504
defined, 48
derived class, 351-352
errors in, 48, 56, 454
for packages, 320-321
rules, 48
and semantics, 48-54
of throw statement, 467
for writing new class, 307

Syntax definitions, 49, 50
Syntax diagrams, 50

for classes, 57
for compilation unit, 320
reading, 51
for try-catch-finally statement, 464

Syntax templates, 51-52, 61, 83
for accessing array component, 505, 602
for assignment statement, 65
for call statements, 97
for class declaration, 351
for constant declaration, 63
for declaring array with dimensions, 601
for do statement, 458
for headings, 309
for if-else form, 247
for if statement (if form), 252
for instantiating array, 503
for one-dimensional array declaration, 502
for responsibility implemented as method, 317
for statement, 461
for switch statement, 453
for while statement, 403

system.exit method call, 110
System.out object, 83, 96
System.out.print, 83
System software, 22, 41

T
Tabular output

GridLayout for, 103-104

772 | Index



Tail recursion
defined, 664

Terminal symbols, 49
Termination condition, 415, 416

and arrays processing, 534
defined, 405

Test cases, 274
Testing, 4
Testing and debugging, 81-82, 221-222

classes and methods, 328-331
during compilation/execution, 274-275
DateFormats, 81-82, 115-116
and do and for loops, 484
and errors with multidimensional arrays,

633-634
FirstList program, 524-525
hints, 275-277, 377, 437-439, 484, 536, 592,

634, 667
loop-testing strategy, 435-436
Name class, 327
NumericField class, 371-377
and out-of-bounds array index, 534-535
in problem-solving phase, 278
program, 6
and recursion, 666
testing strategies, 270-273
test plan, 273
test plan for Calculator application, 274
TheKey class program, 533-534
Walk program, 160-161

Testing process, 275
testNumber, 372, 373
Test plan, 276, 278, 333

defined, 273
for List class, 558
for loops, 436-437
for Name class, 328
for sorted list, 569
for SortedList class, 569

Test plan implementation
defined, 273

testScore array, 503
Text

alignment of, within labels, 104
TextComponent class, 367

Component extended by, 348
TextField extension of, 347

TextField class, 346, 350
constructors in, 361-362
extending for numeric input/output, 367-371

methods available for, 349
summary of classes for, 347

TextField object, 179, 180
assigning, 180
and Label object, 181, 182
methods with, 180

TheKey class program, 530-532
Then-clause, 247
Theoretical foundations

metalanguages, 49-51
this keyword, 339

using to overcome name precedence, 356
Three-dimensional arrays, 611
Throw

defined, 399
Throwable interface, 467
Throwing an exception, 485
throws clause 

and throwing exceptions, 399
throw statement, 467, 485

exception generated with, 466-469
Tic-Tac-Toe, 600
toCharArray method, 517
toLowerCase method, 237
Top-down design, 210
Torricelli, Evangelista, 144
toUpperCase method, 237
Tower of Babel period of programming languages,

101
Towers of Hanoi, 658-662, 666, 667
Trailer value, 408
Transformer, 301, 332

defined, 298
Transformer methods, 626, 630
Treatise on Differential Equations (Boole), 243
Treatise on the Calculus of Finite Differences

(Boole), 243
Tree structure, 210
Triply nested loops, 423
true literal, 497
true value, 234, 235, 247, 278
try-catch-finally statement

execution of, 466
syntax diagram for, 464

try-catch statement, 452, 467, 468, 479, 485
execution of, 465

try statement, 451
throw called from within, 467

Two-dimensional arrays, 599, 600-604, 626, 635
accessing individual components, 602

Index | 773



Two-dimensional arrays (continued)
array declaration and instantiation, 601-602
declaration of, 602
defined, 600
and initializer lists, 603-604
and methods, 609
processing, 604-609
viewing as array of arrays, 599

Type casting, 139, 141
defined, 139

Type-cast operator, 470
Type conversion, 139, 141, 162

defined, 138
Typing errors, 275

U
Unary minus, 131
Unary (one-operand) operator, 135, 162, 240, 475, 476,

535
defined, 132

Unary plus, 131
Unchecked exceptions, 399
Underflow, 619, 620, 621, 630
Underscore character, 52-53, 54
Unicode character set, 9n1, 55, 56, 238, 390, 496
Unicode collating sequence, 239
Unique keys, 546

list with, 547
UNIVAC I, 457
Universal set, 243
Unordered lists

searching in, 571
Unreachable condition, 304
Unsorted list

defined, 546
searching, 571

Unstructured composite data types, 495
Unstructured data types, 499

defined, 498
Updating

conditions, 416, 422, 423, 431
flag variables, 416, 417

Uppercase letters, 54, 63
Upward compatibility, 102
User/computer interface, 23
User-defined objects

arrays of, 517
User-defined types, 54

V
valueOf method, 193, 194, 195, 224, 397, 517
Value-returning methods, 146, 149, 150, 237, 333
Values

and assignment expressions, 471
extracting from fields, 180-182
mechanisms for changing, 317
ordered, 497

Variable declarations, 130-131
comments in, 71
syntax template for, 61

Variable identifier, 60
Variable name, 60
Variable(s), 60-62, 131, 500, 612

and capitalization, 64
relationship between class, object, and, 198
in simple Calculator case study, 267
with value, 60, 66

Vector class, 611-621
arithmetic with floating-point numbers, 615-616
floating-point numbers, 612
implementation of floating-point numbers in computer,

616-621
representation of floating-point numbers, 612-615

Vectors, 612
Video display, 21
Virtual machine

defined, 15
Virus

defined, 26
Void method, 97

W
Walk-through, 204-207, 210, 271

in progress, 206
Web browsers, 2
while conditions, 438
while loops, 385, 459-462, 462, 484
while statement, 385, 403-404, 438, 441, 451, 463

and counting, 413
and end-of-file controlled loops, 410, 412
flow of control, 404
if statement versus, 404, 405
loops using, 405-406
nested, 418
in recursive algorithm, 667

White-box (or clear-box) testing, 272, 633

774 | Index



Whole number parts
of floating-point variables/constants, 612

Widening conversion, 139
Window, 69

closing, 117
creating, 93
elements put into, 98-99
Java support for, 94

WindowAdapter class, 108-109, 112, 117, 208,
209

WindowAdapter constructor, 116
WindowAdapter type, 184
Window closing, 217, 266
Window-closing event, 93
windowClosing method, 108, 110, 112, 117, 208

WindowEvent object, 109
Window events, 108
WindowListener class, 108, 109, 115
WindowListener type, 184
Word processors, 2
Words, 9
WorkAddress class

CRC card for, 342, 344
World Wide Web

and portability, 13
write method, 390, 437, 441

X
Xerox Palo Alto Research Center, 69

Index | 775



TE
AM
FL
Y

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

Team-Fly® 


	sample.pdf
	sterling.com
	Welcome to Sterling Software





