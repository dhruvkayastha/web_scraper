***Categories for Software Engineering***












































Categories for Software Engineering


Categories for Software Engineering



Jose Luiz Fiadeiro

Categories for
Software Engineering

fyj Springer



Jose Luiz Fiadeiro
University of Leicester
Department of Computer Science
University Road
Leicester LEi 7RH
United Kingdom

Library of Congress Control Number: 2004113132

ACM Computing Classification (1998):
D.2.11,R3.1,D.2.1,D.2.4,D.1.3

ISBN 3-540-20909-3 Springer Berlin Heidelberg New York

This work is subject to copyright. All rights are reserved, whether the whole or part of the
material is concerned, specifically the rights of translation, reprinting, reuse of illustrations,
recitation, broadcasting, reproduction on microfilm or in any other way, and storage in
data banks. Duplication of this publication or parts thereof is permitted only under the
provisions of the German Copyright Law of September 9,1965, in its current version, and
permission for use must always be obtained from Springer. Violations are liable for
prosecution under the German Copyright Law.

Springer is a part of Springer Science+Business Media

springeronline.com

© Springer-Verlag Berlin Heidelberg 2005
Printed in Germany

The use of general descriptive names, registered names, trademarks, etc. in this publication
does not imply, even in the absence of a specific statement, that such names are exempt from
the relevant protective laws and regulations and therefore free for general use.

Cover design: KunkelLopka, Heidelberg
Production: LE-TeX Jelonek, Schmidt & Vockler GbR, Leipzig
Typesetting by the author
Printed on acid-free paper 45/3142/YL - 5 4 3 210



From a loving father



Preface

Why Another Book on Category Theory?

In the past ten years, several books have been published on category the-
ory either by computer scientists or having computer scientists as a target
audience (e.g. [6, 12, 22, 89, 105], to which a precious collection of little
gems [90] and the chapter cum book [91] should be added). Isn't the
working computer scientist spoilt with choice?

Although each of the above mentioned books presents an approach of its
own, there is one aspect in common in their view of computer science: the
analogy between arrows (morphisms) and (classes of) computations. This
"type-theoretic" or "functional" approach corresponds to a view of com-
puter science as a science of computation, i.e. a discipline concerned with
the study of computational phenomena where the focus is on the nature
and organisation of computations.

However, there is another view of computer science where the focus is,
instead, on the development of computer programs or systems. This is the
approach that supports, for instance, software engineering. From this point
of view, arrows do not capture computational phenomena, or abstractions
thereof, but instead relationships between programs, or abstractions of
programs, that arise in the development of computer systems, for instance,
refinement of higher-level specifications into executable programs [100,
104], and superposition of new features over existing systems [72].

Not surprisingly, this same difference in the points of view can be found
when logic is taken as a mathematical domain for formalising aspects of
computer science. The "computations as proofs" paradigm is the one that
corresponds to the "classical" application of category theory. Terms of the
logic correspond to objects in a category of programs whose morphisms
capture (partial) computations. From a logical point of view, the perspec-
tive that we take in this book is not centred on terms but on theories as
system specifications. Morphisms then capture what in logic is known as
"interpretations between theories", the cornerstone for the formalisation of
refinement in program development and other operations on specifications
and system designs [17, 82, 103, 104].

Category theory can also be presented as the branch of mathematics
that, par excellence, addresses "structure". As the introduction will try to



VIII Preface

explain, this is because category theory causes structure to emerge from
relationships between objects as captured by arrows, and not extensionally
as in set theory. Indeed, the term morphism, often used for arrow in cate-
gory theory, has in its etymology the notion of preservation of form. What
these structures are, or mean, is up to the "user". Hence, in the "classical"
approach, we find applications of category theory that address the structure
of computations. In the approach that is taken in this book, the structures
that are addressed are those that capture modularisation principles in soft-
ware development, in particular, those that have been used for constructing
distributed systems (e.g. as in [81]) and, more recently, emerging in the
guise of what has become known as software architectures [50].

The practical difference between the two approaches in what concerns
category theory in general, and this book in particular, is that the reader
will not find as many references to algebraic topology or related fields of
mathematics as applied, for instance, to domain theory. Although this
book is still "mathematical", the software engineer will find the mathe-
matics applied to objects of its day-to-day concerns: programs, object
classes, specifications, designs, and so on.

This approach can be also situated as belonging to the class of applica-
tions of category theory to general systems theory, namely in the tradition
initiated in [52, 53, 64], an area of science that, as the name indicates and
the introduction elucidates, encompasses more than computational systems
in the traditional sense. Through books aimed at wider audiences like
[71], a unifying view of complex systems as they arise in disparate areas
like physics, biology, social sciences, economics and, yes, informatics, has
started to emerge (pun intended), which is a clear indication of new levels
of maturity in science in general and informatics in particular. Hence, one
of the purposes of this book is to help computing scientists and software
engineers acquire formal tools that will enable them to follow and partici-
pate in this "new" culture.

A trait that is common to all these areas is a view of complex systems as
communities of interacting, simpler, autonomous entities. Whereas, in ar-
eas like biology or social sciences, the notion of "community" is intrinsic,
its use in areas like software engineering is more artificial and is normally
identified with methods and development techniques that, in the past few
years, have attempted to tackle complexity by borrowing the organisa-
tional principles that can be recognised in such "natural" communities.
Object-oriented modelling, agent-based programming and component-
based development all make use, in one way or another and with different
emphasis, of this analogy. This brings us to the application area covered
in the third part of this book.

Community is the name of a language for parallel program design that
is similar to Unity [19] but adopts instead an interaction model that places
it in the realm of these more general and unifying approaches to systems.



Preface IX

It addresses in particular the most recent trend, service-oriented software
development, an (r)evolution of the popular object-oriented modelling
techniques for the "Internet-age" or what is becoming known as the "real-
time" or "now" economy. The distinctive feature of this new trend is in
the emphasis that it puts in the externalisation and explicit modelling of
interactions as first-class citizens so that systems can be more easily recon-
figured, in run-time, and without interruption of vital services. These
characteristics match, precisely, features that are intrinsic to category the-
ory, namely those that distinguish it from set theory.

That is why, even if a substantial part of this book is illustrated with ex-
amples borrowed from software engineering practice, we decided to de-
vote three chapters to the application of category theory to Community
and its relationship to software architectures. This material will provide an
opportunity for the reader to see concepts and techniques of category the-
ory applied in an integrated and systematic way. At the same time, the
reader will be able to appreciate how far one can go in formalising soft-
ware development methods and techniques in mathematical frameworks,
which is essential for a mature engineering discipline and, in my opinion,
is our responsibility as computing scientists.

This Book and Its Many Authors

Mentioning the connections between category theory and general systems
theory is a good opportunity to give due credit to Joseph Goguen for the
profound inspiration that his work has instilled, a sentiment that I know is
shared by many other researchers in computing science. He has expressed
his own views on the applications of category theory to computing in sev-
eral publications, most notably in [57], which include detailed summaries
of technical results that we all have found very useful when categorical
approaches were still regarded, at best, as "exotic" [60, 61, 66, 102]. All
of us regret that this material has never found its way to a textbook. Be-
cause it is not our aim to fill this gap, the reader is strongly encouraged to
consult this rich legacy at his or her own pace, bearing in mind that the list
of references that is provided at the end is far from being complete.

Completeness is, in fact, a concern that has remained largely alien to my
research agenda. (This observation is intended to make some readers
smile, but you can take it literally.) This book is more about a personal
experience than the output of a rational process of identifying "the" or "a"
complete categorical kernel that software engineers can use as a toolbox.
The only justification for the inclusion of many concepts and constructions
is that they were of help to me, either technically or aesthetically, making
it likely that they will be directly useful for other people "like me". The



X Preface

exclusion of many other, even very basic concepts,1 can be justified by the
officious disclaimer that "the line has to be drawn somewhere", but, most
of the time, the reason is that I never stumbled upon them in my daily rou-
tine or simply that I have not developed an understanding about them that
is deep enough to add any value to what can be found in other books.

This personal experience has gone through well identifiable periods,
each of which is associated with a different focus of interest in computing
and a group of people with whom I worked directly and whose contribu-
tions I would like to acknowledge. My first contact with category theory
was when I was studying mathematics as an undergraduate at the Univer-
sity of Lisbon, and Prof. Furtado Coelho challenged the wrath of my fel-
low students, and his fellow staff, by including this most exotic, difficult
and useless of subjects in the curriculum of Algebra II. Applications to
computing science came a year later through the study of Goguen and
Burstall's Theory of Institutions as a means of formalising conceptual
modelling and knowledge representation approaches, under the supervi-
sion and in collaboration with Amilcar and Cristina Sernadas [46]. This is
when things started to get serious.

In 1988, I started what has been a very rewarding collaboration with
Tom Maibaum. During the three years I spent at Imperial College, we de-
veloped a categorical approach to object-oriented development based on
temporal logic specifications [39], a marriage between my previous work
with institutions and the ideas of Tom Maibaum and Paulo Veloso on the
nature of specifications in system development [103]. Their contribution
permeates the material that is exposed in a way that cannot be referenced
in the same way as a technical result. I have been very fortunate to be able
to keep exchanging ideas and experiences with them; there are always hid-
den subtleties that only come to the surface when you are challenged by
people like them and required to scratch the innermost levels of your un-
derstanding to satisfy their curiosity.

During this same time, Felix Costa explored the categorical semantics of
objects from the point of view of algebraic models of concurrency [21]. In
1992, we brought it all together [32]! My collaboration with Felix pro-
vided much of the inspiration that led to my own understanding of the ap-
plication of category theory to systems modelling. Although specific con-
tributions are acknowledged with references to his work, it would be unfair
to reduce his contribution to this book to those occasions.

The next phase is devoted to the (then) emerging field of software ar-
chitecture. It is centred on a language - Community - that I developed
together with Georg Reichwein and Tom Maibaum in an initial period, and
later on with my students Antonia Lopes and Michel Wermelinger. It

1 Yes, I know that I will not be forgiven for having left out "must-haves" such as
the Yoneda lemma, Cartesian-closed categories, topoi, monads, and so on.



Preface XI

started as a proof of concept, showing that Goguen's categorical approach
could be applied to parallel program design in the style of Unity [19] and
Interacting Processes [48]. Later, it evolved into a prototype language for
architectural modelling [34], a process that led me to understand many
concepts that, until then, were blurred by the poor expressive power of the
formalisms with which we had been working: non-determinism versus un-
der-specification [77], refinement versus composition [78], and the role of
"signatures" in separating computation and coordination [35]. Some of
this is revealed in Part III of this book, but you will have to wait for an-
other book to have the full story!

Although this "architectural" period is still very much alive (which does
not mean that the others are already dead), another step in this evolution
process has occurred: the realization that category theory provides a per-
fect fit to support service-oriented software development, for instance in
the sense of Web-services. But this step is so recent that, in fairness, I
cannot acknowledge/blame anybody in particular for it. Nevertheless, it is
unlikely that it would have happened so soon, or at all, if I had not ac-
cepted the challenge that Luis Andrade presented me with for working
with ATX Software SA in putting these "theories" into "practice". This
has been a very rewarding process that has given me the opportunity to
understand the implications of many of the structures and mechanisms that
are intrinsic to category theory. I hope that I have managed to permeate
this understanding in the way the material is exposed in the book.

This is probably why this book is being finalised now and only now:
during each of the periods I mentioned, a book was planned and parts were
sketched. It is only now that the work of so many people has contributed
to the contents that I can safely write it on my own without feeling guilty
for excluding anybody in particular from coauthoring it.

It so happens that the last thrust in writing this book was made during
my first year at the University of Leicester, a renowned address for re-
search in category theory and its applications to computer science. Al-
though I can honestly assure the reader that the decision to join Leicester
was not for the advantages of promoting this book, it is certainly a privi-
lege for the book to bear this affiliation!

Finally, I should thank all the colleagues and students who have trod
with me the paths that you can choose to follow in this book. The oppor-
tunity to discuss and lecture on many of the topics that are covered con-
tributed decisively in helping me reach the level of maturity that made me
decide that this book could be written. The feedback I received from tuto-
rials presented at events such as ECOOP, ETAPS, FME, OOPSLA and
TOOLS also helped me decide that this book should be written. The inter-
est and encouragement of people like Ira Forman and Desmond D'Souza
have also reassured me that the message could perfectly go beyond the
walls of academia.



XII Preface

Special Acknowledgements

Although the previous paragraphs have given me the opportunity to ac-
knowledge the contributions of a number of people and institutions, there
are some specific colleagues to whom I would like to express my deepest
gratitude for direct contributions to this book:

• Felix Costa: A significant part of the material covered in Part II was de-
veloped jointly with him as reported in [32, 33], As already mentioned,
much of my own understanding of category theory and its role in com-
puting science grew from discussions with him.

• Antonia Lopes and Michel Wermelinger: The fact that Part III of this
book was essentially extracted from [37, 79] is a good indication of how
important and extensive their contribution has been. Community as we
know it today is as much theirs as it is mine.

• Tom Maibaum: His encouragement and support in the earlier phases of
the production of the book were decisive.

• Uwe Wolter. He had the courage to follow an early draft in a course that
he gave in 2002/2003 (repeated in 2003/2004) at the University of Ber-
gen (Norway). As a result, I received precious amounts of feedback,
which was invaluable for the final tuning of the material and the way it
is now presented.

Finally, I would like to thank the EPSRC for an eight-month visiting
fellowship at King's College London in 1999, which gave me the opportu-
nity to make a significant advance in the writing of the book, to Janet Mai-
baum for her help in setting Microsoft Word up to the job1 and to the team
at Springer for their enthusiasm, support and advice.

Gesse,2 April 2004 Jose Luiz Fiadeiro

1 Yes, this book is a proof that writing about category theory is not reserved to
users of a well-known typesetting system that I will not name... And this re-
mark is not meant as a recommendation for the products developed by a com-
pany that I have already named...

2 The little village in the French Pyrenees, by the river Aude, where this book was
written and revised from 2000 until completion.



Contents

Introduction 1
1.1 The Social Life of Objects 1
1.2 Categories Versus Sets 3
1.3 Overview of Typical Application Areas 5
1.4 What Can Be Found in This Book 9

Part I Basics

2 Introducing Categories 15
2.1 Graphs 15
2.2 Categories 20
2.3 Distinguished Kinds of Morphisms 27

3 Building Categories 31
3.1 Some Elementary Operations 31
3.2 "Adding Structure" 33
3.3 Subcategories 37
3.4 Eiffel Class Specifications 43
3.5 Temporal Specifications 46
3.6 Closure Systems 53

4 Universal Constructions 57
4.1 Initial and Terminal Objects 58
4.2 Sums and Products 61
4.3 Pushouts and Pullbacks 67
4.4 Limits and Colimits 75

5 Functors 83
5.1 The Social Life of Categories 83
5.2 Universal Constructions Versus Functors 89



Part II Advanced Topics

6 Functor-Based Constructions 95
6.1 Functor-Distinguished Kinds of Categories 95
6.2 Structured Objects and Morphisms 110
6.3 Functor-Structured Categories 117
6.4 The Grothendieck Construction 124
6.5 Institutions 128

7 Adjunctions 141
7.1 The Social Life of Functors 141
7.2 Reflective Functors 145
7.3 Adjunctions 151
7.4 Adjunctions in Institutions 160
7.5 Coordinated Categories 167

Part III Applications

8 Community 177
8.1 A Language for Program Design 177
8.2 Interconnecting Designs 182
8.3 Refining Designs 191

9 Architectural Description 197
9.1 Motivation 197
9.2 Connectors in Community 199
9.3 Examples 204
9.4 An ADL-Independent Notion of Connector 211
9.5 Adding Abstraction to Connectors 214

10 An Algebra of Connectors 221
10.1 Three Operations on Connectors 223
10.2 Higher-Order Connectors 227

References 237

Index 245



1 Introduction

1.1 The Social Life of Objects

Questions that we are frequently asked are: What is category theory good
for? Why should I use category theory? These questions usually indicate a
genuine and healthy reaction to the proposal of a new piece of mathemat-
ics that one is invited to learn, similar to the reaction we have each time we
are asked to change our eating habits and, say, replace butter with olive oil
when cooking... How is this going to make us happier? Or healthier?
When is the change justified?

The question also indicates that the nature and role of category theory is
not completely clear to many people. The way we like to present category
theory is as a toolbox similar to set theory: as a kind of mathematical lin-
gua franca in the sense that it can be used for formalising concepts that
arise in our day-to-day activity. It constitutes, however, a richer toolbox in
the sense that the instruments that it provides are more sophisticated and
thus make it easier to model situations that are more complex and that in-
volve structured objects. On the other hand, because these instruments are
more sophisticated than those of set theory, they require a dedicated
learning effort. Briefly, in category theory one can do as much as in set
theory, in an easier way when it comes to formalising and relating differ-
ent notions of "structure", but at the cost of learning a few more concepts
and techniques.

So, I would like to reformulate the original question as: Having been
brought up to think about the world in terms of sets, why should I now
change and use another frame of reference? The purpose of this book is to
convince you that this change of reference is worth making, that is, that
this book will have been worth reading and that the concepts and tech-
niques that it introduces belong in the mathematical toolbox of the soft-
ware engineer.

For many of "us", the key factor that justifies this change is related to
the fact that, whereas concepts in set theory are typically formalised exten-
sionally, in the sense that a set is defined by its elements, category theory
provides a more implicit way of characterising objects. It does so in terms
of the relationships that each object exhibits to the other objects in the uni-
verse of discourse. The best summary of the essence of category theory



1 Introduction

that I know is from the logician Jean-Yves Girard.1 For him, category the-
ory characterises objects in terms of their "social lives".

In my opinion, this focus on "social" aspects of object lives is exactly
the reason for the applicability of category theory to computing in general,
and software engineering in particular. To realise why this is so, one just
needs to think that current software development methods, namely object-
oriented ones, typically model the universe as a society of interacting ob-
jects. Agent-oriented methods are based on the same societal metaphor.
This focus on interaction is not accidental; it is an attempt at tackling the
increasing complexity of modern software systems. In this context, com-
plexity does not necessarily arise from the computational or algorithmic
nature of systems, but results from the fact that their behaviour can only be
explained as emerging from the interconnections that are established be-
tween their components. By promoting interactions as a focal point in the
definition of the structure of a system, one also brings software to the
realm of natural, physical and social systems, something that seems to be
essential for the development of well-integrated systems. Category theory
is advocated as a good mathematical structure for this integration precisely
because it focuses on relationships and interactions! The work of Goguen
on general systems theory [52, 53, 64], and recent books like [94] show
exactly that.

This is why many of the examples that are used throughout this book
address what has become known in software engineering as software ar-
chitecture [50], i.e. precisely the study of the gross modularisation princi-
ples that should allow us to design systems as possibly standard structures
of smaller components and the interconnections between them. The focus
that category theory puts on morphisms as structure-preserving mappings
is paramount for software architectures because it is the morphisms that
determine the nature of the interconnections that can be established be-
tween objects (system components). Hence, the choice of a particular cat-
egory can be seen to reflect, in some sense, the choice of a particular "ar-
chitectural style". Moreover, category theory provides techniques for ma-
nipulating and reasoning about system configurations represented as dia-
grams. As a consequence, it becomes possible to establish hierarchies of
system complexity, allowing systems to be used as components of even
more complex systems (i.e. to use diagrams as objects), and for inferring
properties of systems from their configurations.

The ultimate conclusion that we would like the reader to draw is that
high-school education could well evolve in a way that equips our future
generations with tools that are more adequate for the kind of systems that
they are likely to have to develop and interact with. We believe that the

1 What stronger evidence would one need of the close relationship between logic
and category theory...



1.1 The Social Life of Objects

teaching of mathematics could progressively shift from the set-theoretical
approach that made it "modern" some decades ago to one that is centred
on interactions. This is, of course, a big challenge, mainly because it is not
enough for the mathematical theory to be there; the right way needs to be
found for it to be transmitted. We believe that recent books such as [75]
are putting us on a path towards meeting this challenge, and we hope this
book makes a further contribution. However, we will be satisfied if the
rationale for such a shift can somehow emerge from the way we motivate
and present the basics of category theory.

1.2 Categories Versus Sets

Let us consider an example in order to make clear the difference in ap-
proaches between set theory and category theory. For this purpose, there
is nothing better than showing how certain mundane set-theoretic con-
structions are modelled in category theory.

Consider, for instance, the characterisation of the empty set. In set the-
ory, the empty set is characterised precisely by the property of not having
any elements. There are several ways in which we can say this using a
formal notation. Here is one:

The important point here is that any characterisation requires the use of
the membership relation £ , i.e. the characterisation is made with respect to
the elements that belong to the set.

Consider now the characterisation of the empty set in category theory.
As discussed above, such a characterisation involves the definition of a
"social life" of sets, i.e. it has to be made relative to the way sets interact
with one another. Hence, the obvious question to ask first is "What is the
social life of sets"?

The first important thing to understand is that category theory does not
provide an answer to questions like this one; it is up to whoever is formal-
ising a particular domain of discourse to come up with a definition of "so-
cial life" that is convenient. Convenience here has to be measured against
the formalisation activity that is being undertaken, possibly as an abstrac-
tion of real-world phenomena. Hence, it is not subject to mathematical
proof. Category theory requires some basic properties of such a "social
life" so that the whole mathematical machinery that we are about to de-
scribe can be applied successfully. Such basic properties are defined in
Sect. 2.2. In a nutshell, they prescribe ways in which one is related to one-
self and the way one's relations' relations are our own relations.



1 Introduction

Each time, during both classes and industry-oriented tutorials, our audi-
ences were first confronted with the need for defining a social life for sets,
the immediate answer was:

Set A is related to set B iff AQB.
Discussing the reason why this answer comes up spontaneously is well

beyond the scope of this book.1 The characterisation of the empty set
based on this social life of sets is quite easy: the empty set is the only set
that is related to every other set by this particular relationship.

Prompted for another definition of social life, the following answer was
given several times:

Set A is related to set B iffADB*0.
According to this definition, the empty set is the only set that is not re-

lated to any set; all non-empty sets relate at least to themselves. Inciden-
tally, we shall see in Sect. 2.2 that this definition of social life does not de-
fine a category, one of the reasons being that, in a category, every object is
at least related to itself in a canonical way. Nevertheless, the example is
useful for showing that changing the definition of social life may lead to
quite different characterisations of the same objects.

We typically have to force the audience to come up with the "standard"
definition of social life between sets:

A social relationship between a set A and a set B is given as a total func-
tion f.-A^-B.

The characterisation of the empty set in this case is very similar to the
first one: the empty set is such that, given any other set A, there is one, and
only one, function to A - the empty function. Notice that, although con-
cepts such as "contains", "intersection" and "function" are defined via the
membership relation, the characterisation of the empty set given in the
three cases does not involve it directly.

For further evidence that the nature of objects changes according to the
"social life" that is of interest, consider the characterisation of singletons.
According to the first definition, a singleton is such that only the empty set
and the singleton itself relate to it. In the second case, a singleton is such
that it relates to the sets that contain the element: {a} relates to B iff aEB.
This is a good evidence for the fact that the second definition is not very
"categorical": it reduces to set membership and makes the identity of the
elements visible. This is also the case with the first definition: in both
cases, two singletons are socially equivalent, in the sense that they relate to
any other set in the same way, iff they are equal. Incidentally, a possible
set-theoretic characterisation of a singleton set {a} is:

xE{a} iffx=a.

1 Nevertheless, the author is willing to collaborate in any research project that
aims at understanding the psychology of modern formalism.



1.2 Categories Versus Sets

The use of equality between elements makes clear the need to look in-
side the set.

The third definition characterises singletons as sets into which there is
one, and only one, total function from any other set. Indeed, the function
being total, a singleton offers no choice for the mapping to be established:
everything is mapped to this single element. According to this definition,
two singletons cannot be distinguished because they relate in exactly the
same way with the other sets. This is quite intuitive because, not being
able to use set membership, we cannot look inside the singletons and no-
tice that they have different elements. Hence this social life is a better ab-
straction from set membership than the other two.

The "social" way of characterising objects is, in fact, similar to the way,
in object-oriented programming, the view of objects that matters for
building systems is that of the methods that objects make available to the
other objects to interact with. However, the view that matters for their im-
plementation may be different, reflecting the fact that different uses reflect
different structural views of the same concept (which in category theory
means different categories).

Other examples could be given from branches of engineering or our
day-to-day praxis. For instance, another example is the way we under-
stand devices as mundane as hi-fi stereo systems. When assembling a hi-fi
system from separate components it is important to know how each com-
ponent can be connected to the others; the way they are implemented in
terms of microcircuits probably explains the restrictions on the connec-
tions that can be established, but it is something that a user would like to
see abstracted away. The characterisation of human behaviour can also be
used as an example. There is probably a neuro-physiological justification
for what we call a "shy" or "expansive" person, but the meaning that we
normally attach to such features of human nature is derived from the way
people interact with us. The final word, however, comes from Saint
Exupery: "The meaning of things lies not in the things themselves, but in
our attitude towards them".

In brief, like all mathematics, category theory is about providing us with
abstraction mechanisms. In our opinion, the fact that these mechanisms
relate to interaction make category theory particularly suited for certain
aspects of computing science, and software engineering in particular.

1.3 Overview of Typical Application Areas

In this section, we summarise some of the main applications areas of cate-
gorical techniques we know, with references to the literature, bearing in
mind that our focus is software engineering and not computer science as a



1 Introduction

whole. We strongly suggest [26, 57] for excellent introductions to (and
overviews of) the field.

1.3.1 General Systems Theory

Goguen started exploring category theory as a mathematical toolbox in the
early 1970s, applying it to general systems theory [52, 53, 64]. The fa-
mous motto [57]

"given a category of widgets, the operation of putting a system of widgets
together to form a super-widget corresponds to taking a colimit of the dia-
gram of widgets that shows how to interconnect them"

was first applied to mathematical models of system behaviour. We also
find in this area the origins of latter applications to object-oriented model-
ling [58]. In fact, one of Goguen's early works is even called, very appro-
priately, "objects" [54].

But this is just one example of the many applications of category theory
to the area of general systems. We would like to encourage the non-
specialist to get acquainted with the field through one of the recent books
that have appeared in the wider market of science, like [71, 94].

1.3.2 Algebraic Development Techniques

This is one of the most typical areas of the application of category theory
to computer science. One of the earlier and most influential movements
started in the second half of the 1970s with the work of a group of re-
searchers at IBM (Joseph Goguen, Jim Thatcher, Eric Wagner and Jesse
Wright), very aptly named ADJ (for adjunction), around the initial seman-
tics of abstract data type specification [65]. The pioneering work of Rod
Burstall and Joseph Goguen around the language CLEAR [17, 18] showed
how simple universal constructions (e.g. colimits) could be used to give
semantics to operations for structuring specifications (e.g. computing the
sum of two specifications, parameterising a specification, etc.). See also
[95, 96] for some more advanced examples and [101] for an example of
tool support. The area produced textbooks such as [28, 29, 76, 92] as well
as surveys [8, 26] that provide a good showcase for "categories at work",
namely in what concerns elegance and economy of means.

One of the finest hours of this research programme was the development
of the theory of institutions, a categorical formalisation of the notion of
logic developed by Goguen and Burstall in the early 1980s [62]. The aim
of this effort was to provide a mathematical framework in which the speci-
fication building operators defined for the language CLEAR could be
made independent of the underlying logic and thus available for other
specification formalisms. The theory of institutions is, in our opinion, one
of the best examples of the usefulness of category theory as a unifier of
concepts and techniques developed by different research teams in response



1.3 Overview of Typical Application Areas

to different or similar needs. As a science, computing is still very young
and, hence, fragmented in that it is often difficult to find the "universal
laws" that we recognise as the objects of study in other sciences. Through
the theory of institutions, category theory was shown to be a powerful tool
for abstracting from individual and uncoordinated efforts some universal
laws (or "dogmas" as they are called in [57]) that apply to specifications in
general [95]. This categorical framework was subsequently extended and
put to use, for example, in applying algebraic specification techniques to
other computational paradigms (e.g. object-oriented) and defining ways for
specifications to be mapped from one formalism to another.

1.3.3 Concurrent and Object-Oriented Systems

Concurrency theory is another area to which categorical techniques have
been applied in the "engineering" view that interests us in this book. This
domain of application is dominated by the work of Glynn Winskel [106,
107, 108], who showed how models for concurrent system behaviour like
transition systems, synchronisation trees and event structures can be for-
malised in category theory. The idea is that each process model is en-
dowed with a notion of morphism that defines a category in which typical
operations of process calculi are given as universal constructions. This
work was continued in the 1990s in collaboration with Mogens Nielsen
and Vladimiro Sassone [97], exploring the use of adjunctions as a means
of translating between different models. The chapter [109] provides an
excellent overview of this exciting application area.

This stream of work (including [15]) was used for giving semantics to
object-oriented systems by Felix Costa, Hans-Dieter Ehrich, and Amflcar
and Cristina Sernadas [20, 21, 25], also with contributions from Goguen
[24]. In a nutshell, these authors showed how universal constructions can
be used to express object-oriented features like encapsulation, inheritance
and composition in concurrency models endowed with richer notions of
state. The work of Goguen on sheaf-theoretic models [58] also establishes
an interesting connection to the earlier work on general systems theory.

Applications of category theory to the (logical) specification of concur-
rent and object-oriented systems can also be found. These include our
work in the late 1980s and early 1990s [38, 39, 40, 43]. Basically, we
showed how the techniques developed for the modularisation of equational
and first-order logic specifications of abstract data types could be applied
to concurrent and object-oriented systems by using modal and temporal
logics developed for the specification of reactive systems [13].

Briefly, the idea was to fit the specification of such systems in the "in-
stitutional" picture as set up by Goguen and Burstall [32, 33]. We later
showed that our work is directly related to the General Systems tradition
[31], in the sense that the module structure defined by our categorical for-
malisation is directly compositional over the run-time structure of the sys-



1 Introduction

tern. This led to applications of the categorical techniques to parallel pro-
gram design [44], in which the notion of morphism captures what in the
literature is known as superposition or superimposition [19, 48, 72].

There is also a substantial amount of work in the application to concur-
rent and object-oriented systems of the algebraic approach to abstract data
type specification [7], most notably by Egidio Astesiano and his col-
leagues in Genova. Basically, these approaches present different alterna-
tive ways of bringing states and transitions to the universe of discourse of
abstract data types.

1.3.4 Software Architectures

Applications of categorical techniques to the semantics of interface de-
scription and module interconnection languages were developed by
Goguen in the early 1980s [55] and more recently recast in the context of
the emerging interest in software architecture [59]. These applications are
in the tradition of the algebraic approach to abstract data types, more spe-
cifically in what has become known as "parameterised programming" [56],
in the sense that they capture functional dependencies between the mod-
ules that need to be linked to constitute a given program.

The view of architectures that is captured in this way is somewhat dif-
ferent from the one followed in the work of Dewayne Perry, David Garlan
and other researchers who have launched software architecture as we know
it today [14, 50, 99]. This more recent trend focuses instead on the organi-
sation of the behaviour of systems as compositions of components ruled
by protocols for communication and synchronisation. As explained in [2],
this kind of organisation is founded on interaction in the behavioural
sense, which explains why formalisms like the chemical abstract machine
(or CHAM) [16] are preferred to the functional flavour of equational logic
for the specification of architectural components.

This why, in the early 1990s, we proposed a categorical toolset for ar-
chitectural description based on our work on the formalisation of parallel
program design techniques [34, 42]. The idea is that, contrarily to most
other formalisations of architectural concepts that can be found in the lit-
erature, category theory is not another semantic domain in which to for-
malise the description of components and connectors. Instead, through its
universal constructions, it provides the very semantics of interconnection,
configuration, instantiation and composition, i.e. that which is related to
the gross modularisation of complex systems.

1.3.5 Service-Oriented Software Development

However, there is more to category theory than the ability to support such
interaction-based views of system behaviour. By relying on "local nam-
ing" (as shown by the impossibility of distinguishing between singleton



1.3 Overview of Typical Application Areas

sets), category theory requires all such interactions to be modelled explic-
itly and outside the participating objects. This is one of the aspects that
distinguishes service from object-oriented system development.

Clientship, i.e. the ability to establish client/supplier relations between
objects, leads to systems of components that are too tightly coupled and
rigid to support the levels of agility that are required to operate in envi-
ronments that are "business time critical", namely those that make use of
Web-services, Business-to-Business (B2B), Peer-to-Peer (P2P), or other-
wise operate in what is known as "internet-time". Because interactions in
object-oriented approaches are based on identities, in the sense that
through clientship objects interact by invoking specific methods of specific
objects (instances) to get something specific done, the resulting systems
are too rigid to support such levels of agility. Any change in the collabo-
rations that an object maintains with other objects needs to be performed at
the level of the code that implements that object and, possibly, on the level
of the objects with which the new collaborations are established. On the
contrary, interactions in a service-oriented approach should be based only
on an abstract description of what is required, thus decoupling "what one
wants to be done" from "who does it and how". This is precisely the dis-
cipline of interconnection that category theory enforces.

Our last claim, in support of the last paragraph of Sect. 1.1, is that cate-
gory theory is definitely the mathematics of the Internet age (and beyond)!

1.4 What Can Be Found in This Book

This book emerged from tutorials and courses given in the past few years,
both in academia and in more industry-oriented fora like OOPSLA, Ob-
jectWorld, TOOLS, ECOOP and FME. I am particularly grateful to the
University of Lisbon and the Technical University of Lisbon for the op-
portunities that they gave me to lecture on much of the material covered in
the first two parts, at both the undergraduate and postgraduate levels.
These parts of the book were also covered in lectures given at the Univer-
sity of Coimbra, the Institute for Languages and Administration in Lisbon
(ISLA) and the Federal University of Rio Grande do Sul (Brazil). Part III
was used in a 20-hour course on Community and software architecture
that I gave as part of a postgraduate programme of the University of Pisa,
as well as at the Summer School on Generic Programming (Oxford 2002).
All this experience showed that there was an audience for this particular
way of teaching category theory.

The book is structured in three parts, leaving room for different read-
ing/teaching paths to be followed. With respect to most other books in the
market, this one uses examples of a different nature, focusing on and giv-



10 1 Introduction

ing more emphasis to aspects that are less common in other fields of com-
puting. It also adopts a different pace altogether.

• Part I, i.e. Chaps. 2-5, covers some of the basics of category theory, in-
cluding the "bare essentials" that are addressed in any book, from
graphs to universal constructions and functors. However, a different
emphasis and tone are used that are meant to be more appealing and ac-
cessible to software engineers. It is hoped that mathematically mature
readers may appreciate a different way of exposing and illustrating these
familiar concepts and constructions.

• The material included in Part II, Chaps. 6 and 7, is of a more advanced
nature, not only because it is more challenging from a mathematical
point of view but also because it makes appeal to an additional level of
maturity in so far as computing science is concerned, namely the use of
multiple formalisms as supporting complementary viewpoints. There,
the reader will find material that only a few other books cover in compa-
rable depth, with a strong emphasis on functor-based constructions like
fibrations, and ending with a covering of adjunctions that deviates
somewhat from the standard coverage. Again, examples are drawn
from areas that have normally been confined to papers such as institu-
tions and models of concurrency. The sections in this part should be ac-
cessible to anyone with basic knowledge of category theory, but a quick
travel through Part I will help the reader become familiar with the nota-
tion and the examples that are used in Part II.

• Part III offers the chance of seeing category theory at work in a more
ambitious project - giving semantics to Community, a prototype lan-
guage for architectural modelling. This part can be ignored by readers
who are not particularly interested in the applications to software engi-
neering. On the other hand, it can be followed, to a large extent, with-
out the material exposed in Part II. This means that a novice to category
theory but who is interested in software engineering, or anyone whose
goal is to understand Community or set up a course that aims at teach-
ing (any subset of) the material in Part III, can safely skip Part II. It
may be necessary to go back to Part II in order to understand in full the
mathematical structures that relate to software architecture, but this may
be done once the reader feels more at ease with the mathematics.

Parts I and II use examples taken directly from Meyer's book on Eiffel
[86] to illustrate definitions and constructions. It is hoped that readers who
are not familiar with the particular notation of Eiffel, but are used to ob-
ject-oriented modelling, will be able to understand the examples without
much effort. The choice for Eiffel instead of a more modern language has
to do with two facts. On the one hand, it was modern when the book
started to be written.... On the other hand, it is one of the object-oriented



1.4 What Can Be Found in This Book 11

languages that has solid foundations, which allows it to be used to illus-
trate many of the mathematical constructions that we cover in the book.

The use of Eiffel allows us to illustrate applications of category theory
to the more static aspects of system modelling, namely to what is related
with classification (inheritance). Other examples are brought to bear from
specification theory that involve logics and algebraic models for system
behaviour in order to show how the more dynamic and evolutionary as-
pects can also be handled. These aspects come together in Part III.

This means that different reading/teaching paths can be established that
are based on the examples: one can follow the "Eiffel path" for a lighter
approach, perhaps more suitable for "practitioners"; or one can follow the
"specification theory path" that will enable the "scientists" to visit more
challenging places and reach the end of Part II. But who are the true soft-
ware engineers if not the people who can combine both? Therefore, the
best approach is to read the book from the beginning to the very end!



Parti

Basics



2 Introducing Categories

2.1 Graphs

A distinctive attribute of category theory as a mathematical formalism is
that it is essentially graphical. This means that most concepts and proper-
ties can be defined, proved and/or reasoned about using diagrams of a
formal nature. This diagrammatical nature of category theory is one aspect
that makes it so applicable to software engineering. Therefore, it is not
surprising that the first definition in this book is that of graphs.

2.1.1 Definition - Graphs

A graph is a tuple <G0,Ghsrc,trg> where:
• Go is a collection

1 (of nodes).
• G, is a collection (of arrows).
• src maps each arrow to a node (the source of the node).
• trg maps each arrow to a node (the target of the node). •

We usually write f:x-*y to indicate that src(f)=x and trg(f)=y. Between
two nodes there may exist no arrows, just one in either direction, or several
arrows, possibly in both directions.

The attentive reader will have noticed that our very first definition still
uses set theory, even if only informally. This may appear confusing, espe-
cially after our lengthy discussion of the merits of category theory with re-
spect to set theory. However, we need a meta-language for talking about
graphs (and categories, and), which cannot, of course, be the object lan-
guage itself (i.e. that of category theory). Hence, we use the informal lan-
guage that is typical of mathematics, which, as also acknowledged in the
introduction, is full of set-theoretic concepts.

2.1.2 Examples - Sets and Functions

1. The most "popular" graph in this book (and in any other book we know)
is the graph whose nodes are the sets and whose arrows are the total
functions.

1 Questions of "size" arise here because we shall soon be talking about the graph
of graphs and constructions of a similar nature. This is why we use the term
"collection" instead of "set". See, for instance, [80] for such questions.



16 2 Introducing Categories

2. To illustrate the fact that different graphs may share the same nodes, we
introduce what is, perhaps, the second-most popular graph in the book -
the graph whose nodes are, again, the sets, but whose arrows are the
partial functions, i.e. functions that may be undefined on given elements
of the source set. •

2.1.3 Example - Class Inheritance Hierarchies

A typical example of the use of graphs in computing is class inheritance
hierarchies. These are graphs whose nodes are object classes and for
which the existence of an arrow between two nodes (classes) means that
the source class inherits from the target class. The following inheritance
diagram is taken from [86]. It shows that class homejbusiness inherits
from both business and residence, each of which inherits from house.

In class inheritance hierarchies, there exists at most one arrow between
two nodes: either a class inherits from another or it does not. Many graphs
that we encounter in software engineering are like this one. They reflect
partial orderings and similar associations. However, even in the case of
inheritance, arrows can carry more information. For instance, when one
class inherits from another one, some renaming of the features of the
original class may be required. Such renamings may be associated with
the arrows of a class inheritance diagram.

address
insured_value

rename insured_value
as business_value

rename insured_value
as residence_value



2.1 Graphs 17

The figure above is taken, once more, from [86]. It depicts the renam-
ings involved in the inheritance hierarchy previously used as an example.
Each such enriched class inheritance diagram defines a subgraph of the
graph of sets and (total) functions - classes are represented through their
sets of features and the renamings through the functions that they induce.
Notice that the arrows of the class inheritance hierarchy and the functions
that operate the renamings point in opposite directions.

{address,insured_value}

{address,insured_value,A} {address,insured_value,B}

{address,residence_value,business_value,A,B,C} •

2.1.4 Example - Transition Systems

Another very common example of graphs in computing is transition sys-
tems. Every transition system constitutes a graph whose nodes are the
states and whose arrows are the transitions. Below we show the transition
system that models the behaviour of a vending machine that accept coins
and, for each accepted coin, delivers a cake or a cigar, after which it is
ready to accept another coin.

As hinted in the introduction, there are many (and deep) relationships
between logic and category theory. The next two examples convey some
of the simplest relationships. See [22, 68, 70, 74] for advanced textbooks
on this subject.

2.1.5 Example - Logical Entailment

One of the possible views that one can have of a logic is through the no-
tion of a sentence being a consequence of, or derivable from, another sen-
tence. This notion of consequence can be represented by a graph whose
nodes are sentences and whose arrows correspond to logical entailment.



18 2 Introducing Categories

The following is an example of three nodes and two arrows of the graph
that captures logic entailment in propositional logic:

A A B | AvB | C A B ^

We can add detail to entailment and distinguish between different pos-
sible ways in which a sentence can be a consequence of another, i.e. by
taking arrows to be proofs.

2.1.6 Example - Proof Systems

Every proof system constitutes a graph whose nodes are sentences and
whose arrows are proofs. The following is an example of two nodes and
two arrows of the graph that corresponds to natural deduction in proposi-
tional logic, i.e. the nodes are propositions and the arrows are proofs in
natural deduction:

AAB

AAB

AvB I AABAvB
AvB

One should be aware of the difference between a graph and the graphi-
cal representation that is chosen for its nodes and arrows. The latter is
normally chosen according to the traditional notation of the domain of ap-
plication. This is why we deliberately used turnstiles for arrows above. In
the case of the proof system, we could even have omitted the turnstile be-
cause the proof itself is the arrow. However, from a graphical point of
view, using both the proof and the turnstile seems to make the representa-
tion more clear.

Graphs have a "social life" of their own that is useful to know about.
For instance, the graphs introduced in Pars. 2.1.5 and 2.1.6 are intuitively
related through an operation that adds detail (or forgets, depending on the
point of view), namely proofs. Such relationships between graphs are
called graph homomorphisms.

2.1.7 Definition - Graph Homomorphisms

A homomorphism of graphs tp:G—>H is a pair of maps cpo:Go->Ho and
cpj:G1-^H1 such that for each arrow f:x->y of G we have (pi(f):(po(x)—>cpo(y)
in H. That is, nodes are mapped to nodes and arrows to arrows but pre-
serving sources and targets. •

The figure below illustrates a situation in which the node component of
a homomorphism (represented by the dashed arrows) is neither injective
(two nodes are collapsed) nor surjective (one of the nodes of the lower
graph has no counterpart above). When the node component is not injec-



2.1 Graphs 19

tive, arrows may get mapped to endo-arrows, i.e. arrows with the same
source and target, as illustrated. In the example, the arrow component (left
implicit) is injective but not surjective.

• * • •

2.1.8 Example - Abstracting Entailment from Proofs

There is a "canonical" homomorphism between proof systems and conse-
quence systems that consists of the identity on nodes and collapses any
non-empty set of proof arrows between two nodes into just one conse-
quence arrow. That is, this homomorphism "forgets" the details of the
proofs, retaining just the fact that one exists to justify the consequence re-
lation. For instance, when applied to the example in Par. 2.1.6 it would
deliver just one arrow from AAB to A vB as in Par. 2.1.5. •

Notice that the relationship between the inheritance graph used in Par.
2.1.3 and the corresponding graph of feature sets and renamings cannot be
captured by a homomorphism because the source and target of arrows is
reversed. Absence of a homomorphism in these circumstances seems to be
accidental because the direction of the arrows is somewhat arbitrary; we
could well have chosen a graph with the same collections of nodes but
with the arrows reversed.

2.1.9 Definition - Duality

The dual of a graph G=<G0,G1,src,trg> is G
op=<G0,G1,trg,src>, i.e. the

graph obtained by reversing the direction of the arrows. A homomorphism
from a graph G to the dual H°p of a graph H (or from G°r to H) is said to be
contravariant between G and H. •

An essential step towards defining the notion of category concerns paths
in graphs, i.e. what supports the move from direct to more "global" social
relationships.



20 2 Introducing Categories

2.1.10 Definition - Paths in a Graph

Let G be a graph and x, y nodes of G. A path from x to y of length k>0 is a
sequence//.../t of arrows of G (not necessarily distinct) such that:
• src(f,)=x.
• trg(fi)=src(fi+1) for l<i<k-l.
• trg(fk)=y.

For every x, the path of length 0 at x (the empty path at x) from x t o i is,
by convention, the empty sequence. We denote by Gk the collection of
paths of G of length k. Hence:
• Go corresponds to the collection of nodes.
• Gl corresponds to the collection of arrows.
• G2 corresponds to the collection of pairs of composable arrows. •

2.2 Categories

Categories provide an abstraction over graphs by making paths the basic
working elements - what are called morphisms; paths provide richer in-
formation about "social life" than just one-to-one relationships. For that
purpose, categories add to graphs an identity map that "converts" nodes to
morphisms (null paths), and a composition law on morphisms that inter-
nalises path construction. Morphism composition is required to be asso-
ciative as for path concatenation. This means that morphisms have no in-
ternal structure that can be derived from the order of composition.

2.2.1 Definition - Categories

A category C is a triple <G,;,id> where:
• G is a graph, often denoted by graph(C).
• ; is a map from G2 into Gj (called the composition law); for every fg in

G2, we denote by fig the arrow that results from the composition.
• id is a map from Go into G; (called the identity map); for every node x,

we denote by idx its identity arrow.
and, for every/in Ghfg in G2, and fgh in G3:

• src(f;g)=src(f) and trg(f;g)=trg(g).
• src(idx)=trg(idx)=x.
• (fig);h=f;(g;h).
• Iffix^y, idx;f=f;idy=f. •

The nodes (rep. arrows) of G are also called the objects (rep. mor-
phisms) of C. The collection of objects of C is denoted by \C\. We often
use the notation c:C to indicate that c is an object of C or a C-object.
Given C-objects x and y, homc(x,y) denotes the collection of morphisms
from x to y. Such sets are also called hom-sets.



2.2 Categories 21

The properties required are straightforward: the first two establish the
types of the composite and identity arrows, respectively; the other two es-
tablish associativity of composition and the identity laws.

2.2.2 Example - "The" Category of Sets

In the category SET objects are sets, morphisms are (total) functions be-
tween them, composition is functional composition - i.e. (f;g)(x)=g(f(x)) -
and the identity map assigns to every set the identity function on that set.
Because function composition is associative and the identity map is both a
left and right identity for function composition, all the conditions are met.

In mathematics, function composition is usually denoted by the symbol
and the order of the arguments reversed, i.e. given f:x—>y and g:y—>z, the

composed function fig is also denoted by g f. This is the "application or-
der": (g f)(a)=g(f(a)) for every aEx. Most textbooks on category theory
adopt this alternative notation for the composition law. Ultimately, the
choice between one notation and the other is a matter of taste or conven-
ience.1 Our choice is motivated by the fact that it is closer to the diagram-
matic notation (arrow sequencing) and hence supports the diagrammatic
forms of reasoning that normally appeal to software engineers. Besides, as
evidenced by the definition, the application order derives too much from
set membership, i.e. reasoning with it is normally too close to the tradi-
tional set-theoretic approach from which we are trying to get away. •

2.2.3 Example - Graphs

The category GRAPH has graphs as objects and its morphisms are the
graph homomorphisms. The composition law is defined as follows: for
every pair cp and ip of graph homomorphisms such that src(ip)=trg(cp),
(q>;ip)0=((p0;xp0) and (q);ip)1=((p1;ip1). The identity map is defined as fol-
lows: for every graph G, (idG)0=idG and (idG)j=idc .

Proof
By taking graphs as nodes and graph homomorphisms as arrows, we do obtain a
graph. The identity and associativity properties are inherited for each component
(node and arrow) from the corresponding properties of functions between sets. •

2.2.4 Example - Logical Entailment

The category L0G1 has as objects sentences, and morphisms correspond
to the existence of a logical entailment. One can think of morphisms as
"certificates" of the fact that the source sentence entails the target.

In fact, this was one of the major decisions that had to be made before starting
writing! Many people are put off reading a book because they are used to the
"other" notation. Hence, ultimately, the decision was made taking into account
the intended audience (and for "pedagogical" reasons as explained).



22 2 Introducing Categories

Proof
Becase there is at most one morphism between two objects, the identity and com-
position equations are trivially satisfied. We just have to prove the existence of
endomorphisms (reflexivity) and a composition law (transitivity). But (A r—A) is
a tautology, and, from (A \— B) and (B r—C), we conclude (A r—C) (cut rule). •

This property show that every preorder defines a category.

2.2.5 Proposition - Preorders

Every preorder <S,<>, i.e. every set equipped with a reflexive and transi-
tive relation, defines a category S< as follows:

• ISJ=S and there is a morphism between x and y in S< iff x<y.
• Composition is defined by applying the transitivity law.
Identity morphisms are defined by applying the reflexivity laws. •

2.2.6 Example - Inheritance Hierarchies

In Eiffel, the relationship "ancestor" is defined as the "reflexive and tran-
sitive closure" of the inheritance hierarchy: class A is an ancestor of class
B iff A is B itself or A is an ancestor of a parent of B (i.e. of a class from
which B inherits) [86]. Given an inheritance graph G between classes, e.g.
as in Par. 2.1.3, the category ancestor(G) is generated from the graph by
completing it with the arrows that result from reflexivity (identities) and
transitivity (compositions).

The construction of ancestor(G) from G can be generalised as follows.

2.2.7 Proposition - Category Generated from a Graph

Every graph G generates a category cat(G)1 whose objects are the nodes
and whose morphisms are the paths of the graph,
paths. Composition is concatenation of paths.

Identities are empty
•

1 The observant reader may have noted that we have already departed from our
convention of using only uppercase characters for the names of categories! This
is not a random aberration but reflects the fact that generating a category from a



2.2 Categories 23

2.2.8 Example - Runs

Every state transition system generates the category of its runs defined to
be the paths of the underlying graph. •

2.2.9 Example - Proofs

The category PROOF has sentences as objects, and morphisms are proofs,
i.e. a morphism/:A--»B is a specific proof of B from A. The identity mor-
phisms are the trivial proofs of sentences from themselves (empty proofs).
Proof composition corresponds to sequence concatenation - the cut rule. •

Category theory supports and encourages forms of diagrammatic rea-
soning, also called "diagram chasing", a practice that is consistent with the
modern culture in computing. Contrary to what often happens in software
engineering, the notion of diagram is formal and the reasoning that can be
done with diagrams is mathematical.

2.2.10 Definition - Diagrams

Let C be a category and / a graph. A diagram in C with shape 7 is a graph
homomorphism d.I^graph(C). Given a node x (resp. arrow u) of /, we
normally denote its image 50(x) (resp. d^u)) by dx, (resp. <5J. •

The fact that a diagram is being defined as a graph homomorphism and
not a graph may surprise some software engineers. This is because there is
sometimes confusion between the "form" and the "contents" of a diagram.
The homomorphism defines a labelling of the graph I, which establishes
the shape or form of the diagram. That is, a diagram in a category can be
seen as a graph whose nodes are labelled with objects, and the arrows are
labelled with morphisms that respect sources and targets. In particular, the
labelling does not need to be injective, meaning that different nodes may
be labelled with the same object.

An example can be given in terms of configuration diagrams such as
those that are used in Chap. 8. In such diagrams, the graph identifies sys-
tem components and interconnections between them, and the homomor-
phism their types. For instance, a configuration of a queue serving two in-
dependent printers can be given by the diagram below.

The fact that we are using two printers of the same type, and not only
one, results from having two nodes labelled PRINTER. The same applies
to the cables: each printer is connected to the extension cord by its own
cable, but they are of the same type. Therefore, we have two nodes la-
belled with i-cable; these cables connect to the same "printer port", so the
two arrows to PRINTER are labelled with the same morphism get job.
However, the cables connect to different ports of EXTENSION CORD,
hence the corresponding morphisms are different.

graph is a map from one category to another. Such maps, called functors, are
introduced in Chap. 5 and are denoted using bold, lowercase characters.



24 2 Introducing Categories

QUEUE

dequeue

o-cable

sync

EXTENSION CORD

branch, branch.

i-cable i-cable

get Job getjob

PRINTER PRINTER

Whereas objects and morphisms provide the main elements of the "vo-
cabulary" that one uses in category theory, diagrams provide the basic
"sentences" that one can build to express concepts. In turn, most proper-
ties that one can assert in this "language" are expressed in terms of com-
mutative diagrams.

2.2.11 Definition - Commutative Diagrams

Let C be a category and / a graph. A diagram d.I^graph(C) is said to
commute iff, for every pair x,y of nodes and every pair of paths w=u,...um,
w'=Vj...vn from x to y in graph /,

holds in C. •
The property that a diagram commutes establishes a set of equalities

between arrows. Hence, diagrams and commutativity provide us with the
ability of doing equational reasoning in a visual form, an advantage that
has not been fully exploited yet in software engineering. See [49] for a
more developed use of these possibilities for mathematical reasoning. To
indicate that a diagram commutes, we decorate it with the symbol ®.

We close this section with an example that is very typical of the appli-
cations of category theory to computer science: automata. See [27] for an
extended account. This example provides a good illustration of how mor-
phisms "preserve structure" and how diagram-chasing facilitates reasoning
about categories.



2.2 Categories 25

2.2.12 Example - Automata

A (deterministic) automaton consists of an input set X, a state set S, an
output set Y, a transition function/: XxS->S, an initial state s0ES and an
output function g: S—>Y. A notion of morphism of automata must be able
to capture this structure by indicating how a given automaton can be
simulated by another. It must translate the input, state and output sets
from one automaton to the other in such a way that the transition functions,
the initial states and the output functions of the two automata "agree".

More concretely, we should require of a morphism A—>A' that:

1. The initial state of A be mapped to the initial state of A'.
2. If we perform a transition in A and map the resulting state into A', we

get the state that is obtained by first translating the input and initial state
into A' and then applying the transition function of A'.

3. The translation into A' of the output of a state of A consists of the output
in A1 of the translation into A' of the original state of A.
Hence, a morphism from A=<X,S,Y,so,f,g> to A'=<X',S\Y\s'0,f,g'> is

defined to consist of three functions <h:X—>X',i:S—*S',j:Y-*Y> such that

1. i(so)=s'o.
2.f;i=hxi;f.
3. g;j=i;g'.

Notice that the equations in points 2 and 3 can be expressed as requests
for certain diagrams to commute. For the equation in point 2,

X x S

X ' x S

For the equation in point 3,

What about the equation in point 1 ? Can it be expressed as a commuta-
tive diagram as well? The answer seems to be less obvious or immediate
because the equation is very "set-theoretical": it is an equality between
elements (initial states), not functions. However, we have already men-



26 2 Introducing Categories

tioned in Chap. 1 that an element s0ES can be identified with a morphism
so:{*}->S from an arbitrary singleton set - an observation that we shall
formalise in Sect. 4.1, but which can remain at an intuitive level for the
purpose of this discussion. Given this, the first equation can be rewritten
as so;i=s'oand expressed via:

We should make clear that the choice between using diagrams or text
should be made according to the intended readership or usage. The point
that we want to make here is that it is possible to use diagrams to express
and reason about properties in a formal way, and that there is some unified
or universal side to this practice. However, we shall abstain from giving
recommendations as to when and for whom diagrammatic notations should
be used.

The composition law of automata is defined to be that of functions be-
tween sets, i.e. composition applies internally to each of the three compo-
nents of the morphisms. Likewise, the identity for an automaton A is de-
fined to be the triple that consists of the three identity functions over the
sets of input, states and outputs.

The proof that a category -AUTOM - is indeed obtained in this way is
very revealing of a procedure that is systematised in Sect. 3.2. Because the
associativity of the composition law and the properties of the identity are
automatically inherited from the corresponding properties of functions, all
that needs to be proved is that (1) the composition of two morphisms is,
indeed, a morphism (i.e. it satisfies the three equations above) and (2) the
identity is, indeed, a morphism (i.e. it satisfies the same three equations).
We prove just the case of the composition

of morphisms
<X,S,Y,so,f,g>^<X\S',Y\s'o,f,g'>

and
<X\S\Y\s'0,f,g'>^<X",S",Y",s"0,r,g">

l.(i;V)(so)=V(i(so))=V(s'o)=s
n

o.

=(hxi;f);i'
=hxi;(f;i')
=hxi;(h'xi';f)



2.2 Categories 27

=(hxi;h'xi');f
=(h;hyx(i;V);f.

3.g;(j;f)=(g;j);f=(i;g');f=i;(g\f)=i;(r;g")=(i;f);g".
This proof is best understood in terms of the following commutative

diagram(s):
Y • Y1 • Y "

* w
X'xS' s0

X {•}

2.3 Distinguished Kinds of Morphisms

There are several classes of morphisms that have special properties worth
knowing about because they allow us to recognise situations in which
standard results or constructions apply.

2.3.1 Definition/Proposition - Isomorphisms

Let C be a category and x,y objects of C. A morphism/.\x:-*y of C is an
isomorphism iff there is a morphism g:y—>x of C such that: f;g=idx and
g;f=idr In these conditions, x and y are said to be isomorphic. •

2.3.2 Example

1. In SET, a morphism is an isomorphism iff it is bijective.
2. In LOGI, sentences are isomorphic iff they are logically equivalent. •

2.3.3 Exercise

What about isomorphic objects in PROOF! •

2.3.4 Definition/Proposition - Inverses

Given an isomorphism/;*—>v there is a unique morphism g:y-*x such that:
f;g-idx and g;f=idy. This morphism is called the inverse off.



28 2 Introducing Categories

Proof

The morphism g mentioned in the definition above is unique: given h:y—*x in the
same circumstances, we have
h

= h;idx identity property,
= h;(f;g) because f;g=idx,
= (h;f);g associativity,
= idy;g because h;f=idy,
- g identity property. •

Any two objects x and y related by an isomorphism f:x—>y have a very
important property: the class of morphisms from x (resp. into x) is in one-
to-one correspondence with the class of morphisms from y (resp. into y).
This one-to-one correspondence is established by composing any mor-
phism fa:x—*a (resp. ga:a-*x) with the inverse of/(resp. /itself). Because
morphisms characterise the interactions that objects can hold with other
objects (their "social lives"), what this property says is that isomorphic
objects interact in essentially the same way. That is, isomorphic objects
cannot be distinguished by interacting with them. In any context where an
object is used, it can be replaced by an isomorphic one by using the iso-
morphism and its inverse to re-establish the interconnections: any incom-
ing arrow

ga

a • x
is replaced by

ga f
• • • • x •

• y

and any outgoing arrow
f

a -4 x
is replaced by

f. s
x

Hence, it is usual to treat any two isomorphic objects as being "essen-
tially" the same. Again, we should point out that this property holds in so
far as the structure ("social life") that is captured by the category is con-
cerned. For a different category over the same objects, revealing other
structural aspects, the isomorphism may not carry through. For instance, in
object-oriented software development, two objects may be isomorphic in
so far as having the same interfaces and exhibiting the same behaviour at
their interfaces, but may have completely different implementations.



2.3 Distinguished Kinds of Morphisms 29

There are other classes of morphisms that are important to mention,
namely those that generalise well-known properties in set theory, like in-
jective and surjective functions. The way this generalisation is made re-
veals a lot of the way category theory operates and how it relates to and
differs from set theory. For instance, the typical characterisation of an in-
jective function f:x-*y in set theory is:

For every a,bEx, f(a)-f(b) implies a=b.

As expected, this characterisation uses set membership. As motivated
already, in category theory we have to replace it by interactions (mor-
phisms). We have already mentioned that elements aEx of sets can be
identified with morphisms a:{*}->x from singleton sets. Hence, the set-
theoretic definition amounts to saying:

For any (total) functions a,b:{»}—>x, a;f=b;f implies a=b.

{•} » x »> y
b

When considered in this way, an injective function can be characterised
as not interfering with independent observations that are made on the
source. The categorical characterisation consists precisely in generalising
this definition to arbitrary morphisms instead of just elements: for every
pair of morphisms g,h:z->x, g;f=h;f implies g=h.

What is even more interesting is the fact that the generalisation carries
through, in a dual way that we will formalise in the next chapter, to the
characterisation of surjective functions. Surjectivity is all about interfer-
ence with the social life of the target of the arrow. If we take a non-
surjective function f:A—>B and b^f(A), then we can have two functions
g,h:B—>C that coincide in f(A), i.e. such that f;g=f;h, and yet are different
because they disagree on the way they map b.



30 2 Introducing Categories

2.3.5 Definition - Monos and Epis

Consider an arbitrary category C and morphism/:x—*y in C.

1. / is a monomorphism, or a mono, or monic, iff, for every pair of mor-
phisms g,h:z-*x, g,/=/j,/implies g=h.

2./ is an epimorphism, or an epi, or epic, iff, for every pair of morphisms
g,h:y->z,f;g=f;h implies g=h. •

Monos and epis satisfy many of the properties that we know from injec-
tive and surjective functions. They are left here as exercises.

2.3.6 Exercises

Consider an arbitrary category C.

1. Prove that isomorphisms are both epic and monic.
2. Prove that the composition of monos (resp. epis) is also a mono (resp.

epi).
3. Prove that iif;g is monic (resp. epic), then so is/(resp. g). •

A final word of caution though. The analogy with set theory (well ex-
ploited in [4]) cannot be carried too far: the converse of the property re-
ferred to in the first exercise does not hold for arbitrary categories! That
is, not all morphisms that are both epic and monic are isomorphisms. This
is because, to be an isomorphism, an arrow needs to have a left and a right
inverse, which, contrary to what happens in set theory, is not guaranteed
simply by being monic and epic.

2.3.7 Definition - Split Monos and Epis

Consider an arbitrary category C and morphism/.jc^y in C.

l . / i s a split monomorphism, or a split mono, or split monic, iff it admits
a right inverse, i.e. iff there is gry->x such HaaXf;g=idx.

2./ is a split epimorphism, or a split epi, or split epic, iff it admits a left in-
verse, i.e. iff there is gry-*x such that g;f=idy. •

2.3.8 Exercises

Consider an arbitrary category C.
1. Prove that every split mono (resp. split epi) is monic (resp. epic).
2. Prove that every morphism that is a split mono and a split epi is an iso-

morphism. In fact, prove that only one, either the mono or the epi,
needs to be "split". •



3 Building Categories

There are many ways in which new categories can be built from existing
ones. One of the advantages of building new categories by "inheriting"
from old ones is that it is easier to prove that the construction yields, in-
deed, a category. This chapter presents some elementary constructions
that illustrate the point, together with examples of categories that relate to
software development.

3.1 Some Elementary Operations

There are a number of elementary operations for constructing categories.
The first example reflects the fact that the choice for the direction of the
morphisms has no essential significance in the sense that, if we reverse the
direction of all the morphisms, we obtain a category that has the same
structural properties as the original one.

This fact does not mean, however, that the direction of the morphisms
should not be carefully chosen when defining a category. It is often the
case that there is a "natural" direction for morphisms, either given by the
mathematical nature of the morphisms or by their use in practice. If re-
versed, the direction of the morphisms may make it more difficult or less
immediate to understand the intended meaning and the particular con-
structions one may want to define on objects and morphisms. Hence, if
you are going to become a "practising category theorist", be prepared to
answer questions like "but aren't the arrows going the wrong way?"
which, many times, just means "you do not seem to belong to my club!"...

3.1.1 Definition - Dual of a Category

For any category C we can construct its dual or opposite Cp:

• C°p has the same objects and arrows as C.
• The arrows of C°p go in the reverse direction: if f:A->B in C then/:B-»A

in C".
• Arrow composition is in the reverse direction: f;g in Cop is g;f in C. •



32 3 Building Categories

3.1.2 Example

Following [86], the dual of the category ancestor(G) can be named de-
scendant(G). •

The fact that every category and its opposite have the same structural
properties reflects a general duality principle that applies to all definitions
and results. Every concept in category theory has a dual, which is the con-
cept that is obtained by reversing the direction of the arrows, i.e. the con-
cept that holds in the dual category. Every result in category theory has a
dual that holds for the dual concepts. We shall have plenty of occasions to
illustrate how the duality principle is applied in practice.

Another elementary construction consists in taking the product of two
categories:

3.1.3 Definition/Proposition - Product Category

Given categories C and D, their product CxD is such that its objects are
the pairs <c,d>, where c:C and d:D, and the morphisms <c,d>—><c\d'>
are all the pairs <f,g>, where f:c—>c' in C and g:d—>d} in D. Composition
of morphisms is defined componentwise, and the identity for an object
<c,d> is the pair <idc,idD>.

Proof
The properties of composition and the identities are trivially inherited from the
corresponding properties of the components. •

There are also ways of extracting categories from other mathematical
structures. For instance, we mentioned in Par. 2.2.5 that every preorder
defines a category. A simpler construction views sets as categories.

3.1.4 Definition/Proposition - Discrete Categories

Every set 5 determines a category whose objects are the elements of S and
whose morphisms are just the identities, i.e. for every sES hom(s,s) is a
singleton (consisting of the identity for s), and hom(s,s') is empty for every
s,s'ES such that s*s'. Such categories are said to be discrete.

Proof
Immediate. Note that, if we take S to be the set of nodes of a graph with no ar-
rows, then this construction is a special case of Par. 2.2.7. •

The discrete category defined by a set may have many objects, as many
as the elements of the set, but has only the minimum number of morphisms
- the identities. The next example illustrates the other extreme: many
morphisms, but only one object. These categories correspond to monoids.

3.1.5 Definition/Proposition - Monoids as Categories

A monoid is a triple <M,*,1> where M is a set, * is an associative binary
operation on M, and 1 is an identity for *, i.e. m*l-l*m=m for every



3.1 Elementary Operations 33

mEM. Any monoid defines a category that consists of only one object,
which we can denote by "•", and whose morphisms •-»• are the elements
of M. Composition of morphisms is given by the operation * and the
identity morphism is 1.

Proof
The properties of composition and the identity are trivially inherited from the cor-
responding properties of the monoid. •

3.1.6 Exercise

Characterise the duals of the categories defined by monoids. Are these
categories their own duals? •

3.2 "Adding Structure"

The most typical way of building a new category is, perhaps, by adding
structure to the objects of a given category (or a subset thereof)- The ex-
pression "adding structure" has a broad meaning that the reader will only
fully apprehend after building a few categories. The morphisms of the
new category are then the morphisms of the old category that "preserve"
the additional structure.

The following example is as typical as any other and is used throughout
the book for applications related to systems modelling.

3.2.1 Example - Pointed Sets

The category SET± (of pointed sets) is defined as follows. Its objects are
the pairs <A,±A>, where A is a set and 1A is an element of A called the
designated element. The morphisms between two pointed sets <A,±A>
and <B,±B> are the total functions f:A—>B such thatyf±A)=±B.

The category over which SET± is being built is, obviously, SET, the
category of sets and total functions. The additional structure that is being
added to the objects of the base category, sets, is the designation of an
element (not the element itself because it is already in the set). The mor-
phisms of the new category are all the morphisms of the base category that
preserve the additional structure, which in this case means preserving the
designation, i.e. mapping the designated element of the source to the des-
ignated element of the target.

This way of building new categories makes it easier to conduct proofs
as illustrated next.

Proof
The attentive reader will have noticed that the definition of SET± omitted two
fundamental ingredients: the definition of the composition law and of the identity



34 3 Building Categories

map. This is because they are, by default, inherited from the base category. Be-
cause the laws of composition and identity are satisfied in the base category, they
do not need to be checked again for the new category. Hence, all that needs to be
checked is that (1) the composition law is closed for SET±, i.e. that the composi-
tion of two functions that are morphisms in SET± is also a morphism of SET±, and
(2) that the identities are, indeed, morphisms in SET±:
1. Given morphisms /.<A,±A>—*<B,±B> and g:<B,±B>—><C,-LC>, we have to

check that (f;g)(±A)=±c. But/(J.i4J=J.B because/is a morphism of pointed sets.
Hence, (f;g)(±A)=g(f(lA))=g(lB). On the other hand, because g is also a mor-
phism of pointed sets, g(±B)=±c.

2. Given a pointed set <A,-LA>, we now have to prove that the identity map idA for
A as a set is a morphism of pointed sets, i.e. is such that idA(±A)=±A. But this is
true because idA is precisely the identity function on A. •

Notice the similarities between the structure of this proof and the proof
outline given for AUTOM in Par. 2.2.12. This style of proof is typical of
categories built from other categories by "adding structure".

The particular use of pointed sets that we have in mind is for modelling
the behaviour of objects at their interfaces (methods). A very abstract and
general model of object behaviour is one in which the events that can po-
tentially occur during the lifetime of an object consist of all possible sub-
sets of the set of its methods. This means that we work in a model in
which every object can potentially handle concurrent method calls. In
Chap. 4 we study how we can model restrictions to the degree of
concurrency that an object can impose on its methods.

The empty set represents an event in which the object is not involved.
This explicit but abstract representation of environment events has been
shown to be very important for modelling the behaviour of concurrent and
distributed systems [13].

The fact that the events that we are using for modelling object behaviour
consist of sets of method calls can be abstracted away to recognise a more
general notion of process alphabet as used in concurrency. The application
of categorical techniques in concurrency theory is particularly rich and re-
vealing of the power of category theory for systematising constructions
and establishing relationships between different models. The application
to object behaviour that we will use for illustration purposes throughout
the book touches some of these aspects, but the reader interested in a more
complete picture of the breadth of the field should consult [21, 24, 97,
106]. Specific applications of these categorical techniques to object-
oriented modelling can be found in [21, 24].

In this more general model of process behaviour, a process alphabet is a
pointed set. Each element of the set represents an event whose occurrence
may be witnessed during the lifetime of the process. The designated ele-
ment of the set represents an event of the environment, i.e. an event in
which the process is not involved. The notion of morphism in this model
captures the relationship that exists between systems and components of



3.2 "Adding Structure" 35

systems. More precisely, every morphism identifies the way in which the
target is embedded, as a component, in the source. The fact that the mor-
phism is a function between the alphabets is somewhat intuitive: for every
event a occurring in the lifetime of the system, we have to know how the
component participates in that event; if the component is not involved in a,
then the morphism should map a to the designated element of the alphabet
of the component, i.e. to the element that has been designated to represent
the events in which the component does not participate. On the other
hand, any event occurring in the environment without the participation of
the system cannot involve the component either; hence, every morphism
needs to preserve the designated element.

For instance, consider a producer-consumer system. We can assign the
events produce and store to the producer and consume and retrieve to the
consumer. An event of the system during which both produce and con-
sume take place concurrently is mapped to produce by the morphism prod:
system—^producer that identifies the producer as a component of the sys-
tem. On the other hand, an event of the system during which the consumer
executes retrieve and the producer remains idle is mapped by prod to the
designated element of the alphabet of the producer.

Our last example of constructing new categories from base ones is also
very typical. It provides so-called comma categories. Several different
notations can be found in the literature for comma categories. We shall
use the same notation as [80]. The particular form of comma categories
that we are about to define are also called over/under-cone categories in
[22] and (co)slice categories in [49].

3.2.2 Example - Comma Categories

Given a category C and an object a:C, we define the category of objects
under a, denoted aJ,C, as follows. Its objects are all the pairs <f,x> where
/ is a morphism of the form/:a-»x in C. The morphisms between f:a—*x
and g:a—>y are all the C-morphisms h:x->y such thatf;h=g.

Proof:
In this case, the additional structure that is being added to every object x:C is a C-
morphism/:a^»x. Again, we inherit the composition law and the identity map
from the base category and prove only the closure properties.

This is also a good example to illustrate how reasoning in category theory is
often done at a graphical level. Because objects are now morphisms of the base



36 3 Building Categories

category, it is more convenient to represent a morphism h between f:a —*x and
g:a—>y by a diagram. As already mentioned, the symbol @ indicates that the dia-
gram commutes, i.e. all compositions of morphisms in the diagram along paths
that have the same source and target are equal. In the case above, commutativity
of the diagram expresses the equation f;h=g.

Given composable morphisms i and j

we have to prove that the composition (i;j) in C is indeed a morphism in a\C, i.e.
f;(i;j)=h. There is another way of asserting the property that needs to be proved
which makes appeal to the kind of diagrammatic reasoning that we have claimed
to be typical of category theory: we have to prove that, for any diagram of the
form above, the outer triangle commutes if the inner triangles also commute. This
can be done as follows:

1. f;i=g because i is a morphism in a ,/C,
2. (f;i);j=g;j from (1),
3. g;j=h becausey is a morphism in aJ,C,
4. (f;i);j=h from (2) and (3),
5- f;(i;j)=(f;i);j from the associativity of the composition law in C,
6. f;(i;j)=h from (4) and (5).
The fact that idx is an identity for/:a—*x results from the property f;idx=idx. •

For instance, when applied to a category of the form ancestor(G), this
construction returns, for every class c, the classes that inherit from c,
themselves organised as a hierarchy. When applied to PROOF it returns,
for every sentence, the inferences that can be made from that sentence.

3.2.3 Exercise

Characterise the dual category of aJ,C - the category of objects over a,
usually denoted by Cla. •

Generalisations of comma categories are presented in Sect. 6.1.
Together with the example in Par. 2.2.12, we hope that we have pro-

vided enough insight into a way categories are often defined, that is by
"adding structure" to the objects of another category. Because there is no
abstract characterisation of this technique, we have relied on the examples
to make apparent that there is a systematic procedure for checking the
definition of a category built in this way.



3.3 Subcategories 37

3.3 Subcategories

There is another intuitive, and often useful, way of building new categories
from old: by forgetting some of the objects and some of the morphisms to
create a subcategory of the original one. The only proof burden associated
with this method is in making sure that we do not through away too much
(or too little).

3.3.1 Definition - Subcategories

Given categories C=<Gc,;c,idc> and D=<GD,;D,idD>, we say that D is a
subcategory of C iff

• \D\QC\, i.e. every object of D is an object of C.
• For any objects x and y of D, homD(x,y)Qiomc(x,y), i.e. the morphisms

in D are also morphisms in C.
• The composition laws and the identity maps in the two categories agree,

i.e. given composable morphisms/and g of D, their composition/;^ in
D is the same as their composition f;cg in C, and for every object x of D,
its identity idD(x) in D is the same as idc(x) in C. •

Notice that, for D to be a subcategory of C, it is not enough to have in-
clusions between the sets of objects and of morphisms; the additional
structure given by the identities and the composition law has to be pre-
served. Examples of subcategories are given as we go along, most of the
time as exercises.

3.3.2 Examples

1. By keeping just the sets that are finite and all the total functions between
them, we define a subcategory /SET of SET.

2. By keeping all sets but just the functions that are injective, we define a
subcategory INJ of SET. This is because identities are injective and the
composition of injective functions is still injective.

3. Given any category, we can forget all its morphisms except for the
identities and obtain a (discrete) subcategory.

4. We can extend the morphisms of SET to include all partial functions
between sets. Because the identity function is trivially partial and par-
tial functions compose in the same way as total functions, we obtain a
category of which SET is a subcategory. The category of partial func-
tions is called PAR.

5. When discussing pointed sets, we have motivated the notion of alphabet
of object behaviour by identifying events with sets of methods. That is,
we have worked with pointed sets that consist of powersets, the empty
set being the designated element of each powerset. We can show that
we define a subcategory of SET± by choosing as morphisms 2

B—>2A



38 3 Building Categories

maps that compute inverse images for functions A—>B, i.e. a morphism
g:2B^2A is such that, for some/.vWB, g(B')=f'(B') for every B'CB.
We call this category POWER. •

The cases in which we throw away some of the objects but keep all the
morphisms between those that remain, like we did for finite sets, deserve a
special designation:

3.3.3 Definition - Full Subcategories

Given categories C and D we say that D is a full subcategory of C iff D is a
subcategory of C and, for any D-objects x and y, homD(x,y)=homc(x,y). •

3.3.4 Exercise

Check which of the subcategories defined in Par. 3.3.2 are full. •
We have mentioned several times that, intensionally, a category cap-

tures a certain notion of structure, which we called a "social life" for its
objects. It is only natural to expect that, when selecting a subcategory, we
obtain a different but, nevertheless related, notion of structure. For in-
stance, if D is a subcategory of C, two objects that are isomorphic in C are
not necessarily isomorphic in D. A trivial illustration of this fact can be
obtained by realising that the discrete subcategory of C that is obtained by
forgetting all the morphisms except the identities (see Par. 3.3.2) is such
that any object is only isomorphic to itself (it has no social life). Indeed,
the more structure a category provides through its morphisms, the more
observational power we have over its objects and, hence, the more isomor-
phisms we are able to establish. The reverse property, however, holds and
is left as an exercise.

3.3.5 Exercise

Let D be a subcategory of C. Show that any two objects that are isomor-
phic in D are necessarily isomorphic in C. •

The relationship between isomorphisms and subcategories is, in fact,
very revealing of the way categories can be used to capture notions of
structure. Recall that a subcategory is full iff it is obtained by selecting a
subclass of the objects but leaving the morphisms between the selected
objects unchanged. Typically, this happens when one wants to select just
the objects that satisfy a certain property, e.g. sets that are finite as in the
example in Par. 3.3.2. In this case, the converse of the property proved in
the exercise above also holds. This is because, by not interfering with the
morphisms, we are keeping the structure of the objects intact.

3.3.6 Exercise

Let D be a full subcategory of C. Show that any two D-objects that are
isomorphic in C are also isomorphic in D. •



3.3 Subcategories 39

In the cases where, like finiteness of sets, the discriminating property
does not distinguish between isomorphic objects, we obtain a subcategory
that is not only full but contains all objects that are isomorphic, i.e. share
the same substructure.

3.3.7 Definition - Isomorphism-Closed Full Subcategories

A full subcategory D of a category C is said to be isomorphism-closed iff
every C-object that is isomorphic to a Z)-object is also a Z>-object. •

So far, we have looked at the formation of a subcategory as the result of
a selection of special objects and morphisms from a given category. In
certain circumstances, this selection is actually the result of a process of
"abstraction", i.e. certain objects are selected because they are "canonical"
with respect to a set of objects that share a given property.

As an example, consider automata as defined in Par. 2.2.12. Intuitively,
only the states that are reachable, in the sense that they can be reached
through the transition function from the initial state and some input se-
quence, are important for determining the "social life" of automata in
terms of their ability to simulate other automata. Consider then the full
subcategory REACH of AUTOM that consists of all reachable automata.
The idea that, for the purposes of simulating other automata, every
automaton can be represented by the automaton that is obtained by re-
moving all non-reachable states can be formalised as follows:

• Every automaton A is related to a "canonical" reachable automaton R
through a morphism c:R-*A. More concretely, if A-<X,S,Y,so,f,g>,
then R=<X,SR,Y,s0,fR,gR> where SR is the subset of S consisting of the
states that are reachable, andfR (resp. gR) is the restriction of/(resp. g)
to SR. Notice that R is well-defined because / returns reachable states
when applied to reachable states. The morphism c consists of the inclu-
sion of SR into S and the identities on X and Y. Notice that the inclusion
satisfies the three properties of simulations in a trivial way.

• Every inclusion c:R—>A as defined above satisfies the following prop-
erty: given any reachable automata R' and simulation h:R'—*A, there is a
unique morphism of reachable automata h':Rx—*R such that h=h';c.

R

R'

In other words, R is the reachable automaton that is "closest" to A in the
sense that any other reachable automata that A can simulate can also be
simulated by R. Indeed, if R'=<X\S',Y\s'0,f,g'> and h-<hx,hs,hY>, then



40 3 Building Categories

the equation h=h';c can only be satisfied if h's:S'->SR coincides with hs
on the whole domain S", i.e. if hs only returns reachable states. But this
is the case because R' is itself reachable. Finally, the equation fully de-
termines the morphism, thus establishing the uniqueness of h\

This relationship between automata and reachable automata is an in-
stance of what in category theory is called a coreflective subcategory.

3.3.8 Definition - Coreflective Subcategories

Let D be a subcategory of a category C.

1. Let c be a C-object. A Z)-coreflection for c is a C-morphism i:d—>c for
some D-object d such that, for any C-morphism f:d[-*c where d' is a D-
object, there is a unique D-morphism f:d'—>d such that f=f;i, i.e. the
following diagram commutes:

2. We say that D is a coreflective subcategory of C iff every C-object ad-
mits a D-coreflection. •

Coreflections are essentially unique in the following sense.

3.3.9 Proposition

Let D be a subcategory of a category C.

1. Let c be a C-object. If i:d->c and j:e-*c are both D-coreflections for c,
then there is a D-isomorphism/:e-*<i such that j=f;i, i.e. the following
diagram commutes:

i
d

2. Let c be a C-object. If i:d-*c is aZ)-coreflection for c, and/.e-
D-isomorphism, thenf;i:e-*c is also a D-coreflection for c.

is a



3.3 Subcategories 41

Proof
1. The existence of / satisfying the equation results directly from the definition.

The fact that/is an isomorphism can be proved as follows:
• The existence of g:d-*e such that i=g;j can be concluded for the same rea-

sons.
• The composition g;f'\s such that (g'J);i-g',(f'A)=g',j=i=idd;i. We can con-

clude that g;f=idd by applying the uniqueness requirement of the definition
of coreflection to idd.

• A similar line of reasoning allows us to conclude that f;g=ide.
2. This is trivially proved. •

Intuitively, a coreflector for an object is a secretary that manages its so-
cial life, i.e. through which all communication must go. Indeed, consider
two objects c and c' together with their secretaries d and d', respectively.
Consider an interaction h:c—>c'.

T h' @ hT

d1 • c'

The composition V;h is in the same circumstances as the morphism/in
the definition. Hence, we conclude that there is an interaction h':d'—>d that
factorises (intercepts) h in the sense that i';h=h';i.

Given that secretaries are also objects of the bigger category, a question
arises naturally: Who are their secretaries? Do they talk to each other di-
rectly or do they need their own secretaries, and so on? It seems intuitive
to expect that all secretaries communicate directly between them, i.e. that
the coreflection of a D-object (secretary) is the identity (itself) up to iso-
morphism. However, this can only be guaranteed if (and only if) D is a
full subcategory.

3.3.10 Proposition

Let D be a coreflective subcategory of a category C. Then, D is a full sub-
category of C iff, for every Z)-object d, idd is a Z)-coreflection for d.

Proof
1. Let D be a full subcategory of C and d aD-object. Given any C-morphism

f:d'—>d where d' is also a D-object, the equation f=f;idd establishes / = / '
uniquely. So, the only way for the identity idd not to be a coreflector for d is
that/is not a D-morphism as required by the definition. Naturally, if the cate-
gory is full, this cannot happen.



42 3 Building Categories

2. Consider now an arbitrary C-morphism f:d'—>d where both d and d' are D-
objects. If idd is a D-coreflection for d then, by definition, there exists a D-
morphism/.-d'̂ »d such that f=f;idd, i.e./=/. Hence,/is also a ZJ-morphism. •
Indeed, if the subcategory is not full, the secretaries, when playing their

roles as secretaries, may have more restricted means of interaction and,
therefore, may not be able to behave as they would do as "normal" objects.

The social motivation that we have been using is, in fact, somewhat bi-
ased towards objects, i.e. it leads us to consider coreflective subcategories
that are full like that of reachable automata. However, any categorical
property is ultimately determined by the morphisms.

The following example shows that there are coreflective subcategories
that are not full.

3.3.11 Example

We mentioned in Par. 3.3.2 that SET is a subcategory of PAR, the cate-
gory of partial functions. Both categories share the same objects (sets), but
SET retains only the functions that are total. Hence, SET is not a full sub-
category of PAR. However, it is easy to prove that every set A admits as a
coreflector the partial inclusion A1—*A where A1, also called the "elevation
of A", is the set obtained from A by adding an additional element 1 called
"bottom" or "undefined". The partial inclusion is the extension of the
identity on A that is undefined on 1. Given now an arbitrary partial func-
tion/:B-»A there is a unique elevation of/into a total function f-.B-^A1

by mapping to 1 all the elements of B on which/is undefined. This is the
standard technique that mathematicians use to deal with partiality in the
context of total functions. •

Hence, in this case, the secretary is also responsible for transforming
from the "partial" mode of communication into the "total" mode. This is
because, by not being full, the subcategory defines a more specialised
mode of interaction. The coreflector operates a transformation from the
more general to the more specific mode.

Because category theory distinguishes between incoming and outgoing
communication, coreflectors manage, in fact, the incoming communication
only. The dual notion, i.e. the notion that is obtained in the dual category,
is called reflector and manages the outgoing communication.

3.3.12 Definition - Reflective Subcategories

Let D be a subcategory of a category C.

1. Let c be a C-object. A Z)-reflection for c is a C-morphism o:c—*d for
some D-object d such that, for any C-morphism f:c-*d\ where d' is a D-
object, there is a unique Z)-morphism/:<i—*d' such that f=o;f, i.e. the
following diagram commutes:



3.3 Subcategories 43

2. We say that D is a reflective subcategory of C iff every C-object admits
a D-reflection. •

Being the dual concept of coreflections, reflections satisfy all the dual
properties of coreflections. In particular, reflections are essentially
"unique" and identities are reflectors iff the subcategory is full. For con-
sistency, in informal discussions, we shall call coreflectors "insecretaries"
or "cosecretaries", and reflectors "outsecretaries" or "secretaries". Exam-
ples of reflections are given in Par. 3.6.4.

3.4 Eiffel Class Specifications

In order to illustrate some of the ways in which category theory can be
used to capture the semantics of software engineering practice, we intro-
duce a "practical" example related to the Eiffel language. This example is
used in later chapters as well.

As stated in [86], "Eiffel software texts - classes and their routines -
may be equipped with elements of formal specification, called assertions,
expressing correctness conditions". We do not detail the language in
which these assertions can be written; it can be found in [86].

For our purposes, an Eiffel class specification e consists of a triple
<2,P,I> where:
• 2", the class signature, is a set (of features). Each feature has its own

signature which consists of a pair <arg,res> of sequences of types.
Features can be attributes, functions or routines, the sets of which are
denoted by att(2),fiin(Z) and rou(2), respectively.

• P provides, for every rErou(Z), a pair <prer,posr> of Boolean expres-
sions (the pre- and the postcondition of the routine, respectively).

• I is a Boolean expression (the invariant of the class).
The semantics intended for such a specification is the one popularised

under the designation "design by contract". Every client of the class when
calling a routine r should make sure that the precondition for r holds, in
which case the postcondition is assured to hold after the call is completed.
The class invariant is a condition that is guaranteed by every creation pro-
cedure of the class and maintained by any routine.

For an example of a class specification consider bank accounts:



44 3 Building Categories

deferred class account is
attributes balance: int, vip: boolean
routines deposit(i:nat)

require true
ensure balance = old balance + i

withdrawal(i:nat)
require balanced
ensure balance = old balance - i

invariant vip D balance^lOOO

A bank account is capable of handling deposits and withdrawals. These
update the balance, captured through an attribute, as specified in the en-
sure clauses. The routine that performs the withdrawals requires the client
who makes the call to check that the balance is greater than the amount re-
quested. Accounts that are considered to be vip have a balance greater
than 1000.

The idea is that specifications are used to indicate what software com-
ponents do, or are required to do, rather than how they do it. Changes to
the implementations of the specified features are allowed as long as they
do not violate the specifications.

Specifications have a "social life" that results from the need to adapt
features. Feature adaptation [86] typically comes about when the class is
inherited. To be consistent with [86], the notion of morphism that can
capture such structural aspects of class specifications has to account for the
following operations:

• Rename a feature.
• Merge one or more features; this is called the join mechanism and ap-

plies to features inherited as deferred (i.e. without a chosen implemen-
tation).

• Redefine a feature, changing the original signature, preconditions or
postconditions.

• Add conditions to the invariant.
There are other circumstances in which features can be changed, like as-

signing an implementation to a feature that so far was "deferred". Because
they relate only to implementations, and do not involve specifications ex-
cept for discussing the correctness of the changes, i.e. because specifica-
tions are not socially active during these operations, we will not consider
them in our formalisation.

The redefinition of a feature is subject to several constraints:

• At the level of its signature, the number of arguments and results cannot
be changed; changes to their types can be performed subject to a num-
ber of conformance rules that, for simplicity, we ignore.

• Functions can be redeclared as attributes but not vice-versa; routines
cannot be redeclared as attributes or functions, and attributes and func-
tions cannot be redeclared as routines.



3.4 Eiffel Class Specifications 45

• Preconditions can be weakened but not strengthened.
• Postconditions can be strengthened but not weakened.

The constraints that apply to pre/postconditions have in mind the pres-
ervation of the contract: any client of a redefined routine has the right to
expect a service that complies with the original specification. Hence, the
client cannot be required to test for more conditions before calling the
feature. Upon termination, the client must get at least what he would nor-
mally get from the original feature.

All these constraints lead to the following definition:
A morphism F: e-<E,P,I> -» e'=<Z',P'J'> of Eiffel class specifica-

tions consists of a total function between the class features such that
• For every feature fEZ, argF(f)= argf and resF(f)= resf.
• For every attribute aEatt(S), F(a)Eatt(X).
• For every function fEfun(Z), F(f)Eatt(X)Ufun(X).
• For every routine rErou(Z), F(r)Erou(S').
• For every rErou(S), F(prer) \—pre'F(r} andposF(r)\—F(posr).
• r\-F(i).

As an example of a morphism of Eiffel class specifications, consider the
following class specification obtained by inheriting from the previous ex-
ample:

deferred class flexible account is
inherit account
attributes credit: nat
redefine withdrawal(i:nat)

require else balance+credit a i
invariant vip D balancealOOOO

That is, a flexible account extends the account with an attribute credit
whose value can be added to the balance for satisfying a withdrawal re-
quest. As a counterpart to the added flexibility, the minimum balance for
the account to be considered "vip" is now 10000.

The syntax of Eiffel is already such that some of the constraints are
automatically met:
• The redeclaration of routines is such that preconditions are changed

with a require else clause. Its semantics is to add the specified con-
dition to the inherited precondition as a disjunct (hence the weakening).

• The postconditions are changed with a ensure then clause. Its se-
mantics is to add the specified condition to the inherited postcondition
as a conjunct (hence the strengthening).

• The invariant clause is added as a conjunct to the invariant inherited
from the parent class (hence the strengthening).

It is easy to prove that class specifications and their morphisms consti-
tute a category CLASS_SPEC. In Chap. 4 we account for other properties
of specifications, like the "join semantics rule".



46 3 Building Categories

3.5 Temporal Specifications

In this section, we develop a category whose objects are specifications of
process behaviour in temporal logic. This category is used throughout the
rest of the book in examples. Whereas our purpose with Eiffel class speci-
fications was to show how category theory can apply to "real-life" model-
ling techniques, with temporal specifications we will try to illustrate, in the
simplest way we know, typical properties of specification theory as ap-
plied to concurrent systems.

This example will also serve two other purposes. On the one hand, it is
used to show how relationships between different domains can be devel-
oped once they have been formalised in category theory. This is done by
relating temporal specifications with a very simple process model that we
started building in Par. 3.2.1. The other purpose is to show that there is a
degree of "universality" in the kinds of constructions that are typically
used across different domains for system modelling, and that this univer-
sality is very easily made evident and formally characterised through the
use of category theory. Before proceeding, we should make clear that
much of this particular topic was jointly developed with Felix Costa. The
essential part of the technical details can be found in [32, 33].

Specifications are often identified with theories (or theory presentations)
in a given logic, an idea that has been around for quite a long time [17],
although only more recently explored from the point of view of the tempo-
ral logic approach to reactive system specification [38]. In fact, process
specifications are usually given as theory presentations rather than theo-
ries. By a theory presentation, we mean a pair consisting of a signature
and a set of sentences - the nonlogical axioms of the specification. The
signature identifies the vocabulary symbols that are proper to the object
being identified and the sentences provide a description of the properties
that are being specified about that object.

We shall be modelling the behaviour of concurrent processes at the level
of the actions that are provided by their interfaces. Hence, every signature
identifies a set of actions in which a process can engage itself. An exam-
ple of a signature is that of the specification of a vending machine able to
accept coins and deliver cakes and cigars - {coin,cake,cigar}.

3.5.1 Definition - Signatures

A signature of linear temporal logic is a set, the elements of which are
called action symbols. •

The language in which the sentences that specify the behaviour of the
process are written is that of linear temporal logic. The action symbols



3.5 Temporal Specifications 47

provide atomic propositions in the definition of the language associated
with a signature.

3.5.2 Definition - Language

The set of temporal propositions prop(l) for a signature 2 (^-propositions,
for short) is inductively defined as follows:
• Every action symbol is a temporal proposition.
• beg is a temporal proposition (denoting the initial state).
• If (p is a temporal proposition so is (~<(p).
• If (j), and (j>2 are temporal propositions so are (fyjDfa), (faUfa). •

The temporal operator is U (until). Its semantics is defined below; in-
formally, (0;£/02) holds if, from tomorrow, <f>2 will eventually hold and,
until then, but not necessarily then, 0; will hold. Other temporal operators
such as X (next or tomorrow), F (eventually) and G (always) can be de-
fined as abbreviations [67]. We often make use of the operator W (weak
until): (<p]W<f>2) holds if, from tomorrow, either 02

 W1U eventually hold and
until then, but not necessarily then, <f>, will hold, or 02 will forever be false
and cp] true.

3.5.3 Definition - Semantics

The language of linear temporal logic is interpreted over infinite sequences
of sets of actions. That is, an interpretation structure for a signature H is a
sequence XE.{2^)m. These are canonical Kripke structures for linear, dis-
crete, propositional logic [110]. Each infinite sequence represents a possi-
ble behaviour for the process being specified. The sets of actions represent
the events that take place during the lifetime of the process. As already
explained in Par. 3.2.1, the event that consists of the empty set of actions
represents a transition performed by the environment without the partici-
pation of the process.

A ^-proposition <p is said to be true for A£f2-Z)w at state i, which we
write A NXi0 iff:
• If 0GI1, A \=Sri<p iff (f>Etyi).
• A \=1}ibeg iff i=0.
• A K^f-i^,) iff it is not the case that A NX(0.
• A N^/07D02) iff h ^2,<0; implies A NX;,-02.
• A Nx/07£/02/) iff, for some j>i, A N£<;02 and A N^^.^ for every i<k<j.

The proposition <f> is said to be true in A, written A N ^ , if and only if
A N^,-0 at every state /. We also write A Nxc& for a collection of proposi-
tions 0 meaning that each proposition of <P is true in A, and A N^> for a
collection A of sequences meaning that <j> is true in every XEA.

Finally, for every set <P of ^-propositions and every Z-proposition (j), <j>
is a consequence of <&, denoted <P \—^, if and only if 0 is true in every se-
quence that makes all the propositions in <P true. •



48 3 Building Categories

The corresponding notion of theory is given as usual for the closure
system induced by the consequence relation.

3.5.4 Definition - Theories and Presentations

1. Let I be a signature. A subset W of prop(I) is said to be closed if and
only if, for every <j)Eprop(2), W \— ̂  implies (f)EW. By c^W) we de-
note the least closed set that contains W.

2. A temporal theory is a pair < 21, <£>> where 21 is a signature and <P is a
closed set of ̂ -propositions.

3. A theory presentation is a pair <S,O> where 21 is a signature and & is a
set of ̂ -propositions. The presented theory is <S,c^€>)>. •
That is, a theory consists of a set of sentences that is closed for conse-

quence: it contains all the theorems that can be derived from its sentences.
A presentation is not necessarily closed under consequence: it provides a
more "economical" way of specifying the intended behaviour of a system.
A presentation consists only of a selected set of properties (also called the
axioms of the presentation) that are required of the system, leaving the
computation of the properties that can be derived from this selected set
(its theorems) to the proof theory of the logic. Whereas theories, in gen-
eral, and in particular for temporal logic, are infinite, presentations can be
finite or, at least, recursively enumerable. Hence, specifications are usu-
ally identified with presentations, not with theories.

3.5.5 Exercise

Prove that the operators cs satisfy the following properties:
• Reflexivity: for every &Cprop(Z), 0Cc^0).
• Monotonicity: for every &,rCprop(2), &CF implies
• Idempotence: for every ®Qprop(T),

3.5.6 Example - A Vending Machine

As an example, consider the following specification of a vending machine:

specification vending machine is
signature coin, cake, cigar
axioms beg D ( (-'cakeA-'cigar) A

(coin v (-icakeA-'cigar)Wcoin) )
coin D (->coin)W(cakevcigar)
(cakevcigar) D (-'cakeA-'cigar)Wcoin
cake D (->cigar)

This machine is able to accept coins, deliver cakes and deliver cigars.
The machine is initialised so as to accept only coins (first axiom). Once it
accepts a coin it can deliver either a cake or a cigar (second axiom), but
not both (fourth axiom). After delivering a cake or a cigar it is ready to ac-
cept more coins (third axiom). •



3.5 Temporal Specifications 49

As already mentioned, the model of process behaviour that we adopt re-
flects an (abstract) synchronous, multi-processor architecture in which, at
each transition, several actions may be executed concurrently. We are go-
ing to show that this synchronous flavour is captured through the notion of
specification morphism (interpretation between theories) as a mathemati-
cal model of the relationship between systems and their components.

An interpretation between theories is typically defined as a mapping
between their signatures that preserves theorems. Notice, once again, the
idea of structure preservation presiding to the definition of morphisms.
The structure being preserved in this case is given by the properties of the
processes involved as captured through the theorems of the specifications.

3.5.7 Definition - Interpretations Between Theories

1. Let Z and X be signatures. Every function f:Z—>X extends to a transla-
tion mapprop(f):prop(Z)—>prop(X) as follows:
• prop(f)(beg)=beg.
• If aEZ then prop(f)(a)=f(a).

propUHhUhMpropffXhiUprvpfflk)).
2. An interpretation between two theories (or theory morphism) <£,,&,>

and <2'2,02> is a map/:2'i^»2
1

2 such that prop(f)( ®i)C®2.
3. A morphism between two presentations <Zj,®,> and <22,<£>2

> is a map
f:Ij-*X2 such that prop(f)(cSi(®1))CcS2(®2). •

3.5.8 Proposition

1. Temporal theories and interpretations between theories define a cate-
gory called THEOLTL.

2. Presentations of temporal theories and their morphisms define a cate-
gory called PRESLTL, which admits THEOLTL as a subcategory.

Proof
1. Although we have not made it explicit, the composition law and identity map

that we have in mind for theories are the ones inherited from signatures as sets.
Hence, this is another example of constructing a category by adding structure:
the underlying category is that of sets, and the structure being added is the col-
lection of theorems that constitute the specification. Therefore, the properties
of the composition law and identity map are inherited from SET; we only have
to prove the closure properties, i.e. that the composition of theory morphisms as
functions is still a theory morphism and that the identity function is a theory
morphism. The latter is trivial because the translation map induced by the
identity on signatures is itself the identity. The former is proved as follows:
• First of all, given f:2—>2' and g:Z'—>2", we have to prove that prop(f;g) =

prop(f);prop(g). That is, the translation map induced by a composite func-



50 3 Building Categories

tion is the composition of the translation maps induced by the components.
This can be proved by structural induction and is left as an exercise.

• Given theory morphisms/:<2',<£>^»<2",<PI> and g:<I',0'>-*<I",0">, we
have prop(f;g)(0)=prop(g)(prop(f)(&)) as proved above. Because/is a the-
ory morphism, prop(f)(&)C<p\ which implies prop(f;g)(&)Cprop(g)(&').
Because g is a theory morphism, we also have prop(g)(<P')C&'\ which im-
plies prop(f;g)(0)C0". Hence, (f;g) is a theory morphism.

2. The proof that theory presentations and their morphisms define a category can
proceed exactly in the same way as for theories. The fact that THE0LTL is a
subcategory of the resulting category has a very trivial proof:
• Clearly, every theory is a presentation: it just happens to be closed.
• Given a theory morphism f:<2,&>-><!?,&'> we have to prove that it de-

fines a presentation morphism, i.e. that prop(f)(c^0))Ccr(0'). Because 0
and 0' are closed, cJ0)=0 and cr(0')=0'. Because/is a theory morphism,
prop(f)(0)C0<.

• The properties of the composition and the identity are trivially proved. •

For simplicity, we overload the notation and use/instead of prop(f) un-
less there is a risk of confusion.

Checking that a signature map defines a morphism between two pres-
entations by checking that every theorem of the source is translated to a
theorem of the target is not "practical". Typically, one would prefer to
check that only the axioms of the presentation are translated into theorems,
from which it should follow that the theorems are preserved. Although
this is not true for an arbitrary logic, it is a property of the temporal logic
that we defined above as proved below. In order to do so, we need to be
able to relate the models of the signatures involved.

3.5.9 Definition/Proposition - Reducts

1. Let 2 and 2 ' be signatures and f:2->2' a total function. Given an inter-
pretation structure A.'E(2^')a3 for 2', we define its reduct A'ly as the inter-
pretation structure for 2 defined by X'\/i)=f'(X1(i)). That is, the reduct
of a sequence A' of 2'-actions is the sequence that consists, at each point
/, of the 2-actions that are translated through /into X'(i).

2. Let 2 and 2 ' be signatures,/:2-*2' a total function, X'E(2x)m an inter-
pretation structure for 2', and (j> a 2-proposition. Then, for every
i, A' NXy/f</)) iff A'lyNj,^ (the satisfaction condition).

Proof
The proof of point 2 is by induction on the structure of 0. The base case (action
symbols) results directly from the definition of reduct: f(<j>)E?i(i) iff <j>Ef'(X'(i))
{=k'\j(i)). The induction step presents no difficulties. •

3.5.10 Proposition - Presentation Lemma

1. Given a morphismf.-Ij-*^ and



3.5 Temporal Specifications 51

2. Given presentations <II,<P1> and <Z2,
<P2>,

 a m a P f:^i^^2 is a mor-
phism between them ifffffyjCcztfy)- This result is usually called "the
presentation lemma".

Proof

1. Let <pEcE(0). We have to prove thatyf<j>)Ecs (/(&))• For that purpose, consider
an arbitrary interpretation structure X'E(2s)m in which f(<P) is true. From what
was just proved, all the propositions in <P are true in A'ly. But, then, so is 0 be-
cause cj)EcI(0). Applying the same result, but in the other direction, we know
that/(0J is true in A'.

2. All that needs to be proved is that/c^C <P,))£cz2(<P2) ^fC^i)^/^)-
• The forward implication is an immediate consequence of the reflexivity of

closure, which allows us to derive that ^>JQCE(^J).
• Consider now the reverse implication

a. f(Oj)CcE(O2) assumption,
b. cz(f(0I))CcI(cs(€>2)) from a, closure operators being monotone,
c. cE(f(Oj))Ccz(i>2) from b, closure operators being idempotent,
d. f(cz (O1))Q:I(02) from c and the result proved in 1.z (

3.5.11 Example - A Regulated Vending Machine

As an example of the use of morphisms for system modelling, consider the
following specification:

specification regulated vending machine is
signature coin, cake, cigar, token
axioms beg "D (~'cakeA->cigarA->token) A

(coin v (->cakeA-icigar)Wcoin)
coin D (->coin)W(cakevcigar)
coin D ("lcigar)Wtoken
(cakevcigar) D (-•cakeA-'cigar)Wcoin
cake D (-•cigar)
token D (->cakeA->cigarA-icoin)

That is, the machine is now extended to be able to accept tokens, and is
regulated in such a way that it will only deliver a cigar if, after having ac-
cepted a coin, it receives a token. The last axiom says that coins, cakes
and cigars cannot be used as tokens.

This specification results from the previous vending machine through
the superposition of some mechanism for controlling the sales of cigars.
In Par. 6.1.24, we can see how a regulator can be independently specified
and connected to the vending machine in order to achieve the required su-
perposition. That is, the regulated vending machine can be defined as a
configuration of which the original vending machine, as well as the regu-
lator, are components.



52 3 Building Categories

To finalise, we show how theory morphisms can be used to identify
components of systems. For instance, in the example above, we can es-
tablish a morphism between the specifications of the vending machine and
the regulated vending machine. The signature morphism maps the actions
of the vending machine to those of the regulated vending machine that
have the same names. To prove that the signature morphism defines an
interpretation between the two specifications, we have to check that every
axiom of the specification of the vending machine as given in Par. 3.5.6 is
translated to a theorem of the regulated vending machine:

• The initialisation condition is preserved: it is strengthened with -•token.
• The second axiom is translated directly into the second axiom.
• The third axiom is translated directly into the fourth axiom.
• The fourth axiom is translated directly into the fifth axiom.

The fact that morphisms identify components of systems is captured by
the following result.

3.5.12 Proposition

Let <2'/,<?;> and <Z2>
<&2> be theories andf:S1-*22 a signature morphism.

Then, / defines a theory morphism iff, for every model A' of <2'2,02>, ^-'1/
is a model of <217)<?7>.

Proof

1. Assume that/defines a theory morphism and let A' be a model of <Z2,®2>- To
prove that A'ly is a model of <2'7,<P/>, let <pE<P,. B e c a u s e / is a theory mor-
phism, f(<p)E<P2 and, hence, f(<j>) is true in A'. But, by the fundamental property
of reducts, <p is true in A'ly. Hence, A'lyis a model of <Z,, <P7>.

2. Assume now that, for every model A' of <22,<P2
>> A'ly- is a model of <Z,,0j>.

Let <j)E0,. We have to prove that f(<p)E&2- Let A' be a model of <22,<P2
>- Be-

cause A'^ is a model of <S,,^,>, (j) is true in A'ly. By the fundamental property
of reducts (opposite direction), ffcj)) is true in A'. •

That is, given a morphism between two temporal specifications, every
behaviour of the target is projected back to a model of the source. Because
the reduct identifies the actions of the source that occur at each point in the
execution of the target, we can say that an interpretation between theories
identifies in every behaviour that is according to the target specification, a
behaviour that is according to the source specification. Hence, the mor-
phism recognises in the source a component of the target.

Notice that it is not necessary that every behaviour of the source (com-
ponent) be recovered through the reduct. Indeed, as a component of a
larger system, some behaviours of the component may be lost because of
interactions with other components. This is the case above. The behav-
iours in which a coin is followed immediately by a cigar are not part of
any model of the regulated vending machine because a token is required
after the coin before the cigar can be delivered.



3.6 Closure Systems 53

3.6 Closure Systems

In the previous section, we presented several categories related to the
specification of systems on the basis of properties stated in the language of
temporal logic. We show in the next chapters that these categories satisfy
a number of properties that make them useful to modularise specifications.
However, these properties are in no way particular to the temporal logic
that was chosen to express specifications. They are shared by a number of
structures that generalise what, sometimes, are called "closure systems".
This section presents the initial step in a sequence of constructions that
will end up in the definition of institutions [62], Jt-institutions [45] and
general logics [85]. These are all categorical generalisations of the notions
of logic and associated concepts like theories that bring out the structural
properties that make them useful for specification.

3.6.1 Definition - Closure Systems

A closure system is a pair <L,c> where L is a set and c:2L—>2L is a total
function satisfying the following properties:
• Reflexivity: for every &QL, <PCc(&).
• Monotonicity: for every &,FCL, &CFimplies c(0)Cc(F).
• Idempotence: for every <$>CL, c(c(<P))Cc(<P), •

3.6.2 Definition/Proposition - Category of Closure Systems

We define the category CLOS of closure systems whose morphisms
f:<L,o-*<L\c:> are the maps f-.L-^U s.t.f(c(&))Cc'(f[<P)) for all 4>CL.

Proof

Again an example of adding structure to SET.
1. The identity function on sets is trivially a morphism of closure systems.
2. Consider now two morphisms f:<L,c>—*<L',c'> and g:<L',c'>—*<L" ,c">, and

0CL. Because / is a morphism, f(c(<P))Cc'(f(&)). This also implies that
g(f(c(O)))Cg(c'(f(<P))). Because g is a morphism, g(c'(f(<P)))Cc"(g(f(<P))).
Hence, (f;g)(c(&))Cc"((f;g)(&))). •

As an example of closure systems we can give, for every temporal sig-
nature Z, the pair clos(Z) formed by prop(S) as defined in Par. 3.5.2 to-
gether with the closure operator defined in Par. 3.5.4. Notice that the re-
sult proved in Par. 3.5.10 shows that every signature morphism induces a
morphism between the corresponding closure systems.

3.6.3 Definition/Proposition - Theories in Closure Systems

Consider a closure system <L,c>.

1. We say that &CL is closed iff &=c(<P).



54 3 Building Categories

2. We define the category THEO<Lc> whose objects (theories) are the
closed subsets of L and morphisms are given by inclusions.

3. We define the category PRES<Lc> whose objects (theory presentations)
are the subsets of L and morphisms given by the preorder <P<F iff
c(O)Cc(r).

4. We define the category SPRES<Lc> whose objects (strict presentations)
are the subsets of L ordered by inclusion.

Proof
These are trivial examples of categories that are given through preordered sets. •

We call the objects of SPRES<LC> "strict presentations" because the
morphisms require that the axioms be preserved. The more attentive
reader will have noticed that these notions do not coincide exactly with the
definitions used in Sect. 3.5 because they do not contemplate changes of
language. We generalise these notions in later sections to account for re-
lationships between theories in different languages. The following propo-
sition defines several relationships between these categories. For simplic-
ity, we omit the underlying closure system.

3.6.4 Proposition

1. THEO is a full subcategory of PRES (and of SPRES), and SPRES is a
subcategory of PRES.

2. THEO is a reflective subcategory of PRES (and of SPRES), but
SPRES is not.

3. THEO is a coreflective subcategory of PRES (but not of SPRES) and
so is SPRES.

Proof
1. The proof that THEO is a (full) subcategory of SPRES and PRES is trivial.

The result that SPRES is a subcategory of PRES is an immediate consequence
of the monotonicity of the closure operator. This subcategory is not full be-
cause theorems may be preserved even if the axioms are not.

2. The first results are about closure as a reflector. We prove that, given an arbi-
trary presentation 0, its reflector is its closure c(&). There are two parts in the
proofs: (1) the very existence of the reflector as a morphism; (2) its universal
property. All the reasoning evolves around the following diagram:

•c(<&)

In the case of THEO as a subcategory of PRES, part 1 translates to
c(<P)Cc(c(&)), which is a corollary of the reflexivity of the closure relation.
Part 2 translates to c(0)Cc(0[) implies c(0)C<P' because the morphism on
the right is in THEO. This holds because, being a theory, c(&')=&'.



3.6 Closure Systems 55

• In the case of THEO as a subcategory of SPRES, part 1 translates to the in-
clusion 0Cc(<P) because the morphism is now strict. Again, this is a corol-
lary of the reflexivity of the closure relation. Part 2 translates to &C<p' im-
plies c(0)C0' because the morphism on the right is in THEO and the one
on the left is strict. This is a consequence of the monotonicity of the closure
operator and the fact that, being a theory, c(&')=&'.

• The fact that SPRES is not a reflective subcategory of PRES can be inferred
from part 2: c(<P)Cc(<P') implies c(&)C<P' does not necessarily hold because,
being a presentation, <PX is not necessarily closed.

• Summarising, on the side of reflections, these results capture the fact that,
for the purposes of "outward communication", i.e. for being interpreted,
presentations can delegate on theories but not on strict presentations be-
cause, whereas the former will use the full theory for the interpretation, the
latter will only look at relationships between axioms.

The second set of results is about the coreflective properties of closure. The
relevant "diagram" now is:

•

• In the case of THEO as a subcategory of PRES, part 1 translates to the in-
clusion c(c(<P))Q:(&), which is a corollary of the idempotence of the closure
operator. Part 2 translates to c(&')Cc(<P) implies <t>'Cc(<P) because the mor-
phism on the left is in THEO. This holds because of reflexivity.

• The fact that THEO is not a coreflective subcategory of SPRES can be in-
ferred from part 1: the inclusion c(<P)C& does not necessarily hold because,
being a presentation, 0 is not necessarily closed.

• In the case of SPRES taken as a subcategory of PRES, part 1 translates
again to the inclusion c(c(<P))Cc(0). Because the morphism on the left is
strict, part 2 translates once again to c(<P')£c(<P) implies &'Cc(<P), which is a
consequence of reflexivity. •

Summarising, on the side of coreflections, the existence of a coreflec-
tion from strict into loose interpretations reflects (pun intended) the fact
that in order to interpret another theory presentation, a given theory pres-
entation just needs to consider the axioms of the source. On the other
hand, because strict presentations are not expressive enough to interpret
theories, they do not admit theories as coreflectors, i.e. they cannot allow
theories to handle their in-communication.

Globally, this result shows that theories and theory presentations with
the looser notion of morphism define, essentially, the same structure. The
same does not happen with strict presentations. Strict presentations can
coreflect presentations and be reflected by theories, but not the other way
around because they are not expressive enough to capture closure.



4 Universal Constructions

We have already hinted to the fact that category theory provides a totally
different approach to the characterisation of a given domain of objects,
namely to the fact that objects are characterised by their "social life", or
interactions, as captured by morphisms. In this chapter, we take this view
one step further by showing how certain objects, or constructions, can be
characterised in terms of standard relationships that they exhibit with re-
spect to the rest of the universe (of relevant constructions). It is in this
sense that these constructions are usually called "universal". At the same
time, we shift our focus from the social life of individual objects to that of
groups or societies of interacting objects.

Indeed, in this chapter, we shift some of the emphasis from the ma-
nipulation of objects to that of diagrams as models of complex systems.
Diagrams can be taken as expressions of what are often called configura-
tions, be it configurations of running systems as networks of simpler com-
ponents, the way complex programs (text) or specifications are put to-
gether from modules, the inheritance structures according to which
program modules are organised, etc. This where the term universal con-
jures up general principles such as Goguen's famous dogma [57]: "given a
category of widgets, the operation of putting a system of widgets together
to form a super-widget corresponds to taking a colimit of the diagram of
widgets that shows how to interconnect them".

One of our goals with this book is to make the software community
aware that, like in the other domains of science and engineering, there are
universal laws or dogmas in our area that can manifest themselves in dif-
ferent ways but be unified under a "categorical roof. For instance, we
show that the relationship between composition and conjunction, as de-
bated in [112], is universal in a very precise, mathematical way, which is
precisely the one captured by Goguen's dogma.

This chapter is only an entry point to the ways category theory can ad-
dress the complexity of system development. Subsequent chapters will
introduce further constructions, techniques and applications.



58 4 Universal Constructions

4.1 Initial and Terminal Objects

At least at first sight, the first universal constructions that we define are not
so much constructions but identifications of distinguished objects. What
distinguishes them from the other objects are what are usually called "uni-
versal properties", a term that is associated, and used interchangeably in
the literature, with "universal construction".

4.1.1 Definition - Initial Objects

An object x of a category C is said to be initial iff, for every object y of C,
there is a unique morphism from x to y. •

4.1.2 Proposition

1. Any two initial objects in a given category are isomorphic.
2. Any object isomorphic to an initial object is also initial.

Proof
1. Let x and y be initial objects, and/:;t^»v and g:y—*x the associated morphisms

given by their universal properties. Consider now the morphism (f;g):x—>x.
Because x is initial, we know that there is only one morphism with x as source
and target. Hence, (f;g)=idx. The same reasoning applied to y returns (g;f)=idy,
showing that x and y are isomorphic.

2. Left as an exercise. •

Hence, we usually refer to the initial object, if one exists, and denote it by
0. The unique morphism from an initial object 0 into an object a is de-
noted by 0a.

0 ^ a
0a

4.1.3 Examples

1. In SET, the initial object is the empty set. This is because the empty set
can be mapped to any other set in a unique way: through the empty
function. This justifies the notation 0 usually adopted for initial objects.

2. In LOGI, the initial object is 1 (any contradiction). This is because
anything can be derived from a contradiction. This is consistent with
the use of the notation 0 (as the truth value for false) for initial objects.

3. In PAR, the initial object is also the empty set: all functions from the
empty set are, in fact, total; hence it is not surprising that we get the
same initial object as in SET.

4. In SET±, the initial objects are the singletons <{a},a>. This is because
there is one and only one way of mapping the designated object of a
pointed set: to the designated element of the target pointed set. Notice



4.1 Initial and Terminal Objects 59

that, although SET± was built over SET, the initial objects of the two
categories do not coincide. Indeed, when adding structure to a given
category to make another category, the universal constructions may
change precisely because the structure has changed. Nevertheless, the
spirit of emptiness is still there - <{a},a> has no "proper" elements. •

4.1.4 Definition - Terminal Objects

An object is terminal in a category C iff it is initial in Cp. That is, x is
terminal in C iff, for every object y of C, there is a unique morphism from
y to x. •

Once again, any two terminal objects are isomorphic and, therefore, we
usually refer to the terminal object of a category, if one exists. A terminal
object is usually denoted by 1 and the unique morphism from an object a is
denoted by la.

1 «* a
l a

4.1.5 Examples

1. In SET, the terminal objects are the singletons. This is because there is
one, and only one way of mapping any given set to a singleton: by map-
ping all the elements of the source set (even if there is none...) to the
element of the singleton. Any set with more than one element is clearly
not terminal because it provides a choice for the target image of any
element of the source set, i.e. it does not satisfy the uniqueness criterion.
The empty set is not terminal because it only admits total functions from
itself, i.e. it does not satisfy the existence criterion.

Notice that all singletons are indeed isomorphic in SET. This is con-
sistent with what we said before about the way category theory handles
sets as objects: because we are not allowed to look into a set to see what
elements it has, there is no way we can distinguish two singletons in
terms of their structural properties. This also justifies the use of the no-
tation 1 for arbitrary terminal objects.

On the other hand, any singleton can be used to identify the different
elements of any non-empty set A by noticing that each element aEA de-
fines, in a unique way, a function a:l—»A. Indeed, following the idea
that morphisms characterise the "social life" of the objects of a cate-
gory, the social relationships that a singleton set can establish with an
arbitrary non-empty set characterise precisely the elements of that set.

The reader may wish to return to Pars. 2.2.12 and 2.3.5 to see exam-
ples that make use of this analogy, the notation {•} being used for "the"
terminal set. This idea can be generalised to any terminal object lc in
an arbitrary category C as a mechanism for identifying what, in category



60 4 Universal Constructions

theory, are called points [75], constants [12] or global elements [22] of
an object x: morphisms of the form 1 —>x.

2. In LOGI, the terminal object is T (any tautology). This is because any
tautology can be derived from any other formula. Again, this is also
consistent with the use of the notation 1 (the truth value for true) for
terminal objects.

3. In PAR, the terminal object is also the empty set: there is always one
and only one way of mapping any set to the empty one - through the
partial function that is undefined in all the elements of the source!
Hence, in PAR, the initial and the terminal objects coincide. Objects of
an arbitrary category that are both initial and terminal are sometimes
called null [80] or zero [1] objects.

Notice that, in spite of being a subcategory of PAR, SET has different
terminal objects. On the one hand, the undefined function not being to-
tal, the empty set cannot play the role of terminal object in SET. On the
other hand, because sets in PAR have a richer social life, i.e. more mor-
phisms, the singletons in PAR relate differently to other sets than they
do in SET. In particular, besides the constant (total) function, they also
admit the (partial) undefined one. Indeed, categories cannot be ex-
pected to share the same kind of initial/terminal objects with their sub-
categories, unless there is some special structural property that justifies
so (see exercise below).

4. In SET±, the terminal objects are also the singletons <{a},a>. Hence, in
SET±, the initial and the terminal objects also coincide. •

4.1.6 Exercises

1. Let C be an arbitrary category and a:C. Show that ida is initial in a\,C.
Further show that if a is terminal in C, ida is terminal in a IC.

2. Show that the category SET± of pointed sets as introduced in Par. 3.2.1
"corresponds" to the comma category 1 J,SET as defined in Par. 3.2.2.
This correspondence is what is Sect. 5.1 is called an isomorphism of
categories. What can be said about the category SET 11 as defined in
Par. 3.2.3?

3. Show that, in any preorder (see Par. 2.2.5), initial (resp. terminal) ob-
jects coincide with the minimum (resp. maximum), if they exist.

4. Show that, if D is a full subcategory of C, any initial (resp. terminal)
object of C that is an object of D is also initial (resp. terminal) in D. •

4.1.7 Example - Eiffel's Inheritance Structure

The inheritance structure of Eiffel has an initial object - the class NONE
that inherits from every other class, and a terminal object - the class
GENERAL from which every other class inherits.

The following diagram is, once again, copied from [86].



4.1 Initial and Terminal Objects 61

4.2 Sums and Products

Intuitively, the universal constructions that are the theme of this chapter
concern the possibility of finding objects that are able to capture the social
lives of whole collections of objects and morphisms showing how the ob-
jects relate to one another. This is because, for instance, we are interested
in the study of properties of whole systems, e.g. emergent behaviour,
rather than isolated objects. The obvious questions that we have to answer
are: What exactly is meant by a collection? What is the social life of such a
collection of interacting objects?

Leaving the first question out of the discussion for a while, and relying
on an intuitive level of understanding for the time being, we start with a
simple example. Not the simplest, though: this would be for collections
consisting of only one object, in which case only isomorphic objects would
have a social life that is able to capture the one of the given object. The
simplest non-trivial example is that of a collection of two objects with no
interactions between them, for instance two processes running in parallel
with no communication between them, or two software modules with no
dependencies between them.

Consider first the characterisation of the out-going communication for
such a collection x, y of objects. We say that, as a collection, x and y inter-
act with other objects v via morphisms fx:x—*v,fy:y-*v. For instance, to
say how a software module v uses x and y collectively, we have to say how
it uses each of them in particular. This is because there are no dependen-



62 4 Universal Constructions

cies between x and y, otherwise we would have to express the fact that
these dependencies are respected.

An object that is able to stand for the relationships that a collection x, y
of objects has towards its environment is called their sum and is denoted
by x+y. In fact, the sum is more than an object. We need to make explicit
how x and y relate to it. This requires morphisms (injections) ix:x-*x+y
and iy:y->x+y. The ability for this object and the connecting morphisms to
characterise the relationships that the collection has towards its environ-
ment can then be expressed by the property that any such interaction
fx:x—*v,fy:y-*v can be performed via x+y in the sense that there is a unique
morphism k:x+y-*v through which fx andfy can be intercepted, i.e. ix;k=fx
and iy;k=fr The morphism k is often represented by [fx,fy].

4.2.1 Definition - Sums

Let C be a category and x,y objects of C. An object z is a sum (or copro-
duct) of x and y with injections ix:x—*z and iy:y—*z iff for any object v and
pair of morphisms fx:x->v, fy:y —>v of C there is a unique morphism k:z->v
in C such that ix;k=fx and iy;k=fy. •

In order to express, in diagrams, that the objects and morphisms in-
volved are related by a universal construction, we use the symbols
G^ and Cî  according to rules that we will make explicit in each case. For
instance, in the case of sums,

9
x+y

The exact identity of the sum is of no importance, just the way in which
it relates to the other objects. Hence, the following property holds.

4.2.2 Proposition

Let C be a category and x,y objects of C. If a sum of x and y exists, it is
unique up to isomorphism and is denoted by x+y.



4.2 Sums and Products 63

Proof
Let z be a sum of x and y with injections ix:x—*z and iy:y—>z, and w another sum of
x and y with injections jx:x-*w and yr7-*w. By the universal property of z, we can
conclude that there is a morphism k:z—*w such that ix;k=jx and iy;k=jy. Applying
the same reasoning to w, we conclude that there is a morphism l:w-*z such that
jx;l=ix and jy;l=iy. Consider now the morphism (k;l):z-*z- It satisfies:
ix;(k;l)

= (ix;k);l associativity of the composition law,
= jx;l universal property of ix,
= ix universal property of jx.

Similarly, we can prove that iy;(k;l)=iy. The universal property of z, ix and iy im-
plies that there is only one morphism z~*z satisfying this property. This implies
that (k;l)=idz. Using the universal property of w, jx and/,, we can prove in exactly
the same way that (l;k)=idw. Therefore k is an isomorphism. •

4.2.3 Example - Logical Disjunction

1. In LOGI, sums correspond to disjunctions.
2. In PROOF, sums also correspond to disjunctions. Indeed, the sum of A

and B is a sentence characterised by morphisms that capture the intro-
duction and elimination rules for the disjunction as a logical operator:

iA:A ->A vB iB:B^A vB

fA:A->C,fB-.B-*C
[fA,fB]:A\/B — C

Notice that the conditions required of these three morphisms (deriva-
tions) correspond to typical properties of normalisation in proof-theory. •

Other well-known properties of disjunction can be captured in such a
"universal" way.

4.2.4 Exercise

Let C be a category and 0 an initial object of C. Show that, for every ob-
ject x, the sum x+0 exists and ix is an isomorphism, i.e. x+0 "is" x. •

4.2.5 Example - Disjoint Union of Sets

In the category SET, the disjoint union x®y (with corresponding injec-
tions) is the sum of x and y.

Proof
1. Existence: consider an arbitrary object v and pair of morphisms fx:x—*v, fy:y-*v.

Define k:x®y-*v as follows: given AEx®y, let k(A)=fJa) if A=ija) with aEx
and k(A)=fy(a) if A=iy(a) with aEy. This is a proper definition of a total func-
tion because, on the one hand, every element of x®y is either in the image of x



64 4 Universal Constructions

through ix or the image of y through iy and, on the other hand, these two images
are disjoint (which removes any conflict of choice between which case to ap-
ply). The conditions ix;k=fx and iy;k=fy are satisfied by construction.

2. Uniqueness: given any other total function k':x®y-*v, the conditions ix;k'-fx
and iy;k'-fy define k' completely (and equal to k). •

In order to illustrate the construction and show why the union of sets is
not (necessarily) their sum, consider the following example where fx and/>,
are set inclusions. The injections are such that ix(a)=ax and iy(a)-ar By
construction, [fx,fy] is such that [fx,fy](ax)=[fx,fy](ay)=a. The union {a,b,c}
does not provide a sum through the corresponding inclusions because there
is no total function l:{a,b,c}^>{ax,ay,b,c} that satisfies the commutativity
conditions. Indeed, these require l(a)=ax because ax=ija) and l(a)=ay be-
cause ay=iy(a).

{a,b} {a,c}

{a,b,c}

Intuitively, this happens because the union is an operation that "looks"
inside the sets to which it is being applied in order not to repeat the ele-
ments that they have in common. That is, it is an operation that relies on
an interaction between the sets to which it applies, whereas the sum is de-
fined over objects without any relationship between them.

This construction illustrates how, in category theory, all interactions
need to be made explicit and external to the entities involved. That is, we
cannot rely on implicit relationships such as the use of the same names in
the definition of different objects. This may sound too "bureaucratic", but
we are far from suggesting that category theory should be used directly,
that is "naked", as a language for specification, modelling or even pro-
gramming. We view category theory as a mathematical framework that
supports those activities. Hence, the need for an explicit and external rep-
resentation of all interactions is, in our opinion, a bonus because it en-
forces directly fundamental properties of the methodology that is being
supported, service-oriented in the most general case, but also component
or object-oriented as amply demonstrated in the literature.

In the next section, we address constructions that involve interactions.
In the rest of this section, we look at the dual construction of sums: prod-
ucts. We do so extensionally, i.e. by providing the definition of the con-
struction directly. The reason for doing so in spite of knowing already that



4.2 Sums and Products 65

it is enough to reverse the direction of the arrows, is that, from a "prag-
matic" point of view, one is "naturally" biased by the direction of the ar-
rows and, in certain contexts, tradition is that one uses products instead of
sums. Our experience in using and teaching category theory is that argu-
ments and misunderstandings are too often caused by being presented with
the duals of constructions that otherwise would be very familiar! Hence, it
is important that we know these more basic constructions explicitly in both
forms rather than having to translate back and forth every time between a
category and its dual.

4.2.6 Definition - Products

The dual notion of sum is product. That is, letting x, y be objects of a cate-
gory C, a C-object z is a product of x and y with projections nx:z—>x and
ny:z~*y iff for any object v and pair of morphisms fx:v—*x,fy:v—>y of C
there is a unique morphism k:v->z in C (often denoted by <fx,fy>) such that
k;ix=fx and k;iy=fy. •

Products handle the relationships from the environment towards collec-
tions of two unrelated objects. It is easy to see that, in SET, the product of
two sets is given, up to isomorphism, by their Cartesian product. In LOGI,
products capture conjunction, which is consistent with its traditional status
as the "dual" of disjunction.

4.2.7 Example - Parallel Composition Without Interactions

In the category SET± of pointed sets, products are constructed in the same
way as in SET. The Cartesian product of two pointed sets includes all
pairs of "proper elements", the pairs of which one and only one of the
elements is a designated one, and the pair of designated elements. We
claim that, together with the projections, this Cartesian product is still a
product of the pointed sets. On the one hand, it is trivial to prove that if
we elect the pair of designated elements as the designated element of the
product, we obtain morphisms of pointed sets through the original SET-
projections. On the other hand, the commutativity requirements ensure
that all the universal functions <fx,fy> are morphisms of pointed sets, i.e.
preserve designated elements. In other parts of the book, we make use of
this style of argument in the proof of universal properties for certain cate-
gories with structure.

As an example, consider the use of pointed sets for modelling the alpha-
bets of concurrent processes, as suggested in Par. 3.2.1. Products of al-
phabets give us all the possible events in which both processes participate
(a/b, as a representation of the pair <a,b>, in the case below), plus all pos-
sible events in which only one process participates (lA/b and aj±B in the
case below), and the "silent" environment event in which none of the
processes participates (J-AjlB in the case below).



66 4 Universal Constructions

<{a,XA},XA> <{b,XB},XB>

9
<{a|b,XA|b,a|XB,XA|XB},XA|XB>

In order to simplify the notation, both textual and graphical, we nor-
mally hide the designated element as in

Notice in particular that the events in which only one process participates
are represented by the event of that process.

In the specific case in which we identify events with synchronisation
sets of method execution, the product provides for joint executions as dis-
joint unions of synchronisation sets. To be more precise, when we work in
POWER (see Par. 3.3.2), we can take as a representation of a pair <a,b>
the set a®b. This is because, as sets, the Cartesian product 2Ax2B is iso-
morphic to 2Am, and the isomorphism is given precisely by the map that
associates pairs <a,b> with sets a@b. This is to show that, because uni-
versal constructions are only unique up to isomorphism, we can choose
from the isomorphism class the representation that suits us best. In this
case, it justifies a uniform treatment of concurrent process alphabets as
synchronisation sets.

In summary, through products, we obtain the alphabet of the process
that is the interleaving of the given ones. •

4.2.8 Exercise

Characterise products and sums of partial functions (i.e. in PAR). Show in
particular that sums work like in SET, i.e. they compute the disjoint union,
but that products, besides the pairs that result from the Cartesian product,
include the disjoint union of the two sets as well. That is, products in PAR
are very "similar" to those in SET±. Why do you think this is so? What
about sums in SET±1 How do they compare? •

4.2.9 Example - Inheritance Without Name Clashes

In Eiffel, products capture "minimal" inheritance without name clashes, a
typical example being the following hierarchy, copied again from [86]:



4.2 Sums and Products 67

As argued in Par. 2.1.3, when the sets of features of the classes in an in-
heritance graph are considered, the direction of the corresponding arrows
is reversed. As a result, the universal construction on the underlying fea-
tures is a sum:

{orange, apple} {red.orange}

{orangejruit, apple, red, orange_colour}

{orangejruit, apple, red, orange_colour,gin}

The "automatic renaming" associated with this categorical construction
is very useful because it makes sure that no confusion arises from the in-
advertent use of the same names for different "things" in different con-
texts. This is why the injections/projections are an integral part of the con-
cept of sum/product: they keep a record of the renamings that take place,
i.e. of "who is who" or, better, "who comes from where".

However, in many situations we want to make "joins", i.e. identify
things that are meant to be the same but were included in different con-
texts. For instance, how to require that two processes synchronise on
given events? How to require that features declared in different object
classes be identified when performing multiple inheritance? This is the
purpose of the universal construction that we illustrate next.

4.3 Pushouts and Pullbacks

A distinguishing factor of category theory, and one that makes it so suit-
able for addressing architectural concerns and service-oriented develop-
ment in software engineering, is that such forms of interaction are exoge-
nous, i.e. they have to be established outside the objects involved. For



68 4 Universal Constructions

instance, interactions in object-oriented development are endogenous be-
cause feature calling (clientship) is embedded explicitly in the code of the
caller (client). In category theory, the means that we have for establishing
interactions is through third objects that handle communication between
the ones that are being interconnected via given morphisms. In the case of
sums, we are dealing with interactions at the level of the sources, i.e. we
are interested in the social life of pairs of morphisms f:x—*y, g:x—>z. In the
case of products, the interactions are on the target side, \.&.f:y-*x, g:z~*x.

4.3.1 Definition - Pushouts

Let f:x—*y and g:x-*z be morphisms of a category C. A pushout of/and g
consists of two morphisms f:y-*w and g':z-*w such that:

• f;f=g;g'-
• For any other morphisms/'.-y —>v and g":z~>v such that f;f"=g;g", there

is a unique morphism k:w—*v in C such that/;&=/' and g';k=g".

z

Notice the use of the symbol G^ as in the case of sums. •

4.3.2 Example - Amalgamated Sums of Sets

In SET, pushouts perform what are usually called amalgamated sums, i.e.
they identify (join) elements as indicated by the "middle object" and corre-
sponding morphisms. For instance, in the example below, the morphisms
indicate that elements b and d are to be identified. Because nothing is said
about c, the categorical default applies: the two occurrences are to be dis-
tinguished because the fact that the same name was used is accidental.

{c,d}

{a} O {e,Cl,c2}

\ /
4̂ / d->c,
{b,c}



4.3 Pushouts and Pullbacks 69

The proof that what we have built is actually a pushout can be outlined
as follows. On the one hand, the commutativity requirement is clearly
satisfied. On the other hand, for the universal property, consider given
functions f:{c,d}-*A and g:{b,c}->A satisfying the commutativity require-
ment: f(d)=g(b). Any function k:{e,chc2}-*A that satisfies the commuta-
tivity requirements of the universal property must be such that k(e)=f(d),
k(e)=g(b), k(c,)=g(c) and k(c2)=f(c). These requirements leave no other
choice for defining k, hence uniqueness is ensured. Because these re-
quirements are consistent, which is due to the fact thatf(d)=g(b), existence
is also ensured. •

More interesting than this proof is the mechanism through which
pushouts can be systematically constructed in SET. This is revealed once
we address the process of computing pushouts in more general terms.

4.3.3 Example - Multiple Inheritance in Eiffel

Pushouts are the universal construction that allows us to join (merge) fea-
tures during multiple inheritance. For instance, in [86], the construction of
HOME_BUSINESS merges the home and business addresses:

{address,insured_value}

A

{address,insured_value,A} {address,insured_value,B}

{address,residence_value,
business_value,A,B>

I

{address,residence_value,business_value,A,B,C} .

Let us now return to the definition of pushout and explain how the inter-
actions operate. The definition consists of two main requirements: a
commutativity condition and a universal property. The universal property
is just an instance of a "ritual" that we explain in the next section. For the
time being, notice how similar it is to the corresponding property of sums,
and try to see where it lies in the definition of initial object.

The commutativity requirement is the one responsible for the "amalga-
mation" or, more generally, for encapsulating the interactions in place. In
the case of SET, the amalgamation takes place as a quotient defined over
the sum of the objects for an equivalence relation that is defined by the



70 4 Universal Constructions

middle object and the connecting morphisms. If we take two morphisms
f:x-*y, g:x-*z and we can find a sum for y and z, we obtain a square like
before except that it does not necessarily commute.

For instance, consider the following diagram:

{C,d}

ai->d

{a} {b,d,Ci,c2}

{b,c}

This diagram does not commute because, if we pick a in the middle object
and follow all the paths from it, we do not arrive at the same element: one,
via b, terminates in ci and the other, via d, in c2.

In order to enforce commutativity, we have to "equalise" the ends of
these paths. Category theory does not perform miracles (yet), so it cannot
make equal entities that are actually different. What we usually do in
mathematics is to define an equivalence relation expressing that, albeit
being different, these endpoints should be considered the same as far as the
system (as expressed by the diagram) is concerned.

In SET, this equivalence relation is defined as being generated from all
pairs f(iy(a))zsg(iz(a)), where aEx. We claim that the quotient set of the
sum y@z by this equivalence relation together with the functions [iy(_)J
and [iz(_)J that assign, to the elements of the given sets y and z, their
equivalence classes, is a pushout of/and g.

y

The proof of this result is not that difficult because the whole construc-
tion was made to ensure commutativity, i.e. [iy(f(a))]=[iz(g(a))] for every
aEx, which is precisely the set of pairs iy(f(a))&iz(g(a)) that generate the
equivalence relation.

The universal property can now be derived from the universal properties
of the sum (in grey in the figures) and quotients:



4.3 Pushouts and Pullbacks 71

1. Consider any other two morphisms/":y—>v and g":z—>v such that/,/"=g;g".

2. We know from the universal property of the sum that there is a unique mor-
phism k:y®z—*v such that iy;k=f and iz;k=g".

3. The morphism k also equalises the pairs <iy(f(a)),iz(g(a))>:

k(iy(f(a)))
=f(f(a)) from 2,
= g"(g(a)) from 1,
= k(iz(g(a))) from 2.

4. From the properties of quotients, we know that there is a unique way in which
this map can be factorised through [_] i.e. there is a unique k':y®z/^—>v such
that k=[_];k'. Using associativity of morphism composition, this provides us
with the required unique morphism satisfying (iy;[_J);k'=f and (iz;[_J);k'=g".

How can we generalise the quotient construction to categories in gen-
eral? Taking the diagram above to be over an arbitrary category C, the
purpose of the quotient is to make the following diagram commute:

f; iv

The idea is to do so via a third morphism e:y@z~*v whose purpose is to
replace the initial equality f;iy=g;iz by (f;iy);e=(g;iz);e. However, there are
many ways of doing so. One of them is to choose v to be a terminal object
(if one exists), but this is clearly too intrusive on the given morphisms be-
cause it over-equalises them. We prefer to do it in a minimal way, which
is what the universal property of quotients provides: for any other mor-
phism e':y®z—>w that also equalises the morphisms, i.e. such that
(f;iy);e'=(g;iz);e\ there should be a unique k:v-*w such that e;k=e\



72 4 Universal Constructions

This is precisely another instance of a universal construction.

4.3.4 Definition - Coequalisers

Let C be a category and f:x-*y, g:x—>y morphisms of C. A coequaliser of
/and g consists of a morphisms e:y->z such that
• f;e=g;e.
• For any other morphisms e':y-*v such that/;e'=g;e', there is a unique

morphism &:z—*v in C such that e;k=e\ •

4.3.5 Exercises

1. Prove that pushouts can be obtained from sums and coequalisers.
2. Prove that coequalisers are a particular case of pushouts.
3. Prove that, if initial objects exist, sums can be obtained from pushouts. •

The following exercises concern typical properties of pushouts that are
quite useful. Their proofs also reveal a lot about the structures involved.

4.3.6 Exercises

1. Prove that the universal arrow e in a coequaliser is epic (thus generalis-
ing the fact that a quotient map is surjective).

2. In a pushout diagram as below, prove that if g is epic, so i s / .
y

vv

3. Consider a commutative diagram

h1

Prove that if both internal squares are pushouts so is the external rectan-
gle, and that if the external rectangle and the left square are pushouts, so
is the right square. •

Let us consider now the dual of pushouts.



4.3 Pushouts and Pullbacks 73

4.3.7 Definition - Pullbacks
Let f:y—>x, g:z—*x be morphisms of a category C. A pullback (or fibred
product) of/and g consists of morphisms f:w—*y and g':w->z such that

• f;f=g';g-
• For any other morphisms f':v-*y, g":v-*z such thai f";f=g";g, there is a

unique C-morphism k:v-*w such that k;f=f and k;g'=g". •
Pullbacks can also be explained from products and a construction that

equalises arrows, except that this time the equalising needs to be made on
the source and not the target side of the arrows. Not surprisingly, this uni-
versal construction is named equaliser, the dual of coequalisers.

Whereas, in set-theoretic terms, we saw that equalising on the target
side corresponds to taking a quotient to group entities that should be
"equal" in the same equivalence relation, equalising on the source side is
even conceptually easier: it is enough to restrict the domain by throwing
away the elements over which the two functions disagree. That is, we
equalise through the inclusion {aEy: f(a)-g{a)}Qy•

m
{aey: f(a)=g(a)} • y

Hence, computing a fibred product consists of computing a product
followed by a "purge" of the pairs that violate the commutativity require-
ment. We illustrate this procedure with process alphabets.

4.3.8 Example - Parallel Composition With Interactions

We have already argued that in the category SET± of pointed sets, prod-
ucts are constructed in the same way as in SET through Cartesian prod-
ucts. When the pointed sets capture process alphabets, we saw that this
construction captures parallel composition without synchronisation in the
sense that all the pairs of events are generated in an interleaving semantics.
Fibred products allow us to compute parallel composition with synchroni-
sation constraints.

For instance, consider two process alphabets <{produce,store,±P},±P>
and <{consume,retrieve,lc},lc>. The alphabet of the parallel composi-
tion of the two processes when required to synchronise in the store and
retrieve events can be obtained through the pullback of:

{sync}

store H» sync if ft retrieve h-» sync

{produce,store} {retrieve,consume}



74 4 Universal Constructions

Notice that, as mentioned in Par. 4.2.7, and for simplicity, we have
omitted the designated elements from the representations of the pointed
sets and will only show the proper events. The middle object models the
alphabet of the "cable" that is being used to interconnect the two proc-
esses. The maps mean that store and retrieve are being synchronised, with
sync providing the place of their "rendez vous".

The product of the two alphabets gives us:

{sync}

{retrieve,consume}{produce,store}

{produce|retrieve, produce|consume,
storejretrieve, store|consume,

produce, store, retrieve, consume}

Recall that the events of the given processes are recovered as a result of
synchronisations with the designated event, thus capturing system events
in which only one of the two processes participates.

Notice that the diagram does not commute. For instance, the system
event storejconsume is mapped on the left to sync, but on the right to the
designated event of the cable. In order to make the diagram commute, we
throw away all events on which the maps to the channel do not agree:

{sync}

store h-> sync retrieve t—» sync

{produce,store} {retrieve,consume}

{produce|retrieve, produce|consume,
store|retrieve, store|consume,

produce, store, retrieve, consume}

{produce|consume, store|retrieve,
produce, consume}



4.3 Pushouts and Pullbacks 75

Basically, the events that remain are all possible combinations of exe-
cuting produce and consume because there is no synchronisation constraint
on them, plus the synchronisation that is explicitly required. •

4.3.9 Exercise

Follow up on Par. 4.2.8 by characterising fibred products and amalga-
mated sums of partial functions (i.e. in PAR) and relating them to SET and
SET±. •

4.3.10 Exercises

1. Define explicitly the notion of equaliser and prove that pullbacks can be
obtained from products and equalisers as suggested.

2. Prove that equalisers are a particular case of pullbacks.
3. Prove that, if terminal objects exist, products can be obtained from pull-

backs.
4. Prove that the equalising arrow m is a mono. •

4.4 Limits and Colimits

It should be clear by now that the notion of collective behaviour that we
wish to capture through universal constructions takes diagrams as the ex-
pression of the collection of objects and interactions that constitute what
we could call a system. In fact, we tend to use diagrams to deal with com-
plex entities for which the objects of the category provide components and
the morphisms the means for interconnecting them. Hence, for instance, a
typical use of diagrams is for defining configurations. The universal con-
structions that we address in this chapter allow us to define the semantics
of such complex entities by internalising the configuration and collapsing
the structure into an object that captures the collective behaviour.

An aspect of these universal constructions that is important to keep in
mind is the fact that they deliver more than an object: this object comes to-
gether with morphisms that relate it to the objects out of which it was con-
structed. It is through these morphisms that we can understand how prop-
erties of the system (complex object) emerge from the properties of its
components and the interconnections between them. Hence, the construc-
tions are better understood in terms of structures that consist of objects to-
gether with configurations to which they relate, what are called (co)cones.

4.4.1 Definition - Cocones

Let 8:1->C be a diagram in a category C. A cocone with base 8 is an ob-
ject z of C together with a family {pa:8a—>z}aa of morphisms of C, usually
denoted by p:8->z. The object z is said to be the vertex of the cocone, and,



76 4 Universal Constructions

for each aEI0, the morphism pa is said to be the edge of the cocone at point
a. A cocone p with base 5:I-*C and vertex z is said to be commutative iff
for every arrow s:a^b of graph /, ds;ph=pa. •

We tend to consider the family p of morphisms as identifying how the
source is represented in, or is a component of the target, that is the object z.
The commutativity property is important because it ensures that the inter-
connections that are expressed in the base through the morphisms are also
represented in z. Hence, z is an object that is able to represent the base
objects and their interactions. However, it may not do so in a "minimal"
way. If a minimal representation exists, we call it a colimit of the diagram.

4.4.2 Definition - Colimits

Let 5:I->C be a diagram in a category C. A colimit of 5 is a commutative
cocone p:5—>z such that, for every other commutative cocone p':6->z',
there is a unique morphism f:z~*z' such that p;f=p', i.e. pa;f=p'a for every
edge. Colimit cocones are decorated with



4.4 Limits and Colimits 77

Notice how all the ingredients used in the universal constructions stud-
ied in the previous sections are present in this definition. On the one hand,
there is a commutativity requirement. On the other hand, a universal prop-
erty ensures minimality.

4.4.3 Exercise

Show that initial objects, sums, coequalisers and pushouts are instances of
colimits by identifying the shape of the base diagrams and checking that
the properties required are equivalent. •

Cocones over a given base can be organised in a category of their own.

4.4.4 Definition/Proposition

Let 8:1—*C be a diagram in a category C. A category CO_CONE(8) is de-
fined whose objects are the commutative cocones with base 5, and the
morphisms / between cocones p:6—>z and q:8—>w are the morphisms
f:z—*w such that p;f=q, i.e. pa;f=qa for every edge. •

4.4.5 Exercises

1. Prove the previous result.
2. Prove that the colimits of <5 are the initial objects of CO_CONE(d).
3. Conclude that colimits are unique up to isomorphism. •

4.4.6 Definition - Cocompleteness

A category is (finitely) cocomplete if all (finite) diagrams have colimits. •
There are several results on the finite cocompleteness of categories. A

commonly used one is given below.

4.4.7 Proposition

A category C is finitely cocomplete iff it has initial objects and pushouts of
all pairs of morphisms with common source. •

Using this result and the examples that we studied in the previous sec-
tions, we can conclude, for instance, that both SET and LOGI are finitely
cocomplete. These notions are also straightforward generalisations of
well-known constructions over ordered sets, namely least upper bounds
and greatest lower bounds. A more "interesting" example can be given
over Eiffel class specifications.

4.4.8 Example - Eiffel's "Join Semantics" Rule

The category CLASS_SPEC is finitely cocomplete.

Proof
Once more, the proof is much more interesting than the result. Using the previous
result, we show that CLASSJSPEC admits initial objects and pushouts.



78 4 Universal Constructions

1. It is easy to prove that the class specification that has no features is initial.
2. On the other hand, pushouts work as follows:

• Given a diagram
Spec

Spec! Spec2

we first compute the pushout for the underlying diagram of signatures (sets
of attributes, functions and routines). This pushout returns, for each feature

F 2 Fi \ / F,
 F , \ / F,

A F ^ ^ ^ F R ^ ^ * / R

A1 A'UF1 R'

Recall that, according to the definition of morphism given in Sect. 3.4, func-
tions can be mapped to attributes (but not the other way around)! Hence,
equivalence classes can mix together attributes and functions. The pushout
classifies an equivalence class as an attribute iff it contains at least one at-
tribute, and as a function iff it only contains functions. Routines are not
mixed together with functions or attributes.
For every routine r'£R', we compute its pre/postconditions as follows:

prer.= F,(prer)vF2(prerJ and postr = F1(postr)AF2(postrJ.
If r'=Fj {rt)(£F2 (^2) then pref = F}(prer), and postr. = F1(postr).
If r'=F2 (r2)ffi, (Rj) then prer. = F2(prer), and postr, = F2(postr).

• The new invariant is /' = F,(I,) A F2(I2).
2

The proof that the maps Fj and F2 that result from these constructions are in-
deed morphisms of class specifications is trivial. The commutativity property is
inherited from the pushouts in SET that determine the new attributes and routines.
The universal property is left as an exercise. It reflects the universal properties of
conjunction and disjunction that we already identified in the previous sections. •

Note how this construction matches the Join Semantics rule and inheri-
tance of invariants via concatenation of parent invariants [86].

4.4.9 Exercise

Work out in detail the way pushouts operate on attributes and functions of
class specifications. •

4.4.10 Definition - Cones and Limits

The dual notion of cocone is cone, and the dual notion of colimit is limit.
Limit cones are decorated with G .̂ •



4.4 Limits and Colimits 79

Hence, limits generalise terminal objects, products, equalisers and pull-
backs. From the examples studied in the previous sections, we can also
conclude that both SET and SET± are (finitely) complete.

4.4.11 Example - Parallel Composition with Interactions

In order to illustrate the calculation of limits, consider process alphabets
once again. In the previous section, we showed how we can synchronise a
consumer and a producer on the store/retrieve events. This interconnec-
tion is, however, too tight because it ties the consumer completely to that
producer and does not allow it to consume from other producers. Hence,
the situation that we would like to model now is the one in which the con-
sumer retrieves from a producer but leaves open the possibility of retriev-
ing from other producers as well. This form of interconnection cannot be
achieved simply through a channel as before.

What we have to do is to make explicit a communication protocol that
can be placed in between the producer and the consumer. The alphabet of
this protocol needs to account for the synchronisation between the con-
sumer and the producer, which we model through an event sync, and the
open communication between the consumer and other possible producers,
which we model through an event open.

Omitting, as before, the designated events, this configuration is given by
the following diagram:

{a}

retrieve H-> a

{produce,store} {sync,open} {retrieve,consume}

The dual of Par. 4.4.7 can be used to compute the limit of this diagram
by computing successive pullbacks.

We start with the obvious pullbacks over each of the interconnections:
{a} {a}

{produce,store} {sync,open} {retrieve,consume}

9/ \<P
{produce|open, store|sync, {open|retrieve,

produce, open} sync|retrieve, consume}



80 4 Universal Constructions

We finalise with the pullback of the new arrows, which provides for the
global interaction:

{produce,store} {sync,open} {retrieve,consume}

{ open|retr ieve,
sync|retrieve, consume}

{produce|open, store|sync,
produce, open}

9
{produce|open|retrieve, storejsyncjretrieve,

openjretrieve, produce|consume,
produce, consume}

Using the privilege of choosing among the isomorphic representations
of the limit the one that best reflects our intuition or purpose, we can sim-
plify the notation. For instance, we can omit the reference to the actions of
the communication protocol in the synchronisation sets, although at the
expense of making the morphisms less obvious because they are no longer
projections. Hiding the intermediate constructions at the same time, we
obtain the following commutative cone:

{ a } { a }

s to re H> a sync h-> a
sync h-» a
open I—» a r e t r i e v e H4 a

{produce,store} {sync,open} {retrieve,consume}

tproduce|retr ieve H> openstore|retrieve h-» syncretrieve i-> open
{produce|retrieve, store|retrieve, produce|consume,

retrieve, produce, consume}

This representation makes it obvious that, with respect to the intercon-
nection given in Par. 4.3.8, we are allowing retrieve to occur independ-
ently of store, which justifies why it now appears as a single event (though
synchronised with open) and synchronised with produce (and open). •

Although we have systematically motivated universal constructions
such as these in terms of parallel composition of processes, with and with-



4.4 Limits and Colimits 81

out interaction, we have remained at the level of the composition of proc-
ess alphabets, i.e. we have not taken into account their behaviours. There
are two reasons for this. On the one hand, all the complexity of interaction
resides on alphabets. On the other hand, the way behaviours can be
brought into the picture can be used to illustrate another categorical struc-
ture and construction. Hence, we defer the completion of this topic to
Sect. 6.3 (Pars. 6.3.2 and 6.3.7). For similar reasons, we defer the illustra-
tion of the application of universal constructions to configurations of
specifications to Sect. 6.1 (Par. 6.1.24) so that we can use it to illustrate
another class of categorical structures and constructions.



5 Functors

5.1 The Social Life of Categories

It should come as no surprise that we are also interested in the social life of
categories and, therefore, need to define a corresponding notion of mor-
phism. Indeed, we have said more than once that, when defining a cate-
gory, we are capturing only a particular view or structure of the underlying
objects. There may well be more than one such notion of structure for the
same collection of objects. For instance, in the case of object-oriented de-
velopment, we have already mentioned the structure that relates to the way
objects can be interconnected into systems, and the view that captures re-
finement. There may also be relationships that we wish to study between
two different domains, e.g. Eiffel specifications and processes. Hence, we
need a way of reasoning about relationships between categories.

Because categories are structured objects, more precisely, graphs with
the additional structure given by the identity arrows and the composition
law, the definition of morphisms between categories (functors) should now
look "standard".

5.1.1 Definition - Functors

Let C and D be categories. A functor (p:C—>D is a graph homomorphism
(see Par. 2.1.7) from graph(C) into graph(D) such that:

• <Pi(f;g) = fi(f);<Pi(g) for each path/g in graph(C).
• q>i(idx) = idy M for each node x in graph(C). •

5.1.2 Examples

1. For any category C, the identity functor idc:C^C consists of the iden-
tity map on objects and the identity map on morphisms.

2. For any given functor q>:C->D, its dual qfp:Dop^Cop is defined by the
graph homomorphism that operates the same mappings on nodes and ar-
rows.

3. We define a functor nodes:GRAPH->SET as follows:

• nodes(G0,G1,src,trg)=G0.
• nodes(cp:G—*H)=q>0:G0—*H0



84 5 Functors

4. We define a functor PROOF-*LOGI by mapping sentences to them-
selves and every proof between two sentences to a logical implication
between them. This is an example of a forgetful functor, the details of
the proof are forgotten; only the fact that there exists a proof remains.

5. Another example of a forgetful functor is sign:PRESLTL-^*SET mapping
presentations and their morphisms to the underlying signatures and sig-
nature morphisms. A similar forgetful functor is obtained for THEOLTL.

6. We define a functor ANCESTOR^SET0" by mapping classes to the set
of their features and inheritance relationships to the functions that re-
name the features. Notice that the target category is the dual of SET.
This is because, as illustrated in Par. 2.1.3, the edges of the inheritance
graph and the corresponding graph of features have opposite directions.
Functors of the form q):C-^Dop (or (p:Cop^'D) are sometimes called
contravariant between C and D. A functor cp:C-*D can also be called
covariant between C and D. •

5.1.3 Example - Relating Programs and Specifications

In computing, functors are often used to express relationships between dif-
ferent levels of abstraction, namely by providing a way of abstracting
properties from representations. In this context, the abstractions are some-
times called "specifications", and the representations "programs". For in-
stance, although we have worked with specifications of Eiffel classes and
not with the programs that implement the methods of such classes, it is
clear that such specifications are at a lower level of abstraction than the
temporal specifications that we defined in Sect. 3.5. For instance, the tem-
poral specifications can be used to describe general properties of the pos-
sible behaviours of a system whereas Eiffel specifications are concerned
with more specific operational aspects of the execution of actions, like
their effects on the attributes.

The notion of a program satisfying a specification is typically formal-
ised through a (satisfaction) relation. When specifications consist of sets
of logical formulas such as those defined in Sect. 3.5, the collection of
specifications that are satisfied by a given program is ordered by inclusion
and has a maximum: the union of all the sets of properties satisfied by the
program. In this case, we can assign to every program P a "canonical"
specification spec(P) - its strongest specification.

We have also seen that morphisms between models of system behaviour
can be used to capture notions of simulation or refinement. In the tradi-
tional stepwise refinement method initiated by Dijkstra [23], refinement is
formalised as a relationship between two units of design: starting with a
specification of the intended behaviour of the system, one progresses by
adding detail (superposing activities, computation mechanisms, etc) until a
design is reached that satisfies certain criteria. These criteria, the notions
of "specification" and "unit of design", as well as the notion of "progress"



5.1 The Social Life of Categories 85

(refinement step) itself, vary according to the formalism that is being used
to support development.

When spec is a functor, this means that the refinement relationship de-
fined on programs is captured by the corresponding notion of refinement at
the level of specifications. When specifications are given as theory pres-
entations, this means that program refinement is property-preserving,
which is what one usually expects from a refinement relation. Hence,
there is a natural way in which the satisfaction relation between programs
and specifications can be expected to be functorial.

As an example, consider the following mapping spec from
CLASS_SPEC to PRESFQLTL, where by PRESF0LTL we are denoting the
category of theory presentations for the first-order extension of the tempo-
ral logic presented in Par. 3.5.4.1

• The image of every class signature is itself. That is, the features of the
class are taken as symbols of the vocabulary of the logic.

• For every routine r, its specification (pre,pos) is mapped to the temporal
formula

(r A pre A att D Xpos*)

By att we denote the conjunction

A (a = xj
a&zH(2)

where the variables xa are all new, and by pos* we denote the formula
that is obtained from the expression pos by replacing every occurrence
of every expression (old a), where a is an attribute, by the variable xa.

• The invariant / is mapped to itself.

For instance, the specification of the bank account given in Par. 3.5.6 is
mapped to the following set of temporal formulas:

deposit(i)Abalance=xba lance D X(balance=xbalanoe+i)
withdrawal ( i ) Abalance£iAbalance=xbilano. D X (balance=xbalanoe—i)
vip D balancealOOO

To show that we obtain, indeed, a functor, we have to show in particular
that morphisms of class specifications are property preserving. Consider a
morphism F:e=<Z,P,I>-*e'=<2',P',r> of CLASS_SPEC.

• Given any routine r of I, its image F(r) is such that its specification
(pre\pos ) is mapped to: (F(r) A pre' A att' DXpos'*). We know that

1. F(pre) \—pre' because F is a morphism,
2. pos' \—F(pos) because F is a morphism,
3. att'DXpos'* \-F(att)DXF(pos**) from 2.

For simplicity, and because the properties of the categories for the propositional
and first-order versions of temporal logic in which we are interested are the
same, we omit the extension. The reader interested in the logic itself can consult
[67] as well as [39] for its use in a categorical framework.



5 Functors

from which we can conclude that
(F(r)Apre'Aatt' DXpos'*) \— F(rApreAatt DXpos*)

• By definition of morphism, we also have /' \—F(I).

Hence, every axiom of spec(I) is translated through F to a theorem of
spec(I'). •

It should come as no surprise that even categories can be organised in a
category.

5.1.4 Definition/Proposition - The Category of Categories

1. Let <p:C—»D and xfj.D-^E be functors. By qp;ip we denote the functor
defined by (tp;ip)0=cp0;xl>0 and (•<p;t/>/)J=<pJ,t/;j. This law of composition is
associative and admits identities as defined in Par. 5.1.2, point 1.

2. We can thus define the category CAT whose objects are the categories
and whose morphisms are the functors.

Proof
The proofs are trivial. However, bear in mind that, in defining CAT, there are
problems of "size" as noted at the beginning of Sect. 2.1. Again, see a more
"mathematically oriented" book such as [80] for matters of size. •

Having a notion of morphism between categories, we can apply to cate-
gories and functors all the machinery that we have so far presented for
manipulating objects and their morphisms. For instance, the notion of
product that we defined in Sect. 3.1 corresponds to a universal construc-
tion in the category CAT.

5.1.5 Definition/Proposition - Product of Categories

Given categories C and D, we define functors nc:Cx.D—»C and
nD:CxD—*D, called the projections of the product, by mapping objects and
morphisms of CxD to their components in C and D, respectively. These
functors satisfy the universal property of products in the following sense:
given any category E, and functors q>c:E->C and cpD:E->D, there is a
unique functor ip:E->CxD such that q>c=ip;jtc and q>D=ty;jTD. We normally
denote ipby <q>c,cpD>. •

We can also define a product over functors:

5.1.6 Definition/Proposition - Product of Functors

The product <pix<p2:CJxDj->C2xZ>2 of two functors <pi.C1-*D1 and
q?2:C2-»Z>2 is defined by (cpixq>2)<c,,c2>=<(p1(c1),q>^C2)> on objects and
(<pi*(P2)<fi,f2>=«Pi(fi)<<Pif2)> on morphisms. •

Functors come in all "shapes and sizes", and as morphisms between
categories, they provide the means for characterising the structural proper-
ties of categories in the way they relate to other categories. Hence, it is
useful to study the properties of functors and the way they allow us to re-



5.1 The Social Life of Categories 87

veal the structure of categories. We start with some elementary properties
that result from the functional nature of functors as mappings between the
sets of nodes and arrows.

5.1.7 Definition

Let (p:C-*D be a functor.
1. q? is an isomorphism iff there is a functor T/r.D-»C such that cp;\p-=idc and

ip;q)=idD. In this case, C and D are said to be isomorphic and xp to be
the inverse of q>.

2. (p is an embedding iff <p3 is injective, i.e. (p is injective on morphisms.
3. (p is faithful iff all the restrictions cp1:homc(x,y)-*homD(cp0(x),(p0(y)) are

injective.
4. 9? is full iff all the restrictions cp1:homc(x,y)-

>homD(cp0(x),q}0(y)) are sur-
jective. •

5.1.8 Exercise

Show that faithful functors are not necessarily embeddings: this is the case
only when they are also injective on objects. •

5.1.9 Proposition

Let q)\C^D and xp:D^>E be functors.

1. If <p and xp are isomorphisms (resp. embeddings, faithful, full), so is
<p;xp.

2 . If q>;xp is an embedding (resp. faithful), so is <p.
3. If q>;ip is full, so is xp. •

5.1.10 Example

Every subcategory D of a category C defines an inclusion functor
iDjC:D-*C. This functor is an embedding, and is full iff D is a full sub-
category of C. •

Embeddings are, intuitively, the best approximations to subcategories.
In fact, in a world in which concepts are normally taken up to isomor-
phism, it seems intuitive not to make any difference between embeddings
and inclusions of subcategories because all that is at stake are the identities
of the objects involved, not their properties or structure. This intuition is
supported by the following result.

5.1.11 Proposition

A functor xp:D-*C is a (full) embedding iff there is a (full) subcategory C
of C and an isomorphism 0:D—»C" such that xp=(j>;Lc.c. •

The relationships that we studied in Sect. 3.3 between subcategories and
isomorphisms extend to functors.



5 Functors

5.1.12 Proposition

Let cp:C-*D be a functor.

1. cppreserves isomorphisms, i.e. if f:x—>y is a C-isomorphism, then cp(f) is
also an isomorphism.

2. If cp is faithful and full, then it reflects isomorphisms, i.e. if cp(f) for
f:x-*y is an isomorphism, then/is itself an isomorphism. •
The notions of preservation and reflection are extended in Par. 5.2.1 to

universal constructions. We end this section with the definition of a class
of functors that arise from (co)reflective subcategories.

5.1.13 Definition/Proposition - Reflector

Let D be a reflective subcategory of a category C. We define a functor
p:C—*D as follows:

• Every C-objectc has a /^-reflection arrow ric:c—>d. We define p(c)=d.
• Consider now a morphism h:c—>c\ The composition h;r\& is such that

the definition of D-reflection arrow for c guarantees the existence and
uniqueness of a morphism h':p(c)—>p(c') such that h;r]c,=r]c;h'. We de-
fine p(h)-h\

11c

c •p(c)

P(h)

Tic' p(c')

This functor is called a reflector for C, more precisely for the inclusion
functor iDiC:D-*C.

Proof

We have to prove that a functor is indeed defined.
Tic

c ^ p(c)

P(h)

p(c')

P(h')

r

•> P(c")

h'



5.1 The Social Life of Categories 89

1. The fact that a graph homomorphism is defined (i.e. sources and targets of ar-
rows are respected) is trivially checked.

2. By definition, p(idc) is the unique .D-morphism W:p(c)—*p(c) satisfying
idc;r)=r\c;h\ Because id^ also satisfies that equation, we get id^ =p(idc).

3. Consider now the composition law. The composition p(h);p(h') is such that
(h;h');ric~=r]c;(p(h);p(h)). This equality is obtained from the equations satisfied
individually by p(h) and p(h'). Hence, by definition, p(h);p(h') is p(h;h'). •

By duality, we obtain the notion of coreflector. Notice that we had al-
ready made use of the idea of coreflector in Sect. 3.3 to explain the intui-
tions behind coreflective subcategories. When applied to the categories
defined in Par. 3.5.4 for temporal specifications, we obtain several functors
that perform the closure of sets of axioms, both as reflectors (from PRES
and from SPRES to THEO) and coreflectors (from PRES both to SPRES
and THEO). Notice in particular that the functor from PRES to THEO is
both a reflector and a coreflector.

This proposition also shows that the relationship between automata and
reachable automata is functorial. The map that eliminates non reachable
states as defined after Par. 3.3.7 is a coreflector. We generalise these kinds
of functors in Sect. 7.2. They are particular classes of functors that gener-
ate free or canonical structures, or approximate other kinds of structures.

5.2 Universal Constructions Versus Functors

As seen in Chap. 4, one of the motivations for the study of universal con-
structions like (co)limits is the ability to capture the collective behaviour
of systems of interconnected components. In the previous section, func-
tors can be seen to provide the means to map and relate different levels of
abstraction in system development or different aspects of system descrip-
tion. One of the obvious questions that arises concerns the ability of
functors to relate such universal constructions when applied in the catego-
ries related by the functors.

For an example of what we mean, let us discuss what we consider to be
one of the most profound recent contributions that have been made in the
area of programming languages and models: the separation between
"computation" and "coordination" [51]. The best introduction we know to
this topic can be found in [3]. In a nutshell, this whole area of research
evolves around the ability to separate what in systems are the structures re-
sponsible for the computations that are performed and the mechanisms that
are made available for coordinating the interactions that may be required
between them. A decade of research has shown that languages that sup-
port this separation of concerns can improve our ability to handle complex
systems. Its importance for architectures has led to very close synergies
between the two areas and a great deal of cross-fertilisation goes on.



90 5 Functors

One of the challenges of this area has been to provide a mathematical
characterisation of this separation that is independent of the particular lan-
guages that were developed for this paradigm. Such a characterisation is
important, on the one hand, to establish a systematic study of its properties
and relationships to other paradigms and, on the other hand, to extend and
support the new paradigm with tools. This is what we started to do in [35]
through the use of category theory.

The basic idea of our approach is to model this separation by a forgetful
functor int:SYS—>INT, where the category SYS stands for systems, i.e. for
whatever representations (models, behaviours, specifications, etc.) we are
using for addressing systems. The category INT intends to capture the
mechanisms that, in these representations, are responsible for the coordi-
nation aspects. We refer to the objects of INT as interfaces following the
idea that interconnections should be established only on the basis of what
systems make available for interaction with other systems (e.g. communi-
cation channels), not at the level of the computations that they perform.

An example that will help us clarify more precisely what we have in
mind can be given in terms of the linear temporal specifications introduced
in Sect. 3.5. Therein, we motivate the fact that we model the behaviour of
concurrent processes at the level of the actions that are provided by their
public interfaces in the sense that every signature identifies a set of actions
in which a process can engage itself. The axioms of a specification pro-
vide an abstraction of the computations (traces) that are performed locally
through the properties that they satisfy. The idea is, then, to take signa-
tures as interfaces and characterise the ability of linear temporal logic
specifications to separate computation and coordination in terms of prop-
erties of the functor PRESLTL-^SET that maps presentations and their
morphisms to the underlying signatures and signature morphisms.

Which properties should we require of int to capture the proposed sepa-
ration? Basically, we have to capture the fact that any interconnection of
systems is established via their interfaces.

For instance, an important property is that int should be faithful. This
means that morphisms of programs should not induce more relationships
between programs than those that can be captured through their underlying
interfaces. That is, by taking into consideration the computational part, we
should not get additional observational power over the external behaviour
of systems.

Another important property concerns the way colimits are computed.
We have already mentioned that the colimit of a diagram expressing how a
system is configured in terms of simpler components and interconnections
between them, returns a model of the global behaviour of the system and
the morphisms that relate the components to the global system. If only the
interfaces matter for establishing the required interconnections, then the
colimit of the diagram of systems should be obtainable from the colimit of



5.2 Universal Constructions Versus Functors 91

the underlying diagram of interfaces. In other words, if we interconnect
system components through a diagram, then any colimit of the underlying
diagram of interfaces should be able to be lifted to a colimit of the original
diagram of system components.

This property can be stated more precisely as follows: given any dia-
gram dia:I—>SYS and colimit (int(Si)^*C)LI of (dia;int) there exists a
colimit (5,—*5J,-:/ of dia such that int(Sj->S)=(int(Si)^*C). When a functor
satisfies a property like this one we say that it lifts colimits.

This means that when we interconnect system components, any colimit
of the underlying diagram of interfaces establishes an interface for which a
computational part exists that captures the joint behaviour of the intercon-
nected components. Notice that this property does not tell us how to con-
struct the lift; it just ensures that it exists. The operational aspects of lifts
are discussed in Chap. 6. This property is really about (non)interference
between computation and coordination: on the one hand, the computations
assigned to the components cannot interfere with the viability (in the sense
of the existence of a colimit) of the underlying configuration of interfaces;
on the other hand, the computations assigned to the components cannot
interfere in the calculation of the interface of the resulting system.

A kind of inverse property is also quite intuitive: that every intercon-
nection of system components be an interconnection of the underlying in-
terfaces. In particular, that computations do not make viable a configura-
tion of system components whose underlying configuration of interfaces is
not. This property is verified when int preserves colimits, i.e. when given
any diagram dia:I-*SYS and colimit (Sj->S)i:I of dia, (int(Sj)->int(S))i:I is a
colimit of (dia;int). These two properties together imply that any colimit
in SYS can be computed by first translating the diagram to INT, then com-
puting the colimit in INT, and finally lifting the result back to SYS.

So: does the (forgetful) functor sign :PRESLTL-^ SET satisfy these prop-
erties? The answer is "yes", as shown in Chap. 6. This is because this
functor is an instance of a class that captures many useful structures in
computing and, hence, is worth studying on its own, which includes the
properties that we have just discussed. We shall return to the issue of
separating "computation" and "coordination" in several other places in the
book, including examples. Summarising, it is useful to classify functors
vis-a-vis the way they relate universal constructions in the source and tar-
get categories.

5.2.1 Definition
A functor q>:C-^D

1. preserves

• a colimit p:8->c of 6:1-*C iff the cocone {(p(pa): q>(60)-*q>(c)}aa,
denoted by q)(p):8;q}—*qp(c), is a colimit of 5;cp.



92 5 Functors

colimits of shape / iff it preserves the colimits of all diagrams

• colimits iff it preverses the colimits of any diagram in C.
2. lifts colimits iff for any diagram 5.7—*C and colimit/?'; §q)—>d of 8;cp,

there is a cocone p:8—*c that is a colimit of 8 and p'=<p(p). The lift is
unique (or cp is said to lift colimits uniquely) when there is a unique co-
cone p:8—>c satisfying the two properties.

3. reflects colimits iff for any diagram d:I—>C and cocone p:d—>c, if <p(p)
is a colimit ofd;cp, then p is a colimit of 8.

4. creates colimits iff for any diagram 3:1-^C and colimit//: d;cp—>d, there
is a unique cocone p:5—>c such that p'-cp(p) and, moreover, p is a
colimit of 6. •
Points 2, 3 and 4 of this definition extend to specific classes of colimits

(sums, coequalisers, etc.) as formulated for preservation. The dual notions
have the obvious designations. The following exercise can help in under-
standing the difference between these notions.

5.2.2 Exercises

Prove that
1. If a cocone p:8—>c is commutative, so is its image by (p(p) as defined in

point 1.
2. Every functor that creates colimits also reflects them.
3. A functor creates colimits iff it reflects and lifts colimits uniquely. •

Note that the requirement on reflecting colimits is essential in case 2.
For instance, it is easy to prove that the (forgetful) functor
THEOLTL->SET that maps theories and their morphisms to the underlying
signatures and signature morphisms lifts colimits uniquely, but it is easy to
see that it does not create them: the colimit will choose the minimal theory
among the whole class of theories that have the given signature and give
rise to a cocone. This class is only singular when some inconsistency
arises from the interconnections and/or the base theories. We can also re-
late these properties to Par. 4.4.7.

5.2.3 Exercise

Prove that if C is finitely cocomplete then cp:C^>D preserves finite colim-
its iff it preserves initial objects and pushouts. •

More results and related notions can be found, for instance, in [1, 22].



Part II

Advanced Topics



6 Functor-Based Constructions

Functors provide us not only with the ability to investigate relationships
between categories, as shown in Chap. 5 and continued in the first section
of this chapter, but also to build new categories based on such relation-
ships. In this chapter we present some of the functor-based constructions
that we have found useful in our day-to-day work.

6.1 Functor-Distinguished Kinds of Categories

In this section we show how the properties of certain categories can be de-
rived from the properties of functors that relate them to other categories.
That is, we investigate functors as a means of revealing structural proper-
ties of categories and of their objects.

We start with the notion of concrete category, which appeared in [80, p.
26] and was extensively explored in [1]. This is also a notion that we have
found to be extremely useful in computing because it is often the case that,
when building new categories over old ones by adding some structure, we
do not interefere with the structure of the original category. This con-
struction by what amounts to a conservative extension can be captured by
a faithful functor u:D->C, where C is the old category and D is the new
one. Typically, the functor forgets the structure that is being added to the
objects of C to produce objects of D.

6.1.1 Definition - Concrete Categories

A concrete category over a category C is a pair <D,v> where v:D—*C is a
faithful functor. •

Notice that we are using the terminology introduced in [1]. The notion
of concrete category introduced in [80] is a particularisation of the one
above to the case where the category C is SET. Concrete categories over
SET are called constructs in [1]. The category C is sometimes called the
base category of <D,v>, and v is called the forgetful or underlying functor.

Because the underlying functor is faithful, i.e. injective on hom-sets, for
each pair of Z>-objects <x,y>, homD(x,y) is usually regarded as a subset of
homc(v(x),v(y)). Following [1], we shall often use the expression
"f:v(x)-*v(y) is a D-morphism" to mean that there exists a (necessarily)



96 6 Functor-Based Constructions

unique D-morphism x—>y whose image by v i s / . We have already come
across a few concrete categories.

6.1.2 Examples

1. The category CLOS of closure systems defined in Sect. 3.6 is concrete
over SET: the forgetful functor maps closure systems to the underlying
sets (languages).

2. The categories PRESLTL, SPRESLTL and THEOLTL defined in Par. 3.5.4
are all concrete over the category SET of sets. The underlying functors,
which we name signLTL, "forget" the sets of axioms/theorems, mapping
theories and their presentations to the corresponding signatures.

3. Another example is the category AUTOM of automata as defined in Par.
2.2.12. This category is concrete over the product SETxSETxSET.
The underlying functor forgets the input, output and transition functions
and projects every automaton to its sets of inputs, states and outputs. •
A typical situation in which concrete categories arise is one in which the

underlying functor represents some sort of classification or typing mecha-
nism that is strong enough to extend to the morphisms and, hence, to the
structure defined over the objects by the morphisms. In such circum-
stances, one is usually interested in studying the way all the objects that
share the same classification or type relate to one another.

6.1.3 Definition - Fibres

Given a concrete category <D,v> over C and a C-object c, the fibre of c is
the preorder that consists of all the objects d of D that are mapped to c, i.e.
such that v(d)=c, ordered by d,<cd2 iff idc:v(d1)—>v(d2) is a D-morphism. •

The structure of the fibres reveals a lot about the properties of the con-
crete category. A detailed discussion can be found in [1]. We limit our
study to three cases that are used in the book.

6.1.4 Definition

A concrete category <D,v> over C is called:

1. Amnestic provided that its fibres are partially ordered, i.e. d1<cd2
 a nd

d2<cdj implies dj=d2 for all C-objects c and objects d],d2 in the fibre of c.
2. Fibre-complete if its fibres are complete lattices (i.e. admit arbitrary

meets and joints).
3. Fibre-discrete if its fibres are ordered by equality. •

Amnestic concrete categories are such that the morphisms of D do not
introduce additional properties over the structures that are being super-
posed on C. For instance, SPRESLTL and THEOLTL are amnestic because
their morphisms do not introduce any structural properties over the sets of
axioms/theorems. However, PRESLTL is not amnestic because its mor-



6.1 Functor Distinguished Kinds of Categories 97

phisms capture the notion of closure. Two presentations over the same
temporal signature can be isomorphic without being equal. On the other
hand, strictly isomorphic presentations and isomorphic theories over the
same temporal signature are necessarily equal: the former because the con-
sequences of the axioms are not taken into consideration, and the latter be-
cause they are already closed under consequence. In other words, mor-
phisms of theories just take into account the elements of a set (the
theorems), whereas morphisms of presentations have to compute the clo-
sure of a set.

Concrete categories that are fibre-complete superpose over the objects
of C information that the morphisms organise in a "convenient" way, al-
lowing for operations to be performed internally within each fibre. We
shall see some examples further on. Hence, being fibre-complete is a step
further than amnesticity in the degree of interaction that exists between the
existing and the superposed structure. Fibre-discrete categories present
still a step further: they are such that the extension that D makes over the
objects of C is inessential, i.e. it has no intrinsic structure or meaning - it
acts just like a comment.

Because concrete categories have added structure, we should provide a
notion of functor that reflects that structure.

6.1.5 Definition - Concrete Functors

A concrete functor cp between two concrete categories <DuVj> and
<D2,v2> over the same underlying category C is a functor (p:D1^D2 such
that Vj=cp;v2.

<P
D ,

Because the morphisms of a concrete category are imported from its un-
derlying category, concrete functors cannot act on them and, hence, are
fully determined by their values on objects.

6.1.6 Proposition

Given concrete functors <p and xp between two concrete categories <DJ,fi>
and <D2,v2>, q>=ijj if, for every ^-object d, cp(d)=ip(d).

Proof

d' be a morphism of Dj. Given that both functors agree on objects, both
cp(J) and \p(f) have the same source and target. Because both q> and tp are concrete,



98 6 Functor-Based Constructions

we have v,(f)=v2(cp(f))=v2(ip(f)). Finally, because v2 is faithful, we can conclude
that (f(f)-ip(f). Hence, both functors agree on morphisms as well. •

6.1.7 Remark - Concrete Subcategories

Given that subcategories determine embeddings (see Par. 5.1.10), and that
the composition of faithful functors is also faithful (see Par. 5.1.9), every
subcategory Z)1 of a category D that is concrete over C with underlying
functor v can be regarded also as a concrete category over C whose un-
derlying functor is the composition LD>D;V. We then say that <D',iD,D;v> is
a concrete subcategory of <D,v>. •

Consider now the notions of reflective and coreflective subcategories
that we discussed in Sect. 3.3. Intuitively, for the (co)reflection to be
"concrete", i.e. to be consistent with the classification that the underlying
functor provides, we would like to remain within the same fibre. That is,
we would like that the (co)reflection arrows be identities.

6.1.8 Definition - Concretely (Co)Reflective Subcategories

A concrete subcategory <Di,i;J> of <D2,v2> is concretely (co)reflective iff,
for each object of D2, there is a (co)reflection arrow that is mapped by v2
to the identity. •

For instance, although REACH is a coreflective subcategory of
AUTOM, it is not concretely coreflective when both categories are consid-
ered as being concrete over SETxSETxSET. This is because the reach-
able automata are not necessarily in the same fibre as the automata from
which they are computed - their state space may have been reduced.

"Concreteness" also extends to universal constructions in the sense that,
once we consider a category D as being concrete through the underlying
functor v:D—*C, we can classify the way universal constructions in D re-
late to C through v. •

6.1.9 Definition - Concrete Universal Constructions

Consider a concrete category <D,v> over C and a diagram 6:I-*D. A
(co)limit of 8 is said to be a concrete (co)limit in <D,v> iff it is preserved
by v. •

That is, universal constructions are concrete when they map to the un-
derlying category. In some categories, all universal constructions are con-
crete. We give an example in Par. 6.3.6. In other concrete categories,
some universal constructions may be concrete and others not so.

6.1.10 Exercise

Work out examples of limits and colimits in AUTOM that are not concrete
over SETxSETxSET. •



6.1 Functor Distinguished Kinds of Categories 99

The construction of concrete (co)limits, when they exist, can be sys-
tematised through a process that consists in projecting the (co)cones to the
base category where a (co)limit is computed and then lifted back to the
original category. This process can be extended to more general notions of
fibre as discussed further on.

The notion of fibre is not exclusive to concrete categories. It can be
generalised to arbitrary functors as follows.

6.1.11 Definition - Fibres

Consider a functor cp:D—*C.
1. Given a C-object c, the fibre ofc, which we denote by D(c), is the sub-

category of D that consists of all the objects d that are mapped to c, i.e.
such that cp(d)=c, together with the D-morphisms f:dj->d2 such that
<p(f)=idc.

2. The functor q> is said to be amnestic if, in its fibres, no two distinct ob-
jects are isomorphic. That is, if an isomorphism f:d, —>d2 in D is such
that qp(f)=idc for some object c of C, then/is itself an identity. •
The discussion around concrete categories focused basically on the

structure of fibres. Another interesting aspect worth discussing is the rela-
tionships that morphisms on the underlying category induce over the fibres
corresponding to their sources and targets.

For instance, consider again the category THEOLTL of temporal theories
defined in Par. 3.5.4 and the forgetful functor signLTL that maps theories
and their morphisms to their signature components. Consider an arbitrary
signature I. A signature morphism/;2'^»Z" provides a translation from the
symbols of one signature to symbols of the other. We have seen in Par.
3.5.7 that such a translation extends to the temporal language associated
with S. Can we further extend this translation to the fibres of I, i.e. can
we define a mechanism that translates theories with signature E to theories
over 21"? What about the reverse? Can we define a mechanism that trans-
lates theories with signature 2" to theories over iT?

To answer these questions, we have first to provide a reasonable defini-
tion of "translation" (and inverse translation) between fibres induced by a
morphism. Consider a functor cp:D^C, a C-morphism f:c—*c', and a D-
object d in the fibre of c, i.e. cp(d)=c. By the "image" of d under/ we
mean some object f(d) in the fibre of c' that is "closest" to d. By "closest"
we mean the following. On the one hand, / can be lifted to a morphism
between d and f(d), i.e. there must exist some morphism g:d—*f(d) such
that (f>(g)=f. On the other hand, for any other object d" and morphism
g':d^>d" that leaves d" at a "distance" f:c'^>cp(d") off, i.e. such that
<p(g')=f;f, this distance can be covered in D in a unique way by a mor-
phism h:f(d)->d" such that (p(h)-f and g'-g;h. By inverse translation, we
mean the dual.



100 6 Functor-Based Constructions

<P

C

D

D(c) D(c')

The following definitions are adapted from [12], a good source for the
study of fibre-related matters.

6.1.12 Definition - (Co)Cartesian Morphisms

Let q>:D—>C be a functor and f:c—>c{ a C-morphism.

1. Let d:D(c), i.e. a D-object such that cp(d)=c. A D-morphism g:d—>d' is
co-Cartesian for/and d iff:
• <p(g)=f.
• For every g':d-*d" and f:c'—>q>(dn) such that (p(g')=f;f, there is a

unique morphism h:d'-*d" such that qj(h)=f and g'=g;h.
2. Let d':D(c'), i.e. aD-object such that q>(d')=c'. A D-morphism g:d->d' is

Cartesian for /and J' iff:
• <p(g)=f.
• For every g}:d"—>d' and f:cp(d")—>c such that (p(g')=f;f, there is a

unique morphism h:d"—>d such that cp(h)=f and g'=h;g.

c

D

D(c) D(c')

6.1.13 Definition - (Co)Fibrations

Let q>:D->C be a functor.

1. We say that <p is afibration if, for every C-morphism f:c—>c' and D-
object d' in the fibre of c\ there is a Cartesian morphism for/and d\



6.1 Functor Distinguished Kinds of Categories 101

2. We say that q> is a cofibration if, for every C-morphism f:c—>c' and D-
object d in the fibre of c, there is a co-Cartesian morphism for/ and J. •

6.1.14 Example - Specifications as (Co)Fibrations

The forgetful functors that define PRESLTL, SPRESLTL and THEOLTL as
concrete categories over the category SET are all fibrations and cofibra-
tions at the same time, but with different (co)Cartesian morphisms among
themselves. Given a signature morphism f:Z->Z:
1. In THEOLTL, i.e. in the case of theories, f:<Z,f

!($')>-*<!',<P'> is a
Cartesian morphism for <2",<P'>, a.ndf:<Z,<P>^<Z',c(f(<P))> is a co-
Cartesian morphism for <Z, <P>.

2. In PRESLTL, i.e. in the case of presentations, a Cartesian morphism for
<Z\<P'> isf:<2j~1(c(&'))>-*<2?,&'>, and a co-Cartesian morphism for
<Z,<$>> is f:<Z,<P>-^<Z',f(<P)>.

3. In SPRESLTL, i.e. in the case of strict presentations, a Cartesian mor-
phism for <2",<P'> isf:<Z,f1(<P')>—><Z',<[>'>, and a co-Cartesian mor-
phism for <Z,0> isf:<Z,0>-»<Z,f(0)>.
The differences that we can witness between these three cases have to

do with both the properties of the closure operator and the morphisms that
characterise the categories. For instance, even if *P is closed for conse-
quence,/!'^) is not necessarily so. Hence, the co-Cartesian morphisms for
theories have to return the closure of the image set. This is not necessary
for presentations because it is already implicit in the morphisms, nor is it
necessary for strict presentations because they do not involve the conse-
quence operator at all. The Cartesian morphisms, on the contrary, do not
need to compute the closure of the inverse image set. This is because, if 0
is closed, so is f'(<P). However, presentations need to compute the closure
explicitly because they only do it implicitly to the target, not the source. •

These examples illustrate the fact that there may be more than one co-
Cartesian morphism for a given signature morphism and theory presenta-
tion. This is because the set of axioms of the specification can be deter-
mined only up to logical equivalence. In the case of theories, the fact that
the set of sentences must be closed ensures that the lifts are unique.

Hence, although it is possible to generalise the translation induced by
signature morphisms to presentations, there may be more than one way of
doing so. This is the general case of any (co)fibration. Amnestic concrete
(co)fibrations, however, guarantee uniqueness of the lifting and, hence, of
the choice for (co)Cartesian morphisms.

6.1.15 Definition - Cleavages, Cloven Fibrations

Let cp:D—>C be a functor. A choice of a Cartesian morphism for every C-
morphism f:c—>q>(d') and D-object d' is called a cleavage. A fibration
equipped with a cleavage is called cloven.



102 6 Functor-Based Constructions

We shall often denote by cpf^ the Cartesian morphism selected for / and
d' by the cleavage. Given g\d"->d[ and f:cp(d")—>c such that (p(g')=f;f,
we know that there is a unique morphism h:d"—>d such that (p(h)=f and
g'=h;q>fd,. We denote h by g

[/fcpfd: When/ is idc, we omit the subscript.

C

D

d"
D(c) D(c')

The dual notion is called cocleavage, and a cofibration equipped with a
cocleavage is also said to be cloven. Summarising, a cloven (co)fibration
q):D—>C provides us with a way of lifting morphisms to translations be-
tween the objects of their fibres in the sense that every C-morphism f:c-*c'
defines a map from the objects of D(c') to the objects of D(c) in the case of
a fibration, and from the objects of D(c) to the objects of D(c') in the case
of a cofibration. Can these translations be generalised to morphisms of the
fibres? Can we generalise this mapping to a functor between the fibres?

6.1.16 Proposition

Let q>:D—*C be a cloven fibration and f:c-*c' a C-morphism.

f
c • c'

<P

C

D

f1

1. The morphism/defines a functor f1 :D(cl)-*D(c) as follows:
• Given d':D(c'),f~1{d') is the source of the Cartesian morphism

q>fd.:d—>d' that the cleavage associates with the fibration.



6.1 Functor Distinguished Kinds of Categories 103

• Given g:dj-*d2 in D(c'),f~
1(g) is the morphism/^d1)~>f

1(d2) that re-
sults from the universal property of the Cartesian morphism
%d2:f

1(d2)-*d2 when applied to <pfid ;g and idc. That is, f~'(g) is the
morphism that we denote by (q)fd ;g)/<Pf,d • Notice that this morphism
is the only one that satisfies q>f<d ;g=f

1(g);cpf,d a n d fif1 (%))-idc.

2. The morphism /defines a functor f:D(c)-*D(c') in the dual way, i.e. by
working on the target side of the co-Cartesian morphism.

Proof

1. There are three properties to prove. The reader is invited to fill in the details:
• The functor is well defined in the sense that the image objects and mor-

phisms exist and are of the right types.
• Because idfi(dj satisfies the properties of the universal property that charac-

terises f'(idd), the uniqueness associated with that universal property guar-
antees that the cleavage has no other choice.

• The same line of reasoning applies to conclude thatJyl(g1;g2)=J^'(g1);J^'(g2).
2. By duality. •

This definition raises immediate questions: What if f=idcl Are/"
7 and /

the identity functor? What if /=//,/2? Are f
1 and / the compositions

f1i'f12 and/, /2 , respectively? The answer is twofold: they can be equal,
but they do not have to. Consider the first part of the answer, this time in-
stantiated for cofibrations.

6.1.17 Proposition

Let cp:D-*C be a functor.

1. Given a C-object c and an object d in the fibre of c, the identity idd is
both a Cartesian and a co-Cartesian morphism for idc and d.

2. Given C-morphisms/7X/—»c2 and/2."c2—*c3, an object d in the fibre of c;,
and co-Cartesian morphisms gi-'d-rfjfd) and g2:fi(d)-*f2(f1(d)), the com-
position g]',g2 provides a co-Cartesian morphism for/,,/2 and d.

Proof

1. Left as an exercise.
2. There are two properties to prove:

• The composite translation lifts the composition in C:
<p(gi;g2)=<p(gi);<p(g2)=fi;f2-

• The lift has the required couniversal property.
Let g':d—*d" and/x3—*q)(d") be such that <p(g')=fi;f2;f- The couniversal
property of g, applied to g' and (f2;f) gives a unique h1:f1(d)—*d" such that
gi;h,=g' and <p(h])=f2;f. The couniversal property of g2 to h} and/ implies
the existence and uniqueness of h2:f2(f,(d))-*d

n such that g2;h2=h, and
cpih2)=f. We can now prove the properties required of h2. On the one hand,
(p(h2)=f. On the other hand, if we take h'2:f2(f,(d))->d" such that g!;g2;h'2=g'
and q}(h'2)=f\ we derive g2;h'2=hj because <p(g2;h\)=q(g2);<p(h\)=f2;f,
gi;(g2;h'2)=g', and hj is the unique morphism satisfying these two properties.



104 6 Functor-Based Constructions

Then, we conclude that h\-h2 because h, is the unique morphism satisfying
g2;h2=h, and cp(h2)=f.

<P

D

The fact that cleavages do not need to choose (co)Cartesian morphisms
satisfying these properties leads to the following definition.

6.1.18 Definition - Split Fibrations

Let cp:D—>C be a cloven fibration. If, for every C-object c, id'1 is idC(cj
and, for every decomposition/=/7,/2, f

1 is the composition f'2;f'i, then
the fibration is said to be split. •

6.1.19 Remark

More alert readers may have noticed that the universal property of the
(co)Cartesian morphism is taken over a space that is larger than the fibre
of either c or c\ This is why the "distance" / is introduced as a kind of
type converter. This means that the (inverse) translation is chosen not only
over the objects that have the exact type but also those that "type-check".

We point this out is to recall that the categorical way of defining a con-
cept, namely through a universal property, has to be morphism-oriented in
order to yield good properties. The reader should experiment the weaker
notion of (co)Cartesian morphism for which the universal property is re-
quired only over the fibres, and check which of the properties still hold. •

Split (co)fibrations allow us to wrap up the idea of translation between
fibres with which we started in neat categorical clothing.

6.1.20 Proposition

Let cp:D->C be a functor.
1. If 99 is a split fibration, then it defines a functor ind((p):Cop—>CAT by

mapping every C-object c to its fibre D(c) and every morphism f:c->c'
to the functor JT1 :D(c')-*D(c) as above.



6.1 Functor Distinguished Kinds of Categories 105

2. If q> is a split cofibration, then it defines a functor ind(q)):C—^CAT by
mapping every C-object c to its fibre D(c) and every morphism f:c-*c'
to the functor f:D(c)-*D(c') as above.

Proof
Left as an exercise. •

Functors of the form Cop—>CAT are called indexed categories, a struc-
ture widely applied in computing (see, for instance, [102]) precisely be-
cause it generalises what are usually called indexed sets, i.e. mechanisms
for indexing given collections of objects with other kind of objects (in-
dexes). We focus on indexed categories in Sect. 6.4.

One of the reasons to study fibrations is the close relationship that exists
between their universal properties and those of the fibres.

6.1.21 Definition - Fibre Completeness

A cloven fibration cp:D—>C is said to be fibre-complete if its fibres are
complete categories and the inverse translation functors induced on the fi-
bres preserve limits. •

6.1.22 Proposition

Let (p:D-*C be a split fibration.

1. If cp is fibre-complete, then it lifts limits.
2. If in addition q> is amnestic, the lift is unique.

Proof
1. Consider a diagram 8:1'-*D and a limit ix:c—>8;q> for the underlying C-diagram.

We are going to provide a step-by-step construction of a limit for 8 that lifts pi.



106 6 Functor-Based Constructions

First, we take the inverse image of <5 induced by [i. We obtain a diagram
within the fibre of c, related to the original one by the Cartesian morphisms
<p .̂. Notice that every %:dr*dj is translated to fpVL^;glq>^:yi

1(di)->yir
1(di).

Then, given that the fibre of c is complete, we compute the limit
p.'d—^ff^d). We are going to prove that the cone obtained through the com-
positions Pi.'cp^j is a limit for 5.
The cone is commutative: consider g:dt->dj in 8; we have A;<p^ .̂;g=

The universal property or the cone is satisfied. Consider another commuta-
tive cone a:d'—>8.

cp(d')

D

Because the image of a under cp is a commutative cone, the universal prop-
erty of jA:c—>d;q> implies the existence of a unique f:q>(d')—>c such that
f;Hi=q>(aj) for every i&, unfortunately, d' is not necessarily in the fibre of c,
and hence we cannot use the universal properties of the limit.

• Because the inverse translation induced by / preserves limits, the cone
f1(P):f1(d)-*f1(n~1(d)) is itself a limit in the fibre of <p(d'); given that
a/cpf.^d:d'->(f;iJ.)~

1(d) is also a commutative cone and (fifj.)'1(d)=f'1(n'1(6)) is
a consequence of q> being split, we can infer the existence of a unique
h:d'-f(d) such that h;r1m=ail<p,.ilfi.

We now prove that h;cpfd satisfies the required properties.

= «;.
• Let h':d'->d satisfy h';(fii;cplljl)=ai. We then have

which implies h'/q)f>df
1(Pi)=ai/q)f.lljlJ and hence h'/q>fd=h, and h;q>f4=h'.

2. Left as an exercise. •



6.1 Functor Distinguished Kinds of Categories 107

6.1.23 Corollary

Let <p:Z>—»C be a split fibrationlf <p is fibre-complete and C is complete,
then D is also complete. •

These results and their duals tell us how to compute universal construc-
tions over (co)fibrations that are fibre-(co)complete: the diagram is pro-
jected to the underlying category and its (co)limit is computed. Then the
original diagram is (co)translated to the fibre of the apex and its (co)limit
is computed within the fibre.

6.1.24 Example - Colimits of Specification Diagrams

The fibres of PRESLTL, SPRESLTL and THEOLTL as concrete categories
over SET are all complete and cocomplete as ordered sets. It is also easy
to see that the (co)translations are (co)continuous. Taking into account the
operations that define these universal constructions, we have the following
procedure for calculating limits and colimits of a diagram <5 with
6i=<Ei,&i> in these categories.

1. Calculate the limit a:2->8 or colimit o:5—>Z of the underlying dia-
gram of signatures.

2. Lift the result by computing the specification component according to
the following rules:

PRESLTL

SPRESLTL

THEOLTL

Limit

o:<S,nia or'icCPJ^d

o:<Z,Dia ar'(0J>^6

o:<Z,nia ctr'i^-*

Colimit

o-.d-xll ,Uia o£®d>

o:d^><Z,Uia °,<®i)>

o:6-«2,c(Uiaoi4>d)>

In order to illustrate these constructions, consider the specification of
the vending machine given in Sect. 3.5. Therein, we see how the original
specification (Par. 3.5.6) can be extended to include a mechanism for
regulating the sale of cigars, which is captured by a morphism (Par. 3.5.11)

no cigars

vending machine regulated vending machine

The need for this type of extensions arises whenever there is a change in
the original requirements. Such changes may be very frequent in business
domains that are very volatile, for instance, as a result of fierce competi-
tion, which forces companies to maintain a level of service that matches or
beats the offer of their rivals. This prompts the need for mechanisms that
allow systems to evolve in ways that localise the impact of changes. For
instance, a better way of accounting for the need to regulate the sale of ci-
gars is to interconnect the original vending machine with an external de-
vice (regulator). This would indicate that the required change does not



108 6 Functor-Based Constructions

need to be intrusive of the existing system in the sense that it is not neces-
sary to change the way the existing system is implemented. Instead, we
just need to implement the regulator and connect it to the system, even
while it is running, i.e. without interruption of service.

The required regulator can be specified as follows:

specification regulator is
signature trigger, ted, tor
axioms beg D (-'tor)

triggerD (->ted)Wtor
tor D (->ted)

The rationale is the following. When the trigger occurs, action ted (the
one being regulated) is blocked until the regulator occurs.

As discussed in Chap. 4, we use diagrams to express systems as con-
figurations of interconnected components, the (co)limits of which return
the object that represents the system as a component, all the interconnec-
tions having been encapsulated. The regulated vending machine can be
put together by synchronising action trigger of the regulator with action
coin of the vending machine, and the regula/erf action with cigar. The cor-
responding configuration diagram is:

bichannel

c2I—> trigger

vending machine regulator

where

specification bichannel is
signature clf c2
axioms

Notice that there is nothing in the regulator that names the vending ma-
chine: the regulator is intended to be a component that can be reused in
different contexts. The same applies, a fortiori, to the vending machine
because it was developed before the need to be regulated was determined.
As a result, there is no implicit interaction between the two components.
The interconnection through which the vending machine becomes regu-
lated is completely externalised in the bichannel and the two morphisms.
This is one basic difference between object and service-oriented develop-
ment as already mentioned: whereas objects, through clientship, code up
interactions in the way features are called, services cannot name other
services because they are not specified with particular interactions in mind.
Moreover, service integration is only performed when it is needed, at run-
time, and for the services that will have been identified or selected at that
time from the configuration.



6.1 Functor Distinguished Kinds of Categories 109

According to the rules above, the pushout of this configuration diagram
can be calculated in two steps. First, we compute the pushout of the un-
derlying diagram of signatures. Because pushouts are determined only up
to isomorphism, we choose the signature that matches that of the regulated
vending machine.

CjH cigar / ^v Cj I—>ted

c2l—»coin / \ ^ c2 h-> trigger

{coin,cake,cigar} {trigger,ted,tor}

no h-> cigar >^ / tori—> token

{coin,cake,cigar,token}

The second step consists in lifting the result back to the category of
specifications. According to the rules given above, this can be achieved by
choosing as axioms the translations of the axioms of the component speci-
fications. From the vending machine we get:

beg D (-'cakeA-'cigar) A (coin v (-'cakeA-'cigar)Wcoin
coin D (-•coin)W(cakevcigar)
(cakevcigar) D (-•cakeA-'cigar)Wcoin
cake D (-•cigar)

And from the regulator we get:

beg D (-"token)
coinD (-'cigar)Wtoken
token D (-•cigar)

Notice that, because of the renaming imposed by the interconnection,
the axioms are now in the shared language, i.e. they express properties of
the same entities. For instance, the regulator now applies to coins and ci-
gars. As a result, there is interference among the axioms from the different
components, which makes new properties (the new requirements) emerge
at the level of the resulting system. For instance, the vending machine
now requires a token to be able to dispense cigars.

As mentioned in Chap. 1, this form of composition is the reason why the
categorical approach brings software systems into the realm of general,
complex systems, whose global behaviour is characterised in terms of
properties or phenomena that emerge from components and interactions.
This is a view that is now shared across different sciences, from biological
to economics and sociological systems [71]. Furthermore, taking the un-
ion of the translations of the sets of axioms is logically equivalent to taking



110 6 Functor-Based Constructions

their conjunction. Hence, as claimed in the introductory remarks to Chap.
4 we are indeed complying with the "conjunction as composition" view
used in [112]. Indeed, it is easy to see that this set of axioms is logically
equivalent to the one we gave in Par. 3.5.11 for the regulated vending ma-
chine, which further shows that the lifting performed through the forgetful
functor is not unique. Also notice that we recover the original extension
(morphism), no cigar, as one of the cocone projections. Hence, basically,
what we have done is factorise the extension by externalising the regulator
that was coded over the original specification.

We should emphasise that, having performed the externalisation, the
view of the system that interests us is the one given by the (configuration)
diagram. The colimit construction is only useful as a semantics for the
diagram, namely as a means of checking that the required properties will
emerge from the interconnections. Further evolution of the system should
be performed on the configuration, not on the global specification resulting
from the colimit.

Other examples of the application of these techniques in computing can
be found in the area of concurrency theory, namely in the works of G.
Winskel [108], and F. Costa [21]. The idea is that operations on processes
like synchronisation can be defined at the level of the actions that the
processes can perform (their alphabet) through some algebraic operations
and then can be lifted to the category of processes using a (co)fibration.
An example in this area is given in Sect. 6.3. Finally, Part III is dedicated
to a systematisation of this process of structuring complex systems through
what are called software architectures.

6.2 Structured Objects and Morphisms

One of the best examples of the added expressive power that functors
bring into the categorical discourse is the ability to work with more than
one category. An exhaustive study of distinguished objects and arrows
with respect to a functor can be found in [1]. In the following, we present
some of the concepts that we have found to provide a good introduction,
and thus motivate the reader to learn more about this topic.

6.2.1 Example - Realisations of a Specification

We argued in Par. 5.1.3 that the notion of satisfaction of specifications by
programs can give rise to functors spec:PROG—>SPEC that map programs
to the strongest specification that they satisfy. The notion of satisfaction
of a specification S by a program P can then be captured by the existence
of a morphism o:S—*spec(P). Indeed, the morphism expresses the fact that
the properties specified through S are entailed by the strongest specifica-



6.2 Structured Objects and Morphisms 111

tion of P. Such a "structured" morphism o:S->spec(P) accounts for repre-
sentations of abstract concepts of the specification in terms of the syntax of
the program. That is, the morphism reflects design decisions taken during
the implementation of S in terms of P, say the choice of specific represen-
tations for the state of a system. Hence, there is an interest in manipulating
morphisms of the form o:S-*spec(P) as capturing the possible realisations
of specifications in terms of programs. •

6.2.2 Definition - Structured Morphisms

Given a functor cp:D—>C, a <p-structured morphism is a C-morphism of the
foimf:c-*(p(d), where c is an object of C and d is an object of D. •

Structured morphisms can be organised in categories that generalise the
notion of comma category that is studied in Par. 3.3.2.

6.2.3 Definition - Comma Categories

1. Given a functor <p:D-^C and an object c:C, we define a category cj,q>
that has for objects all pairs <f:c->cp(d),d>, where/ is a ^structured
morphism with domain c. The morphisms between <f]:c-*q>(d1),d1>
and <f2:c—>(p(d2),d2> are all the D -morphisms h:d1—*d2 that satisfy
fi;cpih)=f2. These are called under-cone categories in [22, p. 48].

cpCd,)
cp(h)

-• <p(d2) T

Ih
d, • d2 D

2. This construction can be further generalised to _lq> (or CIcp) whose
objects are (^-structured morphisms <c,f:c—>(p(d),d>. A morphism from
<c1,f1:c,->cp(d1),d1> to <c2,f2:c2-^<f(d2),d2> is

 a P a i r <g,h> of a C-
morphism g:cl->c2 and aD-morphism h:dj—*d2 such thatf,;qp(h)=g;f2.

• tp(d2)

cp(h) q>

:
T
I
Ih

d, • d2 D



112 6 Functor-B ased Constructions

Proof
The proof that these constructions yield categories is left as an exercise. The
reader is also invited to consult [80, p. 46-48] for further generalisations of the
notion of comma category, including the one that justifies their name. •

6.2.4 Remark - Compositionality in Software Development

In Chap. 4, universal constructions are used to formalise notions of com-
position that occur in system development. These are applied to system
specification in Par. 6.1.24, including an illustration of their role in sup-
porting evolution through the interconnection, at runtime, of new compo-
nents that can bring about new emergent properties.

However, ideally such constructions should apply to realisations and not
to specifications alone in the sense that, when we compose specifications
for which we have already correct implementations, we should be able to
obtain a correct implementation for the resulting specification as a compo-
sition of the implementations of its components. This is usually called
compositionality of system development. Following on [41], we are going
to show how this form of compositionality can be formulated in this set-
ting and derived from the existence of an abstraction functor.

First of all, we are now interested in extending the notion of realisation
to diagrams as capturing configurations of complex systems: a realisation
of a specification diagram d:I-*SPEC by a program diagram S.I^PROG
is an Ill-indexed family (oi:d(i)-*spec(6'(i)))i0n of realisations such that,
for every f:i->j in / , d(f);Oj=oi;spec(d'(f))- That is, in addition to the indi-
vidual components, the interconnections have to be realised as well.

SPEC

spec(P)

spec(P2) spec

PROG



6.2 Structured Objects and Morphisms 113

Compositionality of the relationship between programs and specifica-
tions can be expressed through the fact that the colimit of d' - the diagram
of programs - is a realisation of <5 - the diagram of specifications - in an
essentially unique way. We can actually prove that, as long as spec is a
functor, this property holds regardless of the nature of the specifications
and programs. Indeed, because functors preserve the commutativity of
diagrams, the image of the program diagram commutes, i.e. in the case of
the diagram in the figure,

spec(f1);spec(f1)=spec(f2);spec(f2).

This entails that

fj,1;a1;spec(f,)=o;spec(f1);spec(f1)=a;spec(f2);spec(f2)=iA2;a2;spec(f2).

Because </J,'J,JJ,'2,S'> is a pushout of <S,^I,,IJ,2>,
 w e conclude that there

exists a unique morphism o:S'->spec(P') such that a,;spec(f1)=^1;a' and
a2;spec(f2)-yC2;a\ Notice that these two equations express the fact that
the pairs <fx\;spec(fi)> are indeed morphisms of realisations. Also notice
that spec is not required to preserve the pushout of programs!

SPEC

spec(P) spec(P')

spec(P2) spec

PROG

Because compositionality is a property that is not exactly easy to
achieve, as more than 20 years of research in the area has shown, this
means that the existence of a functor relating two domains of system mod-
elling expresses a very strong structural relationship between them. In
[31], we gave examples of situations in which compositionality fails be-
cause some of the properties required of functors are not met by the way



114 6 Functor-Based Constructions

specifications relate to programs. Basically, at stake is the balance that
must be struck between the nature of the properties that the abstraction
map is able to derive, and the ability of program morphisms to preserve
such properties. In [31] it was also shown that, in the absence of a functo-
rial relationship, properties of systems may emerge that result from the
need to regulate the interconnections between the components. This hap-
pens when the semantics of the programming language is not strong
enough to ensure the preservation of the properties made observable
through the specification language. This is similar to what happens in so-
cial systems in which regulators (e.g. the police) are necessary to enforce
laws that are not "natural" but imposed by the society for coordinating the
behaviour of individuals.

An example of such a situation can be given in terms of Eiffel class
specifications and linear temporal logic. If we had chosen to restrict the
behaviours of Eiffel classes to those that are normative in the sense that
routines are only executed when their preconditions hold, the following
sentence would be included in the strongest specification of every routine:

r Dprer

That is, if the routine r is about to happen, its precondition holds. It is
easy to see that this property is not preserved by class morphisms. Indeed,
given a class morphism /, all that / guarantees is that F(prer) \—preFfrj.
Hence, from (F(r)DpreF(r)) we cannot infer the translation through F of
(rDprer), i.e. the property (F(r)DF(prer)). This means that an implementa-
tion of a class specification that refuses to execute every routine when the
precondition fails cannot be reused, with the same semantics of refusal,
when the specification is inherited into a larger one. In other words, in-
heritance does not preserve the property of refusing execution of routines
for which preconditions fail. This is probably why the semantics of pre-
conditions in Eiffel does not include such refusals.

Although the construction in Par. 6.2.4 was motivated by the extension
of the notion of realisation to diagrams as compositions of complex sys-
tems, it admits a dual reading as extending composition to realisations, i.e.
moving to the category _lspec whose objects are precisely the realisations.
Actually, this dual reading is supported by a dual visualisation of the fig-
ures above: whereas we analysed them from the point of view of "vertical"
relationships (the realisations) between "horizontal structures" (the speci-
fication and the program configurations), we are now analysing them as
horizontal relationships (a configuration) between vertical structures (the
realisations of the component specifications).

Indeed, because, for every f:i-*j in / , fyflto—o^specid'if)), 6 and 6' de-
fine a diagram <d,d'>:I-*_lspec such that, for every i, <d,5'>(i) is
<d(i),Oi,d'(i)> and, for every f:i-*j, <5,6'>(f) is <6(f),d'(f)>- Composi-
tionality expresses the existence (and uniqueness) of a colimit for this dia-



6.2 Structured Objects and Morphisms 115

gram of realisations when <5 and «5' admit colimits. Compositionality in the
sense that we have just described is a property that can be stated and
proved in the general setting of comma categories.

6.2.5 Definition/Proposition - Projection Creates Colimits

1. Given a functor cp:D—>C, we define two functors 7tc:_lcp—K! and
^D--<1<P^D by projecting objects and morphisms of the comma cate-
gory _lcp to their C and D components, respectively.

2. The functor <nc,nD>:_lcp—K!xD creates colimits.

Proof
1. Left as an exercise.
2. Consider a diagram 8:I—*_jq> and colimits IA,:8;TIC—»C and fi:b;nD—>d for its

projections 8;nc and 8;nD, respectively.

D

Existence of a cocone in _lq> whose image is the pair of projections. Basi-
cally, we have to show that there is a morphism a:c->q?(d) such that

To prove this, consider the C-cocone defined by {Oj;q>(pi)}-*(p(d). This co-
cone is commutative because, given any morphism f:ct-*Cj in the base, if
g:dj->dj is the morphism in D that, together with/, constitutes a morphism in
_l<p, we have that

Pi=g;Pj the D-cocone is commutative,
tyiPd-tp^wifij) functors preserve composition,
f;<jj=oi;q)(g) <f,g> is a morphism in _l q>,



116 6 Functor-B ased Constructions

f;0j;<p(Pj)=0i;q>(g);q>(Pj) from the previous equality,
f'yGjiipifilj-Oiiqiifii) applying the second equality.

Hence, because \x:b;nc->c is a colimit, there is a (unique) morphism
o:c-»<p(d) such that oi;q}(Pi)=iJ,i;a.
Uniqueness of the cocone. For the cocone to be in _ I cp, the equalities
o^tpiPJ=Hi;a have to hold, and the fact that the cocone in C is a colimit im-
plies that cris the only morphism c—>q)(d) that satisfies that property.
The cocone is a colimit. Let <v,y>:d—*<c\o",d'> be a commutative cocone.
Its projections v:d;nc—

!>c' and y:6;jvd—*d' are also commutative. Therefore,
because n and /3 are colimits, there are unique x:c—>c' and p:d—*d' such that
v,=/i,;T and y;=/3,;p. We want to prove, first of all, that <x,p> is a morphism
of _lq>, i.e. x;a'=a;q>(p). For that purpose, we are going to prove that the
cocone defined by (cr^cpfyj) is commutative: given an arbitrary
<f:ci-*Cj,g:di—*dJ> in the base for a structured object <CpOj,dj>,

jj

=f;vi;o' <v;,y,> being a morphism, aj;q>(yj)=vi;&,
=vi;c? vbeing commutative,/;v—v,,
= oj-;<p(Vi) < v;,y,> being a morphism, ai;q>(yi)=vi;a'.

Hence, there is a unique morphism K:c-*q>(d) such that fj,i;K=ai;qi(yi). But
both v;a' and a;cp(p) satisfy that property. Therefore, they are equal. Fi-
nally, we have to prove that <%p> is the only morphism satisfying
<vi,Yi>=<fJ.i,Pi>;<%p>. But this is because any morphism <r ' , p '> satisfy-
ing the same equation is such that v—fx^x' and y~j3,;p', which implies T ' = T
and p'=p.

d'

D



6.3 Functor-Structured Categories 117

6.3 Functor-Structured Categories

In this section, we present a construction that yields concrete categories of
a very simple nature but with wide applicability.

6.3.1 Definition - Functor-Structured Categories

Let (p.C-»S£T be a functor. We define the category spa(cp) whose objects
are the pairs <c,S> where c:C and SQcp(c) and whose morphisms
f:<c,S>^<d,T> are the morphisms f:c-*d of C such that cp(f)(S)QT.

Proof
As illustrated in Sect. 3.2, we have to prove that the composition law and the
identity map inherited from C are applicable.
• Given morphisms f:<c,S>-*<d,T> and g:<d,T>—*<e,R>, we have

1. q(f)(S)Cr because/is a morphism of spa(q>),
2. <p(g)(<rff)(S))Crfg)(T) from 1,
3. (p(g)(T)CR because g is a morphism of spa((p),
4. <p(g)(q>(f)(S))CR from 2, 3, and transitivity of inclusion,
5. (<p(f);(p(g))(S)CR from 4 and function composition in SET,
6. <p(f;g)(S)CR from 5 and the properties of functors.

• The case of the identity map is trivial: given a pair <c,S>, the identity on c is
such that <p(idc)(S)=id¥c)(S)=S. •

Functor-structured categories, sometimes also called spa-categories, are
studied in detail in [1], where some additional terminology is introduced.
The objects of such categories are usually called 97-spaces and their mor-
phisms <p-maps.

6.3.2 Example - Processes

In Par. 3.2.1 and the discussion that follows it, we regard a pointed set as a
signature or alphabet of a process: the proper elements of the set denote
actions or events in which the process can get involved, and the designated
element denotes an action of the environment, i.e. an action in which the
process is not involved. We can associate with every pointed set A±, the
set of possible trajectories over A±: tra(A±)={X:a)^A}. That is, a trajec-
tory for an alphabet is an infinite sequence of actions; it represents one
possible behaviour in a given environment. For instance, in the case of the
alphabet <{produce,store,lP},lP> of a producer, the set of all behaviours
in which produce and store succeed each other is given by:

(_LP*produce_Lp*store) °o

Notice that we make explicit the occurrence of the designated event be-
cause we are capturing behaviours that take place in given environments.
Hence, finite behaviours can be represented by infinite sequences that, af-



118 6 Functor-Based Constructions

ter a certain point, consist of the designated element, i.e. consist only of
environment steps:

(_Lp*produce_Lp* s t o r e ) *_LP<»

This association defines a functor tra.SET±-*SET if we extend it to
morphisms as follows: tra(f:A±->BJ(k)=X;f, i.e. tra(f)(X)(i)=f(X(i)). That
is, every morphism of pointed sets induces a translation between the corre-
sponding trajectories by pointwise application of the function between the
base sets. We usually denote tra(f) by/™.

We can now define the category PROC of processes as spa(tra). A
process consists of a pair <AX,A> where AQtra{A±), i.e. a process consists
of an alphabet and a set of trajectories that capture its behaviour. A proc-
ess morphism f:<A± ,A,>^<A± ,A2> is a morphism f:A± —

>A1 between
the underlying pointed sets such \haXf(A1)QA2, i.e., such that every tra-
jectory of the source is translated to a trajectory of the target.

As mentioned in Par. 3.2.1, a morphism f:P,—*P2 identifies process P2 as
a component of process P;: it identifies, for every action of Ph the partici-
pation of P2 in that action; if the event of P, is mapped to the designated
event of P2, this means that P2 does not participate in it, making it an envi-
ronment step for P2. Notice that the preservation of the designated ele-
ment, as enforced through the morphism, is consistent with the view of P2
as a component of P,: an environment step for P, must necessarily be an
environment step for P2. Hence, Pt identifies part of the environment of
P2. The condition on the trajectories requires that every possible behaviour
of P, (the system) be mapped to one of the allowed behaviours of P2 (the
component). That is, the system cannot exhibit behaviours that are not al-
lowed by the component. However, it is possible that behaviours of the
component do not show up in the system, e.g. because interactions with
other components within the system prevent them from occurring. •

Functor-structured categories provide examples of some of the kinds of
categories discussed in Sect. 6.1.

6.3.3 Proposition

Let cpC^SET be a functor.
1. The functor v: spa(cp)-*C that forgets the SZ?r-component of each ob-

ject defines spa(q>) as a concrete category over C.
2. The forgetful functor v:spa(cp)—*C is both a split fibre-complete fibra-

tion and a split fibre-cocomplete cofibration. Given f:c->c' in C,
f:<c,q}(flr1(S')>-*<c',S'> is the Cartesian morphism for <c',5'> and
f:<c,S>—><c\cp(f)(S)> is the co-Cartesian morphism for <c,S>.

Proof
Left as an exercise. •



6.3 Functor-Structured Categories 119

6.3.4 Example - Processes

We call alph the forgetful functor defined by Proposition 6.3.3(1) on
PROC: it projects processes and their morphisms to the underlying alpha-
bets (pointed sets). Notice how the (co)Cartesian morphisms have an in-
tuitive interpretation in PROC. The Cartesian morphism returns, for a
given process and alphabet morphism having the process as target, the
least-deterministic system over that alphabet in which the process can fit,
through the morphism, as a component: any additional behaviours of the
system would violate the allowed behaviours of the given process.

For instance, consider the alphabet of the producer/consumer system
defined in Par. 4.3.8, whose proper events are: storelretrieve, pro-
duce\consume, produce, consume.

The Cartesian morphism relative to the following behaviour of the pro-
ducer component

(_Lp*produce_Lp* s to re ) °°

defines the following behaviour for the system

( {±s, consume} *{produce|consume, produce} { J.s, consume} *store|retrieve) °°

That is, we obtain the system trajectories in which the producer compo-
nent alternates between executing produce and store. Notice how the en-
vironment of producer is captured by one of _LS or consume. In other
words, an environment step for the component is either performed by the
environment of the whole system J.s or by the consumer component with-
out interacting with producer.

On the other hand, the co-Cartesian morphism returns, for a given proc-
ess and alphabet morphism having the process as source, the most deter-
ministic process over the target alphabet that it admits, through the mor-
phism, as a component. Any additional behaviours that the component
may have will not be able to be observed in the given system.

For instance, consider a system that consists of all trajectories in which
only one exchange is performed between consumer and producer.

-Ls*produce_Ls*store|retrieve-Ls*consume-Lsa>

The Cartesian morphism relative to the consumer component returns:

-Lc*retrieve-Lc*consume-Lc°°

Any other trajectory in the language of consumer will not show up dur-
ing the execution of the given system. Notice that the Cartesian morphism
relative to this behaviour of the consumer component defines the following
behaviour for the system



120 6 Functor-Based Constructions

{_LS, produce}*

store|retrieve

{ -Ls, produce } *

{produce|consume, consume}

{J-s, produce} »

This process is less deterministic than the one we started from because it
captures only restrictions imposed by the consumer. This means that the
original system behaviour can only emerge from the interactions of the
consumer with other components of the system. Indeed, the behaviours

_Ls*produce_Ls*store|retrieve_Ls*consume-Ls«>

belong to the intersection defined by the Cartesian morphisms relative to
both components:

_Lcretrieve-Lc*consume_Lct»

for the consumer and, for the producer

(-LP*produce JLP* s to re ) °°

We show in Par. 6.3.5 that this intersection, which captures parallel
composition, is computed by a limit (pullback). This is yet another in-
stance of the "conjunction as composition" idea [112] and Goguen's
dogma [57].

In summary, the Cartesian and co-Cartesian morphism allow us to
gauge the roles that a given process can play through a morphism as a
system or as a component. •

The characterisation provided in Par. 6.3.3 for (co)Cartesian morphisms
allows us to derive some useful properties.

6.3.5 Corollary

Let q>:C-*SET be a functor, and v:spa(q>)-*C the forgetful functor in-
duced by the spa-construction.1

1. v lifts limits uniquely. Any limit /A:c-*d;v for d:I-*spa(q>) with
<5,=<C;,5,> is lifted uniquely to n:<c,S>^*d where S=flie, <p(fj,i)~

1(Si).
2. v lifts colimits uniquely. Any colimit /J,:6;V-^C for d:I—>spa(q)) with

6i=<ci,Si> is lifted uniquely to pi:d-><c,S> where S= Ui£,

6.3.6 Corollary

Let <p:C^SET be a functor.

1. If C is complete so is spa(q>), all limits being concrete (Par. 6.1.9).
2. If C is cocomplete so is spa(q>), all colimits being concrete.

1 For readability, we shall omit the forgetful functor when referring to objects and
morphisms of C that are projected from spa(<p).



6.3 Functor-Structured Categories 121

Therefore, we can apply the recipe for calculating limits and colimits in
spa(cp) discussed in Sect. 6.1:

1. Project the diagram to the base category and calculate its (co)limit.
2. Lift the result by computing the intersection of the inverse images of the

set components (for a limit) or the union of the direct images of the set
components (for the colimit).

It is useful to see how this construction can be instantiated to particular
universal constructions:

• Lifting of the initial and terminal objects:
If 0c is an initial object of C, then <OC,0> is initial for spa(cp)..
If lc is a terminal object of C, <lc>cp(lc)> is terminal for spa(<p).

• Universal constructions in three steps: projection of the spa(cp)-dmgmm
to C, universal construction performed in C, lifting the result back to
spa(cp).

Product:

<c2,S2>

<c2,S2> c, c2

9/1
<c,gr!(s1)ng2-

1(s2)>

spa(qp)

Sum:

<c2,S2> •=>

<c2,S2> c, c2

9 / t—i \ 9
<c,gl(S,)Ug2(S2)> c

spa(cp) C



122 6 Functor-Based Constructions

Pullback:

Hx,,S,> <c2,S2>

spa(cp)

Pushout:

<co,So>

<c2,S2>

<c2,S2> (" | c, c2

9

<co,So>

V
<c2,S,>

! \Q/"
I g l \ » / g 2 gl
I <c,g1(S,)Ug2(S2)> c |

I spa(cp) C |

Notice that the lifting of the product and the pullback are exactly the
same: the "shared" object is only used for determining the C-component of
the apex of the pullback and does not interfere with the calculation of the



6.3 Functor-Structured Categories 123

SET component. This is another example of the kind of separation that
can be achieved between "coordination" and "computation" as discussed
in Sect. 5.2. We return to these aspects in Sect. 7.5, but this is a simple il-
lustration of the principle.

6.3.7 Example - Parallel Composition of Processes

When applied to processes, these constructions provide us with a mathe-
matical semantics for typical operations of process calculi. Recalling the
universal constructions studied in Chap. 4 for pointed sets, we have:

1. The terminal process is <{±0},{±J"}>. Its alphabet contains only the
witness for actions of the environment, and its behaviour reflects exactly
that - it witnesses life go by. That is, we have an idle process.

2. The initial process is <{±0},0>. Its alphabet is exactly the same as for
the terminal process, but its behaviour is completely different - it does
nothing, not even witnessing life go by! That is, we have a blocking
process that deadlocks any system to which it is interconnected.

3. As seen in Par. 4.2.7, products of pointed sets model the interleaving of
alphabets in the sense that they compute the set of all the synchronisa-
tion pairs of actions between the components plus the individual actions
themselves.

When we take into account the behaviour of processes, products re-
turn the infinite sequences of such parallel actions that, once projected
into the components, result in behaviours of the components. That is,
the product of processes <A1>A1> and <A2,A2> is obtained by comput-
ing the product <A,ghg2> of the alphabets and by taking as set of be-
haviours the intersection of the inverse images of the sets of behaviours
of the components. This intersection consists of the sequences A:cw »̂A
such that g1

a(X)EA1 and g2
a>(A.)EA2. Hence, what we obtain is the tradi-

tional trace-based semantics of parallel composition.
Notice the difference between the idle and the blocking process.

When put in parallel with another process, the idle process is "ab-
sorbed", i.e. the result of the parallel composition is the other process.
This is because its behaviour is already present in any other process (ex-
cept the blocking one). Indeed, the product of a terminal object with
any other object is, up to isomorphism, that object. Hence, the idle
process does nothing and lets the others do as they please.

On the contrary, the blocking process "absorbs" any other process
with which it is put in parallel: it does nothing and does not let the oth-
ers do anything. This is because the product of the initial object with
any other process P returns a process with the alphabet of P but with an
empty behaviour. As claimed at beginning of the book, category theory
is all about the social behaviour of objects...



124 6 Functor-Based Constructions

4. Pullbacks allow us to select only the behaviours that satisfy certain syn-
chronisation requirements. We can see in Par. 4.3.8 that such require-
ments are expressed through the morphisms that connect the compo-
nents to the "channel" that interconnects them. Each action of the
channel acts as a point for rendez vous synchronisation in the sense that
the actions that participate in a rendez vous are not allowed to occur in
isolation, i.e. are not part of the alphabet of the resulting process. Con-
cerning the resulting behaviour, its computation is exactly as for prod-
ucts: it consists of the sequences of actions determined by the pullback
of alphabets that are projected into behaviours of the components.
Hence, the synchronisation is achieved at the level of the alphabets. In
summary, pullbacks model parallel composition with synchronisation.

5. What we have just observed about pullbacks can be generalised to limits
in general. The limit of the diagram of alphabets internalises all the in-
terconnections established via the morphisms as synchronisation sets:
each component may be involved with at most one action in a synchro-
nisation set. That is, internal synchronisations cannot be established and
a given component may not participate in a given rendez vous. When
we take into account the behaviour of the processes involved, limits re-
turn the infinite sequences of such synchronisation sets that are pro-
jected into allowed behaviours of the components. •

6.4 The Grothendieck Construction

In Sect. 6.1 every split fibration cp:D—>C is shown to define a functor
ind(cp):C°p—*CAT that maps every object of C to its fibre. In the case of a
split cofibration, we obtain ind(cp):C—>CAT. The objects of C can be seen
as indexes or types that are used for classifying the objects of D. The
functor <p makes the type assignments and the functor ind(cp) groups the
objects according to their types.

On the morphism side, the functor ind(q>) tells us how to translate be-
tween fibres when moving from one type to another through a type mor-
phism. For fibrations, this translation is contravariant (like when taking
inverse images), whereas for cofibrations the translation is covariant (like
when taking direct images).

For instance, if C is the inheritance hierarchy of an object-oriented sys-
tem, and D models the population of objects, we can think of a cofibration
that assigns to every object the type of which it is a direct instance. For
every inheritance morphism, the co-Cartesian morphisms define how each
object of the child class is also an instance of the parent type (which fea-
ture renaming applies, etc). The CAJ-based functor returns, for each type,
the population of direct instances associated with the type and, for each in-



6.4 The Grothendieck Construction 125

heritance morphism, the functor that maps instances of the child to in-
stances of the parent.

The fact that we work with a fibration or a cofibration, and that the as-
sociated CA jf-based functor is contravariant or covariant, is not very im-
portant. After all, it is all a matter of arrow direction. However, as
pointed out in other parts of this book, it is important that the direction of
the arrows is chosen so as to be "natural" in the context in which they are
going to be used. For instance, in the case of inheritance, hierarchies are
traditionally depicted as graphs with the arrows pointing to the parents,
and it would be counterintuitive to formalise them with morphisms going
in the opposite direction. This is why, in this section, one direction is pre-
ferred for definitions and results, but examples are given in their "natural"
direction. The reader should detail the dual constructions as an exercise.

We have also mentioned that indexed categories are very much part of
the categorical folklore of computing [e.g., 12, 22, 102]. We follow [102]
more closely because it shares with us the same kind of "engineering" in-
spiration that we set ourselves to promote. The reader can also find therein
many more examples and a much more extended coverage of this topic.

6.4.1 Definition - Indexed Categories

An indexed category i over a category / (of indexes) is a functor of the
form i:Iop^CAT. •

6.4.2 Example - Comma categories

In Par. 3.2.2 we show how, given a category C and an object a:C, we can
define the category of objects under a, that is aJ,C. Given a morphism
r:a'-*a, there is a natural way of translating objects under a to objects un-
der a': given f:a—>x, we map it to (r;f):a'-*x.

- • a

r;f ^ _ f

x

It is easy to prove that this translation is indeed a functor alC—>a'JC so
that we obtain an indexed category _IC:CP—*CAT. •

6.4.3 Exercise

Complete the previous example by doing the proofs and generalising it to
the comma categories of the form a J, q> as defined in Par. 6.2.3. •

Once we look at functors i:Iop^>CAT as performing an indexing of cer-
tain classes of objects, it seems natural to think about the amalgamation of



126 6 Functor-Based Constructions

all these classes into a single population, using the indexes to distinguish
between the objects according to their provenance. This operation is tra-
ditionally called the "Grothendieck construction" [12, 22] in honour of A.
Grothendieck, or "flattening" [102].

6.4.4 Definition - Flattening an Indexed Category

Any indexed category v.l°v-^CAT defines a category FLAT(i) as follows:
1. The objects of FLAT(i) are all the pairs <i,a> where /:/ is an index and

a:i(i) is an object of type /.
2. The morphisms <i,a>—><j,b> are all the pairs <o,f>, where a:i—>j is a

morphism of indexes andf:a—>i(o)(b) is a morphism in i(i).
3. Composition is defined componentwise: given <o,f>:<i,a>-><j,b>

and <fx,g>:<j,b>—s-<k,c>, we define <o,f>;<fi,g>=<o;fi,f;i(a)(g)>.
4. The identity for an object <i,a> is <idi;ida>.

- • j
o

a)(

)|

\
1

b

\

i(k)

Proof

The proof that a category is defined in this way is left as an exercise. •

6.4.5 Example

The flattening of _iC:Cp->CAT is the arrow category of C. Its objects
are all triples <x,f:x->y,y>. The morphisms <x,f:x—>y,y>-*<z,g:z-*w,w>
are the pairs <h,k> such that h:x—>z, k:y—>w and h;g=f;k. The equation
results from the requirement that k be a morphism between f:x—>y and

1 in xjC, which is the translation of g:z~*w defined by h.



6.4 The Grothendieck Construction 127

zJC

6.4.6 Exercise

Prove that the category _/<p defined in Par 6.2.3 "is" the flattening of the
indexed category of Exercise 6.4.3. •

The flattened indexed category comes equipped with some structure.

6.4.7 Proposition

Consider an indexed category i:Iop—>CAT.
1. We define a functor fib(i):FLAT(i)->I by projecting objects and mor-

phisms to their /-components.
2. This functor is faithful, defining FLAT(L) as being concrete over /.
3. This functor is a split fibration: the Cartesian morphism associated with

o:i-*j and <j,b> is <a,idl/(a)(b)>:<i,i,(a)(b)>-^<j,b>. That is, we simply
use the translation mechanism of the indexed category to perform the
required lift.

Proof
We leave the proof of the first two properties to the reader.
3. We have to prove that the proposed Cartesian morphisms satisfy the required

properties.



128 6 Functor-Based Constructions

• First of all, it is easy to see that the morphism is well defined: i(o)(b) is in-
deed indexed by i. Moreover, its projection over/ is eras required.

• Consider now the universal property. Let <fx,g>:<k,a>—*<j,b> and X:k—*i
satisfy \i-X;a. Because g:a->i(n)(b) and L(^)(b)-t(?.;a)(b)=t(X)(ij(a)(b)),
we obtain <A,g>:<k,a>—><i,i(cr)(b)>. On the one hand, this morphism is
projected to A as required. On the other hand, <[i,g>=<?i,g>;<o;idl(a)(b)> as
required. The uniqueness property results from the fact that the second
component of the Cartesian morphism is an identity and the projection over
I is faithful.

The fact that the fibration is split is trivially checked. •

This result allows us to derive properties of flattened indexed categories
as corollaries of general results about fibrations.

6.4.8 Proposition

Consider an indexed categon$r>p-»CAr.If / is complete, i(i) is com-
plete for every /:/, and every translation functor i(o) preserves limits, then
FLAT(i) is complete. •

Examples of indexed categories, their properties, and some of their uses
in computing are given in the next section.

6.5 Institutions

I am proud to say that I grew up into category theory when trying to learn
the concept of institution put forward by Goguen and Burstall in the early
1980s! However, and although the fascination is still there, the reasons for
including this section in this book are more than sentimental. The theory
of institutions is a brilliant piece of "engineering mathematics", both in
form and in content. It is the result of a process of abstraction that has al-
lowed computer scientists to classify and relate the specification formal-
isms that they have developed or worked with, as well as construct new
formalisms in a systematic and integrated way. That is, it is a piece of sci-
ence, one that computing can proudly boast.

Like every abstraction, institutions have their limitations. But, as in
every other branch of science, these limitations have inspired many other
computer scientists to develop ramifications that have further enlightened
the path of those of us who are in the business of systematising and sup-
porting the process of software development. Hence, our own account of
the basics of institutions is left here both to exemplify some of the con-
structions that we developed so far in the book, and as a source of inspira-
tion for the reader.

Some readers and, it is to be hoped, users of this book will complain
that this topic comes too late. For instance, it does not require the material
that we introduced so far in this section. While this is clearly true, the rea-



6.5 Institutions 129

son is, as for all the other examples, that we deliberately placed institutions
where we think they "belong". The point, once again, is that the purpose
of this section is not to promote institutions, but rather illustrate the con-
structions that we have been defining with the best examples we know.
The community has been longing for a book on the theory of institutions,
but this section is no substitute for it.

We start by defining not the original notion of institution as it appears in
[62], but a variant that we developed in [45] called Jt-institution. This is
not for self-promotion, but because it will allow us to capitalise on mate-
rial introduced in previous sections. We defined in Sect. 3.6 the notion of
closure system as consisting of a pair <L,c>, where L is a set and c:L—>L
is a total function satisfying the properties of a closure operator: reflexiv-
ity, idempotence and monotonicity. The idea is that the elements of L are
the well-formed formulae that result from a specific choice of vocabulary
symbols and a given grammar. The closure operator captures the notion of
consequence of the logic at stake, instantiated to that particular language.

The idea of (jc-)institutions is to add to this abstract view of logic the
idea that the notion of consequence is independent of the specific choice of
vocabulary symbols that determine the language L. More precisely, it
makes explicit the distinction between logical and nonlogical symbols in a
language: whereas the former (usually called the connectivesof the logic)
are captured by the grammar, the latter are given by (typed) sets. The no-
tion of consequence is then constrained to be invariant under changes of
nonlogical symbols in order to make it depend only on the connectives.
That is, we group together several of these closure systems that we regard
as being different instantiations of the same logic through different choices
of nonlogical symbols, and take that set as defining that logic.

Basically, in Sect. 3.5, when defining linear temporal logic, we intro-
duced the notion of signature as a means of modelling the instantiations of
the general structures of temporal logic, and made explicit the grammar
that defines the connectives. For every specific signature, we obtain a clo-
sure system whose language is determined by the application of the gram-
mar of temporal logic to the signature, and whose closure operator is ob-
tained through a notion of consequence derived from the traditional Kripke
semantics of temporal logic. The idea that all these closure systems are
related in a way that makes them instantiations of the same logic can be
captured by the following property.

6.5.1 Proposition

The mapping prop defined in Par. 3.5.2 and the translations induced by
signature morphisms as defined in Par. 3.5.7 extend to a functor
M:SET—CLOS.



130 6 Functor-Based Constructions

Proof
The crux of the proof is in showing that signature morphisms map to morphisms
of closure systems. But this is a direct consequence of the presentation lemma
(Par. 3.5.10). The reader is invited to fill in the details. •

Through the functor that maps closure systems to their underlying lan-
guages, Itl maps each signature to the set of well-formed formulae over
that signature. The fact that we have a functor means that changes of vo-
cabulary induce corresponding translations at the level of the languages,
thus capturing the idea of "uniformity" that we tend to associate with a
grammar. The same applies to the closure operator. The fact that changes
of vocabulary induce morphisms between the corresponding closure sys-
tems captures the flavour of uniformity and continuity that we associate
with a logic. Naturally, we can make these "flavours" concrete by making
the grammar explicit rather than implicit. It all depends on the level of ab-
straction at which one wants to work. The reader interested in these as-
pects should consult [63].

6.5.2 Definition - fl-lnstitutions

A n-institution consists of a pair <SIGN,clos>, where SIGN is a category
(of signatures), and clos:SIGN->CLOS is a functor. •

6.5.3 Remark

An equivalent definition of a JT-institution, given in [45], consists of:

• A category SIGN.
• A functor gram SIGN-^SET.
• For every Z.SIGN, a relation \-z:2

gmm(I>xgram(I) satisfying the fol-
lowing properties:

- For every pEgram(Z), p \—sp.
- For every pEgram(I) and &1,&2£g

ram(Z)> if <&iQ®2 and <£>i\—sP
then &2 ^sP-

- For every pEgram(I) and 01,02£g
ram(^)' if ®i \~zP and <&2 \~iP'

for every p'E<Ph then &2 \~sP-
- For every a/2'^'2", pEgram(I) and <PCgram(I), <£> \-zp implies

gram(o)(<P) \-rgram(a)(p).
Notice that the functor gram is the composition of clos with the forget-

ful functor that maps closure systems to the underlying languages. The
closure operator itself is derived from the consequence relation: for every
0£gram(I),cI!(0)={pEgram(I):0\—^p}. On the other hand, every clo-
sure operator defines a consequence relation: *P\—Ip iff pEcj(0).

The definition given in [45] further requires the consequence relation to
be compact, a property that we do not need for the constructions that we
are present in this book. •



6.5 Institutions 131

6.5.4 Remarks

1. Given the equivalence between the two definitions, we use the conse-
quence relation and the grammar function without notifying the reader.

2. Because the notation can become quite cumbersome, we often omit the
reference to the grammar functor when applied to morphisms and write
o(p) instead of gram(a)(p), like we did for temporal logic in Sect. 3.5. •
When defining a Jt-institution, the consequence relation or the closure

operator can be presented in many different ways. One of the possible
ways is the one we adopted in the definition of linear temporal logic: by
providing a notion of model and a satisfaction relation. This is what insti-
tutions, as defined by Goguen and Burstall [62], consist of.

6.5.5 Definition - Institutions

An institution is a quadruple <SIGN,gram,mod, N> where:
• SIGN is a category.
• gramSIGN^-SET is a functor.
• mod:SIGN°p^CAT is a functor.
• For every Z.SIGN, ^s:mod(Z)xgram(Z) satisfies for every o:Z—>Z',

pEgram(Z) and M'Emod(Z'), mod(a)(M')\= Ep iff M \=xgram(o)(p).

The functor mod provides, for every signature, the category of models
that can be used to interpret the language defined by gram over that sig-
nature. Signature morphisms induce translations between these classes of
models in the opposite direction. The idea is that, as seen in Par. 3.5.9 for
linear temporal logic, sentences in the language of the source signature can
be interpreted in a model for the target signature through the interpretation
of their translations. The condition that is required on the satisfaction re-
lation, which is usually called the satisfaction condition, states precisely
this property - that satisfaction is invariant under change of notation.

When reasoning about institutions, we normally use the simplified no-
tation for the gram functor that we mentioned for re-institution. We also
adopt a similar simplification for the mod functor: for every morphism
a:Z—»2" and M'Cmod(Z), we normally write M'\a instead of mod(o)(M').
For every signature 2, <PCgram(Z) and MEmod(Z), we usually write
M \=z<I>, meaning that M N^p for every pE<P. •

6.5.6 Proposition

Every institution <SIGN,gram,mod, N> presents the re-institution
<SIGN,gram,\—>, where, for every signature Z, p Egram(Z) and
<PCgram(Z), <P \—zpiff for every MEmod(Z), M \=SQ> implies M \=sp.

Proof
The proof that a ^-institution is obtained in this way offers no difficulties and is
left as an exercise. •



132 6 Functor-Based Constructions

Another way of presenting the closure operator or consequence relation
of a Jt-institution is through the notion of proof, choosing an inference
system for the logic. See [85] for such proof-theoretic presentations and
their integration in a more comprehensive categorical account of logical
systems that the author calls "General Logics".

6.5.7 Remark - Models Defined Via a Split (Co)Fibration

The model functor of an institution is defined in Par. 6.5.5 directly as an
indexed category, signatures providing the indexes. As seen in Par. 6.1.20,
indexed categories can be presented as split (co)fibrations, which is how,
in many cases, the model-theory of some institutions is more naturally de-
fined. That is, it is often more intuitive, not to say "practical", to provide
directly either a split fibration sign: MODL—>SIGN or a split cofibration
sign: MODL—>SIGN°P for some category MODL of models, and take
ind(sign) as the model functor of the required institution. This happens
when we already have a notion of model that corresponds to the domain of
interpretation intended for a given specification formalism, and we want to
use it as the "semantics functor" of the institution. An example can be
given through linear temporal logic.

6.5.8 Example - Linear Temporal Logic Over PROC

Temporal signatures were interpreted in Par. 3.5.3 over infinite sequences
of sets of atomic propositions corresponding to synchronisation sets of ac-
tions. Yet, from the point of view of modelling concurrent systems, such
infinite sequences do not represent abstractions of full behaviour; they
usually represent one single behaviour among many that may also be ob-
served on a given system. Hence, from the point of view of providing a
domain of interpretation for a formalism supporting concurrent system
specification, sets of such trajectories are more meaningful in the sense
that they can be taken to represent full behaviours. Put another way, if we
take single sequences as models of full behaviour, we are restricting the
expressive power of the formalism to a much smaller class of systems:
those that are deterministic and run in a deterministic environment.

We can see in Sect. 6.3 how such a trace-based model of process be-
haviour can be organised in the functor-structured category spa(tra) that
we called PROC, where tra.SETx^SET is the functor that generates and
translates between sets of traces. Hence, it seems intuitive that we investi-
gate the use of this category for providing the models of an institution of
linear temporal logic. However, the split cofibration defined by spa(tra) is
over SET±, not over SET°

P as required for the temporal signatures. Indeed,
processes were defined over arbitrary alphabets of actions, whereas in the
case of temporal logic, propositions are interpreted over traces of synchro-



6.5 Institutions 133

nisation sets. Hence, some adaptation is required. There are two equiva-
lent ways in which this adaptation can be performed.

The first approach is to work with the subcategory of spa(tra) that in-
volves only alphabets of synchronisation sets. Powersets can be regarded
as pointed sets, the empty set providing the distinguished element. More
precisely, we show in 3.3.2 that, by choosing the morphisms 2B—>2A to be
the inverses of the functions A—>B, we define a subcategory of SET± that
we called POWER. Therefore, we can particularise the spa construction
that yields processes to the functor ptra: POWER->SET that yields the set
of infinite traces taken over sets of actions. Finally, there is a straightfor-
ward (and powerful, as seen in Chap. 7) way of relating SET°P to POWER:
through the contravariant functor 2~ that maps every set A to its powerset
2A and every function A—*B to the map 2B-*2A that computes inverse im-
ages according to that function. Hence, we can particularise tra to the
functor ftra:SET°p-*SET=2~;tra and use the split cofibration defined by
spa(ftra) over SET" as the model functor ind(spa(ftra)):SET°r->CAT of
an institution of linear temporal logic. See Par. 6.1.20(2) for details pn the
construction. This is the institution that associates every temporal signa-
ture (set of actions) with the category of processes whose alphabet consists
of the subsets of the signature (synchronisation sets of actions).

An alternative approach is to restrict not the (co)fibration that generates
the indexed category but the indexed category generated by the original
(co)fibration, i.e. to work with 2~;ind(spa(tra)). This is simpler because it
does not require the definition of a new (co)fibration. For the same reason,
this approach is less satisfying because it is less structural in the sense that
it does not characterise explicitly the class of models that are chosen. In
the case of linear temporal logic, both approaches lead to the same indexed
category. Indeed, taking the indexed category SET±-*CAT generated by
spa(tra), we can compose it with the contravariant powerset functor SE-
T°P^SET± to define the required model functor SET"->CAT.

It remains to define the satisfaction relation of this institution. Given
that models over a signature 2 consist of sets of traces AC(2^)W, satisfac-
tion of a temporal proposition by a process is defined as satisfaction by all
the traces of the process as defined in Par. 3.5.3. The satisfaction condi-
tion results from the properties proved in Par. 3.5.9. Indeed, the reader
should check that the notion of reduct defined therein coincides with the
functor between fibres defined by the cofibration as in Par. 6.1.16. •

It is easy to see that the institution defined over this indexed category
yields the same Jt-institution as the one that can be defined directly by ap-
plying Par. 6.5.2 to the functor defined in Par. 6.5.1 (which is based on a
semantic interpretation over single sequences as given in Par. 3.5.3). This
is because the PROC-b&sed institution and the one that uses single trajec-
tories as in Par. 3.5.3 give rise to the same consequence relation. How-
ever, we shall see that they satisfy different structural properties, which



134 6 Functor-Based Constructions

shows that, by forgetting the model-theory to retain just the consequence
relations, Jt-institutions are indeed more abstract than institutions.

6.5.9 Remark - When a Split (Co)Fibration Is Not Available

The availability of a split cofibration for the definition of the model func-
tor is very useful because it allows us to work with reduct functors that op-
erate on the chosen semantic models, and therefore compare the structures
that models and theories provide for specification. However, it may hap-
pen that we have a notion of model in mind that can still be captured by a
functor sign: MODL->SIGN°P', but one that is not a cofibration. The
problem here is the definition of a suitable translation between models.

This problem can be solved by not working directly over the fibres de-
fined by the functor, but with what we could call "generalised" models:
those that are provided by structured morphisms as defined in Par. 6.2.2.
That is, the idea is, for every signature 2, to work with models of the form
<o:2->sign(M),M> so that mod(Z) is Zjsign, making mod the functor
_lsign:SIGN°p—>CAT mapping morphisms n:Z—>I,' to the functors
21' I sign -*Zl sign that map generalised models <a:2"—*sign(M'),M'> to
<[i;o:Z-*sign(M'),M'>. (The reader is encouraged to fill in the way the
functor works on morphisms between models.) In a way, what this con-
struction does is compensate for the lack of (co)Cartesian morphisms by
providing an explicit "adaptor" that maps the signature to the language of
the model. As a result, instead of translating directly between models, re-
ducts operate "syntactically" at the level of these adaptors.

The reader may be wondering whether this is not just a contrived way of
bringing structured morphisms into the discussion and a good example of
"abstract nonsense": an accusation often made to categorical techniques
when developed without a clear application in mind, in a self-justified
process of "structure for structure"... Certainly this is not true in this case
(nor in any other case in this book); these generalised models are quite
common in modal logic (e.g. [67])! Indeed, models for a modal logic,
normally called frames or Kripke structures, can be regarded as concrete
categories over a base category of possible worlds. The adaptors that we
defined correspond to interpretation functions that, for each atomic propo-
sition, return the set of possible worlds in which the proposition is true. A
generalised model, consisting of a Kripke frame and an interpretation
function, is usually called a model in modal logic.

In the case of linear temporal logic, this means that interpretation struc-
tures are no longer traces XE(2s)m as defined in Par. 3.5.3 - where we
mentioned that they are canonical Kripke structures for linear, discrete,
propositional logic [110] - but triples < W,kEWw,v:2->2w> that corre-
spond to the more traditional notion of models. In this case W is a set of
possible worlds (events), the pair <W,A.EWa)> defines a linear frame



6.5 Institutions 135

(Kripke structure), and the function v returns the set of worlds (events) in
which each atomic proposition (action) holds (occurs).

In the case that interests us, MODL is the original spa(tra), but sign is
not the original cofibration but its composition with the powerset functor
SET±—>SET°

P (in fact, as shown in Par. 7.3.6, the left adjoint of the power-
set functor used in Par. 6.5.8). This means that reducts are not operated by
the cofibration, and hence we lose some of the structural properties of
processes. More details on these constructions can be found in [32, 33]. •

In logic, models are considered to be the "duals" of theories. In institu-
tions, this duality can be explored and made explicit in several ways. We
can start by realising that the theories of the underlying closure systems
can be organised in a category that provides itself a split (co)fibration over
the category of signatures. Indeed, we proved in Sect. 6.1 that the cate-
gory THEOLTL of linear temporal theories, as defined in Par. 3.5.4, is both
a split fibration and a split cofibration over SET. The extension to any K-
institution is trivial.

6.5.10 Proposition - The (Co)lndexed Category of Theories

1. Every ^-institution <SIGN,clos> defines a functor theo:SIGN—*CAT
as an extension of clos by mapping every signature 21 to the category
THEOcios(I) of the theories over clos(Z), and every signature morphism
o:Z-*2 to the functor theo(o):THEOclBS(I:j-^THEOclos(Z) that is defined
by theo(o)(<P)=c'(clos(o)(<P)).

2. Every ^-institution <SIGN,clos> defines a contravariant functor
theo'1:SIGNop—>CAT by mapping every signature S to the category
THEOcios(Z) of the theories over clos(I), and every signature morphism
o:I'^S to the functor thecfl{o):THEOcms)-->THEOclos{S) defined by
theo-1(o)(0)=clos(a)-1(0).

Proof
Notice that, because the category of theories over a closure system is, in fact, a
preorder, the functors theo(cr) and theo~'(o) do not have to be defined on mor-
phisms. However, we are required to prove:
1. Given theories &<r in THEOclos(I), theo(o)(&)<theo(o)(r). This holds be-

cause clos is a functor. More precisely, given &CF in THEOclos(Z), we have
clos(o)((t>)Cclos(o)(r) because clos(a) is a function between the languages of
the two closure systems, which implies c'(clos(a)(<P))Cc'(clos(o)(F)) because
closure operators are monotonic with respect to set inclusion.

2. Given theories &<F in THEOdos<I), theo'
1(o)(0)<theo~1(o)(r). Given (per,

we have clos(a)'1(0)Cclos(a)"1(r) because clos(o) is a normal function be-
tween the languages of the two closure systems, and the inverse image of a
closed set is itself closed.

The reader is invited to complete the proof as an exercise. •
The (co)flattening of theo as a (co)indexed category provides us with a

split (co)fibration THEO<SIGNdos>^SIGN, where THEO<SIGNclos>, the flat-



136 6 Functor-Based Constructions

tened category, consists of pairs <1,0>, where 21 is a signature and 0 is a
closed set of sentences of gram(Z), i.e. 0 is a theory of clos(Z). A mor-
phism o:<2, <&>-*< 2", <&'> is a signature morphism o:Z->Z' such that
cr(o(0))C0'. Theories were originally defined in (jt-)institutions in this
way. Notice that it does not matter whether one flattens the indexed or the
coindexed category: the categories obtained are dual. This is because
cx(o(<P))C<p' holds iff (pCa'(0').

This construction can be generalised to (strict) presentations.

6.5.11 Definition - Theories/Presentations in a fT-lnstitution

Given a ̂ -institution <SIGN,clos>, we define the following categories:

1. THEO <SIGNclos>, the category of theories, has for objects the pairs
<Z,0>, where I is a signature and 0 is a closed set of sentences of
gram(I). A morphism o:<2,0>—><2\0'> is a signature morphism
a:I~^I' such that o(0)C0'.

2. PRES<SIGNci0S>, the category of theory presentations, has for objects the
pairs <S,0>, where 21 is a signature and 0Cgram(Z). A morphism

l\0'> is a signature morphism o:Z-*2' such that

3. SPRES<SIGNclos>, the category of strict theory presentations, has for ob-
jects the pairs <2,0>, where Z is a signature and 0Qgram(2). A mor-
phism a:<Z,0>—*<X,0*> is a signature morphism o:S—*X such that
O(0)C0'. •
These categories satisfy the properties that we have already proved for

their linear temporal logic instantiations.

6.5.12 Proposition

Consider a Jt-institution <SIGN,clos>..

1. The categories PRES<SIGNdos>, SPRES<SIGNclos> and THEO<SIGNclos> de-
fine split fibrations and split cofibrations through the functor sign that
projects their objects and morphisms to the corresponding signature
components. Given a signature morphism o:Z->I\

PRES

SPRES

THEO

Cartesian

a:<I,a'(c(

a:<I,a'(0

morphism

)>-*<2,&'>

)>-*<T,®'>

for Cocartesian

a:<S,0>—*<

o:<Z,&>—><

morphism

I',O(0)>

Z\o(<P)>

Z,c(o(<P))>

for

2. All these (co)fibrations are fibre-(co)complete. The following proce-
dure calculates limits and colimits of a diagram 6 with 6j=<2'j,<?

>i> in
these categories:



6.5 Institutions 137

Calculate the limit o:Z->d or colimit o:d->Z of the underlying dia-
gram of signatures.
Lift the result by computing the S/GiV-component according to the
following rules:

PRES

SPRES

THEO

Limit

o:<S,niaor
1(c(<Pi))>^5

o:<2.niaor
1(&i)>-*d

o:<S,niaor
1(&i)>-*d

Colimit

o:8-*<Z ,Uia o^®^

a:6-xl .Uig a^,)>

a:d-xi:,c3iUma^d)>

3. If SIGN is (co)complete, so are PRES<SIGNci0S>, SPRES<SIGNci0S> and
THEOKSIGN ,cios>- ^

This symmetry between theories and models, as captured through in-
dexed categories, can be used to provide every Jt-institution with a canoni-
cal notion of model that makes it an institution.

6.5.13 Proposition - Institution Presented by a fl-lnstitution

Every it-institution <SIGN,gram, \—> defines the institution
<SIGN,gram,theo~', N>, where for every signature 2", pEgram(Z) and
0£theo~1(I), ®\=zp iff pE&.

Proof
We just have to prove that the satisfaction condition holds. Let S:SJGN,
l==E:mod(Z)xgram(2) satisfy for every morphism o:H—*Z', pEgram(Z) and
<J>'aheo-'(S'), theo-'(a)(0[) ^lP iff (r'(&') ^Sp iff pEcr'(<P') iff o(p)E&' iff
<P)=so(p). •

What this results says is that, whereas having a model-theory that corre-
sponds to an intended domain of interpretation for the language of a logic
may be a convenient way of defining a Jt-institution, once we are given a
Jt-institution there is not much point in searching for a model-theory for it.
Its theories are up to the job at no conceptual expense.

Notice that the consequence relation induced by this notion of satisfac-
tion is ®\—Ip iff, for every FEtheo'^Z), &CF implies pEF, which is
equivalent to pEc(&). That is, we recover the Jt-institution from which we
started. Hence, institutions do give us a more concrete level of abstraction
at which properties of specifications can be discussed.

Duality between models and theories can also be explored by lifting
some of the signature-based constructions to theory-based ones.

6.5.14 Proposition

Let <SIGN,gram,mod, h=> be an institution.



138 6 Functor-B ased Constructions

1. The functor mod:SIGNop^>CATextends to tmod:THEOop-*CAT by as-
signing to every theory <2,<P> the full subcategory of mod(S) that con-
sists of the models that satisfy 0.

2. When mod is generated by a cofibration sign:MODL—*SIGNop, we can
lift it to theo:MODL^>THEO°" by associating with every model the
theory that consists of all the sentences that are true for that model.

Proof
We have to prove that a functor is, indeed, defined in point 1. This is because,
given a theory morphism o:<2,([»-><2,&'> and a model M' of <!?,&'>, M'\a
satisfies <P. The reader is invited to work out the proof of the second property. •

6.5.15 Remark - Theories Over Generalised Models

We saw that functors sign: MODL-*SIGN°P give rise to model functors of
the form _lsign:SlGNop —>CAT that are typical of Modal Logic. In an in-
stitution defined over such a model functor, the notions of theory and the
constructions that we have presented around them for arbitrary
(rc-)institutions still apply. For instance, _lsign:SIGNop->CAT extends to
tmod:THEOop-*CAT as defined in Par. 6.5.14. However, in this particular
case, it is interesting to check if, or when, sign:MODL->SIGNop can lift to
theo.MODL^THEO0" so that tmod is, in fact, _ltheo.

The intuition for this interest is that we should be able to associate with
every model M a canonical specification theo(M) so that every morphism
T-*theo(M) identifies T as a specification of M and, dually, M as a realisa-
tion of T. In this case, the models of T correspond to all possible refine-
ments of T into "programs", something that we already discussed in Par.
6.2.1. Identifying MODL with the behaviours of programs (or processes),
this corresponds to the idea that programs can themselves be regarded as
specifications, and that the models of a specification can be identified with
the programs that, in some sense, complete the specification.

Although it is always possible to define a mapping that associates a the-
ory theo(M) with every model M - the obvious candidate assigns to
theo(M) the signature sign(M) and all the sentences that are true in it
{pEgram(sign(M)): <id,M> ̂ p} - it is not always possible to extend it to
a functor that lifts sign, i.e. such that theo(h:M->M')=sign(h). In order to
motivate why this is so, assume that we do have theo:MODL->THEO°P as
a functor and consider a morphism h:M'->M. Because theo is a functor,
we have theo(h):theo(M)->theo(M'). Hence, if M is a model of a theory T,
i.e. if we have a morphism o:T->theo(M), then M' is also a model of T
through the morphism o;theo(h). In particular this implies that, for every
signature 2 and pEgram(S), if <o,M> ^sp then <a;sign(h),M'> ^ZP-
This property, however, is not universal: only some institutions (logics)
satisfy it.



6.5 Institutions 139

There are two important aspects about this property. The first is that, as
proved in [33], it guarantees that sign: MODL-*SIGNop lifts to theo:
MODL-^THEO"" as defined, and that tmod is, in fact, _itheo. The sec-
ond is that, once again, it is not an artificial "fabrication": it captures what,
in modal logic, is known as "the p-property" [67]. That is, there are well-
known principles of modal logic that can be captured in the categorical
framework that we have defined, meaning that we are, indeed, addressing
structural properties of logic as we have known them. Once again, a more
detailed discussion of the p-property and its impact in specification can be
found in [32, 33]. •

6.5.16 Exercise

Check that the institution of linear temporal logic as defined in Par. 6.5.9
over general Kripke structures satisfies the p-property. •

The reader will have noticed that, in an institution, the model functor is
defined over CAT instead of SET. This is because, some times, models
come equipped with a non-trivial notion of morphism and, as argued in
Par. 6.5.9, it is not always possible to reflect in the logic the structure that
they induce on models.

However, so far, the constructions that we discussed do not depend on
the notion of morphism between models, and hence do not reflect the
structure of the interpretation domain that are chosen for the specification
formalisms. We are now going to illustrate a situation in which such
structures are of interest.

6.5.17 Definition - Initial/Terminal Semantics

We say that an institution <SIGN,gram,mod, \=> has initial (resp. termi-
nal) semantics provided that, for every theory <Z,<P>, the category
tmod(<Z,&>) has an initial (resp. terminal) object. •

A non-trivial (but simple) example of an institution with terminal se-
mantics is linear temporal logic.

6.5.18 Example - Terminal Semantics of Linear Temporal Logic

The institution of linear temporal logic as defined in Par. 6.5.8 over the
cofibration spa(ftra) has terminal semantics. This is because, given any
theory <Z,<P>, the category tmod(<Z,<P>) consists of sets of traces or-
dered by inclusion and is closed under intersection. •

Notice that linear temporal logic interpreted over single sequences does
not have terminal semantics: the (discrete) category that represents the set
of all the sequences that satisfy a given theory does not have a sequence
that represents the whole set unless the set is singular.



140 6 Functor-Based Constructions

6.5.19 Exercise

Check that the institution of linear temporal logic as defined in Par. 6.5.9
over general Kripke structures has terminal semantics. Does it coincide
with the one obtained in Par. 6.5.18? •

Properties such as having an initial or terminal semantics can be used
for differentiating between different institutions that present the same n-
institution. It is interesting to note that what we have called the "canoni-
cal" institution for a given Jt-institution, the one that uses theories as mod-
els, has both initial and terminal semantics. The initial model of every
theory is the theory itself and the terminal model is the inconsistent theory,
i.e. the full language. That is, we do not extract much information from
the structure of models, which was only to be expected because we do not
extract any information from the model-theory itself.

This example can also be used to transmit a certain "moral" message,
namely that the pursuit for an institution with "good" properties like the
ones above is, most of the times, a trivial one in the sense that it is usually
possible to engineer a model-theory that satisfies one's requirements. As
already said, the real purpose of these properties is to measure the relation-
ship that the institution provides between specifications and the domain as
abstracted through the models. Hence, one needs to determine the nature
of the models relative to the domain of interpretation and not to the prop-
erties, otherwise what we get is "abstract nonsense".



7 Adjunctions

7.1 The Social Life of Functors

Yes, even functors are entitled to have their own social lives. And they
can be quite rich, too. In this book, we will remain at the level of what is
basic and indispensable for covering this last topic of our introduction to
category theory: adjunctions. For that purpose, we will provide a short in-
troduction to what are normally accepted to be "the" morphisms between
functors: natural transformations. The best way of understanding what
natural transformations consist of, and can be used for, is to look at func-
tors as views that one has from one category into another and to formulate
the properties that characterise the "preservation" of such views.

7.1.1 Example - Two Views of Eiffel Class Specifications

We have already seen how one can look into Eiffel classes from the point
of view of temporal logic specification: this is the view that is provided
through the functor spec that we defined in Par. 5.1.3. This functor ac-
counts for both the pre/postconditions of methods and the class invariants.
However, one is often interested in a higher-level view of the behaviour of
object classes that is concerned with the global properties that can be ob-
served from their interfaces, typically their functions and routines. For this
particular view, the actual specification of the functionality of the methods
is of little relevance; they account for "how" these global properties are
achieved rather than just "what" they are. Therefore, it makes sense that
we define another functor obsv: CLASS_SPEC—*PRESPOLTL that offers
the more abstract point of view. Formally, these observable properties can
be defined as sentences that involve only routines and functions. Hence,
given an Eiffel class specification e=<Z,P,I> we define

obsv(e)=<I,{(/>ELTL(fun(Z)Urou(2:)) I <P \-s (/>}>,

where <P is the set of axioms of spec(e). The reader is invited to check that
this mapping defines a functor, i.e. that class inheritance induces an inter-
pretation between the corresponding global properties.

Given two such views of class specifications, how can we relate them?
Clearly, such a relationship has to be established on the basis of mor-
phisms that, for each class specification e, relate obsv(e) and spec(e). By



142 7 Adjunctions

definition, observable properties are derivable from the full class proper-
ties, so there is a morphism of presentations between each obsv(e) and
spec(e). However, in order to respect the structure that morphisms (in-
heritance between class specification) induce on both views, the way ob-
servable properties relate through inheritance must be "the same" as the
full specifications relate between them. •

7.1.2 Definition - Natural Transformations

Given two functors ty:D->C and cp:D->C, a natural transformation x from
\p to cp, denoted by tp—*—*<p or T:XJJ—~~*<p, is a function that assigns to
each object d of D a morphism Td:ip(d)->(p(d) of C such that, for every
morphism f:d->d[ of D, the following square commutes. In this case we
say that rd is natural in d or that the naturality condition holds:

- • cp(d)

<p(f)

i|>(d') • qp(d') d1

D

7.1.3 Exercise

Work out the example in full by defining and proving all properties. •
The most obvious example of a natural transformation is the identity.

7.1.4 Definition - Identities

Given a functor ip:D->D, the identity natural transformation idy assigns to
each object d of D the identity morphism id^d). •

In the rest of this section, we analyse some of the mechanisms and
properties that are available for using natural transformations when rea-
soning about how given functors relate to each other. The main results
that we need concern the way natural transformations compose and the
mechanisms we have to act on them.

7.1.5 Definition - Dual of a Natural Transformation

Consider two functors ip:D-*C and <p:D->C, and a natural transformation
ip-^^p. We define ^ - ^ - ^ ^ by T ° V % •

Notice that a morphism qfp(d)^fp(d) in C°p corresponds exactly to a
morphism ip(d)-*cp(d) in C.



7.1 The Social Life of Functors 143

A useful class of operations on natural transformations is induced by
functors into the sources, or from the targets, of the categories involved.
For instance, supposing that we have a way (functor) to relate the domain
of a viewpoint to another one (say between PRESF0LTL and PROC as in
Par. 7.3.14), it makes sense to compose it with a natural transformation to
provide a new one that extends the former to the second domain, e.g. to
provide a mapping between the processes that capture the observable and
the full view of object behaviour.

spec

CLASS SPEC
I proc

V
PRESF O L T L P R O C

obsv

7.1.6 Definition - External Composition

Consider a natural transformation ip—^~~*<p between functors ty
and q>:D—*C.
1. Given p:E->D we define p;ip—e2—>p;q>by (p;t)e=rp(e).
2. Given p:C->B we define ty;p—T;p > cp;p by (r;p)d=p(rd). •

These are external operations on a given natural transformation. An in-
ternal law can also be defined that allow us to compose views into more
complex ones in the sense that they bridge over sequences of viewpoints.

7.1.7 Definition - Internal Composition

Consider functors i}),(p,K:D-K! and natural transformations ip *q> and
The composition ty K is defined by (r;v)d=rd;vd.

<p(d)

cp(f)

K(d)

K(f)

- • K(d')

0|),(p,K

d'

D



144 7 Adjunctions

7.1.8 Exercise

Prove that the composition of natural transformations is well defined, is
associative and that the identities are units for the composition law. •

7.1.9 Definition - Natural Isomorphism

A natural transformation tp——><p is said to be a natural isomorphism
provided that each rd is an isomorphism, in which case ty and q> are said to
be naturally isomorphic, denoted by tps cp. •

7.1.10 Definition - Equivalence of Categories

Two categories C and D are equivalent when they admit functors ty:D-*C
and cp:C^D such that xl>;cpszidD and q>;rp=idc. •

Notice that equivalence between categories is a weaker notion than iso-
morphism as defined in Par. 5.1.7. In particular, an equivalence does not
operate up to equality but up to isomorphism. For instance, given any ob-
ject d of D, cp(xp(d)) does not need to be d but just isomorphic to d. Hence,
to mark the fact, we do not use the term "inverse" for qualifiying each of
these functors with respect to the other but "pseudo-inverse". This is the
terminology used, for instance, in [12].

For instance, for any institution, PRES and THEO are usually not iso-
morphic (the same theory may admit many presentations), but they are
equivalent (all the presentations that define the same theory are isomor-
phic). This example shows that a category may be equivalent to one of its
strict subcategories.

7.1.11 Exercise

What about SPRES1 How does it relate to PRES and THEO! •
Another example of an equivalence concerns two categories for which

we have already highlighted many relationships.

7.1.12 Example - Equivalence Between PAR and SET±

The mappings
• -1 that removes the designated element from pointed sets and trans-

forms morphisms into partial functions, and
• +J1 that adds a new element to each set and completes partial functions

by using the new element where they were undefined
define two functors whose compositions are naturally isomorphic to the
identity. •

Indeed, both categories are basically the same in the sense that one just
makes explicit the partiality by presenting the designated element. In
many applications in computing, namely in the modelling of system be-
haviour as we illustrated with processes and specifications (theories), one



7.1 The Social Life of Functors 145

tends to switch between one category and the other depending on whether
we wish to attribute a meaning to the designated element, like for proc-
esses where it models steps performed by the environment, or be less bu-
reaucratic (more pragmatic) and keep it just implicit. In fact, this is what
we did in the graphical representations of the examples of universal con-
structions on processes; to simplify the notation, we omitted the designated
element from the alphabets and represented the morphisms as partial func-
tions. The old duality between syntax and semantics also tends to play a
role: for semantic domains, like processes, it is useful to handle the desig-
nated element; but for design languages, like Community (Chap. 8), it is
often more "practical" to work instead with partial functions. The equiva-
lence tells us how we can switch between the two views.

Note that the two categories are not isomorphic: the new element that is
used to complete a set is not necessarily the one that was forgotten when
that set is obtained from a pointed one. In fact, it is interesting for the
reader to come up with a "real" definition of the functor that adds new
elements to sets to make pointed sets: Which elements does it add? Is
there a canonical way of performing this completion?

The fact that we do not have an isomorphism is more significant for the
"social life" of the categories themselves than for the structures that they
endow internally on their objects (which is basically the same). We give
an example of what we mean by this in Par. 7.3.13.

7.2 Reflective Functors

Keeping the promise of writing for the community of software scientists
and practitioners, who are not necessarily as mathematically oriented as
most of the other books on category theory assume, we abstain from the
traditional introduction to adjunctions, such as the construction of free
monoids and other mathematical structures, or Galois connections. In-
stead, and besides giving examples closer to system development, we fol-
low the method adopted in previous chapters. That is, we give and use
concepts introduced about subcategories to motivate the definition of
"similar" properties of functors, based on the fact that the inclusion of a
subcategory in another one defines a functor.

The generalisation from subcategories into functors that interests us for
adjunctions concerns reflections and coreflections as introduced in Pars.
3.3.8-3.3.12. Therein, we discussed (co)reflections as a specialised class
of "secretaries" through which all the interactions can be factorised. The
generalisation consists, once again, in replacing the inclusion by a functor;
secretaries become "interpreters", i.e. some kind of "adjuncts" through
which all the communication with the other side of the functor is handled.



146 7 Adjunctions

7.2.1 Definition - Reflections
Let q):D—>C be a functor.
1. Let c be a C-object. A (^-reflection for c is a C-morphism o:c-*cp(d) for

some D-object d such that, for any C-morphism f:c—>cp(d') where dy is a
D-object, there is a unique D-morphism/.J-*J' such that/=o;<p(/\), i.e.
the C-diagram commutes:

o
c *• q>(d) d

I

cp(d') d'

c 4 D
2. The functor q> is said to be reflective iff every C-object admits a cp-

reflection. We tend to denote functors that are reflective with the spe-
cial arrow •—•. •

That is, given an object c of C, we are looking for the "best" object of D
that can handle its relationships "across the border", i.e. with other objects
of D through the functor q>. The morphism o can be seen as the protocol
that c needs to have with its "interpreter", or the "distance" that remains to
be bridged in D.

Notice that (^-reflections are (^-structured morphisms in the sense of Par.
6.2.2. The following proposition provides a useful characterisation of re-
flections.

7.2.2 Proposition

1. Given a functor tp:D—>C and a C-object c, the (p-reflections for c are the
initial objects of the category cj(p.

2. A functor y:D-*C is reflective iff, for every C-object c, the category
c J, cp has initial objects. •

7.2.3 Exercise

Prove 7.2.2 and conclude that (^-reflections for an object c are essentially
unique, i.e. two ^-reflections for c are isomorphic and, if f:c-*cp(d) is a cp-
reflection for c and h:d—>d' is an isomorphism, then f;(p(h) is also a cp-
reflection for c. •

The notion of reflector for the inclusion functor defined by a reflective
subcategory put forward in Par. 5.1.13 can also be generalised to an arbi-
trary reflective functor.



7.2 Reflective Functors 147

7.2.4 Definition/Proposition - Reflectors

Let cp:D—>C be a reflective functor. We define a functor p:C-*D as fol-
lows:

• Every C-object c has a (^-reflection arrow rjc:c—>cp(d). We define

Consider a morphism h:c—*c\ The composition h;rjc. is such that the
definition of (p-reflection arrow for c guarantees the existence and
uniqueness of a morphism h':p(c)—>p(c') such that h;ijc=r]c;cp(h'). We
define p(h)=h'.

D

This functor is called a reflector for <p.

Proof
The proof is trivially generalised from the one given in Par. 5.1.13 and is left as an
exercise. •

7.2.5 Definition/Proposition - Reflection Unit

Let sp:D—>C be a reflective functor and p:C—*D a reflector. The definition
of p directly provides a natural transformation idc—

2—*p;<p. We call it
the unit of the reflection. •

By duality, we obtain the notion of coreflective functor and coreflector
for a coreflective functor, generalising what was defined for coreflective
subcategories. We tend to denote functors that are coreflective with the
special arrow*—•.

7.2.6 Proposition

Let <p:D—>C be a reflective functor. Every reflector p:C-*D for cp is core-
flective and admits <p as a coreflector. Moreover, given any D-object d, its
p-coreflection sd:p((p(d))^d satisfies r]¥dy,q)(ed)=idv(d).

Proof
Let d be a Z)-object. The universal properties of r\^d) ensure the existence and
uniqueness of a morphism ed:p(q>(d)) —*d such that rj^q^e^id^^.



148 7 Adjunctions

<p(d) • qp(p(«p(d)))

<p(d)

c +
<P

P(<p(d))

d

D

It is easy to see that ed is, indeed, a p-coreflection for d. Let g:p(c)—>d be a D-
morphism. We are going to prove that g#=t]c;cp(g):c—>q)(d) satisfies p(g#);ed=g.
Because there is only one morphism h:p(c)—*d such that rjc;q)(h)=g#, we are going
to prove that p(g#);sd satisfies the equation:

r]c;(p(p(g#);ed)
= r]c;(p(p(g#));(p(ed)
=g#>"H(p(d)>'<P(ed) properties of natural transformations,
=g# properties of ed.

<P(P(C))

<p(g) N . <p(P(g#))

r

<P(Ed)

q>(d)

P(g#)

P(cp(d))

D

Moreover, g# is the only morphism g': c—*q)(d) that satisfies g=p(g');£d, as the
equality implies r]c;<p(g)=r]c;(p(p(g'));q)(Ed)=g';r]rf<d);(p(Ed)=g'. •

7.2.7 Corollary

Consider a reflective functor cp:D-*C and its reflector p:C—*D.

1. From Proposition 7.2.6 we derive a natural transformation q>;p—-—*idD
that we call the counit of the reflection. The two natural transformations
(unit and counit) satisfy

cp = cp

P = P

2. Every morphism f:c—>q(d) can be mapped to f#=p(f);£d:p(c)—>d, which
is the unique morphism p(c)->d that makes the C-triangle commute.



7.2 Reflective Functors 149

Tic
->cp(p(c))

<p(f#)

<p(d)

P(f)

P(cp(d))

<p
D

Every morphism g:p(c)-*d can be mapped to g#=rjc;cp(g):c—>q(d),
which is the unique morphism c^cp(d) that makes the D-triangle com-
mute.

Ed

d < p(cp(d)) <p(d)

P(g#)

p(c)

D

These mappings define a bijection that is "natural" in C and D in the
sense that it satisfies, for every h:c'—>c and k:d->d\

p(h);f#;k=(h;f;q>(k))# and h;g#;cp(k)=(p(h);g;k)#

Proof

We leave the proof as an exercise. Notice that, for instance,
fi=r]c;cp(fif)=r]c;(p(p(f);sd)=T}c;(p(p(f));(p(ed)=f;r]f(ll);(p(ed)=f •

Some useful properties of reflective functors are as follows.

>D and cp:D—*C are reflective

7.2.8 Proposition

1. Reflective functors compose, i.e. if xj):E-
then so is ip;cp:E—*C.

2. Reflective functors preserve limits.

Proof
Left as an exercise. We give a brief illustration of point 2 for pullbacks. We start
with a pullback diagram in D that we translate to C. If we now consider a com-
mutative cone <c-^q)(di)>, we can lift it back to D through the reflection as a
commutative cone <p(c)—>dj>. From the properties of the pullback, we are given
a morphism p(c)—*d of commutative cones that translates, once again, to C as a
morphism of commutative cones. Uniqueness can be easily checked.



150 7 Adjunctions

<P

The characterisation of reflective functors provided through Proposition
7.2.2 allows us to give examples among some of the constructions ana-
lysed in Chap. 6.

7.2.9 Corollary

1. Let cpC^SET be a functor. The functor v:spa(q>)^C that forgets the
SZiT-component of each object (6.3.3) is both reflective and coreflec-
tive. The u-reflection of any C-object c is idc:c->v(<c,0>), and its
coreflection is idc: v(<c,(p(c)>)-*c.

2. Consider an indexed category v.Iop->CAT. As defined in Par. 6.4.7, the
functor fib(i):FLAT(i)-*I that projects objects and morphisms to their
/-components is reflective iff, for every index /, i(i) has an initial object
0^), and is coreflective iff, for every index /, i(i) has a terminal object
!#). The fib(i)-reflection of any index i, when it exists, is given by
idj.i-rfibfiXKiyOm^), and its/i&fij-coreflection, when it exists, is given
by id,:fib(i)(<U<„>)-*. •
Another obvious example of (co)reflective functors concerns, of course,

(co)reflective subcategories,

7.2.10 Corollary

1. If D is a reflective subcategory of a category C, then the inclusion
functor is reflective.

2. If D is a coreflective subcategory of a category C, then the inclusion
functor is coreflective. •

We can also generalise the results given in Par. 3.3.10 that relate full
(co)reflective subcategories with properties of the (co)unit.



7.2 Reflective Functors 151

7.2.11 Proposition

Consider a reflective functor (p:D—>C, and let e be its counit.
1. cp is faithful iff, for every O-object d, ed is epi.
2. cp is full and faithful iff, for every D-object d, ed is an isomorphism. •

7.2.12 Exercise

Complete the constructions and proofs of Pars. 7.2.6 and 7.2.7 to get ac-
quainted with these newly acquired tools. •

7.3 Adjunctions

Readers who are acquainted with category theory will have noticed that we
are not only following a different path to the topic, even if it turns out not
to be that different from [1], but also departing from the standard termi-
nology (if one really exists) for adjunctions. The reason is that the termi-
nology that we introduce is a natural continuation of the one we used for
subcategories (which is standard, or at least complies with [80], which
comes more or less to the same point). What we have called a cp-reflection
for d is called in [1] a cp-universal arrow for d (or with domain d), and a
reflective functor is called therein an adjoint. The prefix co is used in [1]
exactly in the same way so that a <p-coreflection is a <p-couniversal arrow,
and a coreflective functor is coadjoint.

Although we prefer the terminolgy that we introduced in the previous
sections, there are also good reasons for using the terminology introduced
in [1]: adjoints and coadjoints arise in adjunctions. In this section, we are
going to introduce the standard terminology on adjunctions (i.e. [80]) be-
cause it really is standard. Adjunctions are an intrinsic part of the vo-
cabulary of category theory. What is hardly standard is the way to ap-
proach and define the notion of adjunction. This is where, as authors, we
can allow ourselves a little illusion of originality.

7.3.1 Definition - Adjunctions

An adjunction from a category C to another category D consists of
• Two functors cp:D-*C and p:C—>D.
• Two natural transformations idc—

u-^>p;cp, cp;p—e—*idD satisfying

p •'"- >p;cp;p r* > p = p

ition p— cp for such an adjunc

cp can be called: the right adjoint, the adjoint, the forgetful functor:

We use the notation p— cp for such an adjunction, in which case:



152 7 Adjunctions

• p can be called: the left adjoint, the coadjoint, the free functor.
• r\ is called the unit.
• £ is called the counit. •

Concerning the terminology, the left/right classification is quite wide-
spread; (co)adjoints are used in [1] as already mentioned. Classifying the
functors as forgetful/free can be very helpful when the roles that they play
are obvious. This is precisely the case of the adjunctions that result from
reflective subcategories, functor-structured categories and indexed catego-
ries as illustrated below: the (right) adjoint usually "forgets" part of the
structure of objects that the left/coadjoint is able to freely generate the ad-
ditional structure.

7.3.2 Proposition

Every equivalence defines two adjunctions. •

7.3.3 Proposition

For every adjunction p— <p, qf—\pop is also an adjunction. •

7.3.4 Proposition

Given functors cp:D->C, p:C->D, ip:E->D, y:D-*E, if p is a left adjoint of
q> and y is a left adjoint of ip, then p;y is a left adjoint of ip;q). •

There are many alternative ways of characterising adjunctions. It can
even be hard to find two books that adopt the same characterisation as the
defining one. However, they all involve, in some way or the other, but not
arbitrarily, the properties analysed in Par. 7.2.7.

7.3.5 Proposition

An adjunction from a category C to another category D can be obtained
from:

• Two functors cp:D-*C and p:C-*D.
• A bijection between morphisms c-*cp(d) and p(c)—>d that is natural in C

andZ).

Proof
Much of the proof is sketched in Par. 7.2.7. We leave it as an exercise. •

This characterisation is useful for the following example in particular.

7.3.6 Proposition

The powerset functor 2~ :SET°P->SET± that maps every set to its powerset
as a pointed set, the empty set being the designated element, and every
function to its inverse image, defines an adjunction from SET± to SET°

P.



7.3 Adjunctions 153

Its left adjoint computes powersets of proper elements (i.e. excluding the
designated element) and inverse images.

Proof
The reader is invited to carry out the proof as it is very instructive, if not chal-
lenging, due to the fact that it operates on a contravariant functor! The natural bi-
jection is defined by associating functions of the form f:A—>2? with g:B—»2A by
aEg(b) iff b£f(a). •

An adjunction is a very strong relationship between two categories: it
allows us to give canonical approximations of objects in one domain with
respect to the structural properties that are captured in the other domain.
Examples of the use of adjunctions abound, even in the particular aspects
of computing science that interest us in this book. One that we have
worked out and presented in [36] concerns the synthesis of programs from
specifications.

7.3.7 Example - Synthesis of Programs from Specifications

Par. 5.1.3 shows how a satisfaction relationship between programs and
specifications can be defined from a functor spec:PROG—>SPEC that
maps every program to the maximal set of properties that it satisfies. In
Par. 6.2.1, every morphism S—>spec(P) is called a possible realisation of
the specification 5 by the program P. Par. 6.1.24 illustrates how systems
can be evolved by interconnecting components that make new required
properties to emerge. Par. 6.2.4 shows how the process of assembling a
system from smaller components, including the interconnection of new
components, can be addressed in a compositional way by addressing reali-
sations and not just individual specifications or programs.

We are now interested in incorporating into the picture the ability to
synthesise programs from specifications. This is intended as a means of
supporting the process of compositional evolution that we have been ad-
dressing. According to this principle, the addition of a component to a
system should not require the recalculation (or the resynthesis) of the
whole system, but only of the new component and its interconnections to
the previous system. To illustrate our purpose, consider once again the
vending machine as defined in Par. 3.5.6. In Par. 6.1.24, we develop the
specification of a regulator and show that, once interconnected with the
vending machine, the new system does not allow arbitrary sales of cigars,
but requires the insertion of a special token before a cigar can be selected.
Assuming that the original vending machine is implemented and running,
and that we are in possession of a realisation of the regulator, possibly by
using the synthesis method of [83], we want to be able to synthesise the
interconnections between the two programs (the running vending machine
and the realisation of the regulator) in order to obtain a realisation of the
specification diagram.



154 7 Adjunctions

In summary, given realisations of component specifications (either ob-
tained through traditional transformational methods, or synthesised di-
rectly from the specifications, or reused from previous developments), we
would like to be able to synthesise the interconnections between the pro-
grams in such a way that the program diagram realises the specification
diagram. That is, given specifications Sj and S2 (newly) interconnected via
morphisms (pj.S-^Sj and cp2:S-*S2, and realisations <CT ; ,P ;>, «J2,P2> of S,
and S2, respectively, one would like to be able to synthesise a realisation
<a,P> of S and interconnecting morphisms ji^P-^Pj and fi2:P—

>P2 such
that o;spec(ni)=q}i;Oi (i=l,2).

SPEC

spec(P)

spec(P2) spec

PROG

This general statement of what it means to synthesise interconnections
makes it clear that it is necessary to synthesise both the middle program P
and the morphisms jU, that are required to interconnect the given programs.
Because, in the general case, any object can be used in an interconnection,
this suggests, rather obviously, that a functor synt: SPEC—>PROG is re-
quired that is somehow related to spec. One possible such relationship is
for spec to be the inverse (in the sense of Par. 5.1.7) of synt, but this is a
rather strong property because it would require the two categories of pro-
grams and specifications to be isomorphic. Clearly, if this were to be the
case, we could hardly claim that we were dealing with two different levels
of abstraction. Hence, it makes sense to look for weaker properties of the
relationship between the two functors.

It seems clear that, more than programs, synthesis must return realisa-
tions of the given specifications. That is, for every specification S, synt(S)



7.3 Adjunctions 155

must be provided together with a morphism r\s:S-*spec(synt(S)) that es-
tablishes synt(S) as one of the possible realisations of S. Hence, rjs ex-
presses a correctness criterion for synt. Moreover, synt must respect inter-
connections in the following sense: given a specification diagram 8:
I-*SPEC, it is necessary that the program diagram 8;synt be a realisation
of 8 through (ot:8(i)^spec(8'(i)))i3n as defined in Par. 6.2.4. That is, we
must have, for every f:i-*j in / , 8(f);o~oi;spec(8'(f)). But these are the
ingredients that define a natural transformation. Hence, synt must be pro-
vided together with a natural transformation ?7.1S/S£C—»syn£,s//ec.

Consider now the synthesis of interconnections themselves. Given an
interconnection of specifications o:S-*spec(P), we should be able to syn-
thesise &:synt(S)-^P in such a way that the interconnection is respected,
i.e. o=t]s;spec(o'). This is equivalent to defining a (natural) bijection be-
tween the morphisms S—>spec(P) and the morphisms synt(S)—>P. But this
is precisely the property that characterises the existence of an adjunction
between SPEC and PROG. Hence, synthesis of interconnections can be
characterised by the existence of a reflector (left adjoint) synt for spec.
Notice that Proposition 7.2.2 characterises the synthesis functor precisely
in terms of the existence, for every specification, of a "minimal" realisa-
tion in the sense that all other programs that implement the specification
simulate it.

a
- • spec(P)

spec(a') SPEC

spec(synt(S))
spec

synt

PROG

synt(S) synt(spec(P))

synt(a)

Notice that the counit of the adjunction eP:synt(spec(P))->P is not nec-
essarily an isomorphism because spec(P) may not be powerful enough to
fully characterise P (we cannot guarantee that the specification domain is



156 7 Adjunctions

expressive enough to capture the semantics of P in full). Hence, we are
not even in the presence of an equivalence.

The direction of the counit reflects the fact that if we synthesise from
the strongest specification of a program P, we obtain a program that can-
not be stronger than P. Hence, the morphism eP provides a sort of "univer-
sal adaptor" between the program synthesised from spec(P) and P itself.

Although weaker than the existence of an inverse or a pseudo-inverse,
the existence of a left adjoint to the functor spec: PROG—>SPEC is quite a
strong property. This is not surprising because the ability to synthesise
any specification is itself, in intuitive terms, a very strong property. In the
literature, examples of synthesis of finite state automata from temporal
logic specifications can be found, both from prepositional linear temporal
logic as above [83] and from branching time logic [30]. However, their
generalisation to a full systems view is difficult. We shall see in Sect. 7.5
that we can go a longer way in the context of formalisms that separate
"coordination" from "computation".

Another important property that results from the properties of reflective
functors is as follows.

7.3.8 Proposition - Adjunctions and Reflections

1. Every reflective functor defines an adjunction in which it plays the role
of right adjoint.

2. In every adjunction, the adjoint <p is reflective with the co-adjoint p as
reflector, and p is coreflective with coreflector q>. •
This result allows us to derive from Par. 7.2.9 two useful adjunctions.

7.3.9 Corollary

1. Let q>:C-*SET be a functor. The functor v: spa((p)-*C has for left ad-
joint the functor that maps each C-object c to <c,0>, and for right ad-
joint the functor that maps each C-object c to <c,cp(c)>.

2. The functor alph that maps PROC to SET± by forgetting behaviours has
both a left and right adjoint. The left adjoint maps each alphabet A± to
the process <A±,0> and the right adjoint to <A±,tra(A±)>. •

7.3.10 Corollary

In any jr-institution, the functor sign:THEO—>SIGN that maps theories to
their underlying signatures has both a left and right adjoint. The left ad-
joint maps each signature to the theory <2,cI(0)>, and the right adjoint
maps it to <Z,gram(Z)>. •

Basically, both results tell us how to map back and forth between proc-
esses and alphabets, and between theories and signatures.



7.3 Adjunctions 157

7.3.11 Exercise

Work out direct proofs for Pars. 7.3.9 and 7.3.10, and interpret the mean-
ing of the natural transformations. Check how far Par. 7.3.10 extends to
presentations and strict presentations. •

From Pars. 7.2.10 and 7.3.8 we get another class of adjunctions.

7.3.12 Corollary

1. Every reflective subcategory defines an adjunction in which the inclu-
sion functor is the right adjoint.

2. Every coreflective subcategory defines an adjunction in which the inclu-
sion is the left adjoint. •

7.3.13 Example - Adjunctions Between SET, PAR and

The fact that, as seen in Par. 3.3.11, SET is a coreflective subcategory of
PAR tells us that the inclusion has a right-adjoint. As also seen in Par.
3.3.11, this right adjoint (called +_L in Par. 7.1.12) is the one that performs
the traditional "elevation" of partial into total functions by extending sets
with an "undefined" element, or "bottom", that serves as image for the
elements in which the partial functions are undefined. This construction
may well remind the reader of one of the functors over which the equiva-
lence between PAR and SET± was built in Par. 7.1.12: the one that bears
the same name. That is, we have the same kind of construction - the "ele-
vation" - being performed over two different categories. Are they related?

There is a "natural" way in which every pointed set can be viewed as a
(normal) set: just forget the "added structure", i.e. the fact that it has a
designated element. Note that this does not mean "through away the des-
ignated element", which is what the functor -1 (the pseudo-inverse of +J.
in the equivalence) does. Going back to Par. 3.2.1, we are mapping
pointed sets<A,J.A> to the underlying set A and morphisms between two
pointed sets f:<A,±A>-><B,±B> to the corresponding total function
f:A->B. This mapping defines SETX as a concrete category over SET.
The two elevations of PAR are related by this forgetful functor. The ele-
vation to SET is simply the result of forgetting that there is a designated
element in the elevation to SET±, which is captured by the following
commutative diagram:

PAR

+1 +1
SET < SETX

Notice that the elevation to SET± is explicitly recorded into a structure
that is added to sets, whereas the elevation to SET is merely a representa-
tion or encoding. This difference is well captured in the fact that it gives



158 7 Adjunctions

rise to an equivalence in the first case, but "just" a reflective functor in the
second. The elevation from PAR to SET± is also reflective, but the fact
that it is a coreflection is more interesting. If we complete the diagram
with the adjunctions that we have already built

PAR

SET

we can see that the functor that forgets the designated elements admits a
right adjoint that again performs another kind of elevation, this time super-
posing a designated element to every set. This is just the elevation of par-
tial functions being performed on total ones as a particular case.

PAR

SET

Notice that we obtain a commutative diagram of adjunctions (i.e. of re-
flective and coreflective functors), but not of the functors in general. For
instance, the diagram of +J. is clearly not a commutative one!

It is also important to point out, in what follows the remarks made in
Par. 7.1.12, that because PAR and SET± are equivalent, we tend to look at
them as being "the same", but they may bear quite different relationships
to other categories like, in this case, SET. For instance, the "elevations"
go in opposite directions, one from PAR, the other into SET±; one is re-
flective and the other coreflective. What is more interesting is that these
are "technical" differences. Conceptually, both PAR and SET± provide a
coreflective representation for "normal" sets; the representations are dif-
ferent because, in spite of being equivalent, the two categories offer differ-
ent structures and, hence, require different encodings of what is, essen-
tially, the same kind of relationship.

This example also shows how diagrams of adjunctions can be useful to
understand how different domains relate to each other. They provide a
kind of "roadmap" or "classification scheme" that is essential for being
able to "navigate" among the different structures that one tends to find in
the literature. For instance, we can enrich the previous diagram of adjunc-
tions with the one that we obtained in Par. 7.3.6:

+± 2~
SET *4 \ PAR « SETJL *4 * . SET

op

+_L -± 2~



7.3 Adjunctions 159

The composition of these adjunctions gives us the well-known adjunction
between SET and SET°P performed by the powerset functor.

This kind of roadmap was used in [97, 109] for formalising relation-
ships between models of concurrency like transition systems, synchronisa-
tion trees, event structures, etc., in what constitutes one of the most strik-
ing examples of the expressive power of adjunctions. Each such model is
endowed with a notion of morphism that captures a form of simulation as a
behaviour-preserving mapping. Typical operations of process calculi are
captured as universal constructions as exemplified in Par. 4.3.8 for PROC.
Reflections and coreflections1 are used for expressing the way one model
is embedded in another: one of the functors in the adjunction embeds the
more abstract model in the other, while the other functor abstracts away
from some aspect of the representation.

Instead of reproducing an example of such uses of adjunctions, which
on its own would hardly capture the richness of the classification that is
developed for different kinds of concurrency models in [97, 109], we pre-
sent a related kind of application: a duality between process models and
specifications. More precisely, a duality between PROC and linear tempo-
ral logic specifications given by THEOLTL as presented in [32] to show
how both semantics domains - theories and models - can be made part of
the same roadmap.

7.3.14 Example - Processes versus Specifications

We start by recalling that PROC is concrete over SET± through alph and
that THEO is concrete over SET through sign. In fact, we proved in Pars.
7.3.9 and 7.3.10 that these functors are both reflective and coreflective.
Moreover, we showed in Par. 7.3.6 that the contravariant powerset functor
2-:SETop^>SET± is reflective. We now show that 2~ can be lifted to
proc:THEOop-*PROC as a reflective functor that makes the diagram (of
reflective functors) commute.

2-
SETX < • SET

op

alph sign0"

PROC < • THEOop

proc

Let <Z,<P> be a theory. Requiring the diagram to commute fixes the
choice of the alphabet for proc(<Z,<P>): the powerset 2s considered as a

1 Further terminological confusion arises with respect to [109], where a coreflec-
tion is an adjunction in which the reflective functor (the adjoint) is a full em-
bedding, i.e. the straight generalisation of a full reflective subcategory.



160 7 Adjunctions

pointed set. We are going to choose for its behaviour the set
Af=<P}, i.e. the least deterministic process that satisfies the properties
given by the theory. It is not difficult to prove that we do obtain a functor.

If we consider now a process <A±,A>, the category <A±,A> iproc con-
sists of the specifications that are validated by the behaviours in A after a
suitable translation (which we called generalised models in Par. 6.5.9).
This category has an initial object: the set of all sentences in the language
of 2A that are validated by the behaviours of A translated by the unit of the
powerset adjunction. It is the largest, not the smallest, because we are
working with a contravariant functor. Hence, proc is indeed reflective,
with its reflector assigning to <AltA> the theory <2

A ,{p\A;r\k ^p}>.
Note that because, as shown in Par. 7.2.8, reflective functors preserve

limits, colimits of specifications are mapped by proc to limits of the corre-
sponding processes - again a form of compositionality. This says that
composition of specifications as given by colimits of configuration dia-
grams captures parallel composition of the corresponding processes taking
into account their interactions. In other words, compositionality expresses
precisely the view that "conjunction as composition" [112] applies to de-
velopment steps, not just specifications or designs. •

The reader is encouraged to consult [32, 33] for a wider discussion of
the relationships between these two categories, namely in the context of
what are called categorical institutions in [85].

7.3.15 Exercises

1. Work out the full proof of Example 7.3.14.
2. Relate this result to Par. 6.5.18.
3. Since, in the diagram in Par. 7.3.14, signop and 2~ are reflective and

alph is coreflective, why didn't we take the composition of sigtf with
2~ and the coreflector of alph to obtain an adjunction from PROC to
THEO°P7

4. What kind of generalisation into institutions can we hope for? •
Can we extend this ability of adjunctions to relate different semantic

models of concurrency to different specification formalisms as captured by
the categories of theories defined by institutions? To answer this question,
we present in the next section a summary of the results published in [5].

7.4 Adjunctions in Institutions

We start with an example in order to motivate the structures that are in-
volved in mapping between specification formalisms as captured by insti-
tutions. The typical temporal logics that have been used for the specifica-
tion of reactive systems are based on linear time, of which the one we have



7.4 Adjunctions in Institutions 161

been working with is an example. However, sometimes, branching time is
more justified. For instance, it is well known that verification techniques
over branching time logic can be more effective. The expressive power of
branching time logic can also be useful, especially in relation to progress
properties related to required non-determinism, like responsiveness. So,
we would like to have ways of mapping between specifications in these
different logics that support translations back and forth between them,
through which one can take advantage of the best features of each.

As an example, consider the specification of a "user-friendly" vending
machine that, once it accepts a coin, will make a cake and a cigar avail-
able. Notice that this is not a property of the vending machine as specified
in Par. 3.5.6; the specification given therein allows behaviours in which,
for instance, after a coin is accepted, no cakes and no cigars are delivered!
One could think that adding a property like (coinDF(cakevcigar)) would
solve the problem, but it is easy to see that this requirement does not cap-
ture the availability of a cake or a cigar for the customer to choose. It re-
quires that, in every behaviour, the acceptance of a coin is followed by the
delivery of a cigar or a cake. Hence, it admits as an implementation a ma-
chine that only delivers cigars! Moreover, it forces the customer to take
either the cake or the cigar among the options that are given, which does
not make sense when that activity is not initiated by the machine. All this
is because the trace-based semantics is not expressive enough to model
choice; for that purpose, branching structures are required.

A logic in which such properties can be easily expressed is the branch-
ing time logic CTL*. This logic is said to be branching because operators
are provided that quantify over the possible future behaviours from the
current state.

7.4.1 Definition - CTL* as an Institution

The branching temporal logic institution CTL* is defined as follows:
• Its category of signatures is SET.
• We define two classes of propositions (the state propositions fa and the

path propositions fa) for a temporal signature 1
fa ::= a I (^fa) I (faDipJ I (Afa)
fa ::= fa I (^fa) I (faDrpp) I (faU%)

• The set of branching temporal propositions gramCTL*(Z) is the set of
state propositions.

• Every signature morphism f:Z—>Z' induces the translation function
gram{f):gramCTLt{I,)-*gramCTL*('Z!) defined as follows:

gram(f)(fa) ::=f(a) I ^gram(f)(fa) I gram(f)(fa)Dgram(f)(ipj
I Agram(f)(fa)

gram(f)(fa) ::=f(fa) I ->gram(f)(fa) I gram(f)(fa)Dgram(f)(%)
I gram(f)(fa)Ugram(f)W



162 7 Adjunctions

• The model functor modCTL* is defined as follows:

- For every signature 21, a branching Z-model is a triple <W,R,V> with
R a total relation on W and V:2->2W.

- Given a branching model M=<W,R,V> we denote by L(M) the set of
all infinite sequences a>—>2s of the forraX;V~' where k:u>—*W is such
that X(i)RX(i+l) for every iEco. We denote by L(M,s) the subset of
L(M) that is generated by the sequences Xs:co—*W such that Xs(0)=s,
i.e. L(M,s) contains the subset of paths that begin at state s.

- Let M7=<W7,/?;,V;> and M2=<W2,R2,V2> be ^-models. A morphism
from Mj to M2 is a map f:W1—>W2 such that:
1. sRrf implies/(sjR^t).
2.f(s)R2u implies the existence of tEW, such that sRjt and f(t)=u.
3. sEVj(a) ifff(s)EV2(a).

- Let f:2j —>£2 be a morphism. If < W2,R2,V2> is a i^-model, then
<W2,R2,f;V2> is a 2"y-model called the f-reduct of <W2,R2,V2>.

• The satisfaction relation is as follows: the truth of a ̂ -proposition 0 in
M=<W,R,V> at state sEW (which we write (M,s)^^>) is inductively
defined as for LTL except for the operator A for which

(M,s) \=zA<j> iff, for every XsEL(M,s), Xs 1=°^.
• The branching temporal proposition 0 is said to be true in M, which we

denote by M \=^, iff (M,s) N^" at every state s of W. •

Notice how the new operator A quantifies over all possible paths that
start from the current state.

The reader is invited to check that the satisfaction condition holds.

7.4.2 Proposition - Satisfaction Condition

Let f:Z, —>Z2 be a signature morphism. For every ME\modCTL*(22)\
 a nd

<l>EgramCTL*(Z,), M ̂ E2gram(f)(<j)) iff modCTLt(f)(m) \= ^>. •
As done in previous chapters, we often use/instead of gram(f).

7.4.3 Corollary

CTL* as defined in Par. 7.4.1 is an institution. •
As an example of a specification in CTL*, consider the user-friendly

vending machine.

specification user-friendly vending machine is
signature coin, cake, cigar
axioms beg D A(-'cakeA-'cigar)

A A(coin v (-lcakeA-'cigar)Wcoin)
coin D A( ("lcoin)W(cakevcigar) )
coin D (EXcake A EXcigar)
(cakevcigar) D A( (-'cakeA-'cigar)Wcoin)
cake D (->cigar)



7.4 Adjunctions in Institutions 163

The operator E is the dual of A: it expresses the existence of a path from
the current state in which the given property holds. Notice the use of the
conjunction in (coinD(EXcakeAEXcigar)); it requires the machine to
give the customer the choice; hence, for instance, if the machine runs out
of cakes, it may not accept coins even if cigars are still available.

It is clear from the definition of CTL* that this logic "incorporates" LTL
in the sense that it can express at least as much as LTL. A theory in LTL
expresses properties about all possible behaviours of a system taken as in-
finite sequences of states. In CTL* this quantification can be made explicit
through the operator A. Hence, it should be straightforward to map a the-
ory of LTL to a theory of CTL* by qualifying every proposition with A.

This syntactic transformation between the two languages respects the
translations defined by signature morphisms, i.e. is "natural" on signatures.
Indeed, it is captured by a natural transformation.

7.4.4 Definition/Proposition

The family of functions as:gramLTL(2)—>gramCTL4Z) defined by a^(p)=A(j)
is a natural transformation from gramLTL to gramCTL*. •

There is also a way in which this translation can be claimed to be "cor-
rect". Every branching structure gives rise to a linear one in a natural way.

7.4.5 Definition/Proposition

Let /3Z map every branching model M=<W,R,V> to the linear model L(M)
defined in Par. 7.4.1. Given branching X-models M=<W,R,V> and
M'=<W',R\V>, and a p-morphism f:M-*M', let p^f) be the inclusion
L(M)^*L(Ml) that is induced by the properties of the morphism. The map-
ping fis is a functor modCTL*(^)-^modLTL(H) and the family <PS>SQSIGN\ de-
fines a natural transformation modCTU,-^modLTL. •

That is, we generate from every branching structure M the linear struc-
ture L(M) that consists of all possible paths through M. The syntactic and
semantic transformations agree in the sense of the proposition below.

7.4.6 Definition/Proposition

If M=<W,R,V> is a branching .T-model and (j>EgramLTL(H), then MN^40
iff^MjKtf.. •

This relationship between the syntax and semantics of the given institu-
tions allows us to define the intended functor between the corresponding
categories of theories.

7.4.7 Definition/Proposition

The mapping 7:THEOLTL-*THEOCTL, defined by 7(<2,r>)=<i:,c(Ar)> is
a functor. •



164 7 Adjunctions

By AF we are denoting the set {A(f> I (f>EF} and by c the closure operator
of CTL*. This functor allows us to translate any specification (theory) in
LTL to a specification in CTL*. This translation is "canonical" in the sense
of the proposition below.

7.4.8 Proposition

The functor 1:T11EOLJL-*TFIEOCTL* is coreflective, that is, admits a right
adjoint. •

It is not difficult to guess the nature of the right adjoint. Because T
computes direct images through a, its right adjoint computes inverse im-
ages, i.e. the adjunction is given by a generalisation to closure operators of
the well-known Galois connection between direct and inverse images of
sets. The unit of the adjunction is given by the inclusion rCaf'(c(a^r))).

7.4.9 Proposition

The mapping V:THEOCTL*^THEOLTL given by L(<Z,r>)=<I,a£'(r)>
is a coreflector (right adjoint) of T.

Proof (of Propositions 7.4.7 and 7.4.8)
The functor V is a coreflector of Tiff for every theory <Z,F> of LTL, the pair
(K^af'ida^r^^Mx) is a reflection. Consider f:<Z,F>-»<Z',a1r

1(r)>. We
have to prove that there is a unique CTL* moiphism f:<S,c( aJF))>—*<X,F>
such that ids;f=f. Unicity is automatically guaranteed by this equation. All that
remains is the proof that/is a theory morphism <Z,c(a2{r))>-><Z',r'> in CTL*.
Let a^F) \—^>. We have to prove that f(<p)EP. Because a^F) \—^> we have
f(a^F)) \—zf((j)) (a consequence of the satisfaction condition of CTL*). But
fia^F))=ar(f(r)) because a is a natural transformation. Hence, f(<p)Easc(f(r)).
On the other hand, f(F)CaIr'(F) because / was taken as a theory morphism
<Z,F>^<2,ar-'(F)>. Hence, fffyEF. •

The coreflector "forgets" the branching nature of time in CTL* by re-
taining only those propositions 0 for which A(f> is a theorem in CTL*, i.e. it
retains those truths that hold for every possible path.

The existence of the adjunction means that, in order to prove that a
CTL*-theory BT provides an interpretation (refinement) of an LTL-theory
LT, it is equivalent to prove LTQt{BT) or %LT)C.BT. For practical pur-
poses, the inclusion 'TfLTjCBT is easier to prove because it can be lifted to
presentations. Indeed, if we take the category PRESLTL of the theory pres-
entations of LTL, the adjunction between presentations and theories as
given in Par. 3.6.4 allows us to extend the adjunction between THEOCTL*
and THEOLTL to one between THEOCTL* and PRESLTL. Hence, the inclu-
sion %LT)CBT can be proved at the level of a presentation of LT. The
converse, however, does not hold because although there is also an ad-
junction between THEOCTL* and PRESCTL,, the right adjoint does not go in
the same direction as V.



7.4 Adjunctions in Institutions 165

The actual relationship between THEOCTL* and THEOLTL is stronger
than what we proved. The proof above showed us that every L7L-theory
<Z,F> is included in <2yaI'

1(c(a^r)))> but, in fact, they are equal. That
is, when translated back from its image in CTL*, an LTL-theory does not
gain any theorems. This result can be proved by noticing that every linear
structure can be generated by a branching one, i.e. the natural transforma-
tion fi consists of surjective mappings, which gives us the faithfulness of
the right-adjoint as in Par. 7.2.11. We will generalise this result below, but
it is important to realise that this means that the translation from LTL to
CTL* is "conservative", i.e. the representation of LTL in CTL* is faithful.

Notice that, in the proof above, no use was made of the syntactic trans-
formation itself. Only the fact that a is a natural transformation was used,
which indicates that the relationship between LTL and CTL* can be gener-
alised to other institutions.

In order to perform the generalisation, let us first analyse what in the
example above can be cast directly in categorical terms. The basic ingre-
dients in our example were:

• A natural transformation a:gramLTL—*gramCTL*.
• A natural transformation P:modCTL*—>modLTL.
• The invariance condition M ^s

ad<l>) iff b^M) N ^ .
These are exactly the ingredients found in institution morphisms [62]

and institution maps [85].

7.4.10 Definition - Institution Morphisms

Let i=<SIGN ,gram,mod, N > and i'=<SIGN',gram\mod\ ^ ' > be insti-
tutions. An institution morphism p:i—*i' is a triple <0,a,/3> where:

• ®:SIGN^SIGN' is a functor.
• a:0;gram'-*gram is a natural transformation.
• I3:mod-*&;mod' is a natural transformation.
such that the following property (the invariance condition) holds for any
signature I£\SIGN\, mE\mod(I)\ and fiEgram'(&(!)): m^jcc^^) iff

7.4.11 Definition - Institution Maps

Let i=<SIGN,gram,mod,^> and i'=<SlGN',gram\mod',^'> be insti-
tutions. An institution map p:i—n' is a triple <<P,a,/3> where:

• 0:SIGN^SIGN' is a functor.
• a:gram—><I>;gram' is a natural transformation.
• P:&;mod' —>mod' is a natural transformation.
such that the following property (the invariance condition) holds for any
signature IE\SIGN\, m'E\mod(®(Z))\ and §Egram(2):P^m<^^ iff

•



166 7 Adjunctions

7.4.12 Proposition

Through Pars. 7.4.4, 7.4.5 and 7.4.6 we have defined both a map
LTL->CTL* and a morphism CTL*^LTL. •

The fact that the relationship between the two institutions is based on
the identity functor between their categories of signatures blurs the differ-
ence between the concepts of morphism and map. The existence of the
two functors :Tand ^between THEOLTL and THEOCTL* is also a conse-
quence of the existence of a map and a morphism between the institutions.

7.4.13 Proposition

Let p=<&,a,/3>:L->L' be an institution map. The functor 0 extends to
THEO^THEO, by establishing 4>(<I,r>)=<0(S),c(a^r))>. •

7.4.14 Proposition

Let p=<W,a\p'>:i-*C be an institution morphism. The functor y7extends
to THEO^THEO, through W(<Z\r>)=< W(X), a'r-'(r)>. •

We can now generalise the results on the adjunction between the catego-
ries of theories of two institutions.

7.4.15 Proposition

Let i=<SIGN,gram,mod,^> and i'=<SIGN\gram\mod\^'> be insti-
tutions, p=<0,a,/3>:i->i' an institution map and <W,a\fl'>:i'->i a mor-
phism such that W is a right adjoint of <P, and, for every SE\SIGN\,
as=gram(riI:);a'0(I) where r\ is the unit of the adjunction. Then,

1. The functor V:THEO\,-*THEO', induced by the institution morphism
<W,a\/3'>, is a right adjoint of the functor THEO^THEO, induced by
the institution map <&,a,fi>.

2. If each component of |3' is surjective, i.e. if the institution morphism is
sound in the sense of [62], then the units rjs are conservative.

Proof:
This is a direct generalisation of the proof of Proposition 7.4.9. •

In other words, adjunctions on signatures can be lifted to adjunctions of
theories provided that the left adjoint is associated with a map and the right
adjoint with a morphism of institutions. A compatibility result is required,
a£=gram(rji:);a'0(i:), to make sure that both the map and the morphism
make essentially the same translations. Notice that the invariance condi-
tion relating a and /?, automatically generates a similar property for /3. The
result on "conservative" representations of one formalism into another is
also important: basically, it says that no new theorems arise when a theory
is translated from one formalism to another.

This result shows that there is a very strong relationship between insti-
tution morphisms and maps, as suggested by the fact that they make use of



7.4 Adjunctions in Institutions 167

essentially the same transformations between languages and models. The
difference between them, which is evident in the directions taken by the
transformations vis-a-vis the functor between the categories of signatures,
can be explained more easily when we see that they correspond to the two
directions of an adjunction. Note that the map takes the direction of the left
adjoint, while the morphism takes the direction of the right adjoint. These
directions are consistent with the accepted view of maps as providing rep-
resentations and morphisms projections of one institution into another.

In fact, provided that there is an adjunction between the categories of
signatures of two institutions, maps and morphisms between them can be
defined, interchangeably, that provide adjunctions for the functor between
the corresponding categories of theories.

7.4.16 Proposition

Let L=<SIGN,gram,mod, N> and C=<SIGN\gram',mod\ N'> be insti-
tutions.
1. If p=<0,a,/3>:L—»i' is a map such that #has a right adjoint W, then

a. The triple <f,a',/?'>, where a' is the natural transformation defined
by a'r=aV(i:.);gram'(£S:) and /?' is the natural transformation defined
by fi's-mod\£s);PV(S), is an institution morphism t'-»i.

b. The functor ITTHEO^THEO, induced by the map has a right ad-
joint: the functor ZJ:THEOr-^THEOj induced by the morphism
U

2. If <W,a',P'>:i'->L is a morphism such that Whas a left adjoint <P, then

a. The triple <&,a,/3>, where a is the natural transformation defined by
aE=gram(r]z);a'^E) and fl is the natural transformation defined by
fiz=fl<s>(i);mod(r]s), is an institution map from i—>C.

b. The functor V:THEO'C-*THEO', induced by the morphism has a left
adjoint: the functor TiTHEO^THEO^ induced by the map

. •

7.5 Coordinated Categories

In this last section of the last chapter of Part II, we address one of the top-
ics at the heart of the research programme on Community, i.e. the subject
of Part III: the formalisation of the separation of concerns that is known as
"coordination". This provides a good justification for stopping our intro-
duction to category theory here, because the reader will not need any more
categorical "ammunition" to attack Part III.

An introduction to coordination was given in Sect. 5.2 as part of the
motivation for studying the behaviour of functors in relation to universal



168 7 Adjunctions

constructions. The reader is invited to read it (once again) as well as, if
possible, what I consider to be the best introduction to "coordination": Ar-
bab's gem "What Do You Mean, Coordination?" [3]. The central idea of
this research area is to investigate the extent up to which a given formal-
ism can separate between the mechanisms that coordinate the interactions
that are responsible for emergent behaviour from the description of what in
systems is responsible for the computations that ensure the functionalities
of the services that individual system components provide.

For instance, object-oriented systems do not go a long way in support-
ing that separation. Because interactions in object-oriented approaches are
based on identities [73], in the sense that, through clientship, objects inter-
act by invoking specific methods of specific objects (instances) to get
something specific done, the resulting systems are too rigid to support the
levels of agility required by the "just-in-time" binding mechanisms of
(Web) services. Any change on the collaborations that an object maintains
with other objects needs to be performed at the level of the code that im-
plements that object and, possibly, of the objects with which the new col-
laborations are established. That is, as put in [98], feature calling is for
interconnections what assembly language represents for computations.

On the contrary, interactions in a service-oriented approach should be
based only on the description of what is required, thus decoupling the
"what one wants to be done" from the "who does it". In the context of the
societal metaphor that we used in the book, it is interesting to note that this
shift from "object"-oriented to "service"-oriented interactions mirrors what
has been happening in human society: more and more, business relation-
ships are being established in terms of acquisition of services (e.g. 1000
Watt of lighting for your office) instead of products (10 lamps of 100 Watt
each for the office).

Our introduction to Sect. 5.2 discloses most of the "secrets" of the
mathematical characterisation that we started to develop in [35] as a sys-
tematic study of the nature and properties of the separation between "com-
putation" and "coordination". Now that the reader has more categorical
background, we can revisit the motivation that has been already delivered.
Note that we shall systematically work with colimits just to fix a direction
of the "component-of' relationship and use it consistently. However,
those that are more accustomed to limits can simply switch the direction of
the arrow, i.e. work in the opposite category. Summarising:

• We model this separation by a forgetful functor int:SYS—>INT, where
the category SYS stands for the representations (models, behaviours,
specifications, programs, etc) of the components out of which systems
can be put together. The category INT captures the "interfaces" through
which interconnections between system components can be established.

• The functor int should be faithful (as in Par. 5.1.7) so that morphisms in
SYS (the "component-of relationship) do not induce more relationships



7,5 Coordinated Categories 169

between components than those that can be captured through their un-
derlying interfaces. That is, by taking into consideration the computa-
tional part, we should not get additional observational power over the
external behaviour of systems. Using the terminology that we intro-
duced in Chap. 6, SYS is concrete over INT.

• Because we use diagrams for modelling configurations of complex sys-
tems and colimits to obtain emergent behaviour, int should lift colimits
as defined in Par. 5.2.1. That is, when we interconnect system compo-
nents in a (configuration) diagram, any colimit of the underlying dia-
gram of interfaces establishes an interface for which a computational
part exists that captures the joint behaviour of the interconnected com-
ponents as given by the colimit of the original diagram. We have al-
ready mentioned that this property expresses (non)interference between
computation and coordination. On the one hand, the computations as-
signed to the components cannot interfere with the viability (in the sense
of the existence of a colimit) of the underlying configuration of inter-
faces. On the other hand, the computations assigned to the components
cannot interfere in the calculation of the interface of the resulting sys-
tem. For instance, we saw in Par. 6.1.22 that split fibre-(co)complete
(co)fibrations lift limits.

• It is also clear that int should preserve colimits in the sense of Par. 5.2.1.
That is, every interconnection of system components should be an inter-
connection of the underlying interfaces. In other words, computations
should not make a configuration of system components "viable", in the
sense that it admits a colimit, when the underlying configuration of in-
terfaces is not. This is another form of the required "noninterference".
Given that int is faithful, this means that all colimits in SYS are concrete
as defined in Par. 6.1.9.

Lifting and preservation of colimits imply that any colimit in SYS can
be computed by first translating the diagram to INT, then computing the
colimit in INT, and finally lifting the result back to SYS. We have already
encountered this situation for PROC through the functor alph and for the
category of theories (or presentations) THEO of any (jt-)institutions
through the functor sign. In the case of processes, this means that the set
of behaviours does not interfere with the interconnections; and in the case
of theories, that interconnections are established just by name bindings.

Both examples allow us to illustrate another intuitive property of the
separation that is not captured by those mentioned so far. Consider, for in-
stance, processes. Taking pullbacks as the most basic form of intercon-
nection, we can notice that the "middle" process through which we express
the interconnection is "always" idle, i.e. has all possible behaviours. In-
deed, the set of behaviours that is present in the middle process does not
interfere either in the interconnection, which is expressed at the level of
the alphabets, or in the calculation of the set of behaviours of the resulting



170 7 Adjunctions

process, which is defined through the intersection of the inverse images of
the sets of behaviours of the other two component processes. Hence, there
is a sort of "canonical" middle processes: those that are idle. Notice that
their duals, the empty processes, do not make good middle processes be-
cause they do not admit any incoming morphisms.

The same happens with theories and theory presentations: the middle
object in a pushout is always empty (or the closure of the empty set of axi-
oms) because the theorems that result from the pushout are computed from
the pushout of the signatures and the theorems of the other two compo-
nents. This seems to be saying that the middle objects that we use for in-
terconnecting components, be it for pullbacks or pushouts, are essentially
interfaces, which makes all the sense from the point of view of the separa-
tion of coordination from computation. How can we express this property
in categorical terms?

Basically, and taking the colimit approach as exemplified by, for in-
stance, theories, what we want is to be able to assign to every interface
CINT a component s(C):SYS such that, for every morphism/;C—>int(S),
there is a morphism g:s(C)->S such that int(g)=f. That is, we want every
interface C to have a "realisation" as a system component s(C) in the sense
that, using C to interconnect a component 5, which is achieved through a
morphism f:C-*int(S), is tantamount to using s(C) through any g:s(C)—>S
such that int(g)=f.

Notice that, because int is faithful, there is only one such g, which
means that/and g are essentially the same. That is, sources of morphisms
in diagrams in SYS are essentially interfaces. We would use the dual
property to characterise what happens with processes. Such a realisation is
called a discrete lift in [1]. A functor int for which every object CINT
admits a discrete lift is said to have discrete structures.

7.5.1 Definition - Discrete Lifts/Structures

Given a concrete category q>:D—*C, a discrete lift for c:C is a D-object d
such that <p(d)=c and, for every morphism f:c-*(p(d}), there is a morphism
g:d—>d' such that <p(g)=f The functor (concrete category) is said to have
discrete structures whenever every C-object admits a discrete lift. •

The dual notion is called indiscrete lift and the functor (concrete cate-
gory) is said to have indiscrete structures.

When int lifts and preserves colimits, this property allows us to replace
every middle object in a configuration diagram by the discrete lift of the
underlying interface: both diagrams will have the same colimits. For all
practical purposes, this means that we can use more economical represen-
tations for configuration diagrams by showing only the interfaces of the
middle objects that interconnect components.

It is easy to see that the indiscrete lift of a process alphabet A± i s
<A±,tra(A±)>, and the discrete lift of a signature Us the theory <S,cj0)>.



7.5 Coordinated Categories 171

They also admit their dual versions, i.e. signatures have indiscrete lifts (in-
consistent theories) and alphabets have discrete lifts (empty processes), but
these are not the ones that interest us for system configuration: they disable
rather than enable interaction! Notice that the (in)discrete lifts are the ob-
jects involved in the (co)reflections that define the corresponding forgetful
functors as (co)reflectors (see Pars. 7.3.9 and 7.3.10).

7.5.2 Proposition

Every concrete category cp:D~->C that has discrete structures is reflective,
the reflections (i.e. the components of the unit) being identities. •

The proof of this result is immediate once one transcribes the definition
of discrete lifts to diagrams:

•1
d'

D

Notice that, cp being faithful, the coreflections are epis as shown in Par.
7.2.11. Actually, this is the property that allows us to replace the middle
objects that perform interconnections by the discrete lifts of their underly-
ing interfaces.

Indeed, denoting by sys the reflector of int, every diagram

extends to
sys(int(S))

i
S2

S, S,

Both diagrams admit the same pushouts because, ss being epi, we have that
£S;fj ;gi = esrfi:gi implies / ; ;g, =f2;g2.



172 7 Adjunctions

sys(int(S))

s,
\ O
g, ^ *

S'

7.5.3 Exercise

Prove that both diagrams have, indeed, the same pushouts. •
We now have all the ingredients for our proposed characterisation of the

formalisms that separate coordination from computation:

7.5.4 Definition - Coordinated Categories

A concrete category (faithful functor) tp:D—>C is said to be coordinated if:
• cp lifts colimits.
• cp has discrete structures.

In these circumstances, we also say that D is coordinated over C (via the
functor <p). •

We have omitted the requirement on the preservation of colimits be-
cause it can be inferred from the two properties.

7.5.5 Exercise

Prove that coordinated functors preserve colimits. •
As examples, we already saw that theories and theory presentations of

any (ir)institution constitute a concrete category that is coordinated over
their signatures, and that the (dual of) PROC is coordinated over (the dual
of) the category of alphabets. In Part III, we study an example related to
architectural description languages, the language Community. We end
this section with a "genuine" example: a simplified version of the language
Gamma [11], which is based on the chemical reaction paradigm [16].

First, we would like to point out that the properties that characterise SYS
as being coordinated over INT make SYS "almost" topological over INT.
To be topological [1], int would have to lift colimits uniquely, which
would make the concrete category amnestic in the sense of Par. 6.1.4. As
far as the algebraic properties of the underlying formalism are concerned,
this is not a problem because every concrete category can be modified to
produce an amnestic, concretely equivalent version. However, and al-



7.5 Coordinated Categories 173

though PROC is indeed amnestic, PRES, for instance, is not, and neither is
Community.

This is the "closest" characterisation we have to a "classical" mathe-
matical structure: topological categories abound in mathematics and other
areas of computer science. In the areas related to software engineering,
namely those in which one welcomes, or cannot avoid, "user intervention",
one tends to work "up to isomorphism" more than "up to equality". In the
case of the lifting of colimits, this means that there can be room for
choosing between different, but isomorphic, system representations, for in-
stance, alternative presentations of the same theory. One tends not to care
whether a given conjunction ends up represented as aAb or bAa.

7.5.6 Definition - Gamma Programs

A Gamma program P consists of:
• A signature Z=<S,Q,I1>, where 5 is a set of sorts, Qis a set of opera-

tion symbols and U is a set of relation symbols, representing the data
types that the program uses.

• A set of reactions, each of which is of the form:

RmX,t1,...,tn—t'h...,t'm*=C
where
1. X is a set (of variables); each variable is typed by a data sort in S.
2. tj, ..., tn —» t'i, ..., t'm is the action of the reaction - a pair of sets of

terms over X.
3. c is the reaction condition - a proposition over X. •
An example of a Gamma program is the following producer of burgers

and salads from, respectively, meat and vegetables.

PROD: sorts meat, veg, burger, salad
ops vprod: veg-*salad, mprod: meat—*burger
reactions mrmeat, m -> mprod(m)

v:veg, v —* vprod(v)

The parallel composition of Gamma programs, as defined in [11], is a
program consisting of all the reactions of the component programs. Its be-
haviour is obtained by executing the reactions of the component programs
in any order, possibly in parallel. This leads us to the following notion of
morphism.

7.5.7 Definition - Morphisms of Gamma Programs

A morphism a between Gamma programs P, and P2 is a morphism be-
tween the underlying data signatures such that o{P1)CP2, i.e. P2 has more
reactions than P,. •

In order to illustrate system configuration in Gamma, let us consider
that we want to interconnect the producer with the following consumer:



174 7 Adjunctions

CONS: sorts
ops
reactions

food,
cons:
f:food

waste
food -
, f -»

-»waste
cons(f)

The interconnection of the two programs is based on the identification
of the food the consumer consumes, that is, the interconnection is estab-
lished between their data types. For instance, the coordination of the pro-
ducer and the consumer based on meat is given as follows:

sorts s

s I—»burger / \ si—>food

PROD CONS

Gamma is, indeed, coordinated over the category of data types:

• The forgetful functor dt from Gamma programs to data types is faithful.
• Given any diagram in Gamma, a colimit Oi:(dt(Pj) —*Z)i:Iof the corre-

sponding diagram in the category of data types is lifted to the following
colimit of programs O^PJ-^KZ, UOj(Rj)>)i:I.

• The discrete lift of a data type is the program with the empty set of re-
actions.

7.5.8 Exercise

Work out the full characterisation of the category of Gamma programs and
prove that it is indeed coordinated over the data types. •



Part III

Applications



8 Community

8.1 A Language for Program Design

CommUnity is a language similar to Unity [19] and Interacting Processes
[48]. It was initially developed [44] to show how "programs" could fit
into Goguen's categorical approach to general systems theory. Since then,
the language and the design framework have been extended to provide a
formal platform for testing ideas and experimenting techniques for the ar-
chitectural design of open, reactive and reconfigurable systems.

One of the extensions that we have made to CommUnity since its origi-
nal definition concerns the support for higher levels of design. At its ear-
lier stages, the architecture of the system is normally given in terms of
components that are not necessarily programs but abstractions of programs
- called designs - that can be refined into programs in later steps of the
development process. Designs may also account for components of the
real world with which the software components are interconnected. Typi-
cally, such abstractions derive from requirements specified in some logic
or other mathematical models of the behaviour of real-world components.

The goal of supporting abstraction is not only to address a typical step-
wise approach to software construction, but to also address the definition
of an architectural design layer that is close enough to the application do-
main for the evolution of the system to be driven directly as a reflection of
the changes that occur in the domain. An important part of this evolution
may consist of changes in the nature of components, with real-world com-
ponents being replaced or controlled by software components, or software
components being reprogrammed in another language.

The support for abstraction in CommUnity is twofold. On the one hand,
designs account for what is usually called under specification, i.e. they are
structures that do not denote unique programs but collections of programs.
On the other hand, designs can be defined over a collection of data types
that do not correspond necessarily to those that are available in the final
implementation platform. Therefore, there are two refinement procedures
that have to be accounted for in CommUnity. First, the removal of under-
specification from designs in order to define programs over the layer of
abstraction defined by the data types that have been used. A second form



178 8 Community

of refinement consists of the reification of the data types in order to bring
programs into the target implementation environment.

The choice of data types determines, essentially, the nature of the ele-
mentary computations that can be performed locally by the components,
which are abstracted as operations on data elements. Such elementary
computations also determine the granularity of the services that compo-
nents can provide and, hence, the granularity of the interconnections that
can be established at a given layer of abstraction. Nevertheless, data re-
finement is more concerned with the computational aspects of systems
than with the coordination mechanisms that are responsible for interactions
among system components. Because the support that category theory can
provide to the specification of abstract data types is already well estab-
lished and available in the literature [8, 28, 29, 76, 92], we do not address
this aspect of Community in depth but, rather, concentrate on the broader
architectural aspects. We give more emphasis to the refinement of designs
for a fixed choice of data types and omit any discussion on data refine-
ment. An approach similar to the refinement calculus for actions systems
[9] can also be followed to support data refinement in the context of reac-
tive systems.

Given this, we assume a fixed collection of data types. In order to re-
main independent of any specific language for the definition of these data
types, we take them in the form of a first-order algebraic specification.
That is, we assume a data signature <S,Q>, where S is a set (of sorts) and
Q is a S*xS-indexed family of sets (of operations), to be given together
with a collection <P of first-order sentences specifying the functionality of
the operations.

A Community design for a component over such a data type specifica-
tion is of the form

design
out
i n
prv
do
DgeslKD

DoEor r>

F i s
out(V)
in(V)
prv(V)

g[D(g)] :
prv g[D(g)] :

L(g) ,
L(g) ,

U(g)
u(g)

- R(g)
- R(g)

where
V is a set (of communication channels). A communication channel (or,
simply, channel) can be declared as input, output or private. Each chan-
nel v is typed with a sort sort(v)ES that reflects the nature of the data
that is exchanged through it. Input channels are used for reading data
from the environment of the component. The component has no control
of the values that are made available in such channels. Moreover,
reading a value from an input channel does not "consume" it; the value
remains available until the environment decides to replace it.



8.1 A Language for Program Design 179

Output and private channels are controlled locally by the component,
i.e. the values that, at any given moment, are available on these channels
cannot be modified by the environment. Output channels allow the en-
vironment to read data produced by the component. Private channels
support internal activity that does not involve the environment in any
way. We use loc(V) to denote the union prv(V)Uout(V), i.e. the set of
local channels.

In some earlier papers on Community, we named the elements of V
variables or attributes. The change to channels reinforces the idea that
they are means that components have to communicate rather than store
data. This is consistent with the black-box view of components that we
intend to model, which should hide the representation of the state of
components and provide only means for it to be observed.

Channels cater for asynchronous communication between compo-
nents in the sense that reading and writing into a channel are independ-
ent operations. A value that.is written on a channel will remain there,
regardless of how many times it is read, until it is overwritten.
F is a set (of action names). Actions can be either private or shared (for
simplicity, we only declare those that are private). Private actions rep-
resent internal computations in the sense that their execution is uniquely
under the control of the component. Shared actions are used for syn-
chronous interactions with the environment, meaning that their execu-
tion is also under the control of the environment.

The significance of naming actions will become obvious below. The
idea is to provide points of rendez vous at which components can syn-
chronise, for instance, as a means of ensuring that the right values are
being exchanged through the channels.
For each action name g, the following attributes are defined:

- D(g) is a subset of loc(V) consisting of the local channels into which
executions of the action can write. This is sometimes called the write
frame of g. For simplicity, we will omit the explicit reference to the
write frame when R(g) is a conditional multiple assignment (see be-
low), in which case D(g) can be inferred from the assignments.
Given a local channel v, we will denote by D(v) the set of actions g
such that vED(g), i.e. the actions that write into v.

- L(g) and U(g) are two conditions such that U(g)DL(g). These condi-
tions establish an interval in which the enabling condition of any
guarded command that implements g must lie. The condition L(g) is
a lower bound for enabledness in the sense that it is implied by the
enabling condition. Therefore, its negation establishes a blocking
condition. On the other hand, U(g) is an upper bound in the sense
that it implies the enabling condition, therefore establishing a pro-
gress condition. Hence, the enabling condition is fully determined
only if L(g) and U(g) are equivalent, in which case we write only one.



180 8 Community

- R(g) is a condition on V and D(g)', where by D(g)' we denote the set
of primed local channels from the write frame of g. As usual, primed
channels account for references to the values that the channels display
after the execution of the action. These conditions are usually a con-
junction of implications of the form preDpos where pre does not in-
volve primed channels. They correspond to pre/postcondition speci-
fications in the sense of Hoare. When R(g) is such that the primed
version of each local channel in the write frame of g is fully deter-
mined, we obtain a conditional multiple assignment, in which case we
use the notation that is normally found in programming languages.
When D(g) is empty, R(g) is tautological, which we denote by skip.

CommUnity supports several mechanisms for underspecification. Ac-
tions may be underspecified in the sense that their enabling conditions may
not be fully determined (subject to refinement by reducing the interval es-
tablished by L and U), and their effects on the channels may also be unde-
termined. When, for every gEF, L(g) and U(g) coincide, and the relation
R(g) defines a conditional multiple assignment, then the design is called a
program and the traditional notation for guarded commands is used.

Notice that a program with a nonempty set of input channels is open in
the sense that its execution is only meaningful in the context of a configu-
ration in which these inputs have been connected with local outputs of
other components. The notion of configuration, and the execution of an
open program in a given configuration, are discussed after Par. 8.2.4.

The behaviour of a closed program is as follows. At each execution
step, one of the actions whose enabling condition holds of the current state
is selected, and its assignments are executed atomically. Furthermore, pri-
vate actions that are infinitely often enabled are guaranteed to be selected
infinitely often. See [77] for a model-theoretic semantics of CommUnity.

Designs can be parameterised by data elements (sorts and operations)
indicated after the name of the component (see an example below). These
parameters are instantiated at configuration time, i.e. when a specific com-
ponent needs to be included in the configuration of the system being built,
or as part of the reconfiguration of an existing system.

As an example, consider the following parameterised design:

design buffer [t:sort, bound mat] is
in i:t
out o: t
prv rd: bool, b: list(t)
do put: |b|<bound —» b:=b.i
0 prv next: |b|>0A-.rd -»o:=head(b) || b:=tail(b) || rd:=true
D get: rd -»rd:=false

The parameters of this design consist of the sort t of data elements that
the buffer can handle and the capacity bound of the buffer. The buffer it-
self is defined over a list with elements of t. As already discussed, we are



8.1 A Language for Program Design 181

assuming that the data type list is available through an algebraic specifica-
tion that includes the traditional operations such as l_l returning the current
size of the list, head(_) returning the first element of the list, tail(_) re-
turning the list after the first element, and _._ for appending an element to
the end of the list.

This design is actually a (parameterised) program, and the traditional
notation of guarded commands was used accordingly. Notice in particular
that the reference to the write frame of the actions was omitted; it can be
inferred from the multiple assignments that they perform. As already
mentioned, because we are dealing with multiple assignments, the tradi-
tional notation involving the symbol := was used instead of the logical lan-
guage over channels and their primed versions. In the case above, this cor-
responds to:

R(put): b'=b.i
R(next): o'=head(b) A b'=tail(b) A rd'
R(get): -,rd'
This program models a buffer with a limited capacity and a FIFO disci-

pline. It can store, through the action put, messages of sort t received from
the environment through the input channel i, as long as there is space for
them. The buffer can also discard stored messages, making them available
to the environment through the output channel o and the action next. Natu-
rally, this activity is possible only when there are messages in store and the
current message in o has already been read by the environment (which is
modelled by the action get and the private channel rd).

In order to illustrate the ability of Community to support higher-level
component design, consider the design of a typical sender of messages.

design sender[t:sort] is
out o:t
prv rd: bool
do prod[o,rd]: -•rd,false—»rd'
(] send[rd]: rd, false—>Td'

In this design, we are primarily concerned with the interaction between
the sender and its environment, ignoring details of internal computations
such as the production of messages. This is why the output channel o is
included in the write frame of prod, but R(prod) does not place any con-
straint on how it is updated. Notice that the component sender cannot pro-
duce another message before the previous one has been processed: after
producing a message, the sender expects an acknowledgement (modelled
through the execution of send) to produce a new message.

In order to leave unspecified when and how many messages the sender
will send and in which situations it will produce a new message, the pro-
gress conditions of prod and send are false. Furthermore, the discipline of
production is also left completely unspecified: the action prod includes the



182 8 Community

output channel o in its write frame, but the design does not commit to any
specific way of updating the values in this channel.

From a mathematical point of view, (instantiated) Community designs
are structures defined as follows.

8.1.1 Definition - Signatures and Designs

A signature in Community is a tuple <V,r,tv,ta,D>, where
• V is an 5-indexed family of mutually disjoint finite sets,
• P i s a finite set,
• tv: V—>{out,in,prv} is a total function,
• ta: F->{sh,prv} is a total function,
• D: r^>2'ocm is a total function.

A design in Community is a pair <6,A>, where 6=<V,r,tv,ta,D> is a
signature and A, the body of the design, is a tuple <R,L,U>, where:
• R assigns to every action gEF, a proposition over VUD(g)',
• L and U assign a proposition over Vto every action g£F. •

The reader who is familiar with parallel program design languages or
earlier versions of Community may have noticed the absence of initialisa-
tion conditions. They are not included in Community designs because
they are part of the configuration language of Community, not the parallel
program design language. That is, we take initialisation conditions as part
of the mechanisms that relate to the building and management of configu-
rations out of designs, not of the construction of designs themselves.

8.2 Interconnecting Designs

So far, we have presented the primitives for the design of individual com-
ponents, which are another variation on guarded commands, albeit with
some "twists" of originality such as the use of an interval as a specification
for the enabling conditions of commands. The main distinguishing fea-
tures of Community are those that concern design "in the large", i.e. the
ability to design large systems from simpler components.

The model of interaction between components in Community is based on
action synchronisation and the interconnection of input channels of a com-
ponent with output channels of other components. These are standard
means of interconnecting software components. What distinguishes
Community from other parallel program design languages is the fact that
such interactions between components have to be made explicit by pro-
viding the corresponding name bindings. Indeed, parallel program design
languages normally leave such interactions implicit by relying on the use
of the same names in different components. In Community, names are lo-



8.2 Interconnecting Designs 183

cal to designs. This means that the use of the same name in different de-
signs is treated as being purely accidental and, hence, expresses no rela-
tionship between the components.

In Community, name bindings are established as relationships between
the signatures of the corresponding components, matching channels and
actions of these components. These bindings are made explicit in configu-
rations. A configuration determines a diagram containing nodes labelled
with the components that are part of the configuration. Name bindings are
represented as additional nodes representing the actual interactions, and
edges labelled with the projections that map each interaction to the signa-
tures of the corresponding components.

For instance, a configuration in which the messages from a sender com-
ponent are sent through a bounded buffer is defined through the following
diagram:

cable

send h^ sync / \ put h-> sync
/ \ i/H»i

sender buffer

The node labelled cable is the representation of the set of bindings. It
stands for the following design:

design cable[t:sort] is
in i/o:t
do sync: true,false -» skip

By using the word "cable" we mean to suggest analogies with the use of
physical cables for interconnecting mechanical or electrical components.
Because, as we have seen, channels and action names are typed and classi-
fied in different categories, not every pair of names is a valid binding. To
express the rules that determine valid bindings, it is convenient to define
cable as a component itself (just like electric cables are made of coloured
wires so that we know what should be connected to what). Hence, in the
case above, cable consists of an input channel i/o to model the medium
through which data is to be transmitted between the sender and the buffer,
and a shared action sync for the two components to synchronise in order to
transmit the data. Because, as we have already mentioned, names in
Community are local, the identities of the shared input channel and the
shared action in cable are not relevant; they are just placeholders for the
projections to define the relevant bindings.

The bindings themselves are established through the labels of the edges
of the diagram. In the case above, the input channel of cable is mapped to
the output channel o of sender and to the input channel i of buffer. This
establishes an i/o-interconnection between sender and buffer. On the other
hand, the actions send of sender and put of buffer are mapped to the shared



184 8 Community

action of cable. This defines that sender and buffer must synchronise each
time either of them wants to perform the corresponding action. The fact
that the mappings on action names and on channels go in opposite direc-
tions is discussed after Par. 8.2.1.

Notice that sync does not perform any activity: it just provides the place
for the rendez vous between the sender and the buffer to take place. This
is in analogy with cables that are completely neutral, i.e. they do not inter-
fere with the computations that are going on in the components. Hence,
cables are, essentially, signatures. This observation is formalised in Pars.
8.2.4 and 8.2.5.

The arrows that we are using to define interconnections between com-
ponents are also mathematical objects: they are examples of signature
morphisms.

8.2.1 Definition - Signature Morphisms

A morphism o:61—>d2 of signatures 61=<V1,r,,tv1,ta1,D1> and
62=< V2,r2,tv2,tci2,D2> is a pair <och,oac>, where
• och: V,->V2 is a total function satisfying:

1. sort2(ach(v))=sort1(v) for every vEV,.
2. och(o)Eout(V2) for every oEout(V,).
3. och(i)Eout(V2)Uin(V2) for every iEin(V,).
4. och(p)Eprv(V2) for every pEprv(V,).

• aac: r2—>rj is a partial mapping satisfying for every gEF2 s.t. aac{g) is
defined:

5. If gEsh(r2), then oac(g)Esh{Tl).
6. If gEprv(r2), then oJg)Eprv(r1).
1. oJDAoJgMCDJg).
8. oac is total on D2(och(v)) and oac(D2(ach(v)))CD,(v), vEloc(Vj). •
Signature morphisms represent more than the projections that arise from

name bindings as illustrated above. A morphism afrom 6t to 62 is in-
tended to support the identification of a way in which a component with
signature 8, is embedded in a larger system with signature 62. This justi-
fies the various constructions and constraints in the definition.

The function och identifies for each channel of the component the corre-
sponding channel of the system. The partial mapping aac identifies the ac-
tion of the component that is involved in each action of the system, if ever.
The fact that the two mappings go in opposite directions is justified as
follows. Actions of the system constitute synchronisation sets of actions
of the components. Because not every component is necessarily involved
in every action of the system, the action mapping is partial. On the other
hand, because each action of the component may participate in more than
one synchronisation set, but each synchronisation set cannot induce inter-



8.2 Interconnecting Designs 185

nal synchronisations within the components, the relationship between the
actions of the system and the actions of every component is functional
from the former to the latter. Hence, actions are dealt with in the category
PAR of partial functions. As seen in Par. 7.1.12, this category is equiva-
lent to the category that we used for modelling alphabets of processes,
meaning that the intuitions that we developed on the way universal con-
structions capture composition can be used for Community as well.

Input/output communication within the system is not modelled in the
same way as action synchronisation. Synchronisation sets reflect parallel
composition, whereas with i/o-interconnections we wish to identify com-
munication channels declared in the components. This means that, in the
system, channels should be identified rather than paired. This is why
mappings on channels and mappings on actions go in opposite directions.
As a result, the mathematical semantics of configuration diagrams as de-
fined after Par. 8.2.3 induces fibred products of actions (synchronisation
sets) and amalgamated sums of channels (equivalence classes of connected
channels).

The constraints are concerned with typing. Sorts associated with chan-
nels have to be preserved, but, in terms of their classification, input chan-
nels of a component may become output channels of the system in the
sense that, as a default, they should remain open for communication with
other components. In most languages for parallel design, the default is to
hide the communication, which in Community would correspond to clas-
sify the resulting channel as being private. In our opinion, closing/hiding
the channel should not be a default but a design decision that should be
performed explicitly. Hence, in Community, mechanisms for internalis-
ing communication can be applied but they are not the default in a con-
figuration. The last two conditions on write frames (7 and 8) imply that
actions of the system in which a component is not involved cannot have
local channels of the component in their write frame. That is, change
within a component is completely encapsulated in the structure of actions
defined for the component.

Given the ingredients out of which signatures are assembled, the proof
of the following result is purely routine and is left as an exercise.

8.2.2 Proposition - Category of Signatures

Signatures in Community together with their morphisms constitute a cate-
gory that we shall denote by c-SIGN. •

The notation can be simplified and made more friendly by adopting
features that are typical of languages for configurable distributed systems
like [87]. For instance, the interconnection defined before can be de-
scribed as follows:



186 8 Community

sender buffer

( send ( put

The notation should be self-explanatory. Components are represented
through boxes, their channels through bullets and their actions through cir-
cles. Normally we only depict the actions and channels involved in the
configuration. Hence, as discussed below, private actions and channels in
particular do not figure up.

Interconnections, i.e. name bindings, are still represented explicitly, but,
instead of being depicted as a component, the cable is now represented,
perhaps more intuitively, in terms of arcs that connect channels and actions
directly. The direction of the arcs is from output to input channels. Con-
figurations in this notation are easily translated into categorical diagrams
by transforming the interconnections into channels and morphisms, some-
thing that, again, we abstain from formalising in this book.

So far, we explained how interconnections between components can be
established at the level of the signatures of their designs. It remains to ex-
plain how the corresponding designs are interconnected, i.e. what is the
semantics of the configuration diagram once designs are taken into ac-
count. For that purpose, we need to extend the notion of morphism from
signatures to designs.

8.2.3 Definition/Proposition - Design Morphisms

A morphism a:P7-»P2 of designs P1=<61,A1> and P2=<62,A2> consists of
a signature morphism o:d1—>62 such that, for every gEF2 for which oac(g)
is defined:

2.0\- (L2(g)DdyL1(oac{g)))).

where <& is the axiomatisation of the data type specification, I— denotes
validity in the first-order sense, and a is the extension of a to the language
of expressions and conditions as discussed in Par. 6.5.3 for institutions in
general. We normally simplify the notation and overload the use of a in
place of a as mentioned in Par. 6.5.4. Designs and their morphisms con-
stitute a category c-DSGN. This category is concrete over c-SIGN
through the obvious forgetful functor. •

A morphism o:P1—>P2 identifies a way in which P; is "augmented" to
become P2 so that P2 can be considered as having been obtained from P,
through the superposition of additional behaviour, namely the intercon-
nection of one or more components. The conditions on the actions require
that the computations performed by the system reflect the interconnections



3.2 Interconnecting Designs 187

established between its components. Condition 1 reflects the fact that the
effects of the actions of the components can only be preserved or made
more deterministic in the system. This is because the other components in
the system cannot interfere with the transformations that the actions of a
given component make on its state, except possibly by removing some of
the underspecification present in the component design.

Conditions 2 and 3 allow the bounds that the component design speci-
fies for the enabling of the action to be strengthened but not weakened.
Strengthening of the lower bound reflects the fact that all the components
that participate in the execution of a joint action have to give their permis-
sion for the action to occur. On the other hand, it is clear that progress for
a joint action can only be guaranteed when all the designs of the compo-
nents involved can locally guarantee so.

This notion of morphism captures what in the literature on parallel pro-
gram design is called "superposition" or "superimposition" [10, 19, 48,
72]. See [44] for a categorical formalisation of different notions of super-
position and their algebraic properties.

The semantics of configurations is given by a categorical construction:
the colimit of the underlying diagrams. As explained in Chap. 4, taking
the colimit of a diagram collapses the configuration into an object by in-
ternalising all the interconnections, thus delivering a design for the system
as a whole. Furthermore, the colimit provides a morphism o; from each
component design P, in the configuration into the new design (that of the
system) - the edge of the cocone at P, as seen in Par. 4.4.1. Each such
morphism is essential for identifying the corresponding component within
the system because the construction of the new design typically requires
that the features of the components be renamed in order to account for the
interconnections.

Again, given the nature of the "ingredients", it is not difficult to under-
stand how colimits of designs work: because channels are handled through
total functions, colimits amalgamate channels as seen in Par. 4.3.2. Be-
cause actions are handled as partial functions in the opposite direction, i.e.
in the dual category, colimits operate on actions as limits and compute fi-
bred products as explained in Par. 4.3.8. For instance, in the case of ac-
tions, the colimit represents every synchronisation set {g,,...,gn}of actions
of the components, as defined through the interconnections, by a single
action g;//...//#n whose occurrence captures the joint execution of the ac-
tions in the set (recall the discussions around Pars. 4.3.8 and 4.4.11). Be-
cause, as mentioned after Par. 4.2.6, limits perform conjunctions of logical
conditions, the transformations performed by a joint action are specified
by the conjunction of the specifications of the local effects of each of the
synchronised actions:

A.. .AOn(R(gJ)



188 8 Community

where the ot are the morphisms that connect the components to the system
(the edges of the cocone). The bounds on the guards of joint actions are
also obtained through the conjunctions of the bounds specified by the
components, i.e.

gll- • .Ugn) = O,(Ugl))A .. .AOjL(gJ)
ill- • -ll8J=°i(U(g,))A... A an(U(gJ)

Finally, because morphisms require inclusions of write frames, the write
frame of a joint action is given by the union of the (translations of) the
write frames of the component actions. This way of computing colimits
derives from the strong algebraic properties of the category of designs.

8.2.4 Proposition

The forgetful functor c-sign that maps Community designs to the corre-
sponding signatures defines c-DSGN as a category coordinated over c-
SIGN as defined in Par. 7.5.4. We shall call a cable the discrete lift of a
signature: given a signature 6, the corresponding cable dsgn(d) has 0for
signature and, for every action g, R(g), L(g) and U(g) are all true, which
we normally denote by skip. •

Summarising, colimits in Community capture a generalised notion of
parallel composition in which the designer makes explicit what intercon-
nections are used between components. Because the category of designs is
coordinated over signatures, all interconnections can be performed through
cables, i.e. they do not involve the computational part of components, only
their "interfaces" - i/o communication through channels and rendez vous
through action synchronisation. We can see this operation as a generalisa-
tion of the notion of superimposition as defined in [48].

The colimit of the configuration, when it returns a closed program, can
also be used for providing an operational semantics for the system thus
configured. As explained in Sect. 8.1, at each execution step, any action
whose guard is true can be executed, with the guarantee that private ac-
tions that are infinitely often enabled are selected infinitely often. Because
actions of the system are synchronisation sets of actions of the compo-
nents, the evaluation of the guard of the chosen action can be performed in
a distributed way by evaluating the guards of the component actions in the
synchronisation set. According to the semantics that we have just given,
the joint action will be executed iff all the local guards evaluate to true.
The execution of the multiple assignment associated with the joint action
can also be performed in a distributed way by executing each of the local
assignments. What is important is that the atomicity of the execution is
guaranteed, i.e. the next system step should only start when all local exe-
cutions have completed, and the i/o-communications should be imple-
mented so that every local input channel is instantiated with the correct
value - that which holds before any execution starts (synchronicity).



8.2 Interconnecting Designs 189

Hence, the colimit of the configuration diagram should be seen as an ab-
straction of the actual distributed execution that is obtained by coordinat-
ing the local executions according to the interconnections, rather than the
program that is going to be executed as a monolithic unit. The fact that the
computational part, i.e. the one concerned with the execution of the actions
on the state, can be separated from the coordination aspects is therefore an
essential property for guaranteeing that the operational semantics is com-
positional on the structure of the system as given through its configuration.

Not every diagram of designs reflects a meaningful configuration. For
instance, it does not make sense to interconnect components by connecting
two output channels because it creates conflicts among the actions that
output to these channels. Such constraints are not "structural": they cannot
be captured by morphisms between designs because they concern general
interconnections, not just the component-of relationship. In other words,
the constraints are not technical but, rather, methodological.

8.2.5 Definition/Proposition - Well-Formed Configurations

Let chart be the forgetful functor from c-DSGN to SET that maps designs
to their underlying sets of channels. A configuration is a finite diagram
dia:I^c-DSGN together with a subset / of I/I (the nodes that represent the
components being interconnected) such that:

1. For any f:i-*j in /, either i=j and f=idh or jEJ, i0 and dia(i) is a cable.
2. For every iE\I\\J s.t. dia(i) is a cable, there exist distinct nodes

j,kE\I\ with morphisms f:i-*j and g:i—>k.
3. If {fA,j:chan(dia(i))-*V: iE\I\} is a colimit of dia;chan then, for every vEV,

there exists at most one iQ/l s.t. [i{(v)nout(Vdia(i))*0, and for such /,
fJ-'!(v)nout(Vdia(i)) is a singleton.

A configuration dia is well-formed if for every iE\I\\I s.t. dia(i) is a ca-
ble, dia(i) has neither private actions nor private channels. •

Condition 1 states that the elementary interconnections are established
through cables. Condition 2 ensures that a configuration diagram does not
include cables that are not used. Finally, condition 3 prevents the identifi-
cation of output channels. The explicit reference to the subset J of compo-
nents is necessary because the distinction between nodes that are being
used as channels and as components is a pragmatic, not formal one. It is
possible that, in a given configuration, a node is intended to represent a
component, but, because it is still totally underspecified, it is the discrete
lift of a signature, i.e. what we have called a cable.

Well-formed configurations are such that private actions and channels
are not involved in the interconnections, i.e. they support the intuitive se-
mantics we gave in Sect. 8.1 according to which private channels cannot
be read by the environment and that the execution of shared actions is
uniquely under the control of the component.



190 8 Community

An example of a more complex configuration is given below. It models
the interconnection between a user and a printer via a buffer.

The user produces files that it stores in the private channel w. It can
then convert them either to Postscript or Pdf formats, after which it makes
them available for printing in the output channel p.

design user is
out p: ps+pdf
prv s,t: bool, w: Lowtex
do work[w,s,t]: ->t,false -» t'
D pr_ps: ~BAt,false —> p:=ps(w) || s:=true
D pr_pdf: "BAt,false —> p:=pdf(w) || s:=true
[] print: s —» s:=false || t:=false

The printer copies the files it downloads from the input channel rdoc
into the private channel pdoc, after which it prints them.

design printer is
in rdoc: ps+pdf
prv busy: bool, pdoc: ps+pdf
do rec: -busy -* pdoc: =rdoc |[ busy: =true
D prv end_print: busy -* busy:=false

The configuration connects the user to the printer via a buffer as ex-
pected. The user "prints" by placing the file in the buffer: this is achieved
through the synchronisation set {print,put} and the i/o-interconnection
{p,i}. The printer downloads from the buffer the files that it prints: this is
achieved through the synchronisation set {get,rec} and the i/o-
interconnection {o,rdoc}.

The design of the system that results from the colimit of the configura-
tion diagram contains two channels that account for the two i/o-
interconnections {p,i} and {o,rdoc}, together with the private channels of
the components. At the level of its actions, it generates the following
shared actions (synchronisation sets):

printjput, getjrec

as required by the interconnections, and

work, pr_ps, prjpdf, work/get/rec, prjps\get\rec, pr_pdf\get\rec

which reflect the concurrent executions that respect the interconnections.
No other shared actions are possible because of the synchronisation re-
quirements imposed on the components.



8.3 Refining Designs 191

8.3 Refining Designs

The notion of morphism defined in the previous section does not capture a
refinement relation in the sense that it does not ensure that any implemen-
tation of the target provides an implementation for the source. For in-
stance, it is easy to see that morphisms do not preserve the interval as-
signed to the guard of each action. Given that the aim of the defined
morphisms was to capture the relationship that exists between systems and
their components, this is hardly surprising.

The same holds in languages such as CSP [69]: in the failure or ready
semantics, parallel composition does not induce refinement. On the one
hand, PJJQ is not necessarily a refinement of P. On the other hand, refine-
ment cannot always be expressed as the result of a parallel composition; P
may refine Q and, yet, there may not exist a Q' such that P is QJJQ'-

Because refinement is an important dimension in structuring develop-
ment, it is natural that we investigate ways of supporting it in a categorical
setting. This would be especially useful for analsying the way refinement
and composition can work together. A notion of morphism can indeed be
defined that captures a refinement relation for Community designs.

8.3.1 Definition/Proposition - Refinement Morphisms

A refinement morphism o:Pj—>P2 between two designs P,=<61,A1> and
P2=<d2,A2> is a pair <och,oac> satisfying:
• och:V,->V2 is a total function satisfying, for every vEVh oEout(Vj),

1. sort2(ojv))=sort1(v).
2. ach(o)Eout(V2).
3. och(i)Ein(V2).
4. ach(p)Eprv(V2).
5. ochl(out(Vj)Uin(V))) is injective.

• oac:T2-^T1 is a partial mapping satisfying, for every vEloc(V,):

6. oac is total on D2(ach(v)).
7. oJDJoJv^CDJv).

• For every gEF2 s.t. oac(g) is defined:
8. If gEsh(r2) then oJg)Esh(r1).
9. If gEprv(r2) then aac(g)Eprv(r1).

10. If gEsh(r,) then ol(g)*0.
11.
12.
13.



192 8 Community

• For every g1ET1,
U.^^-(o(U,(g,))DV U2(g2)).

ua6s2>-5l

As in Par. 8.2.3, we denote by cP the axiomatisation of the data type
specification, and by h- the validity relation of first-order logic; o is,
again, the extension of a to the language of expressions and conditions.

Designs and their refinement morphisms constitute a category r-DSGN.
This category is concrete over c-SIGN through the functor r-sign that, like
c-sign, projects designs to their signatures. •

A refinement morphism identifies a way in which a design P, (its
source) is refined by a more concrete design P2 (its target). The function
och identifies, for each channel of P,, the corresponding channel of P2.
Notice that, contrary to what happens with design morphisms (recall Par.
8.2.3), refinement does not change the border between the system and its
environment, and hence, input channels can no longer be mapped to output
channels (3). This is also why the mapping is required to be injective on
input and output channels (5): identifying channels is a configuration op-
eration to be achieved through interconnections, not a refinement step.

As for design morphisms, refinement morphisms are required to pre-
serve the sorts of channels (1). As discussed at the beginning of this
chapter, data refinement is a dimension that, for simplicity, we are deliber-
ately ignoring in the book. A more general notion of refinement can be
given by mapping channels to terms defined over the language of the data
types enriched by channels as constants. See [37] for details.

The mapping aac identifies for each action g of Pl the set cfldg) of ac-
tions of P2 that implements g. This set is a menu of refinements that is
made available for implementing action g; different choices can be made
at different states to take advantage of the structures available at the more
concrete design level. This menu can be empty for private actions, i.e. one
may choose not to implement the private actions of the more abstract de-
sign. Because private actions do not intervene in interconnections, what is
important is that the overall behaviour of the component as made observ-
able through shared actions and output channels be implemented. This is
also why every shared action has to be implemented (10); again, such ac-
tions model interaction between the component and its environment, and
refinement should not interfere with the border between them.

The actions for which oac is left undefined (the new actions) and the
channels which are not involved in och(V,) (the new channels) introduce
more detail in the description of the component. As for the "old actions",
the interval defined by their blocking and progress conditions (in which
the enabling condition of any implementation must lie) must be preserved
or reduced (14 and 15). This is intuitive because refinement, pointing in
the direction of implementations, should reduce underspecification.
Hence, the lower bound cannot be weakened (14), and contrary to design



8.3 Refining Designs 193

morphisms, the upper bound cannot be strengthened (15). This is also the
reason why the effects of the actions of the more abstract design are re-
quired to be preserved or made more deterministic (13).

Notice that the forgetful functors r-sign and c-sign are essentially the
same; they are only formally different because their sources are not the
same category. Indeed, the only difference between design and refinement
morphisms at the level of signatures is on the additional properties that re-
finement morphisms need to satisfy: 3, 5 and 10.

As an example, it is easy to see that sender is refined by user via the re-
finement morphism r\:sender—>user defined by

VJo)=p, r)ch(rd)=(s)
Vac(pr-ps)=r)jprj>df)=prod,i]ac(print)=send

In user, the production of messages (to be sent) is modelled by any of
the actions pr_ps and pr_pdf, the messages are made available in the out-
put channel p. Notice that the production of messages, which was left un-
specified in sender, is completely defined in user: it corresponds to the
conversion of the files stored in w to ps or pdf formats.

In the simplified graphical notation that we have been using, refinement
is represented through patterned arrows. Notice that, for depicting refine-
ment, all the actions and channels of the source should be represented, in-
cluding private ones.

Summarising what we have built so far, we have two categories c-
DSGN (defined in Par. 8.2.3) and r-DSGN (defined in Par. 8.3.1), both
over the same notion of object - Community design - but with different
notions of morphism. That is, they capture different aspects of their social
lives: one tells us about their ability to relate with other designs at the same
level of abstraction, and the other about the way they can be made more
"concrete" by reducing underspecification. Furthermore, c-DSGN is coor-
dinated over c-SIGN through the functor c-sign as seen in Par. 8.2.4. We
are now interested in the way interconnection relates to refinement.



194 8 Community

The first important property relates to the requirement that refinement
should not be based on the specificities of each particular design as far its
ability to be interconnected to other designs is concerned. In other words,
refinement morphisms should be such that designs that are isomorphic in
c-DSGN refine, and are refined exactly by, the same designs.

8.3.2 Proposition

Every isomorphism in c-DSGN defines an isomorphism in r-DSGN. •
Another crucial property is in the ability to refine a complex system

from refinements of its individual components. Consider a well-formed
configuration dia of a system with components Sh...,Sn and refinement
morphisms r7,-:5,--*5',-: i

;) ... dsgn(9n) >

By composing the morphisms r\, with those in dia that originate in ca-
bles (designs of the form dsgn(6), where 0is a signature) and have the S,
as targets, we obtain a new diagram in c-DSGN - dia+(rji):

This composition is possible because, c-DSGN being coordinated over
c-SIGN, any morphism o^dsgnfOJ-^St is also c-signfoJtfj—^c-signfSJ.
Given now a refinement morphism r7(-:S,--*5',-, we can compose c-
signfa) with r-sign(r\j) to obtain a signature morphism di—*c-sign(S\) that
can be lifted back to c-DSGN as a morphism



8.3 Refining Designs 195

The two diagrams satisfy the following important property.

8.3.3 Proposition

In the circumstances laid out above, if p:dia—>S andp':dia+(rjj)—>S' are
colimits, there is a unique refinement morphism S-*S' such that, for every
f:i-*j in /, c-sign(dia(f));r-sign(r]j)=r-sign(r]i);c-sign(dia'(f)).

This property is another form of compositionality: it states that refine-
ment of the whole can be obtained from refinements of the parts. Compo-
sitionality, as discussed in Par. 6.2.4, is a key issue in the design of com-
plex systems because it makes it possible to reason about a system using
the descriptions of their components at any level of abstraction, without
having to know how these descriptions are refined in the lower levels
(which includes their implementation).

This form of compositionality can be formulated more precisely in
Community by extending the notion of refinement to configurations much
in the same way as we extended the notion of realisation to configurations
of specifications in Par. 6.2.4.

8.3.4 Definition - Refinement of Configurations

Given two configurations dia :/-»c-Z)SGiV and dia':/—»c-DSGiV, a refine-
ment of dia over dia' is an Ill-indexed family (r\i:dia(i)—»diax{i))iQi\ of
morphisms in r-DSGN s.t., for every f:i-*j in / , c-sign(dia(f));r-
sign(r]j)=r-sign(r]i);c-sign(dia'(f)).



196 8 Community

•Ho

V

\
s2

Th

S'o

V
->S\

In order to ensure compositionality, i.e. that the colimit of dia is refined
by the colimit of dia', it is necessary to further require that:

• The diagram dia' cannot establish the instantiation of any input channel
that was left "unplugged" in dia. That is, the input channels of the
composition are preserved by refinement.

• The diagram dia' cannot establish the synchronisation of actions that
were defined as being independent in dia.

8.3.5 Proposition - Compositionality

Consider two well-formed configurations dia:I-»c-Z)SGiV and dia':/-*c-
DSGN over a set J of components, and a refinement (r]i:dia(i)-*dia'(i))ien
of dia over dia' such that, for every f:i—*j in /,

1. For every v'E.in(V\), if v'0],{Vi) then dia'(f)(v')gr]/in(Vj)).
2. For every g'EF), if rj/g) and dia'(f)(g') are define4 rji(dia'(f)(g')) is

also defined.
3. For every iQIWJ, rjiac is injective.
Then, there is a unique morphism rj.S—>S' in r-DSGN s.t., for every /6EFI/I,
c-sign(ii,i);r-sign(r])=r-sign(rii);c-sign(ix'i), where (nt: dia(i)^>S)iem and
(n\: dia'(i)->S')iE\r\ are colimits of dia and dia

1, respectively.

An outline of the proof of this result can be found in [78].



9 Architectural Description

9.1 Motivation

Although components have always been considered to be the fundamental
building blocks of software systems, it is in the way that the components
of a system interact that the emergence of global properties of the system
resides. With no interaction there is no emergence of new behaviour and,
therefore, no value to the system as a whole that is not already provided
through its components in isolation.

We can safely say that most of the complexity of system construction
lies in the definition of the interconnections that should regulate how com-
ponents interact. Designing small, encapsulated components that, through
the computations that they perform locally, provide services with certain
functionalities is something that can be mastered, without much difficulty,
with existing methods and development techniques.

Knowing how to interconnect components so that, from the interactions,
the global properties that are required of the system can emerge is a totally
different matter. Most of the time, it is an error-prone process. What in
the literature is known as the "feature interaction problem" [111] is just a
symptom of this difficulty: the emergence of "strange", "unexpected" or
"undesired" behaviour from feature composition is intrinsic to the use of
methods for putting together systems from individual features as basic
units of functionality. While we compose features having in mind the
emergence of certain properties that constitute requirements on the be-
haviour of the system, it is difficult to predict which other forms of be-
haviour will also emerge, namely ones that are not of interest and whose
"negation" is normally omitted from the requirements specification be-
cause one never thought of them being possible.

Situations like feature interaction are not problems that need to be
solved. They are phenomena that are intrinsic to the way we build systems
and that "just" need to be controlled. For that purpose, we need first-class
representations of the interconnections.



198 9 Architectural Description

This level of complexity is aggravated by the need to evolve systems.
As the world of business in general becomes more and more aggressive
and competitive, for instance, as a consequence of the impact of the Inter-
net and wireless technologies, companies need their information systems
to be easily adaptable to changes in the business rules with which they op-
erate, most of the time in a way that does not imply interruptions to the
services that they provide. Quoting directly from [47], "... the ability to
change is now more important than the ability to create e-commerce sys-
tems in the first place. Change becomes a first-class design goal and re-
quires business and technology architecture whose components can be
added, modified, replaced and reconfigured". All this means that the
"complexity" of software has definitely shifted from construction to evo-
lution, and that methods and technologies are required that address this
new level of complexity and adaptability.

Software architecture [50, 88] is a "recent" topic in software engineer-
ing aimed at addressing the gross decomposition and organisation of sys-
tems in which, through so-called connectors, component interactions are
recognised as being first-class design entities [98]. According to [2], a
connector (type) can be defined by a set of roles and a glue specification.
For instance, a typical client-server architecture can be captured by a con-
nector type with two roles - client and server - that describe the expected
behaviour of clients and servers, and a glue that describes how the activi-
ties of the roles are coordinated (e.g. asynchronous communication be-
tween the client and the server). The roles of a connector type can be in-
stantiated with specific components of the system under construction,
which leads to an overall system structure consisting of components and
connector instances establishing the interactions between the components.

The similarities between architectural constructions as informally de-
scribed above and parameterised programming [56] are rather striking and
have been developed in [59] in the context of the emerging interest in
software architecture. The view of architecture that is captured by the prin-
ciples and formalisms of parameterised programming is reminiscent of
module interconnection languages and interface definition languages [55].
This perspective is somewhat different from the one we discussed above in
the sense that, whereas they capture functional dependencies between the
modules that need to be linked to constitute a given program, we focus in-
stead on the organisation of the behaviour of systems as compositions of
components ruled by protocols for communication and synchronisation.

In this chapter, we show that the mathematical "technology" of param-
eterised programming can also be used for the formalisation of architec-
tural connectors in the interaction sense. The mathematical framework
that we propose for formalising architectural principles is not specific to
any particular Architecture Description Language (ADL). In fact, it will
emerge from the examples that we shall provide that, contrary to most



9.1 Motivation 199

other formalisations of software architectural concepts that we have seen,
category theory is not another semantic domain for the formalisation of the
description of components and connectors (like, say, the use of CSP in [2]
or first-order logic in [87]). Instead, it provides for the very semantics of
"interconnection", "configuration", "instantiation" and "composition", i.e.
the principles and design mechanisms that are related to the gross modu-
larisation of complex systems. Category theory does this at a very abstract
level because what it proposes is a toolbox that can be applied to whatever
formalism is chosen for modelling the behaviour of systems as long as that
formalism satisfies some structural properties. It is precisely the structural
properties that make a formalism suitable for supporting architectural de-
sign that we make our primary focus. However, we need some concrete
language in which to illustrate and motivate our approach. Not surpris-
ingly, we use Community for that purpose.

9.2 Connectors in Community

According to [2], a connector (type) can be defined by a set of roles that
can be instantiated with specific components of the system under con-
struction, and a glue specification that describes how the activities of the
role instances are to be coordinated. Using the mechanisms that we intro-
duced in the previous chapter for configuration design in Community, it is
not difficult to come up with a formal notion of connector that has the
same properties as those given in [2] for the language WRIGHT.

9.2.1 Definition - Architectural Connectors

A connection consists of
• Two designs G and R, the glue and the role, respectively.
• A signature 6 and two morphisms o:dsgn(d)->G,jJ,:dsgn(d)->R con-

necting the glue and the role.
A connector is a finite set of connections with the same glue that, to-

gether, constitute a well-formed configuration (see Par. 8.2.5). Its seman-
tics is the colimit of the diagram formed by its connections.

G

dsgn(e,)



200 9 Architectural Description

Because we are working in a coordinated category, we know already
that we can adopt a simplified notation for diagrams such as these by using
signatures directly in place of their discrete lifts (cables):

a

For instance, asynchronous communication through a bounded channel
can be modelled by a connector ASYNC with two connections, as depicted
below using the graphical notation that we introduced for configurations:

The glue of ASYNC is the bounded buffer with FIFO discipline pre-
sented in Sect. 8.1. It prevents the sender from sending a new message
when there is no space, and prevents the receiver from reading a new mes-
sage when there are no messages. The two roles, sender and receiver, de-
fine the behaviour required of the components to which the connector can
be applied. For the sender, we require that no message be produced before
the previous one has been processed. Its design is the one given already in
Sect. 8.1. For the receiver, we simply require that it have an action that
models the reception of a message.

design receiver [t:sort] is
in i: t
do rec: true, false -* skip

What we described are connector types in the sense that their roles can
be instantiated with specific designs. In WRIGHT [2], role instantiation
has to obey a compatibility requirement expressed via the refinement rela-
tion of CSP [69]. In Community, the refinement relation is formalised
through the morphisms defined in Par. 8.3.1, leading to the following no-
tion of instantiation:

9.2.2 Definition - Connector Instantiation

An instantiation of a connection with role R consists of a design P together
with a refinement morphism (j>:R—>P. An instantiation of a connector con-
sists of an instantiation for each of its connections. •



9.2 Connectors in CommUnity 201

In order to define the semantics of such an instantiation, notice that, as
discussed in Par. 8.3.2, each instantiation <j>:R—>P of a connection can be
composed with n:dsgn(d)->R to define fi;(j):6—>c-sign(P). Because, as
seen in Par. 8.2.4, the category of designs is coordinated over signatures,
every such signature morphism can be lifted to a design morphism
[i;<p:dsgn(d)->P. Hence, an instantiation of a connector defines a diagram
in c-DSGN that connects the role instances to the glue.

G
a,

P. Pi Pn

Because each connection is according to the rules set for well-formed con-
figurations as detailed in Par. 8.2.5, the diagram defined by the instantia-
tion is, indeed, a configuration and, hence, has a colimit.

9.2.3 Definition - Semantics of Connector instantiation

The interconnection (configuration) defined by a connector instantiation is
the diagram in c-DSGN formed as described above by composing the role
morphism of each connection with its instantiation. The semantics of an
instantiation is the colimit of the interconnection that it defines. •

Because, as already argued, colimits in c-DSGN express parallel com-
position, this semantics agrees with the one provided in [2] for the lan-
guage WRIGHT. In the next section, we take this analogy with WRIGHT
one step further. Moreover, through compositionality as formalised in Par.
8.3.5, the categorical formalisation makes it possible to prove that the de-
sign that results from the semantics of the instantiation is a refinement of
the semantics of the connector itself.

As a simple example, consider a connector with just one role.

9 • G
(* T o pi

K • C

ill' a
11 a1



202 9 Architectural Description

The semantics of the connector is given by the colimit of the pair <pi,o>
- <a:R-*C,/3:G->C>. The instantiation of the role with the component P
through the refinement morphism <f> is given by the colimit of <fi;<f>,cr> -
<a':P-*S,(}':G-*S>. We can easily prove that there exists a refinement
morphism <p':C->S, which establishes the "correctness" of the instantiation
mechanism. This is because all the different objects and morphisms in-
volved can be brought into a more general category in which the universal
properties of colimits guarantee the existence of the required refinement
morphism. A full proof of this property is given in [78].

As an example, consider again the connector ASYNC. We have already
seen in Sect. 8.3 that sender is refined by the design user. Likewise,
printer is a refinement of receiver via the refinement morphism
K.receiver—sprinter defined by Kch(i)=rdoc and Kac(rec)=rec: the reception
of a message from the input channel (named rdoc) corresponds to down-
loading it into the private channel pdoc. This action is only enabled if the
previous message has been printed.

X '
pr ps ( pr—pdf ( p r i n t

Using these refinement morphisms, we can instantiate the connector
ASYNC to connect the user to the printer:



9.2 Connectors in CommUnity 203

The final configuration is obtained by calculating the composition of the
signature morphisms that define the two connections of ASYNC with the
refinement morphisms r\,K. For instance, the channel p of user gets con-
nected to the input channel i of buffer because r\(o)=p and o is connected
to i of buffer. The resulting configuration is the one presented in Sect. 8.2.

In order to simplify the notation when making use of connectors, we
normally hide the glue and its connections to the roles, leaving just the
roles visible to suggest that they provide the "interface" of the connector:

Instantiation is denoted as follows:

Architectural connectors are used for systematising software develop-
ment by offering standard means for interconnecting components that can
be reused from one application to another. In this sense, the typical glue is
a program that implements a well-established pattern of behaviour (e.g. a
communication protocol) that can be superposed to existing components of
a system through the instantiation of the roles of the connector.



204 9 Architectural Description

However, architectures also fulfil an important role in supporting a
high-level description of the organisation of a system by identifying its
main components and the way these components are interconnected. An
early identification of the architectural elements intended for a system will
help to manage the subsequent design phases according to the organisation
that they imply, identifying opportunities for reuse or the integration of
third-party components. From this point of view, it seems useful to allow
for connectors to be based on glues that are not yet fully developed as pro-
grams, but for which concrete commitments have already been made to
determine the type of interconnection that they will ensure. For instance,
at an early stage of development, one may decide to adopt a client-server
architecture without committing to a specific protocol of communication
between the client and the server. This is why, in the definition of con-
nector in Community, we left open the possibility for the glue not to be a
program but a design in general.

However, in this more general framework, we have to account for the
possible refinements of the glue. What happens if we refine the glue of a
connector that has been instantiated to given components of a system? Is
the resulting design a refinement of the more abstract design from which
we started? More generally, how do connectors propagate through design,
be it because the instances of the roles are refined or the glue is refined?
One of the advantages of using category theory as a mathematical frame-
work for formalising architectures is that answers to questions like these
can be discussed at the right level of abstraction. Another advantage is
that the questions themselves can be formulated in terms that are inde-
pendent of any specific ADL and answered by characterising the classes of
ADLs that satisfy the given properties. This is what we do further on.

9.3 Examples

We now present more examples of connectors, namely some that we will
need in later sections for illustrating algebraic operations on connectors.
Their application is illustrated on examples related to a case study on mo-
bility [93]:

One or more carts move continuously in the same direction on a £/-units
long circular track. A cart advances one unit at each step. Along the track
there are stations. There is at most one station per unit. Each station corre-
sponds to a check-in counter or to a gate. Carts take bags from check-in
stations to gate stations. All bags from a given check-in go to the same
gate. A cart transports at most one bag at a time. When it is empty, the
cart picks a bag up from the nearest check-in. Carts must not bump into
each other. Carts also keep a count of how many laps they have done,
starting at some initial location.



9.3 Examples 205

The program that controls a cart is

design cart is
in idest: 0..U-1, ibag:int
out obag, laps : int
prv loc: 0..U-1, dest: -1..U-1, initloc: int
do move: loc^dest -*

loc:=loc+ul || laps :=if( loc=initloc,laps+l,laps)
0 get: dest=-l —» obag:=ibag || dest:=idest
0 put: loc=dest —* obag:=0 || dest:=-l

where +a is addition modulo U.
Locations are represented by integers from zero to the track length mi-

nus one. Bags are represented by integers, the absence of a bag being de-
noted by zero. Whenever the cart is empty, its destination is an unreach-
able location (-1), so that the cart keeps moving until it gets a bag and a
valid gate location through action get. When it reaches its destination, the
cart unloads the bag through action put. Notice that, because input chan-
nels may be changed arbitrarily by the environment, the cart must copy
their values to output/private channels to make sure the correct bag is un-
loaded at the correct gate.

A check-in counter manages a queue of bags that it loads one by one
onto passing carts.

design check-in is
out bag: int, dest: 0..U-1,
prv loc: 0..U—1, next: bool, q: list(int)
do new: q^[]Anext —» bag:=head(q)|| q:=tail(q)|| next: =false
Q put: ->next -» next:=true

Channel next is used to impose sequentiality among the actions. In a
configuration in which a cart is loading at a gate, the put action must be
synchronised with a cart's get action and channels bag and dest must be
shared with ibag and idest, respectively.

A gate keeps a queue of bags and adds each new bag to the tail.

design gate is
in bag: int
prv loc: 0..U-1, q: list(int)
do get: true -»q:=q.bag

In a configuration in which a cart is unloading at a gate, action get of the
gate must be synchronised with the cart's put action, and channel bag must
be shared with obag.

9.3.1 Synchronisation

We begin with the connector that allows us to synchronise two actions of
different components. A plain cable would suffice for this purpose, but it
is not able to capture the general case of transient synchronisation [93].
Having already a connector for the simpler case makes the presentation



206 9 Architectural Description

more uniform. The glue and roles of the synchronisation connector are the
same.

SXNC

actionaction

where

design action is
do a: true,false —» skip

Notice that the action has the least deterministic specification possible: its
guard is given the widest possible interval and no commitments are made
on its effects. Hence, it can be refined by any action.

According to the colimit semantics of connectors, when the two roles
are instantiated with particular actions a; and a2 of particular components,
the components have to synchronise with each other every time one of
them wants to execute the corresponding action. That is, either both exe-
cute the joint action, or none executes.

As an example of using this connector, if we wish to count how often a
cart unloads, we can monitor its put action with a counter:

action

SINC 1
action

where

design

out
do

D

( put
V^'

cart

counter is
c:int
inc: true -»
reset: true

c:=c+l
-» c:=0

1 xnc

counter

According to what is defined in Par. 9.2.2, the interconnection defined
by this instantiation is the following configuration:



9.3 Examples 207

The resulting semantics is the synchronisation of put and inc. The fol-
lowing program captures the joint behaviour of the interconnected compo-
nents:

design monitored_cart is
in iciest: 0..U-1, ibag: int
out obag, laps, unloads : int
prv loc: 0..U-1, dest: -1. .U-1, ini t loc : int
do move: loc^dest

—* loc:=loc+ul || laps:=if(loc=initloc,laps+l,laps)
Q get: dest=-l -» obag:=ibag || dest:=idest
0 put|inc: loc=dest

-* obag:=0 || dest:=-l || unloads :=unloads+l

9.3.2 Subsumption

Intuitively, synchronisation corresponds to an equivalence between the oc-
currence of two actions: the occurrence of each of the actions implies the
occurrence of the other. In many circumstances, we are interested in one
of the implications, like in remote method invocation: a call requests the
execution of the method, but that method may be invoked by other calls.

For instance, to avoid a cart colliding with a cart that is right in front of
it, we only need one implication: if the first one moves, so must the one in
front. The other implication is not necessary. The analogy with implica-
tion also extends to the counter-positive: if the front car cannot move, for
instance, because it is (un)loading a bag, then neither can the rear one.

We call this one-way synchronisation action subsumption. The sub-
sumption connector is given by the following configuration:

where the glue is now given by

design subsume is
do sync: true,false
D free: true,false

• skip
• skip



208 9 Architectural Description

Notice that although the two roles are the same, the connector is not
symmetric because the connections treat the two role actions differently:
the right-hand one may be executed alone at any time, while the left-hand
one must co-occur with the right-hand one through sync. Indeed, the se-
mantics of the connector generates the following synchronisation sets:
ajlsyncla2 and free\a2, where a, is a renaming of the left-hand role action
and a2 is a renaming of the left-hand role one. Hence, action a1 can only
occur together with a2, but a2 can occur without a,.

In order to understand how subsumption works, let us detail the con-
struction of the semantics of the connector, starting with the corresponding
diagram of signatures. Because only actions are involved, we take the dia-
gram directly over pointed sets:

ah)c synch->
free I—>c
synch-^c ah>c

{sync,free}

The limit can be computed by first taking the two obvious pullbacks:

{a} ^. {c} ̂  {sync,free} ^ . {c}^ {a}

{a|sync,a|free}

Notice that, because the interconnecting morphisms are different, differ-
ent synchronisations are generated even if the nodes are the same. Finally,
the middle pullback relates the pairwise synchronisations to make up the
global interconnection:

{sync,free}

9
{ a,|syncja2, a2|f ree}

As an example of the application of this connector, consider its instan-
tiation with the move actions of two carts: any movement of the cart on the



9.3 Examples 209

left implies a movement of the cart on the right. Hence, this instantiation
can be used to prevent collision when the left cart is too close behind the
right cart.

SUBSUMPTION

cart

9.3.3 Extension Cord

A generalisation of the subsumption and synchronisation connectors is to
allow an action to synchronise, independently, with actions of two differ-
ent components, achieving an effect similar to an extension cord that one
uses to connect two devices to the same power supply.

where

design extend
do branchl: true, false —>skip
D branch2: true, false -> skip

If we instantiate the left-hand role with an action ah the right-hand role
with an action a2 and the middle role with an action b, the semantics of the
interconnection, as obtained through the colimit, is given by two synchro-
nisation sets: ai\branchi\b and a2\branch2\b. Notice that action b will al-
ways occur simultaneously with either a7 or a2 but not with both. For in-



210 9 Architectural Description

stance, a gate that can handle two carts downloading simultaneously can
configured as follows:

This connector can be generalised to any finite number n of ramifica-
tions (branch actions), giving rise to an n-EXTENSION CORD through
which a server can be connected simultaneously, but independently, to a
fixed maximum number of clients.

The more attentative reader may also have noticed that the glue extend
of EXTENSION CORD is the same as (isomorphic to) subsume of
SUBSUMPTION. Indeed, the difference between the two connectors is in
the roles that they offer; SUBSUMPTION does not offer the "free" ramifi-
cation of the subsumed action as a role for interconnection. We can also
say that SUBSUMPTION is no more than a 1-EXTENSION CORD. This
relationship is discussed in more detail in Par. 10.1.2.

9.3.4 Inhibition
Another basic connector type is the one that allows us to inhibit an action
by making its guard false. This is useful when, for some reason, we need
to prevent an action from occurring but without having to reprogram the
component. Indeed, the mechanism of superposition that we use as a se-
mantics for the application of architectural connectors allows us to disable
an action without changing the guard directly but by just inducing this ef-
fect: it suffices to synchronise the action with one that has a false guard.

INHIBITIOS

action issisibit



9.3 Examples 211

The glue is:

design inhibit is
do never: false —» skip

When the role is instantiated with an action with guard B, the result of the
interconnection is the same action guarded by BAfalse.

This connector can be generalised to arbitrary conditions with which
one may strengthen the guards of given actions. The inhibitor just has to
be provided with the data that is necessary to compute the condition C that
will strengthen the guard. This can be done, for instance, through the use
of input channels through which we can select the sources of the informa-
tion that will disable the action.

design inhibit(C) is
in
do never: C -* skip

The result of instantiating the role with an action with guard B is the
same action guarded by BAC.

9.4 An ADL-lndependent Notion of Connector

The notion of connector presented in Sect. 9.2 can be generalised to design
formalisms other than Community. In this section, we discuss the proper-
ties that such formalisms need to satisfy for supporting the architectural
concepts and mechanisms that we have illustrated for CommUnity.

Before embarking on this discussion, we need to fix a framework in
which designs, configurations and relationships between designs, such as
refinement, can be formally described.

9.4.1 Definition - Design Formalisms

A formalism supporting system design consists of:
• A category c-DESC of component descriptions in which systems of in-

terconnected components are modelled through diagrams.
• For every set CD of component descriptions, a set Conf(CD) consisting

of all well-formed configurations that can be built from the components
in CD. Each such configuration is a diagram in c-DESC that is guaran-
teed to have a colimit. Typically, Con/is given through a set of rules
that govern the interconnection of components in the formalism.

• A category r-DESC with the same objects as c-DESC, but in which
morphisms model refinement, i.e. a morphism r]:S—*S' in r-DESC ex-
presses that 5' refines 5, identifying the design decisions that lead from
S to 5'. Because the description of a composite system is given by a
colimit of a diagram in c-DESC and, hence, is defined up to an isomor-



212 9 Architectural Description

phism in c-DESC, refinement morphisms must be such that descriptions
that are isomorphic in c-DESC refine, and are refined exactly by, the
same descriptions. •

Summarising, all we require is a notion of system description, a rela-
tionship between descriptions that captures components of systems, an-
other relationship that captures refinement and criteria for determining
when a diagram is a well-formed configuration.

In the context of this categorical framework, we shall now discuss the
properties that are necessary for supporting software architecture. A key
property for supporting architectural design is a clear separation between
the description of individual components and their interaction in the over-
all system organisation. In other words, the formalism must support the
separation between what, in the description of a system, is responsible for
its computational aspects and what is concerned with coordinating the in-
teraction between its different components.

In the case of Community, as we have seen, only signatures are in-
volved in interconnections. The body of a component design describes its
functionality and, hence, corresponds to the computational part of the de-
sign. At the more general level that we are discussing, we shall take the
separation between coordination and computation to be materialised
through a functor sign:c-DESC—>SIGN mapping descriptions to signa-
tures, forgetting their computational aspects. The fact that the computa-
tional side does not play any role in the interconnection of systems can be
captured by requiring sign to be coordinated in the sense of Par. 7.5.4.

Another crucial property for supporting architectural design is in the
interplay between structuring systems in architectural terms and refine-
ment. We have already pointed out that one of the goals of software ar-
chitectures is to support a view of the gross organisation of systems in
terms of components and their interconnections that can be carried through
the refinement steps that eventually lead to the implementation of all its
components. Hence, it is necessary that the application of architectural
connectors to abstract designs, as a means of making early decisions on the
way certain components need to be coordinated, will not be jeopardised by
subsequent refinements of the component designs towards their final im-
plementations. Likewise, it is desirable that the application of a connector
may be made on the basis of an abstract design of its glue as a means of
determining main aspects of the required coordination without committing
to the final mechanisms that will bring about that coordination.

One of the advantages of the categorical framework that we propose is
that it makes the formulation of these properties relatively easy, leading to
a characterisation of the design formalisms that support them in terms of
the structural properties that we have been discussing. For instance, we
show in Sect. 8.3 that, in the situations in which refinement morphisms
map directly to signature morphisms, we can simply put together, in a dia-



9.4 An ADL Independent Notion of Connector 213

gram of signatures, the morphisms that define the interactions and the
morphisms that establish the refinement of the component descriptions.

More precisely, in the situations in which there exists a forgetful functor
r-sign:r-DESC->SIGN that agrees with the coordination functor sign on
signatures, i.e. r-sign(S)=sign(S) for every S.c-DESC, and given a well-
formed configuration diagram dia of a system with components Slr...,Sn
and refinement morphisms r̂ .'S,—»S',-, iEl.j,

we can obtain a new diagram in c-DESC and, hence, a new configuration,
by composing the morphisms r-sign(rjj) with those in dia that originate in
channels (signatures) and have the 5, as targets.

I

Q> O) O>

In general, it may be possible to propagate the interactions between the
components of a system when their descriptions are replaced by more con-
crete ones, even when refinement morphisms do not map to signature
morphisms. This more general situation can be characterised as follows.

9.4.2 Definition - Compositional Design Formalisms

We say that a design formalism is compositional whenever, for every well-
formed configuration dia involving descriptions fS7,...,S^ and refinements
morphisms {rjj.Si-^S): iEL.n}, there is a well-formed configuration dia-
gram dia+(r),) that characterises the system obtained by replacing the St by
their refinements and satisfies the following correctness criterion: the
colimit of dia+(r/j) provides a refinement for the colimit of dia. •

When we consider the specific case of the configurations obtained by
direct instantiation of an architectural connector, this property reflects the
compositionality of the connector as an operation on configurations.



214 9 Architectural Description

Compositionality ensures that the semantics of the connector is preserved
(refined) by any system that results from its instantiation. For instance,
given instantiations rjI:R,—»P1 and rj2:R2—

>P2 of a binary connector

compositionality means that the description returned by the colimit of dia
is refined by the description returned by the colimit

Pi P2

Likewise, compositionality guarantees that if a connector with an ab-
stract glue G is applied to given designs, and the glue is later refined
through a morphism rj:G->G\ the description that is obtained through the
colimit of dia+r) is a refinement of the semantics of the original instantia-
tion. In fact, we can consider the refinement of the glue to be a special
case of an operation on the connector that delivers another connector - a
refinement of the original one in the case at hand.

9.4.3 Definition - Architectural Schools

A design formalism F=<c-DESC,Conf,r-DESC> supports architectural
design, and is called an architectural school, iff

• c-DESC is coordinated over SIGN through sign.c-DESC^SIGN.
• F is compositional. •

9.5 Adding Abstraction to Connectors

The mathematical framework that we presented in the previous sections
provides not only an ADL-independent semantics for the principles and
techniques that can be found in existing approaches to software architec-
tures, but also a basis for extending the capabilities of existing ADLs. In
the remainder of this chapter, we present and explore some of the avenues



9.5 Adding Abstraction to Connectors 215

that this mathematical characterisation has opened, hoping that the reader
will want to explore them even further, or find new ones.

As already mentioned, the purpose of the roles in a connector is to im-
pose restrictions on the local behaviour of the components that are admissi-
ble as instances. In the approach to architectural design outlined in the
previous sections, this is achieved through the notion of correct instantia-
tion via refinement morphisms. As also seen above, roles do not play any
part in the calculation of the resulting system. They are used only for de-
fining what a correct instantiation is. This separation of concerns justifies
the adoption of a more declarative formalism for the specification of roles,
namely one in which it is easier to formulate the properties required of
components to be admissible instances.

In this section, we place ourselves in the situation in which the glues are
designs, the roles are specifications, and the instantiations of the roles are,
again, designs. We are going to consider that specifications are given as a
category SPEC, e.g. the category of theories of a logic formalised as an in-
stitution (see Par. 6.5.11). We take the relationship between specifications
and designs to be captured through the following elements:

• A functor spec .SIGN->SPEC mapping signatures and their morphisms
to specifications. The idea behind the functor spec is that like through
c-desc (the left adjoint of sign) signatures provide the means for inter-
connecting designs, they should also provide the means for intercon-
necting specifications. Hence, every signature generates a canonical
specification - the specification of a cable. However, it is not necessary
for spec to satisfy as many structural properties as c-desc because, for
the purposes of this section, we are limiting the use of specifications to
the definition of connector roles. Naturally, if we wish to address ar-
chitecture building at the specification level, then we will have to re-
quire SPEC to satisfy the properties that we discussed in Sect 9.4.

• A satisfaction relation 1= between design morphisms and specification
morphisms satisfying the following properties:

1. If n:P->P' ̂ a:S->S', then idP ̂ ids and idP,
2. n1;n2 h=o);a2if Jt^P,—>P2 NCT7:S7—*S2 and n2
3. Let s:I->SPEC be a diagram of specifications and p:I->c-DESC a

diagram of designs with the same shape such that, for every edge
f:i—*j in /, pfPi—^Pj N=Sy:s,--»sj. We require that, if/) admits a colimit
jti.pj-fP, then s admits a colimit Oj.s^S such that, for every node i:I,

4. If idP N ids and p:P~*P
[ is a refinement morphism, then idP< N ids

5. For every signature 6, idc.desc(S) ^idspec(e).
The satisfaction relation is defined directly on morphisms because our

ultimate goal is to address interconnections, not just components. Satis-
faction of component specifications by designs is given through the iden-



216 9 Architectural Description

tity morphisms. The properties required of the satisfaction relation address
its compatibility with the categorical constructions that we use, namely
composition of morphisms and colimits. The last two properties mean that
refinement of component designs leaves the satisfaction relation invariant,
and that the design (cable) generated by every signature satisfies the speci-
fication (cable) generated by the same signature.

We saw in Par. 5.1.3 how a satisfaction relation between specifications
and programs is defined by a functor r-DESC—*SPEC that maps every de-
sign to the set of properties that it "satisfies". Intuitively, this functor is an
extension of spec in the sense that, for every 6, spec(6)is isomorphic to
spec(c-desc(6)). Therefore, we call it spec. In this case, it makes sense to
define n:P->P' ^o:S-*S' iff there exist p:S^spec(P), p':S'->spec(P') s.t.
p;spec(jt)=o;p'.

a
S • S'

P © P' SPECI • I
spec(P) • spec(P')

spec(it) spec

•>• P' c-DESC

Notice that we get idP 1= ids iff there exists p:S—>spec(P), which is ex-
actly how satisfaction was defined in Par. 5.1.3. Moreover, properties 1-4
are obtained free from the fact that spec is a functor. Condition 5 is satis-
fied because spec(6) was required to be isomorphic to spec(c-desc(d)).

In such a setting, we generalise the notion of connector as follows.

9.5.1 Definition - (Generalised) Architectural Connectors

A (generalised) connection consists of
• A design G and a specification R, its glue and role, respectively.
• A signature 6 and two morphisms \i:c-desc(Q)-*G, o:spec(d)->R in

c-DESC and SPEC, respectively, connecting the glue and the role via
the signature (cable).

A (generalised) connector is a finite set of connections with the same
glue. An instantiation of a connection with signature 8 and role morphism
a consists of a design P and a design morphism n;:c-desc(d)->P such that
Jt No. An instantiation of a connector consists of an instantiation for each
of its connections. An instantiation is correct if the diagram defined by the
instantiation morphisms and the glue morphisms is a well-formed configu-
ration. The colimit of this configuration defines the semantics of the in-
stantiation, and is guaranteed to exist if the instantiation is correct. •



9.5 Adding Abstraction to Connectors 217

Although the generalisation seems to be quite straightforward, we do
not have an immediate generalisation for the semantics of connectors.
This is because the glue is a design and the role is a specification, which
means that a connector does not provide us with a diagram like in the ho-
mogeneous case that we studied in Sect. 9.2. However, if we are provided
with a specification for the glue, we can provide semantics for the con-
nector at the specification level.

9.5.2 Definition - Complete Architectural Connector

A complete connection consists of
• A design G and a specification R, called the glue and the role of the

connection, respectively.
• A signature 6 and two morphisms n:c-desc(d)^G,a:spec(d)^R in c-

DESC and SPEC, respectively, connecting the glue and the role via the
signature (cable).

• A specification S and a morphism r:spec(d)—>S such that n \=x. Notice
that this means that the design G satisfies the specification 5.
A complete connector is a finite set of complete connections with the

same glue design and specification. Its semantics is given by the colimit,
if it exists, of the SP2?C-diagram defined by the ot and the rt. •

9.5.3 Proposition

The semantics of the instantiation of a complete connector satisfies the
semantics of the connector. •

An illustration of an abstract architectural school can be given in terms
of a first-order extension1 of the linear temporal logic that we studied in
Sect. 3.5. As an example, we present below the specifications of a typical
sender and receiver of messages through a pipe.

specification pipe_sender is
signature eof, send
axioms eof O G(->sendAeof)

specification pipereceiver is
signature cl, eof, rec
axioms cl 3 G^rec A cl)

(Geof A ̂ cl) D (-•recUcl)

The specification pipe_sender accounts, through send, for the transmis-
sion of data. The end of data transmission is signalled through channel
eof. the axiom requires that eof be stable (remains true once it becomes
true) and transmission of messages to cease once eof becomes true.

1 The extension is straightforward: the reader is encouraged to formalise it as an
exercise, for which [38, 39, 67] can be consulted.



218 9 Architectural Description

The specification pipejreceiver accounts, through rec, for the reception
of data. The other means of interaction with the environment is concerned
with the closure of communication. Through channel eof, a Boolean can
be received that indicates if transmission has ceased. Closure of commu-
nication is signalled in the channel cl. The first axiom requires that cl be
stable and the reception of messages to cease once cl becomes true. The
second axiom expresses that, if the information received through eof is
stable, the receiver is obliged to close the communication as soon as it is
informed that there will be no more data. However, the receiver may de-
cide to close the communication before that.

It remains to capture the relationship between specifications and designs
in Community. On the one hand, every design signature 6 can be mapped
into a temporal signature by forgetting the different classes of channels
and actions, as well as the write frames of action. On the other hand, part
of the semantics of designs can be encoded in LTL:

• For every action g, the negation of L(g) is a blocking condition for its
occurrence: (gDL(g)).

• For every local channel v, D(v) consists of the set of actions that can
modify it: v g v (Xv=v).

gSXvf
• For every action g, the condition R(g) holds in every state in which g is

executed: (gDr(R(g)), where T is a translation that replaces any primed
variable v' by the term (Xv).

• Private actions that are infinitely often enabled are guaranteed to be se-
lected infinitely often: (GFU(g)DGFg)
This encoding extends to refinement morphisms, establishing a functor

r-DESC->THEOFOLTL, from which we can define a satisfaction relation.
Notice that the fact that refinement of Community designs is contravariant
on the upper bound of actions is crucial: refinement morphisms are live-
ness preserving but interconnection morphisms are not.

In order to illustrate the generalised notion of connector in this setting,
we present below the connector cpipe whose glue is given by

design pipe [t:sort, bound:t] is
in i : t , scl:bool
out o:t , eof:bool
prv rd: bool, b: l i s t ( t )
do put: true -» b:=b.i
0 prv next: |b|>0A r̂d -»o:=head(b) || b:=tail(b) || rd:=true
[] get: rd —>rd:=false
[] prv sig: sclA|b|=0 —»eof:=true

This design models a buffer with unlimited capacity and a FIFO disci-
pline. It signals the end of data to the consumer of messages as soon as the



9.5 Adding Abstraction to Connectors 219

buffer gets empty and the sender of messages has already informed,
through the input channel scl, that it will not send anymore messages.

The two roles — the specifications sender and receiver introduced before
- define the behaviour required of the components to which the connector
cpipe can be applied. It is interesting to notice that, due to the fact that
LTL is more abstract than Community, we were able to abstract away
completely the production of messages in the role sender. In the design of
sender presented in Sect. 8.1 we had to consider an action modelling the
production of messages.

We can now generalise these constructions even further by letting the
connections use different specification formalisms and the instantiations to
be performed over components designed in different design formalisms.
In this way, it is possible to support the reuse of third-party components,
namely legacy systems, as well as the integration of non-software compo-
nents. We can thus highlight the role of architectures in promoting a
structured and incremental approach to system construction and evolution.

However, to make sense of the interconnections, we have to admit that
all the design formalisms are coordinated over the same category of sig-
natures. That is, we assume that the integration of heterogeneous compo-
nents is made at the level of the coordination mechanisms, independently
of the way each component brings about its computations. Hence, we will
assume given

• A family {DSGNJ-^o of categories of designs, all of which are coordi-
nated over the same category SIGN via a family of functors {dsgnJ-^D.

• A family {SPECc}c:C of categories of specifications together with a fam-
ily {specc:SPECc-*SIGN}c:C of functors.

• A family {)=Js:s of satisfaction relations, each of which relates a design
formalism d(s) and a specification formalism c(s). We do not require 5
to be the Cartesian product DxC, i.e. there may be pairs of design and
specification formalisms for which no satisfaction relation is provided.

Given such a setting, we can generalise the notion of connector.

9.5.4 Definition - (Heterogeneous) Architectural Connectors
A heterogeneous connection consists of

• A design formalism DSGNd and a specification formalism SPECC.
• A design G:DSGNd and a specification R:SPECC, called the glue and

the role of the connection, respectively.



220 9 Architectural Description

• A signature 6:SIGN and two morphisms \i:dsgnd(B)—K}, o:specc(8)—>R
in DSGNd and SPEC, respectively, connecting the glue and the role via
the signature (cable).

An heterogeneous connector is a finite set of connections with the same
glue.

An instantiation of a heterogeneous connection with specification for-
malism SPECC, signature Sand role morphism a consists of
• A design formalism DSGN'd' and a satisfaction relation N<(/. c> between

DSGN'd and SPECC such that <d',c>ES.
• A design P and a design morphism Jt:dsgnd'(6)->P such that JT k=so.
An instantiation of a connector consists of an instantiation for each of its
connections. •

Given that in the context of heterogeneus connectors we have to deal
with several design formalisms, providing a semantics for the resulting
configurations requires a homogeneous formalism to which all the design
formalisms can be mapped. Clearly, because we want the heterogeneity of
formalisms to be carried through to the implementations in order to be able
to support the integration of legacy code, third-party components and even
non-software components, this common formalism cannot be at the same
level as that of designs, and the mapping cannot be a simple translation.
What seems to make more sense is to choose a behaviour model that can
be used to provide a common semantics to all the design formalisms so
that the integration is not performed at the level of the descriptions, but of
the behaviours that are generated from the descriptions. Indeed, when we
talk about the integration of heterogeneous components, our goal is to co-
ordinate their individual behaviours. An architecture should provide pre-
cisely the mechanisms through which this coordination is effected.



10 An Algebra of Connectors

As argued in [84], the level of support that Architectural Description Lan-
guages (ADLs) provide for connector building is still far from the one pro-
vided for components. For instance, although considerable amounts of
work can be found on several aspects of connectors [2, 14, 84], further
steps are still necessary to achieve a systematic way to construct new con-
nectors from existing ones. Yet, the ability to manipulate connectors in a
systematic and controlled way is essential for promoting reuse and incre-
mental development, and to make it easier to address complex interactions.

At an architecture level of design, component interactions can be very
simple (for instance, a shared variable), but they can be very complex as
well (for example, database-accessing and networking protocols). Hence,
it is very important that we have mechanisms for designing connectors in
an incremental and compositional way, as well as principled ways of ex-
tending existing ones, promoting reuse. This is especially important for
connectors that are used at lower levels of design because it is well known
that the implementation of complex protocols is a very difficult and error-
prone part of system development.

It is not always possible to adapt components to work with existing
connectors. Even in those cases where it is feasible, a better alternative
may be to modify the connectors because, typically, there are fewer con-
nector types than component types. Moreover, most ADLs either provide
a fixed set of connectors or only allow the creation of new ones from
scratch, hence requiring from the designer a deep knowledge of the par-
ticular formalism and tools at hand. Conceptually, operations on connec-
tors allow one to factor out common properties for reuse and to better un-
derstand the relationships between different connector types.

The notation and semantics of such connector operators are, of course,
among the main issues to be dealt with. Our purpose in this chapter is to
show how typical operators can be given an ADL-independent semantics
by formalising them in the categorical framework that we presented in the
previous chapter.

For instance, given a connector expressed through a configuration dia-
gram dia



222 10 An Algebra of Connectors

and a refinement r]:G-*Gx of its glue, we can construct through dia+rj an-
other connector that has the same roles as the original one, but whose glue
is now G'.

dia+ri

A fundamental property of this construction, given by compositionality,
is that the semantics of the original connector, as expressed by the colimit
of its diagram, is preserved in the sense that it is refined by the semantics
of the new connector. This means that all instantiations of the new con-
nector are refinements of instantiations of the old one. This operation sup-
ports the definition of connectors at higher levels of abstraction by delay-
ing decisions on concrete representations of the coordination mechanisms
that they offer, thus providing for the definition of specialisation hierar-
chies of connector types.

In this chapter we present three connector transformations that operate
on the roles rather than the glue. Transformations that, like above, operate
at the level of the glue are more sensitive in that they interfere more di-
rectly with the semantics of the connector to which they are applied.
Hence, they should be restricted to engineers who have the power, and en-
suing responsabilities, to change the way connectors are implemented.
Operations on the roles are less critical and can be performed more liber-
ally by users who have no access to the implementation (glue). In the last
section, we present higher-order mechanisms that can be applied to con-
nectors to obtain other connectors.

Throughout the chapter, we will be working over a fixed architectural
school F=<c-DESC,Conf,r-DESC> (see Par. 9.4.3).



10.1 Three Operations on Connectors 223

10.1 Three Operations on Connectors

10.1.1 Role Refinement

To tailor general-purpose connectors for a specific application, it is neces-
sary to replace the generic roles by specialised ones that can effectively act
as "formal parameters" for the application at hand. Role replacement is
done in the same way as applying a connector to components: there must
be a refinement morphism from the generic role to the specialised one.
The old role is cancelled, and the new role morphism is the composition of
the old one with the refinement morphism as discussed in Sect. 8.3.

Given an n-ary connector

and a refinement morphism r/,//?,—>i?', for some l<i<n, the role refinement
operation yields the connector

This operation can be applied to both abstract and heterogeneous con-
nectors. It preserves the semantics of the connectors to which it is applied
in the sense that any instantiation of the new connector is also an instan-
tiation of the original one. This is because the refinement morphism that
instantiates R\ can be composed with rft to yield an instantiation of/?,.

As an example of role refinement, consider the asynchronous connector
shown previously. This connector is too general for our luggage distribu-
tion service because the sender and receiver roles do not impose any con-
straints on the admissible instances. We would like to refine these roles in
order to prevent meaningless applications to our example, like sending the
location of the check-in as a bag to the cart. This can be done through the
refinement of sender with



224 10 An Algebra of Connectors

design cart-role i s
out obag: int
prv dest: -1..U-1
do get[obag]: dest=-l
0 put: dest>-l,false

dest '>-l
obag:=0 || dest:=-l

where the channel rd of sender is refined by the term dest>-l. Notice that
this is a generalised refinement as observed after Par. 8.3.1 in the sense
that we are using a term of the target language to refine a channel. See
[37] for details on this extension.

ASYNC

receiver

The resulting connector is

CART2GATE

receiver

Notice that the invalid combinations are not possible because cart-role
cannot be refined with a gate or a check-in. Moreover, the obag channel
of cart-role cannot be refined by channel laps of cart.

10.1.2 Role Encapsulation

To prevent a role from being further refined, the second operation we con-
sider, when executed repeatedly, decreases the arity of a connector by en-
capsulating some of its roles, making the result part of the glue.



10.1 Three Operations on Connectors 225

Given an n-ary connector

the encapsulation of the ith role is performed as follows: the pushout of the
ith connection is calculated, and the other connections are changed by
composing the morphisms that connect the channels to the glue with the
morphism that connects the glue with the apex of the pushout, yielding a
connector of arity n-1.

G'

For instance, we can obtain SUBSUMPTION as defined in Par. 9.3.2,
from EXTENSION CORD as defined in Par. 9.3.3, through encapsulation
of the right-hand side action role. Indeed, as observed in Par. 9.3.3, both
connectors have isomorphic glues: the difference between them is in the
roles that they offer. On the other hand, the pushout of the glue-role con-
nection that is involved in the encapsulation returns, up to isomorphism,
that same glue because the role does not require any properties of the in-
stances; it just performs name bindings.

action

H branch branch-

action

t' a

action



226 10 An Algebra of Connectors

10.1.3 Role Overlay

The third operation allows combining several connectors into a single one
if they have some roles in common, i.e. if there is an isomorphism between
those roles. The construction is as follows.

Consider a connector with roles {RJjskai and glue G, and a connector
with roles {R'k}i<k<m and glue G' such that Rj and R't are isomorphic. We
construct a new connector by overlaying the isomorphic roles. The glue of
the new connector is calculated from the diagram that consists of all the
connections that have isomorphic roles together with the isomorphisms,
and calculate its colimit. The apex of the colimit is the new glue.

Each of the pairs of connections involved gives rise to a connection of
the new connector. The role of this connection is one of the roles of the
old connections; because they are isomorphic, it does not matter which one
is chosen (in the figure, we chose /?',). This role is connected directly to
the new glue through one of the morphisms that results from the colimit;
hence, its channel is the role signature.

Each of the connections of the original connectors that is not involved in
the calculation of the new glue, which means that it does not share its role
with a connection of the other connector, becomes a connection of the new
connector by composing the old new glue morphism with the colimit mor-
phism that connects the old glue to the new one. This is exemplified in the
figure with the connection with role /?,-.

This operation provides a way of building SYNC by overlaying two
copies of SUBSUMPTION in a symmetric way.



10.1 Three Operations on Connectors 227

action

SUBSUMPTION

( sync free

free sync

Z'j,isi. '•',»'/,

SUBStlMFTIOH

Notice that the colimit of the underlying diagram makes all actions col-
lapse into a single one. Hence the glue of the resulting connector is iso-
morphic to the "sync" component. Moreover, each pair of overlaid roles
results into a single one, and therefore there will be only two "action"
roles. In summary, the resulting connector is SYNC.

10.2 Higher-Order Connectors

As explained before, it is important to have principled forms of adapting
connectors to new situations, for instance, in order to incorporate compres-
sion, fault-tolerance, security, monitoring, etc. Let us consider compres-
sion as an example. The goal is to be able to adapt any connector that rep-
resents a communication protocol in order to compress data for
transmission in a transparent way. In order to give a first-class description
of this form of adaptation, the kind of communication protocol modelled
by the adapted connector needs to be made more precise. We shall de-
scribe the compression adaptation mechanism only for connectors that
model unidirectional communication protocols.

A generic unidirectional communication protocol can be modelled by
the binary connector Uni-comm[s]\

where



228 10 An Algebra of Connectors

design glue[s] is
in i:s
out o: s
do put: true,false -» skip
[] prv prod[o] : true,false -» skip
D get: true,false —» skip

and sender[s] and receiver[s] are defined as before (see Sects. 8.1 and 9.2,
respectively). Notice that this glue leaves the way in which messages are
processed and transmitted completely unspecified.

Our aim is to install a compression/decompression service over Uni-
comm. That is, our aim is to apply an operator to Uni-comm such that, in
the resulting connector, a message sent by the sender is compressed before
it is transmitted through Uni-comm and then decompressed before it is de-
livered to the receiver. We describe such an operator by a higher-order
connector, where the compression and decompression algorithms are taken
as parameters as captured by the following algebraic specification:

spec Hcd is S"" +
sorts s,t
ops comp:t->s

decomp:s->t
size_s:s->nat
size_t:t->nat

axioms decomp(comp(x) )=x, for any x:t

size_s(comp(x)) s size_t(x), for any x:t

Sorts t and s represent the types of original and compressed messages,
respectively. The operation comp represents the process of compression of
a single message, and decomp the inverse process of decompression. The
size of the compressed message is required not to be greater than the size
of the original message. At configuration time, these data elements must
be instantiated with specific sorts and operations.

The higher-order connector itself, which we name Compression(Uni-
comm)[3:d], is defined by:

• The binary connector COMPRESSION

COMPRESSION

I ! receiver£

where the glue comp-decomp[Scd] is defined in terms of a configuration
with the following two components:



10.2 Higher-order connectors 229

design comp[Hcd] i s
in di:t
out co:s
prv v : t ; rd,msg:bool
do dree: ->msg —»v:=di || msg:=true
[j prv comp:->rd/TOsg -»co:=comp(v) || rd:=true
Q csend:rd -* rd:=false || msg:=false

design decomp[Scd] i s
in ci:s
out do:t
prv v : s ; rd,msg:bool
do crec: -•msg —»v:=ci || msg:=true
fl dec:->rdA msg-» do:=decomp(v) || rd:=true
D dsend: rd -» rd:=false || msg:=false

Design comp[Scd] models the compression of messages of type £ re-
ceived through di into messages of type s that are then transmitted
through co. Design decompfS"1] models the decompression of mes-
sages of type s received through ci into messages of type t that are then
transmitted through do.

• The connector Uni-comm[s] — the formal parameter.
• The refinement morphisms r\s:sender[s]-^comp-decomp[E!

:dJ and
r\r:receiver[s] —^comp-decomp[S

d] induced, respectively, by

rfs(o)=co, rfs(rd)=rd, rj*s(comp)=prod, rf s(csend)=send
rfr(i)=ci, rfr{crec)-rec

Because components comp and decomp do not interact, any component
refined by one of them is also refined by their composition comp-
decomp[E:d]. The corresponding induced morphisms have only to take
into account the renaming of variables and actions.



230 10 An Algebra of Connectors

In summary, Compression(Uni_comm)[S:d] has the formal parameter
Uni-comm[s], which restricts the actual connectors to which the service of
compression/decompression can be applied — it requires that any actual
parameter (connector) models a unidirectional communication protocol.
The connector COMPRESSION describes, on the one hand, that messages
sent by the actual sender are transmitted to comp, which compresses them,
and, on the other hand, that decomp decompresses the messages it receives
and delivers the result to the actual receiver. Finally, the two refinement
morphisms establish the instantiation of Uni-comm[s] with comp[s] in the
role of sender, and decomp[s] in the role of receiver. In this way, the for-
mal parameter Uni-comm[s] is the connector used to transmit compressed
messages.

It remains to explain the procedure of parameter passing, i.e. how the
service just described can be installed over a specific connector and how
the resulting connector is obtained. As an example, consider again
ASYNC. It is not difficult to realize that we may replace Uni-comm[s], as
the formal parameter of Compression(Uni-comm)[3:d], by ASYNC because
this connector does model a unidirectional communication protocol. More
concretely, ASYNC has exactly the same roles as Uni-comm and its glue -
buffer[s] - is a refinement of Uni-comm's glue.

In a more general situation, the instantiation of a higher-order connector
is established by a suitable fitting morphism from the formal to the actual
connector. Such a morphism formulates the correspondence between the
roles and glue of the formal parameter with those of the actual parameter
connector. We will present and discuss these morphisms in more detail
further below.

The construction of a new connector from the given higher-order con-
nector and the actual parameter connector is straightforward. We only
need to compose the interconnections of the buffer to sender and receiver
with the refinements r]s and r\r that define the instantiation of Uni-comm
with comp and decomp, respectively.



10.2 Higher-order connectors 231

Compre ssion(ftS¥NC)

V.

0 rd

./

prod ( send

Cf>pp

For example, channel co of comp becomes connected to the input chanel
/ of buffer because co corresponds to the chanel o of sender, which in turn
is, in ASYNC, connected to i. The resulting configuration fully defines the
connector Compression(ASYNC)[3:d+ K ]. Its roles are sender and re-
ceiver, and its glue is defined in terms of a configuration involving comp,
decomp and buffer, as shown above.

Summarising, we described the installation of a compression-
decompression service over a unidirectional communication protocol as a
parameterised entity that has connectors as parameters and delivers a con-
nector as a result of its instantiation. This is why it is called a higher-order
connector. Then we explained how the higher-order connector can be in-
stantiated with a specific connector, and finally, we showed how the re-
sulting connector is obtained.

10.2.1 Definition - Higher-Order Connectors
A higher-order connector (hoc) consists of:

• A connector pC, called the formal parameter of the hoc; its roles, glue
and connections are called, respectively, the parametric roles, the para-
metric glue and the parametric connections of the hoc.

• A connector C - its roles and glue are also called the roles and the glue
of the hoc.

• An instantiation of the formal parameter connector with the glue of the
hoc, i.e. a refinement morphism 77, from each of the parametric roles to
the glue, such that the diagram in c-DESC obtained by composing the
role morphism of each parametric connection with its instantiation con-
stitutes a well-formed configuration.



232 10 An Algebra of Connectors

10.2.2 Definition - Semantics of Higher-Order Connectors

The semantics of a higher-order connector is the connector depicted be-
low. Its roles are the roles of C and its glue is G', the design returned by
the colimit of the configuration pC+trjJ. •



10.2 Higher-order connectors 233

For simplicity, we have assumed one single parameter. However, the
definition can be extended to the case of several parameters in a straight-
forward way. Intuitively, instantiation of can be regarded as the replace-
ment of a connector (the formal parameter pC) that was instantiated to
given components of a system (the glue of the hoc) by another connector
(the actual parameter). In addition, the type of interconnection that pC en-
sures must be preserved. In other words, the design that results from the
replacement must be a refinement of the design from which we started.

Like for connectors, the instantiation of the formal parameter of a
higher-order connector is established via a fitting morphism from the for-
mal to the actual parameter. These morphisms, on the one hand, formulate
the correspondence between roles and glue of the formal parameter with
those of the actual parameter and, on the other hand, capture conditions
under which the "functionality" of the formal parameter is preserved.

In order to be able to use, in the design of a given system, a connector C
in place of a connector C", it is obvious that the two connectors must have
the same number of roles. Furthermore, C" must be able to be instantiated
with the same components as C. In other words, every restriction on the
components to which C" can be applied must also be a restriction imposed
by C. In this way, fitting morphisms must require that each of the roles of
C" is refined by the corresponding role of C.

As shown through the connector Uni-comm, connectors may be based
on glues that are not fully developed as designs (that is, may be under-
specified). Nevertheless, the concrete commitments that they make may
determine, to some extent, the type of interconnection that the connector
will ensure. The type of interconnection is clearly preserved if we simply
consider a less unspecified glue, i.e. if we refine the glue. Hence, fitting
morphisms must allow for arbitrary refinements of the glue. Having this
in mind, we arrive at the following notion of fitting morphism.

10.2.3 Definition - Fitting Morphisms

A morphism <j) from a connection <o1:desc(d1)->G1,[i1:desc(d])-*R1> to a
connection «j2:desc(d2)-*G2yl

l2:desc(d2)-*R2>, also called a fitting mor-
phism, consists of a pair <(pG:G]—>G2,<pR:R2—>R]> of refinement mor-
phisms in r-DESC s.t. the interconnection <o),iu/>+0G of R; with G2 is re-
fined by the interconnection <cr2,/U2>+0s. A fitting morphism 0 from a
connector C; to a connector C2 with the same number of connections con-
sists of a fitting morphism <p from each of C/s connections to each of C2's
connections, all with the same glue refinement 0G.



234 10 An Algebra of Connectors

If there exists a fitting morphism from a connector C; to a connector C2,
then we may replace each occurrence of C; by an occurrence of C2. Com-
positionality ensures that every coordination decision is preserved.

10.2.4 Definition - Instantiation of Higher-Order Connectors

An instantiation of a higher-order connector with formal parameter p C
consists of a connector CA (the actual parameter) together with a fitting
morphism (j):pC-*CA such that a well-formed configuration is obtained by
first composing the role morphisms of each actual connection with the cor-
responding fitting component, and then with the role instantiation.



10.2 Higher-order connectors 235

The semantics of a higher-order connector instantiation is the connector
with the same roles as C and whose glue is a design returned by the colimit
of the configuration CA+(<pi;rii). •

Higher-order connectors facilitate the separation of concerns in the de-
velopment of complex connectors and their compositional construction.
An important feature of our notion of higher-order connector is that differ-
ent kinds of functionality, modelled separately by different higher-order
connectors, can be combined, giving rise also to a higher-order connector.
In this way, it is possible to analyse the properties that such compositions
exhibit, namely to investigate whether undesirable properties emerge and
desirable properties are preserved.

The key idea for composition of hoes is the instantiation of a hoc with a
hoc — parameterised instantiation. Examples, definitions and properties
of this mechanism can be found in [79].



References

1. J. Adamek, H. Herrlich, G. Strecker (1990) Abstract and Concrete Catego-
ries. Wiley Interscience, New York

2. R. Allen, D. Garlan (1997) A formal basis for architectural connectors. ACM
TOSEM 6(3):2l 3-249

3. F. Arbab (1998) What do you mean, coordination? In: Bulletin of the Dutch
Association for Theoretical Computer Science (NVTI), March 1998

4. M. Arbib, E. Manes (1975) Arrows, Structures and Functors: The Categori-
cal Imperative. Academic Press, New York

5. M. Arrais, J. L. Fiadeiro (1996) Unifying theories in different institutions.
In: M. Haveraaen, O. Owe, O.-J. Dahl (eds) Recent Trends in Data Type
Specification. LNCS, vol 1130. Springer, Berlin Heidelberg New York, pp
81-101

6. A. Asperti, G. Longo (1991) Categories, Types and Structures: An Intro-
duction to Category Theory for the Working Computer Scientist. MIT Press,
Cambridge, MA

7. E. Astesiano, M. Broy, G. Reggio (1999) Algebraic specification of concur-
rent systems. In: [8]

8. E. Astesiano, B. Krieg-Briickner, H.-J. Kreowski (eds) (1999) IF IP WG 1.3
Book on Algebraic Foundations of System Specification. Springer, Berlin
Heidelberg New York

9. R. J. Back (1990) Refinement calculus II: parallel and reactive programs. In:
J. deBakker, W. deRoever, G. Rozenberg (eds) Stepwise Refinement of Dis-
tributed Systems. LNCS, vol 430. Springer, Berlin Heidelberg New York, pp
67-93

10. R. J. Back, K. Sere (1996) Superposition refinement of reactive systems.
Formal Aspects of Computing 8(3):324-346

11. J. P. Banatre, D. Le Metayer (1993) Programming by multiset transforma-
tion. Communications ACM 16(l):55-77

12. M. Barr, C. Wells (1990) Category Theory for Computing Science. Prentice
Hall, London

13. H. Barringer (1987) The use of temporal logic in the compositional specifi-
cation of concurrent systems. In: A. Galton (ed) Temporal Logics and Their
Applications. Academic Press, New York

14. L. Bass, P. Clements, R. Kasman (1998) Software Architecture in Practice.
Addison-Wesley, Reading, MA

15. M. Bednarczyk (1988) Categories of Asynchronous Transition Systems. PhD
Thesis, University of Sussex



238 References

16. G. Berry, G. Boudol (1992) The chemical abstract machine. Theoretical
Computer Science 96:217-248

17. R. Burstall, J. Goguen (1977) Putting theories together to make specifica-
tions. In: R. Reddy (ed) Proc. Fifth International Joint Conference on Artifi-
cial Intelligence, August 1977, Cambridge, MA, pp 1045-1058

18. R. Burstall, J. Goguen (1980) The semantics of CLEAR, a specification lan-
guage. In: Proc. Advanced Course on Abstract Software Specification.
LNCS, vol 86. Springer, Berlin Heidelberg New York, pp 292-332

19. K. Chandy, J. Misra (1988) Parallel Program Design - A Foundation.
Addison-Wesley, Reading, MA

20. J. F. Costa, A. Sernadas, C. Sernadas (1993) Data encapsulation and modu-
larity: three views of inheritance. In: A. Borzyszkowski, S. Sokolowski (eds)
Mathematical Foundations of Computer Science. LNCS, vol 711. Springer,
Berlin Heidelberg New York, pp 382-391

21. J. F. Costa, A. Sernadas, C. Sernadas, H.-D. Ehrich (1992) Object interac-
tion. In: Mathematical Foundations of Computer Science. LNCS, vol 629.
Springer, Berlin Heidelberg New York, pp 200-208

22. R. Crole (1993) Categories for Types. Cambridge University Press, Cam-
bridge

23. E. Dijkstra (1976) A Discipline of Programming. Prentice Hall, London
24. H.-D. Ehrich, J. Goguen, A. Sernadas (1991) A categorial theory of objects

as observed processes. In: J. deBakker, W. deRoever, G. Rozenberg (eds)
Foundations of Object-Oriented Languages. LNCS, vol 489. Springer, Berlin
Heidelberg New York, pp 203-228

25. H.-D. Ehrich, A. Sernadas, C. Sernadas (1989) Objects, object types and
object identity. In: H. Ehrig et al. (eds) Categorical Methods in Computer
Science with Aspects from Topology. LNCS, vol 393. Springer, Berlin Hei-
delberg New York, pp 142-156

26. H. Ehrig, M. GroBe-Rhode, U. Wolter (1998) Applications of category the-
ory to the area of algebraic specification in computer science. Applied Cate-
gorical Structures 6:1—35

27. H. Ehrig, K.-D. Kiermeier, H.-J. Kreowski, W. Kuhnel (1974) Universal
Theory of Automata: A Categorical Approach. B. G. Teubner, Stuttgart

28. H. Ehrig, B. Mahr (1985) Fundamentals of Algebraic Specification 1: Equa-
tions and Initial Semantics. EATCS Monographs on Theoretical Computer
Science, vol 6. Springer, Berlin Heidelberg New York

29. H. Ehrig, B. Mahr (1990) Fundamentals of Algebraic Specification 2: Mod-
ule Specifications and Constraints. EATCS Monographs on Theoretical
Computer Science, vol 21. Springer, Berlin Heidelberg New York

30. E. Emerson, E. Clarke (1982) Using branching time logic to synthesize syn-
chronisation skeletons. Science of Computer Programming 2:241-266

31. J. L. Fiadeiro (1996) On the emergence of properties in component-based
systems. In: M. Wirsing, M. Nivat (eds) Algebraic Methodology and Soft-
ware Technology. LNCS, vol 1101. Springer, Berlin Heidelberg New York,
pp 421-443

32. J. L. Fiadeiro, J. F. Costa (1996) Mirror, mirror in my hand: a duality be-
tween specifications and models of process behaviour. Mathematical Struc-
tures in Computer Science 6:353-373



References 239

33. J. L. Fiadeiro, J. F. Costa (1995) Institutions for behaviour specification. In:
E. Astesiano, G. Reggio, A. Tarlecki (eds) Recent Trends in Data Type
Specification. LNCS, vol 906. Springer, Berlin Heidelberg New York, pp
273-289

34. J. L. Fiadeiro, A. Lopes (1997) Semantics of architectural connectors. In:
M. Bidoit, M. Dauchet (eds) Theory and Practice of Software Development.
LNCS, vol 1214. Springer, Berlin Heidelberg New York, pp 505-519

35. J. L. Fiadeiro, A. Lopes (1999) Algebraic semantics of coordination, or what
is in a signature? In: A. Haeberer (ed) Algebraic Methodology and Software
Technology. LNCS, vol 1548. Springer, Berlin Heidelberg New York, pp
293-307

36. J. L. Fiadeiro, A. Lopes, T. Maibaum (1997) Synthesising interconnections.
In: R. Bird, L. Meertens (eds) Algorithmic Languages and Calculi. Chapman
Hall, London, pp 240-264

37. J. L. Fiadeiro, A. Lopes, M. Wermelinger (2003) A mathematical semantics
for architectural connectors. In: R. Backhouse, J. Gibbons (eds) Generic
Programming. LNCS, vol 2793. Springer, Berlin Heidelberg New York, pp
90-234

38. J. L. Fiadeiro, T. Maibaum (1991) Describing, structuring, and implement-
ing objects. In: J. deBakker, W. deRoever, G. Rozenberg (eds) Foundations
of Object-Oriented Languages. LNCS, vol 489. Springer, Berlin Heidelberg
New York, pp 274-310

39. J. L. Fiadeiro, T. Maibaum (1992) Temporal theories as modularisation units
for concurrent system specification. Formal Aspects of Computing
4(3):239-272

40. J. L. Fiadeiro, T. Maibaum (1995) Verifying for reuse: foundations of ob-
ject-oriented system verification. In: C. Hankin, I. Makie, R. Nagarajan (eds)
Theory and Formal Methods. World Scientific Publishing Company, Singa-
pore, pp 235-257

41. J. L. Fiadeiro, T. Maibaum (1995) Interconnecting formalisms: supporting
modularity, reuse and incrementality. In: G. E. Kaiser (ed) ACM SIGSOFT
Software Engineering Notes 20(4):72-80

42. J. L. Fiadeiro, T. Maibaum (1996) A mathematical toolbox for the software
architect. In: Proc. 8th Int. Workshop on Software Specification and Design.
IEEE Computer Society Press, Silver Spring, MD, pp 46-55

43. J. L. Fiadeiro, T. Maibaum (1996) Design structures for object-based sys-
tems. In: S. Goldsack, S. Kent (eds) Formal Methods and Object Technol-
ogy. Springer, Berlin Heidelberg New York, pp 183-204

44. J. L. Fiadeiro, T. Maibaum (1997) Categorical semantics of parallel program
design. Science of Computer Programming 28(2-3): 111-138

45. J. L. Fiadeiro, A. Sernadas (1988) Structuring theories on consequence. In:
D. Sannella, A. Tarlecki (eds) Recent Trends in Data Type Specification.
LNCS, vol 332. Springer, Berlin Heidelberg New York, pp 44-72

46. J. L. Fiadeiro, A. Sernadas, C. Sernadas (1988) Knowledge bases as struc-
tured theories. In: K. Nori, S. Kumar (eds) Foundations of Software Tech-
nology and Theoretical Computer Science. LNCS, vol 338. Springer, Berlin
Heidelberg New York, pp 469-486



240 References

47. P. Fingar (2000) Component-based frameworks for e-commerce. Communi-
cations ACM 43(10):61-66

48. N. Francez, I. Forman (1996) Interacting Processes. Addison-Wesley,
Reading, MA

49. P. Freyd, A. Scedrov (1990) Categories, Allegories. North-Holland, Am-
sterdam

50. D. Garlan, D. Perry (1994) Software architecture: practice, potential, and pit-
falls. In: Proc. 16th International Conference on Software Engineering.
IEEE Computer Society Press, Silver Spring, MD, pp 363-364

51. D. Gelernter, N. Carriero (1992) Coordination languages and their signifi-
cance. Communications ACM 35(2):97-107

52. J. Goguen (1971) Mathematical representation of hierarchically organised
systems. In: E. Attinger (ed) Global Systems Dynamics. Kriiger, New York,
pp 112-128

53. J. Goguen (1973) Categorical foundations for general systems theory. In:
F. Pichler, R. Trappl (eds) Advances in Cybernetics and Systems Research.
Transcripta Books, New York, pp 121-130

54. J. Goguen (1975) Objects. International Journal of General Systems
l(4):237-243

55. J. Goguen (1986) Reusing and interconnecting software components. IEEE
Computer 19(2): 16-28

56. J. Goguen (1989) Principles of parametrised programming. In: T. J. Bigger-
staff, A. J. Perlis (eds) Software Reusability. Addison-Wesley, Reading,
MA, pp 159-225

57. J. Goguen (1991) A categorical manifesto. Mathematical Structures in Com-
puter Science l(l):49-67

58. J. Goguen (1991) Sheaf semantics of concurrent interacting objects. Mathe-
matical Structures in Computer Science 1(2): 159-191

59. J. Goguen (1996) Parametrised programming and software architecture. In:
Proc. 4th International Conference on Software Reuse. IEEE Computer So-
ciety Press, Silver Spring, MD, pp 2-11

60. J. Goguen, R. Burstall (1984) Some fundamental algebraic tools for the se-
mantics of computation, part 1: comma categories, colimits, signatures and
theories. Theoretical Computer Science 31(2): 175-209

61. J. Goguen, R. Burstall (1984) Some fundamental algebraic tools for the se-
mantics of computation, part 2: signed and abstract theories. Theoretical
Computer Science 31(3):263-295

62. J. Goguen, R. Burstall (1992) Institutions: abstract model theory for specifi-
cation and programming. Journal ACM 39(1):95-146

63. J. Goguen, R. Burstall (1986) A study in the foundations of programming
methodology: specfications, institutions, charters and parchments. In: D. Pitt
et al. (eds) Category Theory and Computer Programming. LNCS, vol 240.
Springer, Berlin Heidelberg New York, pp 313-333

64. J. Goguen, S. Ginali (1978) A categorical approach to general systems the-
ory. In: G. Klir (ed) Applied General Systems Research. Plenum, New York,
pp 257-270

65. J. Goguen, J. Thatcher, E. Wagner (1978) An initial algebra approach to the
specification, correctness and implementation of abstract data types. In:



References 241

R. Yeh (ed) Current Trends in Programming Methodology IV. Prentice Hall,
London, pp 80-149

66. J. Goguen, J. Thatcher E. Wagner, J. Wright (1973) A junction between
computer science and category theory I: basic concepts and examples. Tech-
nical report, IBM Watson Research Center, Yorktown Heights NY, Report
RC 4526 (part 1) and 5908 (part 2)

67. R. Goldblatt (1987) Logics of Time and Computation. CSLI, Stanford
68. R. Goldblatt (1989) Topoi: The Categorial Analysis of Logic. North-

Holland, Amsterdam
69. C. A. R. Hoare (1985) Communicating Sequential Processes. Prentice Hall,

London
70. B. Jacobs (2001) Categorical Logic and Type Theory. Elsevier, Amsterdam
71. S. Johnson (2001) Emergence: The Connected Lives of Ants, Brains, Cities

and Software. Penguin, London
72. S. Katz (1993) A superimposition control construct for distributed systems.

ACMTOPLAS 15(2):337-35
73. W. Kent (1993) Participants and performers: a basis for classifying object

models. In: Proc. OOPSLA 1993 Workshop on Specification of Behavioral
Semantics in Object-Oriented Information Modeling

74. J. Lambek, P. Scott (1986) Introduction to Higher-Order Categorical Logic.
Cambridge University Press, Cambridge

75. F. W. Lawvere, S. H. Schanuel (1997) Conceptual Mathematics - A First
Introduction to Categories. Cambridge University Press, Cambridge

76. J. Loeckx, H.-D. Ehrich, M. Wolf (1996) Specification of Abstract Data
Types. Wiley, New York

77. A. Lopes, J. L. Fiadeiro (1999) Using explicit state to describe architectures.
In: E. Astesiano (ed) Fundamental Approaches to Software Engineering.
LNCS, vol 1577. Springer, Berlin Heidelberg New York, pp 144-160

78. A. Lopes, J. L. Fiadeiro (2004) Superposition: composition vs refinement of
non-deterministic action-based systems. Formal Aspects of Computing

79. A. Lopes, M. Wermelinger, J. L. Fiadeiro (2003) Higher-order architectural
connectors. ACM TOSEM 12(l):64-104

80. S. MacLane (1971) Categories for the Working Mathematician. Springer,
Berlin Heidelberg New York

81. J. Magee, J. Kramer, M. Sloman (1989) Constructing distributed systems in
Conic. IEEE TOSE 15(6):663-675

82. T. Maibaum, P. Veloso, M. Sadler (1985) A theory of abstract data types for
program development: bridging the gap? In: H. Ehrig et al. (eds) Formal
Methods and Software Development. LNCS, vol 186. Springer, Berlin Hei-
delberg New York, pp 214-230

83. Z. Manna, P. Wolper (1984) Synthesis of communicating processes from
temporal logic specifications. In: ACM TOPLAS 6(l):68-93

84. N. Mehta, N. Medvidovic, S. Phadke (2000) Towards a taxonomy of soft-
ware connectors. In: Proc. 22nd International Conference on Software En-
gineering. IEEE Computer Society Press, Silver Spring, MD, pp 178-187

85. J. Meseguer (1989) General logics. In: H.-D. Ebbinghaus et al. (eds) Logic
Colloquium 87. North-Holland, Amsterdam, pp 275-329



242 References

86. B. Meyer (1992) Object-Oriented Software Construction. Addison-Wesley,
Reading, MA

87. M. Moriconi, X. Qian (1994) Correctness and composition of software ar-
chitectures. ACM SIGSOFT Software Engineering Notes 19(5): 164-174

88. D. Perry, A. Wolf (1992) Foundations for the study of software architec-
tures. ACM SIGSOFT Software Engineering Notes 17(4):40-52

89. B. Pierce (1991) Basic Category Theory for Computer Scientists. MIT Press,
Cambridge, MA

90. D. Pitt, S. Abramsky, A. Poigne, D. Rydeheard (eds) (1985) Category The-
ory and Computer Programming. LNCS, vol 240. Springer, Berlin Heidel-
berg New York

91. A. Poigne (1992) Basic category theory. In: Handbook of Logic in Computer
Science, vol 1. Oxford University Press, pp 413-640

92. H. Reichel (1987) Initial Computability, Algebraic Specifications, and Par-
tial Algebras. Oxford University Press

93. G.-C. Roman, P. J. McCann, J. Y. Plun (1997) Mobile UNITY: reasoning
and specification in mobile computing. ACM TOSEM 6(3):250-282

94. R. Rosen (2000) Life Itself. Columbia University Press, New York
95. D. Sannella, A. Tarlecki (1988) Building specifications in an arbitrary insti-

tution. Information and Control 76:165-210
96. D. Sannella, S. Sokolowski, A. Tarlecki (1992) Toward formal development

of programs from algebraic specifications: parameterisation revisited. Acta
Informatica 29:689-736

97. V. Sassone, M. Nielsen, G. Winskel (1996) Models for concurrency: to-
wards a classification. Theoretical Computer Science 170:277-296

98. M. Shaw (1996) Procedure calls are the assembly language of software in-
terconnection: connectors deserve first-class status. In: D. A. Lamb (ed)
Studies of Software Design. LNCS, vol 1078. Springer, Berlin Heidelberg
New York, pp 17-32

99. M. Shaw, D. Garlan (1996) Software Architecture: Perspectives on an
Emerging Discipline. Prentice Hall, London

100. D. Smith (1993) Constructing specification morphisms. Journal of Symbolic
Computation 15 (5-6): 571-606

101. Y. Srinivas, R. Jiillig (1995) Specware™: formal support for composing
software. In: B. Moller (ed) Mathematics of Program Construction. LNCS,
vol 947. Springer, Berlin Heidelberg New York, pp 399-422

102. A. Tarlecki, R. Burstall, J. Goguen (1991) Some fundamental algebraic tools
for the semantics of computation, part 3: indexed categories. Theoretical
Computer Science 91:239-264

103. P. Veloso, T. Maibaum, M. Sadler (1985) Program development and theory
manipulation. Proc. Third Int. Workshop on Software Specification and De-
sign. IEEE Computer Society Press, Silver Spring, MD, pp 228-232

104. P. Veloso, T. Maibaum (1995) On the modularisation theorem for logical
specifications. Information Processing Letters 53:287-293

105. R. Walters (1991) Categories and Computer Science. Cambridge Computer
Science Texts

106. G. Winskel (1984) Synchronization trees. Theoretical Computer Science
34:33-82



References 243

107. G. Winskel (1985) Categories of models for concurrency. In: S. D. Brookes
et al. (eds) Seminar on Concurrency. LNCS, vol 197. Springer, Berlin Hei-
delberg New York, pp 246-267

108. G. Winskel (1987) Petri nets, algebras, morphisms and compositionality. In:
Information and Computation 72:197-238

109. G. Winskel, M. Nielsen (1995) Models for concurrency. In: S. Abramsky,
D. Gabbay, T. Maibaum (eds) Handbook of Logic in Computer Science, vol
4, Oxford University Press, pp 1-148

110. P. Wolper (1989) On the relation of programs and computations to models
of temporal logic. In: B. Banieqbal, H. Barringer, A. Pnueli (eds) Temporal
Logic in Specification. LNCS, vol 398. Springer, Berlin Heidelberg New
York, pp 75-123

111. P. Zave (1993) Feature interactions and formal specifications in telecommu-
nications. IEEE Computer XXVI(8):20-30

112. P. Zave, M.Jackson (1993) Conjunction as composition. ACM TOSEM
2(4):371-411



Index

aiC, 35, 125
aicp, 111
action (CommUnity), 179
adjoint, 151
adjunction, 151

(co)unit, 152
dual of, 152

amalgamated sum. See pushout
amnestic concrete category, 96, 99
ANCESTOR, 22
architectural connector

ASYNC, 200, 202
complete, 217
EXTENSION CORD, 209
generalised, 216
heterogeneous, 220
in CommUnity, 199
INHIBITION, 210
instantiation, 200
semantics, 199
SUBSUMPTION, 207
SYNC, 205

architectural school, 214
arrow category, 126
ASYNC, 202
AUTOM, 25
automata

category of, AVTOM, 25
reachable, 39

B
base of a concrete category, 95

cable, 183, 188
Cartesian morphism, 100
CAT, 86
category

ANCESTOR, 22
arrow, 126
AUTOM, 25
CAT, 86
c-DSGN, 186
CLASSJSPEC, 45, 85, 141
CLOS, 53
cocomplete, 77
comma category, 35, 111, 125
concrete, 95
coordinated, 172
c-SIGN, 185
definition, 20
discrete, 32
dual, 31
equivalent, 144
finitely cocomplete, 77
functor structured, 117
generated from a graph, 22
GRAPH, 21
indexed, 125
isomorphic, 87
monoids as categories, 33
of categories, 86
of partial functions, 37
of power sets and inverse

functions, 38
of processes, 118



246 Index

opposite, 31
PAR, 37
POWER, 38
preorder as a, 22
PRES, 54
PRESF0LTL, 85
PRESLTL, 49
product of, 32
REACH, 39
SET1, 21
sets as categories, 32
SET±, 33
spa(cp), 117
SP/iES, 54
subcategory, 37
THEO, 54
THEOLTL, 49

c-DSGN, 186
channel (CommUnity), 178
class inheritance hierarchies

as graphs, 16
CLASSJSPEC, 45, 85, 141
cleavage, 101
CL0S, 53
closure system, 53
coadjoint, 152
co-Cartesian morphism, 100
cocompleteness, 77
cocone, 75

base of, 75
category of, 77
colimit, 76
commutative, 76
edge of, 76
vertex of, 75

coequaliser, 72
quotients in SET, 71

cofibration, 101
colimit

concrete, 98
definition of, 76
in spa(q>), 120
of theories and presentations in

(jr-)institutions, 136

of theories and presentations in
LTL, 107

vs. (co)fibrations, 107
comma category, 35, 111, 125
CommUnity

cable, 188
compositionality, 196
configuration, 189
design, 182
design morphism, 186
program, 180
refinement morphism, 191
signature, 182
signature morphism, 184

commutative (diagram), 24
composition law, 20
compositionality

design formalisms, 213
in CommUnity, 196
of programs relative to

specifications, 112
concrete

(co)limits, 98
(co)reflective subcategories, 98
amnestic category, 96,99
category, 95
fibre-complete category, 96, 105
fibre-discrete category, 96
functor, 97
subcategories, 98

cone, 78
configuration, 189

refinement, 195
well-formed, 189

connector. See architectural
connector
higher-order, 231

construct, 95. See also concrete
category

contravariant
functor, 84
graph homomorphism, 19

coordinated category/functor, 172
coproduct, 62



Index 247

coreflection
arrow, 40
coreflective subcategory, 40
REACH as a coreflective

subcategory ofAUTOM, 39
creates

colimits, 92
c-SIGN, 185

D(g), 179
D(v), 179
design, 182

action, 206
buffer, 180
cart, 205
check-in, 205
counter, 206
extend, 209
gate, 205
inhibit, 211
monitored_cart, 207
morphism, 186
pipe, 218
printer, 190
receiver, 200
refinement morphism, 191
sender, 181,183
subsume, 207
user, 190

design formalism, 211
compositionality, 213

diagram, 23
commutative, 24
shape, 23

discrete
category, 32
lift, 170
structures (functor/concrete

category has), 170
dual

of a category, 31
of a functor, 83
of a natural transformation, 142

of an adjunction, 152

E
Eiffel class specification, 43
embedding, 87
epi (also epic and epimorphism), 30
equaliser, 73
equivalence of categories, 144
EXTENSION CORD, 209

faithful, 87
fibration, 100

cloven, 101
split, 104
theories(presentations) as, 136
universal constructions, 107
vs. indexed categories, 127

fibre
general definition, 99
of a concrete category, 96

fibre-complete concrete category,
96,105

fibred product. See pullback
fibre-discrete concrete category, 96
fitting, 233
free functor, 152
full

embedding, 87
functor, 87
subcategory, 38
vs coreflections, 41
vs. reflections, 43

functor, 83
(co)reflective, 146
(co)reflector, 88, 147
composition law, 86
contravariant, 84
coordinated, 172
creates colimits, 92
dual of, 83
embedding, 87
faithful, 87
full, 87



248 Index

has discrete structures, 170
identity, 83
inverse, 87
isomorphism, 87
lifts colimits, 92
nodes, 83
preserves colimits, 91
preserves isomorphisms, 88
reflects colimits, 92
reflects isomorphisms, 88
right/left adjoint, 151

functor structured category, 117

G
Gamma

morphisms, 173
programs, 173

graph, 21
category of, 21
definition, 15
dual, 19
homomorphism, 18
path, 20

H

higher-order connector, 231
fitting morphism, 233
instantiation, 234

horn-set, 20

in(v), 178
indexed category, 125

as a split fibration, 127
flattening of, 126

indiscrete. See discrete (dual)
INHIBITION, 210
initial object, 58

in ANCESTOR, 60
in LOGI, 58
in PAR, 58
in SET, 58
in SET±, 58
in spa(q>), 121

institution, 131
CTL*, 161
defined via a split (co)fibration,

132
generalised models, 134
initial/terminal semantics, 139
modal logics, 134
morphism, 165
the p-property, 138

interpretation between temporal
theories. See temporal theory:
morphism of

isomorphism, 27
functor, 87
inverse, 27

isomorphism-closed full
subcategory, 39

L(g), 179
left adjoint, 152
lifts

colimits, 92
vs. fibrations, 105
vs. functor structured categories,

120
limit, 78

concrete, 98
in PROC, 123
in spa(cp), 120
of theories and presentations in

(jt-)institutions, 136
of theories and presentations in

LTL, 107
vs. (co)fibrations, 107

loc(v), 179

M
mono (also monic and

monomorphism), 30
monoid, 32
morphism

composition law, 20
epi (or epic), 30



identity, 20
inverse, 27
isomorphism, 27
mono (or monic), 30
of graphs, 18
split (mono, epi), 30

• •

N
natural transformation, 142

(co)unit of an adjunction, 152
composition law, 143
counit of a reflection, 148
dual of, 142
identity, 142
natural isomorphism, 144
unit of a reflection, 147

null object, 60

0
object

initial, 58
null, 60
terminal, 59
zero, 60

out(v), 179

r
PAR, 37
path in a graph, 20
pointed sets. See SET±
POWER, 38
p-property, 138
PRES, 54, 136
presentation lemma, 51
preserves

colimits, 91
isomorphisms, 88

PRESF0LTL, 85
PRESLTL, 49
PROC, 118

universal constructions, 123
process. See PROC
product, 65

in LOGI, 65

Index 249

in PROC, 123
in SET, 65
in SET±, 65
of categories, 32, 86
of functors, 86

proof systems
as graphs, 18

prv(v), 179
pullback, 73

in PROC, 123
in SET±, 73

pushout, 68
in CLASSJSPEC, 78
in SET, 68
vs. multiple inheritance, 69
vs. the 'Join Semantics rule', 78

R
R(g), 180
REACH, 39
realisation

of configurations (diagrams), 112
of specifications by programs,

111
reduct

for temporal logic, 50
refinement

of configurations, 195
of designs (morphism), 191

reflection
(co)reflective functor, 146
arrow, 42
for a functor, 146
reflective subcategory, 43
THEO as a reflective subcategory

of PRES and SPRES, 54
reflector

for a functor, 147
for a subcategory, 88

reflects
colimits, 92
isomorphisms, 88

right adjoint, 151



250 Index

satisfaction condition
in CTL*, 162
in institutions, 131
in temporal logic (LTL), 50

SET, 21
SET±, 33
shape (of a diagram), 23
skip, 180
slice category. See comma category
spa(<p)

as a (co)fibration, 118
functor structured categories, 117
universal constructions, 120

split (mono, epi), 30
split fibration, 104
SPRES, 54, 136
strict theory presentation

in a (jr-)institution, 136
in a closure system, 54

subcategory, 37
coreflective, 40
full, 38
isomorphism-closed full, 39
reflective, 43

SUBSUMPTION, 207
sum, 62

in LOGI, 63
in PROOF, 63
in SET, 63

superposition (or superimposition),
187

SYNC, 205

semantics, 47
signatures, 46
theories, 48

temporal theory
as a concrete category, 96
category of, 49
morphism of, 49
presentation of, 49

terminal object, 59
in ANCESTOR, 60
in LOGI, 60
in PAR, 60
in PROC, 123
in SET, 59
in SET±, 60
in spa(q>), 121

THEO, 54,136
THE0LTL, 49
theory (presentation)

as a split (co)fibration, 136
in a (jt-)institution, 136
in a closure system, 54
in temporal logic, 49
universal constructions, 107, 136

transition systems
as graphs, 17

u
U(g), 179
unit

of an adjunction, 152

zero object, 60

temporal logic
presentations, 48
propositions, 47
reducts, 50

JT-institution, 130
presented by an institution, 131,

137




