24.7Critical Practices662
24.8Summary663
PROBLEMSANDPOINTSTOPONDER
663FURTHERREADINGSANDINFORMATIONSOURCES
664CHAPTER 25PROCESS AND PROJECT METRICS666
25.1Metrics in the Process and Project Domains667
25.1.1Process Metrics and Software Process Improvement667
25.1.2Project Metrics670
25.2Software Measurement671
25.2.1Size-Oriented Metrics672

25.2.2Function-Oriented Metrics673

25.2.3Reconciling LOC and FP Metrics673

25.2.4Object-Oriented Metrics675

25.2.5Use-CaseÐOriented Metrics676

25.2.6WebApp Project Metrics677
25.3Metrics for Software Quality679
25.3.1Measuring Quality680

25.3.2Defect Removal Efficiency681
25.4Integrating Metrics within the Software Process682
25.4.1Arguments for Software Metrics683

25.4.2Establishing a Baseline683

25.4.3Metrics Collection, Computation, and Evaluation684
25.5Metrics for Small Organizations684

25.6Establishing a Software Metrics Program686

25.7Summary688
PROBLEMSANDPOINTSTOPONDER
688FURTHERREADINGSANDINFORMATIONSOURCES
689CHAPTER 26ESTIMATION FOR SOFTWARE PROJECTS691
26.1Observations on Estimation692
26.2The Project Planning Process693

26.3Software Scope and Feasibility694

26.4Resources695
26.4.1Human Resources695

26.4.2Reusable Software Resources696

26.4.3Environmental Resources696
26.5Software Project Estimation697

26.6Decomposition Techniques698
26.6.1Software Sizing698

26.6.2Problem-Based Estimation699

26.6.3An Example of LOC-Based Estimation701

26.6.4An Example of FP-Based Estimation702

26.6.5Process-Based Estimation703

26.6.6An Example of Process-Based Estimation704

26.6.7Estimation with Use Cases705

26.6.8An Example of Use-CaseÐBased Estimation706

26.6.9Reconciling Estimates707
26.7Empirical Estimation Models708
26.7.1The Structure of Estimation Models709

26.7.2The COCOMO II Model709

26.7.3The Software Equation711
TABLE OF CONTENTSxxipre75977_FM.qxd  11/27/08  6:38 PM  Page xxi
26.8Estimation for Object-Oriented Projects712
26.9Specialized Estimation Techniques713
26.9.1Estimation for Agile Development713

26.9.2Estimation for WebApp Projects714
26.10The Make/Buy Decision715
26.10.1Creating a Decision Tree715

26.10.2Outsourcing717
26.11Summary718
PROBLEMSANDPOINTSTOPONDER
719FURTHERREADINGSANDINFORMATIONSOURCES
719CHAPTER 27PROJECT SCHEDULING721
27.1Basic Concepts722
27.2Project Scheduling724
27.2.1Basic Principles725

27.2.2The Relationship Between People and Effort725

27.2.3Effort Distribution727
27.3Defining a Task Set for the Software Project728
27.3.1A Task Set Example729

27.3.2Refinement of Software Engineering Actions730
27.4Defining a Task Network731

27.5Scheduling732
27.5.1Time-Line Charts732

27.5.2Tracking the Schedule734

27.5.3Tracking Progress for an OO Project735

27.5.4Scheduling for WebApp Projects736
27.6Earned Value Analysis739

27.7Summary741
PROBLEMSANDPOINTSTOPONDER
741FURTHERREADINGSANDINFORMATIONSOURCES
743CHAPTER 28RISK MANAGEMENT744
28.1Reactive versus Proactive Risk Strategies745
28.2Software Risks745

28.3Risk Identification747
28.3.1Assessing Overall Project Risk748

28.3.2Risk Components and Drivers749
28.4Risk Projection749
28.4.1Developing a Risk Table750

28.4.2Assessing Risk Impact752
28.5Risk Refinement754

28.6Risk Mitigation, Monitoring, and Management755

28.7The RMMM Plan757

28.8Summary759
PROBLEMSANDPOINTSTOPONDER
759FURTHERREADINGSANDINFORMATIONSOURCES
760CHAPTER 29MAINTENANCE AND REENGINEERING761
29.1Software Maintenance762
29.2Software Supportability764
xxiiTABLE OF CONTENTSpre75977_FM.qxd  11/27/08  6:38 PM  Page xxii
29.3Reengineering764
29.4Business Process Reengineering765
29.4.1Business Processes765

29.4.2A BPR Model766
29.5Software Reengineering768
29.5.1A Software Reengineering Process Model768

29.5.2Software Reengineering Activities770
29.6Reverse Engineering772
29.6.1Reverse Engineering to Understand Data773

29.6.2Reverse Engineering to Understand Processing774

29.6.3Reverse Engineering User Interfaces775
29.7Restructuring776
29.7.1Code Restructuring776

29.7.2Data Restructuring777
29.8Forward Engineering778
29.8.1Forward Engineering for Client-Server Architectures779

29.8.2Forward Engineering for Object-Oriented Architectures780
29.9The Economics of Reengineering780

29.10Summary781
PROBLEMSANDPOINTSTOPONDER
782FURTHERREADINGSANDINFORMATIONSOURCES
783PART FIVEADVANCED TOPICS785
CHAPTER 30SOFTWARE PROCESS IMPROVEMENT786
30.1What Is SPI?787
30.1.1Approaches to SPI787
30.1.2Maturity Models789

30.1.3Is SPI for Everyone?790
30.2The SPI Process791
30.2.1Assessment and Gap Analysis791

30.2.2Education and Training793

30.2.3Selection and Justification793

30.2.4Installation/Migration794

30.2.5Evaluation795

30.2.6Risk Management for SPI795

30.2.7Critical Success Factors796
30.3The CMMI797

30.4The People CMM801

30.5Other SPI Frameworks802

30.6SPI Return on Investment804

30.7SPI Trends805

30.8Summary806
PROBLEMSANDPOINTSTOPONDER
806FURTHERREADINGSANDINFORMATIONSOURCES
807CHAPTER 31EMERGING TRENDS IN SOFTWARE ENGINEERING808
31.1Technology Evolution809
31.2Observing Software Engineering Trends811
TABLE OF CONTENTSxxiiipre75977_FM.qxd  11/27/08  6:38 PM  Page xxiii
31.3Identifying ÒSoft TrendsÓ812
31.3.1Managing Complexity814
31.3.2Open-World Software815

31.3.3Emergent Requirements816

31.3.4The Talent Mix816

31.3.5Software Building Blocks817

31.3.6Changing Perceptions of ÒValueÓ818

31.3.7Open Source818
31.4Technology Directions819
31.4.1Process Trends819

31.4.2The Grand Challenge821

31.4.3Collaborative Development822

31.4.4Requirements Engineering824

31.4.5Model-Driven Software Development825

31.4.6Postmodern Design825

31.4.7Test-Driven Development826
31.5Tools-Related Trends827
31.5.1Tools That Respond to Soft Trends828

31.5.2Tools That Address Technology Trends830
31.6Summary830
PROBLEMSANDPOINTSTOPONDER
831FURTHERREADINGSANDINFORMATIONSOURCES
831CHAPTER 32CONCLUDING COMMENTS833
32.1The Importance of SoftwareÑRevisited834
32.2People and the Way They Build Systems834

32.3New Modes for Representing Information835

32.4The Long View837

32.5The Software EngineerÕs Responsibility838

32.6A Final Comment839
APPENDIX 1AN INTRODUCTION TO UML841
APPENDIX 2OBJECT-ORIENTED CONCEPTS863

REFERENCES871

INDEX889
xxivTABLE OF CONTENTSpre75977_FM.qxd  12/3/08  1:55 PM  Page xxiv
When computer software succeedsÑwhen it meets the needs of the people who useit, when it performs flawlessly over a long period of time, when it is easy to modify
and even easier to useÑit can and does change things for the better. But when software

failsÑwhen its users are dissatisfied, when it is error prone, when it is difficult to change

and even harder to useÑbad things can and do happen. We all want to build software that

makes things better, avoiding the bad things that lurk in the shadow of failed efforts. To

succeed, we need discipline when software is designed and built. We need an engineer-

ing approach.It has been almost three decades since the first edition of this book was written. Duringthat time, software engineering has evolved from an obscure idea practiced by a relatively

small number of zealots to a legitimate engineering discipline. Today, it is recognized asa

subject worthy of serious research, conscientious study, and tumultuous debate. Through-

out the industry, software engineer has replaced programmer as the job title of preference.

Software process models, software engineering methods, and software tools have been
adopted successfully across a broad spectrum of industry segments.Although managers and practitioners alike recognize the need for a more disciplinedapproach to software, they continue to debate the manner in which discipline is to be

applied. Many individuals and companies still develop software haphazardly, even as they

build systems to service todayÕs most advanced technologies. Many professionals and

students are unaware of modern methods. And as a result, the quality of the software that

we produce suffers, and bad things happen. In addition, debate and controversy about the

true nature of the software engineering approach continue. The status of software engi-
neering is a study in contrasts. Attitudes have changed, progress has been made, but

much remains to be done before the discipline reaches full maturity.
The seventh edition of Software Engineering: A PractitionerÕs Approach
is intended toserve as a guide to a maturing engineering discipline. Like the six editions that preceded it,
the seventh edition is intended for both students and practitioners, retaining its appeal as
a guide to the industry professional and a comprehensive introduction to the student at the
upper-level undergraduate or first-year graduate level.The seventh edition is considerably more than a simple update. The book has beenrevised and restructured to improve pedagogical flow and emphasize new and important

software engineering processes and practices. In addition, a revised and updated Òsupport
system,Ó illustrated in the figure, provides a comprehensive set of student, instructor, and

professional resources to complement the content of the book. These resources are pre-
sented as part of a website (www.mhhe.com/ pressman) specifically designed for 
SoftwareEngineering: A PractitionerÕs Approach.
The Seventh Edition.
The 32 chapters of the seventh edition have been reorganized intofive parts. This organization, which differs considerably from the sixth edition, has been
done to better compartmentalize topics and assist instructors who may not have the time
to complete the entire book in one term.PREFACE
xxvpre75977_FM.qxd  11/27/08  6:38 PM  Page xxv
Part 1, The Process,presents a variety of different views of software process, consider-ing all important process models and addressing the debate between prescriptive andagile process philosophies. Part 2, Modeling,presents analysis and design methods withan emphasis on object-oriented techniques and UML modeling. Pattern-based design and
design for Web applications are also considered. Part 3, 
Quality Management,presents theconcepts, procedures, techniques, and methods that enable a software team to assess
software quality, review software engineering work products, conduct SQA procedures,

and apply an effective testing strategy and tactics. In addition, formal modeling and veri-
fication methods are also considered. Part 4, Managing Software Projects,presents topicsthat are relevant to those who plan, manage, and control a software development project.

Part 5, Advanced Topics,
considers software process improvement and software engineer-
ing trends. Continuing in the tradition of past editions, a series of sidebars is used through-
out the book to present the trials and tribulations of a (fictional) software team and to
provide supplementary materials about methods and tools that are relevant to chapter

topics. Two new appendices provide brief tutorials on UML and object-oriented thinking

for those who may be unfamiliar with these important topics.xxviPREFACEWeb resources
 (1,000+ links)

Reference library

 (500+ links)

Checklists
Work product templates

Tiny tools
Adaptable process model

Umbrella activities task set
Comprehensive case studyStudentresourcesInstructorresourcesSolvedproblemsInstructormanualTest
bankIndustry
commentDistancelearning
Professional
resourcesPower-
pointslidesPracticequizzesOtherSEtopicsSEPA
7/eChapterstudyguidesSupportSystem for
SEPA, 7/e
pre75977_FM.qxd  11/27/08  6:39 PM  Page xxvi
The five-part organization of the seventh edition enables an instructor to ÒclusterÓtopics based on available time and student need. An entire one-term course can be builtaround one or more of the five parts. A software engineering survey course would select
chapters from all five parts. A software engineering course that emphasizes analysis and
design would select topics from Parts 1 and 2. A testing-oriented software engineering
course would select topics from Parts 1 and 3, with a brief foray into Part 2. A Òmanage-
ment courseÓ would stress Parts 1 and 4. By organizing the seventh edition in this way,

Ihave attempted to provide an instructor with a number of teaching options. In every case,

the content of the seventh edition is complemented by the following elements of the SEPA,

7/e Support System.Student Resources.
A wide variety of student resources includes an extensive onlinelearning center encompassing chapter-by-chapter study guides, practice quizzes, prob-
lem solutions, and a variety of Web-based resources including software engineering

checklists, an evolving collection of Òtiny tools,Ó a comprehensive case study, work prod-

uct templates, and many other resources. In addition, over 1000 categorized 
Web Refer-

encesallow a student to explore software engineering in greater detail and a ReferenceLibrary
with links to over 500 downloadable papers provides an in-depth source of
advanced software engineering information.Instructor Resources.
A broad array of instructor resources has been developed tosupplement the seventh edition. These include a complete online InstructorÕs Guide
(alsodownloadable) and supplementary teaching materials including a complete set of over

700 PowerPoint Slidesthat may be used for lectures, and a test bank. Of course, all
resources available for students (e.g., tiny tools, the Web References, the downloadable

Reference Library) and professionals are also available.The InstructorÕs Guide for Software Engineering: A PractitionerÕs Approach
presents sug-gestions for conducting various types of software engineering courses, recommendations
for a variety of software projects to be conducted in conjunction with a course, solutions

to selected problems, and a number of useful teaching aids.Professional Resources.
A collection of resources available to industry practitioners(aswell as students and faculty) includes outlines and samples of software engineering

documents and other work products, a useful set of software engineering checklists, a
catalog of software engineering (CASE) tools, a comprehensive collection of Web-based

resources, and an Òadaptable process modelÓ that provides a detailed task breakdown of

the software engineering process.When coupled with its online support system, the seventh edition of Software Engi-neering: A PractitionerÕs Approach,
provides flexibility and depth of content that cannot be
achieved by a textbook alone.Acknowledgments.
My work on the seven editions of Software Engineering: A Practi-
tionerÕs Approach
has been the longest continuing technical project of my life. Even whenthe writing stops, information extracted from the technical literature continues to be
assimilated and organized, and criticism and suggestions from readers worldwide is eval-
uated and cataloged. For this reason, my thanks to the many authors of books, papers,
and articles (in both hardcopy and electronic media) who have provided me with addi-

tional insight, ideas, and commentary over nearly 30 years.
Special thanks go to Tim Lethbridge of the University of Ottawa, who assisted me in
the development of UML and OCL examples and developed the case study that accompa-
nies this book, and Dale Skrien of Colby College, who developed the UML tutorial in
PREFACExxviipre75977_FM.qxd  11/27/08  6:39 PM  Page xxvii
The content of the seventh edition of Software Engineering: A PractitionerÕs Approach
has been shaped by industry professionals, university professors, and students who haveused earlier editions of the book and have taken the time to communicate their sugges-
tions, criticisms, and ideas. My thanks to each of you. In addition, my personal thanks go
to our many industry clients worldwide, who certainly have taught me as much or more

than I could ever teach them.As the editions of this book have evolved, my sons, Mathew and Michael, have grownfrom boys to men. Their maturity, character, and success in the real world have been an

inspiration to me. Nothing has filled me with more pride. And finally, to Barbara, my love

and thanks for tolerating the many, many hours in the office and encouraging still another

edition of Òthe book.ÓRoger S. PressmanxxviiiPREFACEOsman Balci,Virginia Tech University
Max Fomitchev,
Penn State UniversityJerry (Zeyu) Gao,San Jose State University
Guillermo Garcia,Universidad Alfonso X MadridPablo Gervas,Universidad Complutense de MadridSK Jain,National Institute of Technology Hamirpur
Saeed Monemi,Cal Poly PomonaAhmed Salem,California State UniversityVasudeva Varma,
IIIT Hyderabad
Appendix 1. Their assistance and comments were invaluable. Special thanks also go to

Bruce Maxim of the University of MichiganÐDearborn, who assisted me in developing
much of the pedagogical website content that accompanies this book. Finally, I wish to

thank the reviewers of the seventh edition:Their in-depth comments and thoughtful

criticism have been invaluable.
pre75977_FM.qxd  11/27/08  6:39 PM  Page xxviii
He had the classic look of a senior executive for a major software companyÑmid-40s, slightly graying at the temples, trim and athletic, with

eyes that penetrated the listener as he spoke. But what he said shocked me.ÒSoftware is dead.Ó
I blinked with surprise and then smiled. ÒYouÕre joking, right? The world is
driven by software and your company has profited handsomely because of it. It
isnÕt dead! ItÕs alive and growing.Ó
He shook his head emphatically. ÒNo, itÕs dead . . . at least as we once knew it.Ó

I leaned forward. ÒGo on.Ó
He spoke while tapping the table for emphasis. ÒThe old-school view ofsoftwareÑyou buy it, you own it, and itÕs your job to manage itÑthatÕs coming to

an end. Today, with Web 2.0 and pervasive computing coming on strong, weÕre

going to be seeing a completely different generation of software. ItÕll be delivered
via the Internet and will look exactly like itÕs residing on each userÕs computing

device . . . but itÕll reside on a far-away server.Ó
1CHAPTER1SOFTWAREAND
SOFTWARE
ENGINEERINGWhat is it?Computer software isthe product that software profession-als build and then support over the

long term. It encompasses programs
that execute within a computer of any size and
architecture, content that is presented as the
computer programs execute, and descriptive
information in both hard copy and virtual forms

that encompass virtually any electronic media.

Software engineering encompasses a process, a
collection of methods (practice) and an array
oftools that allow professionals to build high-

quality computer software.Who does it?Software engineers build and sup-port software, and virtually everyone in the indus-

trialized world uses it either directly or indirectly.
Why is it important?
Software is important
because it affects nearly every aspect of our

lives and has become pervasive in our com-

merce, our culture, and our everyday activities.
QUICKLOOKSoftware engineering is important because it

enables us to build complex systems in a timely
manner and with high quality.
What are the steps?You build computer soft-
ware like you build any successful product, by
applying an agile, adaptable process that leads
to a high-quality result that meets the needs of
the people who will use the product. You apply

a software engineering approach.What is the work product?
From the point ofview of a software engineer, the work product is

the set of programs, content (data), and other
work products that are computer software. But
from the userÕs viewpoint, the work product is

the resultant information that somehow makes

the userÕs world better.
How do I ensure that IÕve done it right?Read the remainder of this book, select those
ideas that are applicable to the software that
you build, and apply them to your work.KEYCONCEPTSapplication domains . . . . . . . .7
characteristics ofsoftware . . . . . . .4
framework activities . . . . . .15
legacy software . .9

practice . . . . . . .17

principles . . . . . .19

softwareengineering . . . .12
software myths . .21
softwareprocess . .14

umbrella activities . . . . . .16
WebApps . . . . . .10
pre75977_ch01.qxd  11/27/08  3:11 PM  Page 1
I had to agree. ÒSo, your life will be much simpler. You guys wonÕt have to worry
about five different versions of the same App in use across tens of thousands ofusers.ÓHe smiled. ÒAbsolutely. Only the most current version residing on our servers.
When we make a change or a correction, we supply updated functionality and
content to every user. Everyone has it instantly!Ó
I grimaced. ÒBut if you make a mistake, everyone has that instantly as well.Ó

He chuckled. ÒTrue, thatÕs why weÕre redoubling our efforts to do even better
software engineering. Problem is, we have to do it ÔfastÕ because the market has
accelerated in every application area.ÓI leaned back and put my hands behind my head. ÒYou know what they say, . . .
you can have it fast, you can have it right, or you can have it cheap. Pick two!ÓÒIÕll take it fast and right,Ó he said as he began to get up.
I stood as well. ÒThen you really do need software engineering.Ó
ÒI know that,Ó he said as he began to move away. ÒThe problem is, weÕve got to
convince still another generation of techies that itÕs true!Ó
Is software reallydead?If it was, you wouldnÕt be reading this book!
Computer software continues to be the single most important technology on theworld stage. And itÕs also a prime example of the law of unintended consequences.
Fifty years ago no one could have predicted that software would become an indis-
pensable technology for business, science, and engineering; that software would

enable the creation of new technologies (e.g., genetic engineering and nanotech-
nology), the extension of existing technologies (e.g., telecommunications), and the
radical change in older technologies (e.g., the printing industry); that software would
be the driving force behind the personal computer revolution; that shrink-wrapped
software products would be purchased by consumers in neighborhood malls; that
software would slowly evolve from a product to a service as Òon-demandÓ software
companies deliver just-in-time functionality via a Web browser; that a software

company would become larger and more influential than almost all industrial-era
companies; that a vast software-driven network called the Internet would evolve and
change everything from library research to consumer shopping to political discourse
to the dating habits of young (and not so young) adults.No one could foresee that software would become embedded in systems of allkinds: transportation, medical, telecommunications, military, industrial, entertain-

ment, office machines, . . . the list is almost endless. And if you believe the law of

unintended consequences, there are many effects that we cannot yet predict.No one could predict that millions of computer programs would have to be cor-rected, adapted, and enhanced as time passed. The burden of performing these
ÒmaintenanceÓ activities would absorb more people and more resources than all
work applied to the creation of new software.As softwareÕs importance has grown, the software community has continually
attempted to develop technologies that will make it easier, faster, and less expensive
2CHAPTER 1SOFTWARE AND SOFTWARE ENGINEERINGuote:ÒIdeas andtechnological
discoveries are the
driving engines of
economic growth.ÓWall Street
Journalpre75977_ch01.qxd  11/27/08  3:11 PM  Page 2
to build and maintain high-quality computer programs. Some of these technologiesare targeted at a specific application domain (e.g., website design and implementa-
tion); others focus on a technology domain (e.g., object-oriented systems or aspect-
oriented programming); and still others are broad-based (e.g., operating systems
such as Linux). However, we have yet to develop a software technology that does it

all, and the likelihood of one arising in the future is small. And yet, people bet their
jobs, their comforts, their safety, their entertainment, their decisions, and their very

lives on computer software. It better be right.This book presents a framework that can be used by those who build computersoftwareÑpeople who must get it right. The framework encompasses a process, a
set of methods, and an array of tools that we call software engineering.1.1T
HENATUREOF
SOFTWARE
Today, software takes on a dual role. It is a product, and at the same time, the vehi-

cle for delivering a product. As a product, it delivers the computing potential em-
bodied by computer hardware or more broadly, by a network of computers that are

accessible by local hardware. Whether it resides within a mobile phone or operates
inside a mainframe computer, software is an information transformerÑproducing,

managing, acquiring, modifying, displaying, or transmitting information that can be
as simple as a single bit or as complex as a multimedia presentation derived from
data acquired from dozens of independent sources. As the vehicle used to deliver the
product, software acts as the basis for the control of the computer (operating sys-
tems), the communication of information (networks), and the creation and control
of other programs (software tools and environments).
Software delivers the most important product of our timeÑinformation.It trans-forms personal data (e.g., an individualÕs financial transactions) so that the data can

be more useful in a local context; it manages business information to enhance com-
petitiveness; it provides a gateway to worldwide information networks (e.g., the

Internet), and provides the means for acquiring information in all of its forms.
The role of computer software has undergone significant change over the last
half-century. Dramatic improvements in hardware performance, profound changes

in computing architectures, vast increases in memory and storage capacity, and a

wide variety of exotic input and output options, have all precipitated more sophisti-
cated and complex computer-based systems. Sophistication and complexity can
produce dazzling results when a system succeeds, but they can also pose huge
problems for those who must build complex systems.Today, a huge software industry has become a dominant factor in the economies
of the industrialized world. Teams of software specialists, each focusing on one part

of the technology required to deliver a complex application, have replaced the lone
programmer of an earlier era. And yet, the questions that were asked of the loneCHAPTER 1SOFTWARE AND SOFTWARE ENGINEERING3Software is both aproduct and a vehicle
that delivers a product.uote:ÒSoftware is a
place where
dreams are planted
and nightmares
harvested, an

abstract, mystical
swamp where
terrible demons
compete with
magical panaceas,
a world of
werewolves and
silver bullets.ÓBradJ.Cox
pre75977_ch01.qxd  11/27/08  3:11 PM  Page 3
programmer are the same questions that are asked when modern computer-basedsystems are built:14CHAPTER 1SOFTWARE AND SOFTWARE ENGINEERING1In an excellent book of essays on the software business, Tom DeMarco [DeM95] argues the coun-
terpoint. He states: ÒInstead of asking why software costs so much, we need to begin asking ÔWhathave we done to make it possible for todayÕs software to cost so little?Õ The answer to that ques-
tion will help us continue the extraordinary level of achievement that has always distinguished the
software industry.Ó¥Why does it take so long to get software finished?¥Why are development costs so high?¥Why canÕt we find all errors before we give the software to our customers?
¥Why do we spend so much time and effort maintaining existing programs?¥Why do we continue to have difficulty in measuring progress as software is
being developed and maintained?These, and many other questions, are a manifestation of the concern about
software and the manner in which it is developedÑa concern that has lead to the
adoption of software engineering practice.1.1.1Defining Software
Today, most professionals and many members of the public at large feel that they

understand software. But do they?A textbook description of software might take the following form: Software is: (1) instructions (computer programs) that when executed provide desired
features, function, and performance; (2) data structures that enable the programs to ad-
equately manipulate information, and (3) descriptive information in both hard copy and
virtual forms that describes the operation and use of the programs.There is no question that other more complete definitions could be offered.But a more formal definition probably wonÕt measurably improve your under-
standing. To accomplish that, itÕs important to examine the characteristics of soft-
warethat make it different from other things that human beings build. Software is a

logical rather than a physical system element. Therefore, software has characteris-

tics that are considerably different than those of hardware:1.Software is developed or engineered; it is not manufactured in the classical sense.
Although some similarities exist between software development and hard-ware manufacturing, the two activities are fundamentally different. In both
activities, high quality is achieved through good design, but the manufactur-
ing phase for hardware can introduce quality problems that are nonexistentHow shouldwe definesoftware??Software isengineered, not
manufactured.pre75977_ch01.qxd  11/27/08  3:11 PM  Page 4
(or easily corrected) for software. Both activities are dependent on people,
but the relationship between people applied and work accomplished is
entirely different (see Chapter 24). Both activities require the construction of
a Òproduct,Ó but the approaches are different. Software costs are concen-
trated in engineering. This means that software projects cannot be managed
as if they were manufacturing projects.2.Software doesnÕt Òwear out.Ó
Figure 1.1depicts failure rate as a function of time for hardware. The rela-
tionship, often called the Òbathtub curve,Ó indicates that hardware exhibits

relatively high failure rates early in its life (these failures are often attributa-
ble to design or manufacturing defects); defects are corrected and the failure
rate drops to a steady-state level (hopefully, quite low) for some period of

time. As time passes, however, the failure rate rises again as hardware com-

ponents suffer from the cumulative effects of dust, vibration, abuse, tempera-

ture extremes, and many other environmental maladies. Stated simply, the

hardware begins to wear out.Software is not susceptible to the environmental maladies that cause
hardware to wear out. In theory, therefore, the failure rate curve for software

should take the form of the Òidealized curveÓ shown in Figure 1.2. Undiscov-

ered defects will cause high failure rates early in the life of a program.
However, these are corrected and the curve flattens as shown. The idealized

curve is a gross oversimplification of actual failure models for software.

However, the implication is clearÑsoftware doesnÕt wear out. But it does

deteriorate!
CHAPTER 1SOFTWARE AND SOFTWARE ENGINEERING5ﬁWear outﬂ
ﬁInfantmortalityﬂ
TimeFailure rateFIGURE1.1Failure curve

for hardware
Software doesnÕt wearout, but it does
deteriorate.If you want to reduce
software deterioration,
youÕll have to do
better software design
(Chapters 8 to 13).pre75977_ch01.qxd  11/27/08  3:11 PM  Page 5
This seeming contradiction can best be explained by considering theactual curve in Figure 1.2. During its life,
2 software will undergo change. Aschanges are made, it is likely that errors will be introduced, causing the
failure rate curve to spike as shown in the Òactual curveÓ (Figure 1.2). Before
the curve can return to the original steady-state failure rate, another change

is requested, causing the curve to spike again. Slowly, the minimum failure

rate level begins to riseÑthe software is deteriorating due to change.Another aspect of wear illustrates the difference between hardware andsoftware. When a hardware component wears out, it is replaced by a spare
part. There are no software spare parts. Every software failure indicates an
error in design or in the process through which design was translated into
machine executable code. Therefore, the software maintenance tasks that

accommodate requests for change involve considerably more complexity

than hardware maintenance.3.Although the industry is moving toward component-based construction, most

software continues to be custom built.
As an engineering discipline evolves, a collection of standard design compo-nents is created. Standard screws and off-the-shelf integrated circuits are
only two of thousands of standard components that are used by mechanical
and electrical engineers as they design new systems. The reusable compo-
nents have been created so that the engineer can concentrate on the truly
innovative elements of a design, that is, the parts of the design that represent
6CHAPTER 1SOFTWARE AND SOFTWARE ENGINEERINGIncreased failurerate due to sideeffectsTimeFailure rateChangeActual curve
Idealized curve
FIGURE1.2Failure curves
for software
2In fact, from the moment that development begins and long before the first version is delivered,
changes may be requested by a variety of different stakeholders.Software engineeringmethods strive to
reduce the magnitude
of the spikes and the
slope of the actual
curve in Figure 1.2.
uote:ÒIdeas are the
building blocks of
ideas.ÓJasonZebehazy
pre75977_ch01.qxd  11/27/08  3:11 PM  Page 6
something new. In the hardware world, component reuse is a natural part of
the engineering process. In the software world, it is something that has only
begun to be achieved on a broad scale.A software component should be designed and implemented so that it canbe reused in many different programs. Modern reusable components encap-
sulate both data and the processing that is applied to the data, enabling the
software engineer to create new applications from reusable parts.3 For exam-ple, todayÕs interactive user interfaces are built with reusable components

that enable the creation of graphics windows, pull-down menus, and a wide
variety of interaction mechanisms. The data structures and processing detail
required to build the interface are contained within a library of reusable
components for interface construction.1.1.2Software Application Domains
Today, seven broad categories of computer software present continuing challenges

for software engineers:System software
Ña collection of programs written to service other pro-
grams. Some system software (e.g., compilers, editors, and file management
utilities) processes complex, but determinate,
4 information structures. Othersystems applications (e.g., operating system components, drivers, networking
software, telecommunications processors) process largely indeterminate data.

In either case, the systems software area is characterized by heavy interaction

with computer hardware; heavy usage by multiple users; concurrent opera-
tion that requires scheduling, resource sharing, and sophisticated process
management; complex data structures; and multiple external interfaces.Application software
Ñstand-alone programs that solve a specific businessneed. Applications in this area process business or technical data in a waythat facilitates business operations or management/technical decision mak-
ing. In addition to conventional data processing applications, application

software is used to control business functions in real time (e.g., point-of-sale
transaction processing, real-time manufacturing process control).Engineering/scientific software
Ñhas been characterized by ÒnumbercrunchingÓ algorithms. Applications range from astronomy to volcanology,
from automotive stress analysis to space shuttle orbital dynamics, and
frommolecular biology to automated manufacturing. However, modern

applications within the engineering/scientific area are moving away from
CHAPTER 1SOFTWARE AND SOFTWARE ENGINEERING73Component-based development is discussed in Chapter 10.
4Software is 
determinateif the order and timing of inputs, processing, and outputs is predictable.Software is indeterminateif the order and timing of inputs, processing, and outputs cannot bepredicted in advance.WebRef
One of the mostcomprehensive libraries
of shareware/ freeware
can be found at
shareware.cnet
.compre75977_ch01.qxd  11/27/08  3:11 PM  Page 7
conventional numerical algorithms. Computer-aided design, system simula-
tion, and other interactive applications have begun to take on real-time and
even system software characteristics.Embedded software
Ñresides within a product or system and is used toimplement and control features and functions for the end user and for the
system itself. Embedded software can perform limited and esoteric functions
(e.g., key pad control for a microwave oven) or provide significant function

and control capability (e.g., digital functions in an automobile such as fuel
control, dashboard displays, and braking systems).Product-line software
Ñdesigned to provide a specific capability for use by
many different customers. Product-line software can focus on a limited andesoteric marketplace (e.g., inventory control products) or address mass

consumer markets (e.g., word processing, spreadsheets, computer graphics,
multimedia, entertainment, database management, and personal and
business financial applications).Web applications
Ñcalled ÒWebApps,Ó this network-centric software cate-
gory spans a wide array of applications. In their simplest form, WebApps can
be little more than a set of linked hypertext files that present information
using text and limited graphics. However, as Web 2.0 emerges, WebApps are

evolving into sophisticated computing environments that not only provide

stand-alone features, computing functions, and content to the end user, but

also are integrated with corporate databases and business applications.Artificial intelligence software
Ñmakes use of nonnumerical algorithms tosolve complex problems that are not amenable to computation or straightfor-ward analysis. Applications within this area include robotics, expert systems,
pattern recognition (image and voice), artificial neural networks, theorem
proving, and game playing.
Millions of software engineers worldwide are hard at work on software projects in
one or more of these categories. In some cases, new systems are being built, but in
many others, existing applications are being corrected, adapted, and enhanced. It is
not uncommon for a young software engineer to work a program that is older than
she is! Past generations of software people have left a legacy in each of the cate-
gories I have discussed. Hopefully, the legacy to be left behind by this generation will

ease the burden of future software engineers. And yet, new challenges (Chapter 31)
have appeared on the horizon:Open-world computing
Ñthe rapid growth of wireless networking maysoon lead to true pervasive, distributed computing. The challenge for soft-

ware engineers will be to develop systems and application software that will
allow mobile devices, personal computers, and enterprise systems to com-
municate across vast networks.8CHAPTER 1SOFTWARE AND SOFTWARE ENGINEERINGuote:ÒThere is nocomputer that has
common sense.ÓMarvinMinsky
pre75977_ch01.qxd  11/27/08  3:11 PM  Page 8
Netsourcing
Ñthe World Wide Web is rapidly becoming a computing engine
as well as a content provider. The challenge for software engineers is to

architect simple (e.g., personal financial planning) and sophisticated applica-
tions that provide a benefit to targeted end-user markets worldwide.
Open source
Ña growing trend that results in distribution of source code forsystems applications (e.g., operating systems, database, and development en-

vironments) so that many people can contribute to its development. The chal-
lenge for software engineers is to build source code that is self-descriptive,

but more importantly, to develop techniques that will enable both customers

and developers to know what changes have been made and how those
changes manifest themselves within the software.Each of these new challenges will undoubtedly obey the law of unintended conse-

quences and have effects (for businesspeople, software engineers, and end users) that

cannot be predicted today. However, software engineers can prepare by instantiating

a process that is agile and adaptable enough to accommodate dramatic changes in
technology and to business rules that are sure to come over the next decade.
1.1.3Legacy Software
Hundreds of thousands of computer programs fall into one of the seven broad
application domains discussed in the preceding subsection. Some of these are state-
of-the-art softwareÑjust released to individuals, industry, and government. But

other programs are older, in some cases 
much
older.
These older programsÑoften referred to as legacy softwareÑhave been the focusof continuous attention and concern since the 1960s. Dayani-Fard and his
colleagues [Day99] describe legacy software in the following way:Legacy software systems . . . were developed decades ago and have been continuallymodified to meet changes in business requirements and computing platforms. The pro-
liferation of such systems is causing headaches for large organizations who find them
costly to maintain and risky to evolve.Liu and his colleagues [Liu98] extend this description by noting that Òmany legacysystems remain supportive to core business functions and are ÔindispensableÕ to
the business.Ó Hence, legacy software is characterized by longevity and business

criticality.
Unfortunately, there is sometimes one additional characteristic that is present
inlegacy softwareÑ
poor quality.5 Legacy systems sometimes have inextensibledesigns, convoluted code, poor or nonexistent documentation, test cases and results
CHAPTER 1SOFTWARE AND SOFTWARE ENGINEERING9uote:ÒYou canÕt always
predict, but you
can always
prepare.ÓAnonymous5In this case, quality is judged based on modern software engineering thinkingÑa somewhat unfair
criterion since some modern software engineering concepts and principles may not have been wellunderstood at the time that the legacy software was developed.What do I doif I encountera legacy system
that exhibits poor
quality??pre75977_ch01.qxd  11/27/08  3:11 PM  Page 9
that were never archived, a poorly managed change historyÑthe list can be quitelong. And yet, these systems support Òcore business functions and are indispensable
to the business.Ó What to do?The only reasonable answer may be: Do nothing,at least until the legacy systemmust undergo some significant change. If the legacy software meets the needs of its
users and runs reliably, it isnÕt broken and does not need to be fixed. However, as

time passes, legacy systems often evolve for one or more of the following reasons:¥The software must be adapted to meet the needs of new computing environ-

ments or technology.
¥The software must be enhanced to implement new business requirements.¥The software must be extended to make it interoperable with other more
modern systems or databases.¥The software must be re-architected to make it viable within a network
environment.
When these modes of evolution occur, a legacy system must be reengineered (Chap-

ter 29) so that it remains viable into the future. The goal of modern software engi-
neering is to Òdevise methodologies that are founded on the notion of evolutionÓ;
that is, the notion that software systems continually change, new software systems

are built from the old ones, and...all must interoperate and cooperate with each

otherÓ [Day99].1.2T
HEUNIQUENATUREOF
WEBAPPSIn the early days of the World Wide Web (circa 1990 to 1995), 
websitesconsisted oflittle more than a set of linked hypertext files that presented information using text
and limited graphics. As time passed, the augmentation of HTML by development
tools (e.g., XML, Java) enabled Web engineers to provide computing capability along

with informational content.Web-based systems and applications
6(I refer to these col-lectively as WebApps
) were born. Today, WebApps have evolved into sophisticated

computing tools that not only provide stand-alone function to the end user, but also

have been integrated with corporate databases and business applications.As noted in Section 1.1.2, WebApps are one of a number of distinct software cat-
egories. And yet, it can be argued that WebApps are different. Powell [Pow98] sug-

gests that Web-based systems and applications Òinvolve a mixture between print

publishing and software development, between marketing and computing, between10CHAPTER 1SOFTWARE AND SOFTWARE ENGINEERINGWhat typesof changesare made to
legacy systems??Every software

engineer must
recognize that change
is natural. DonÕt try to

fight it.uote:ÒBy the time wesee any sort of
stabilization, the
Web will have

turned into
something
completely
different.ÓLouisMonier
6In the context of this book, the term 
Web application(WebApp) encompasses everything from a sim-ple Web page that might help a consumer compute an automobile lease payment to a comprehen-sive website that provides complete travel services for businesspeople and vacationers. Included
within this category are complete websites, specialized functionality within websites, and infor-
mation processing applications that reside on the Internet or on an Intranet or Extranet.pre75977_ch01.qxd  11/27/08  3:11 PM  Page 10
internal communications and external relations, and between art and technology.Ó
The following attributes are encountered in the vast majority of WebApps.
Network intensiveness.
A WebApp resides on a network and must serve
the needs of a diverse community of clients. The network may enable world-
wide access and communication (i.e., the Internet) or more limited access
and communication (e.g., a corporate Intranet).Concurrency.
A large number of users may access the WebApp at one
time. In many cases, the patterns of usage among end users will vary greatly.

Unpredictable load.
The number of users of the WebApp may vary by
orders of magnitude from day to day. One hundred users may show up on
Monday; 10,000 may use the system on Thursday.
Performance.
If a WebApp user must wait too long (for access, for server-
side processing, for client-side formatting and display), he or she may decideto go elsewhere.Availability.
Although expectation of 100 percent availability is unreason-able, users of popular WebApps often demand access on a 24/7/365 basis.
Users in Australia or Asia might demand access during times when tradi-

tional domestic software applications in North America might be taken 
off-line for maintenance.Data driven.
The primary function of many WebApps is to use hypermedia
to present text, graphics, audio, and video content to the end user. In addi-
tion, WebApps are commonly used to access information that exists on data-

bases that are not an integral part of the Web-based environment (e.g.,

e-commerce or financial applications).Content sensitive.
The quality and aesthetic nature of content remains animportant determinant of the quality of a WebApp.

Continuous evolution.
Unlike conventional application software that
evolves over a series of planned, chronologically spaced releases, Web appli-
cations evolve continuously. It is not unusual for some WebApps (specifically,

their content) to be updated on a minute-by-minute schedule or for content
to be independently computed for each request.Immediacy.
Although immediacyÑthe compelling need to get software tomarket quicklyÑis a characteristic of many application domains, WebApps
often exhibit a time-to-market that can be a matter of a few days or weeks.7Security.
Because WebApps are available via network access, it is difficult,
if not impossible, to limit the population of end users who may access the

application. In order to protect sensitive content and provide secure modes
CHAPTER 1SOFTWARE AND SOFTWARE ENGINEERING117With modern tools, sophisticated Web pages can be produced in only a few hours.
Whatcharacteristicdifferentiates
WebApps from

other software??pre75977_ch01.qxd  11/27/08  3:11 PM  Page 11
of data transmission, strong security measures must be implementedthroughout the infrastructure that supports a WebApp and within the appli-

cation itself.Aesthetics.An undeniable part of the appeal of a WebApp is its look and
feel. When an application has been designed to market or sell products orideas, aesthetics may have as much to do with success as technical design.It can be argued that other application categories discussed in Section 1.1.2 canexhibit some of the attributes noted. However, WebApps almost always exhibit all of

them.1.3S
OFTWARE
ENGINEERINGIn order to build software that is ready to meet the challenges of the twenty-first
century, you must recognize a few simple realities:
¥Software has become deeply embedded in virtually every aspect of our lives,
and as a consequence, the number of people who have an interest in the

features and functions provided by a specific application
8has grown dramati-cally. When a new application or embedded system is to be built, many

voices must be heard. And it sometimes seems that each of them has a
slightly different idea of what software features and functions should be
delivered. It follows that a concerted effort should be made to understand the
problem before a software solution is developed.¥The information technology requirements demanded by individuals, busi-
nesses, and governments grow increasing complex with each passing year.

Large teams of people now create computer programs that were once built
by a single individual. Sophisticated software that was once implemented in
a predictable, self-contained, computing environment is now embedded

inside everything from consumer electronics to medical devices to weapons
systems. The complexity of these new computer-based systems and products
demands careful attention to the interactions of all system elements. It
follows that design becomes a pivotal activity.
¥Individuals, businesses, and governments increasingly rely on software for

strategic and tactical decision making as well as day-to-day operations and
control. If the software fails, people and major enterprises can experience
anything from minor inconvenience to catastrophic failures. 
It follows that
software should exhibit high quality.
¥As the perceived value of a specific application grows, the likelihood is that
its user base and longevity will also grow. As its user base and time-in-use
12CHAPTER 1SOFTWARE AND SOFTWARE ENGINEERING8I will call these people ÒstakeholdersÓ later in this book.
Understand theproblem before you
build a solution.Design is a pivotalsoftware engineering
activity.
Both quality andmaintainability are an
outgrowth of good
design.pre75977_ch01.qxd  11/27/08  3:11 PM  Page 12
increase, demands for adaptation and enhancement will also grow. 
It followsthat software should be maintainable.These simple realities lead to one conclusion:software in all of its forms and across allof its application domains should be engineered.And that leads us to the topic of thisbookÑsoftware engineering.Although hundreds of authors have developed personal definitions of softwareengineering, a definition proposed by Fritz Bauer [Nau69] at the seminal conference
on the subject still serves as a basis for discussion:[Software engineering is] the establishment and use of sound engineering principles in or-der to obtain economically software that is reliable and works efficiently on real machines.You will be tempted to add to this definition.
9It says little about the technical as-pects of software quality; it does not directly address the need for customer satisfac-tion or timely product delivery; it omits mention of the importance of measurement
and metrics; it does not state the importance of an effective process. And yet, BauerÕs

definition provides us with a baseline. What are the Òsound engineering principlesÓ

that can be applied to computer software development? How do we ÒeconomicallyÓ
build software so that it is ÒreliableÓ? What is required to create computer programs
that work ÒefficientlyÓ on not one but many different Òreal machinesÓ? These are the
questions that continue to challenge software engineers.The IEEE [IEE93a] has developed a more comprehensive definition when it states:Software Engineering: (1) The application of a systematic, disciplined, quantifiable approach
to the development, operation, and maintenance of software; that is, the application of
engineering to software. (2) The study of approaches as in (1).And yet, a Òsystematic, disciplined, and quantifiableÓ approach applied by one
software team may be burdensome to another. We need discipline, but we also need
adaptability and agility.
Software engineering is a layered technology. Referring to Figure 1.3, any engineer-
ing approach (including software engineering) must rest on an organizational com-
mitment to quality. Total quality management, Six Sigma, and similar philosophies
10foster a continuous process improvement culture, and it is this culture that ultimately

leads to the development of increasingly more effective approaches to software engi-
neering. The bedrock that supports software engineering is a quality focus.The foundation for software engineering is the processlayer. The software engi-
neering process is the glue that holds the technology layers together and enables
rational and timely development of computer software. Process defines a frameworkCHAPTER 1SOFTWARE AND SOFTWARE ENGINEERING13uote:ÒMore than adiscipline or a body
of knowledge,
engineering is a
verb, an action
word, a way of
approaching a
problem.ÓScottWhitmir
How do wedefinesoftware
engineering??9For numerous additional definitions of 
software engineering,see www.answers.com/topic/software-engineering#wp-_note-13.10Quality management and related approaches are discussed in Chapter 14 and throughout Part 3 of
this book.Software engineeringencompasses a
process, methods for
managing and
engineering software,
and tools.pre75977_ch01.qxd  11/27/08  3:11 PM  Page 13
that must be established for effective delivery of software engineering technology.
The software process forms the basis for management control of software projects
and establishes the context in which technical methods are applied, work products
(models, documents, data, reports, forms, etc.) are produced, milestones are estab-
lished, quality is ensured, and change is properly managed.Software engineering methodsprovide the technical how-toÕs for building soft-
ware. Methods encompass a broad array of tasks that include communication,
requirements analysis, design modeling, program construction, testing, and sup-
port. Software engineering methods rely on a set of basic principles that govern

each area of the technology and include modeling activities and other descriptive
techniques.Software engineering toolsprovide automated or semiautomated support for the
process and the methods. When tools are integrated so that information created by
one tool can be used by another, a system for the support of software development,

called computer-aided software engineering
, is established.1.4T
HESOFTWARE
PROCESSAprocessis a collection of activities, actions, and tasks that are performed whensome work product is to be created. Anactivitystrives to achieve a broad objective(e.g., communication with stakeholders) and is applied regardless of the application
domain, size of the project, complexity of the effort, or degree of rigor with which
software engineering is to be applied. An action(e.g., architectural design) encom-passes a set of tasks that produce a major work product (e.g., an architectural design
model). A taskfocuses on a small, but well-defined objective (e.g., conducting a unittest) that produces a tangible outcome.In the context of software engineering, a process is nota rigid prescription for howto build computer software. Rather, it is an adaptable approach that enables the peo-

ple doing the work (the software team) to pick and choose the appropriate set of
work actions and tasks. The intent is always to deliver software in a timely manner
and with sufficient quality to satisfy those who have sponsored its creation and those
who will use it.14CHAPTER 1SOFTWARE AND SOFTWARE ENGINEERINGTools
A quality focusMethodsProcessFIGURE1.3Software
engineering
layersWebRef
CrossTalk
is a journal
that providespragmatic
information on

process, methods,
and tools. It can be
found at:
www.stsc

.hill.af.mil.What are the
elements ofa software
process??uote:ÒA process defines
who is doing what
whenand howtoreach a certain
goal.ÓIvarJacobson,
GradyBooch,

andJames

Rumbaughpre75977_ch01.qxd  11/27/08  3:11 PM  Page 14
A process framework
establishes the foundation for a complete software engi-neering process by identifying a small number of framework activities
that are appli-cable to all software projects, regardless of their size or complexity. In addition, the
process framework encompasses a set of umbrella activitiesthat are applicableacross the entire software process. A generic process framework for software engi-
neering encompasses five activities:Communication.Before any technical work can commence, it is critically
important to communicate and collaborate with the customer (and other
stakeholders11The intent is to understand stakeholdersÕ objectives for theproject and to gather requirements that help define software features and
functions.Planning.Any complicated journey can be simplified if a map exists. Asoftware project is a complicated journey, and the planning activity creates a
ÒmapÓ that helps guide the team as it makes the journey. The mapÑcalled a

software project planÑdefines the software engineering work by describingthe technical tasks to be conducted, the risks that are likely, the resources

that will be required, the work products to be produced, and a work
schedule.Modeling.Whether youÕre a landscaper, a bridge builder, an aeronautical
engineer, a carpenter, or an architect, you work with models every day. You
create a ÒsketchÓ of the thing so that youÕll understand the big pictureÑwhat
it will look like architecturally, how the constituent parts fit together, and

many other characteristics. If required, you refine the sketch into greater and
greater detail in an effort to better understand the problem and how youÕre
going to solve it. A software engineer does the same thing by creating mod-
els to better understand software requirements and the design that will
achieve those requirements.Construction.This activity combines code generation (either manual orautomated) and the testing that is required to uncover errors in the code.

Deployment.
The software (as a complete entity or as a partially com-pleted increment) is delivered to the customer who evaluates the deliveredproduct and provides feedback based on the evaluation.
These five generic framework activities can be used during the development of small,
simple programs, the creation of large Web applications, and for the engineering of

large, complex computer-based systems. The details of the software process will be

quite different in each case, but the framework activities remain the same.
CHAPTER 1SOFTWARE AND SOFTWARE ENGINEERING1511A 
stakeholderis anyone who has a stake in the successful outcome of the projectÑbusiness man-agers, end users, software engineers, support people, etc. Rob Thomsett jokes that, Òa stakeholderis a person holding a large and sharp stake. . . . If you donÕt look after your stakeholders, you know
where the stake will end up.Ó). What are thefive genericprocess
framework
activities??uote:ÒEinstein argued
that there must be
a simplified
explanation of
nature, because
God is not
capricious or
arbitrary. No such

faith comforts the
software engineer.

Much of the
complexity that he
must master is
arbitrary

complexity.Ó
FredBrooks
pre75977_ch01.qxd  11/27/08  3:11 PM  Page 15
For many software projects, framework activities are applied iteratively as aproject progresses. That is, communication, planning, modeling, construction,and deployment
are applied repeatedly through a number of project iterations.Each project iteration produces a software incrementthat provides stakeholders with
a subset of overall software features and functionality. As each increment is pro-

duced, the software becomes more and more complete.Software engineering process framework activities are complemented by a num-ber of umbrella activities.In general, umbrella activities are applied throughout a soft-ware project and help a software team manage and control progress, quality,

change, and risk. Typical umbrella activities include:
Software project tracking and control
Ñallows the software team toassess progress against the project plan and take any necessary action to
maintain the schedule.Risk managementÑassesses risks that may affect the outcome of theproject or the quality of the product.Software quality assurance
Ñdefines and conducts the activities requiredto ensure software quality.
Technical reviews
Ñassesses software engineering work products in an effortto uncover and remove errors before they are propagated to the next activity.
Measurement
Ñdefines and collects process, project, and product measuresthat assist the team in delivering software that meets stakeholdersÕ needs;
can be used in conjunction with all other framework and umbrella activities.Software configuration management
Ñmanages the effects of changethroughout the software process.
Reusability managementÑdefines criteria for work product reuse(including software components) and establishes mechanisms to achievereusable components.Work product preparation and production
Ñencompasses the activitiesrequired to create work products such as models, documents, logs, forms,and lists.Each of these umbrella activities is discussed in detail later in this book.Earlier in this section, I noted that the software engineering process is not a rigidprescription that must be followed dogmatically by a software team. Rather, it should

be agile and adaptable (to the problem, to the project, to the team, and to the organi-
zational culture). Therefore, a process adopted for one project might be significantly

different than a process adopted for another project. Among the differences are¥Overall flow of activities, actions, and tasks and the interdependencies
among them¥Degree to which actions and tasks are defined within each framework activity¥Degree to which work products are identified and required16CHAPTER 1SOFTWARE AND SOFTWARE ENGINEERINGUmbrella activitiesoccur throughout the
software process and
focus primarily on
project management,
tracking, and control.Software processadaptation is essential
for project success.How do
processmodels differ from
one another??pre75977_ch01.qxd  11/27/08  3:11 PM  Page 16
¥Manner in which quality assurance activities are applied¥Manner in which project tracking and control activities are applied¥Overall degree of detail and rigor with which the process is described¥Degree to which the customer and other stakeholders are involved with the
project¥Level of autonomy given to the software team¥Degree to which team organization and roles are prescribedIn Part 1 of this book, IÕll examine software process in considerable detail. Prescriptive
process models(Chapter 2) stress detailed definition, identification, and applicationof process activities and tasks. Their intent is to improve system quality, make proj-

ects more manageable, make delivery dates and costs more predictable, and guide

teams of software engineers as they perform the work required to build a system.
Unfortunately, there have been times when these objectives were not achieved. If

prescriptive models are applied dogmatically and without adaptation, they can in-
crease the level of bureaucracy associated with building computer-based systems
and inadvertently create difficulty for all stakeholders.Agile process models(Chapter 3) emphasize project ÒagilityÓ and follow a set of prin-ciples that lead to a more informal (but, proponents argue, no less effective) approach

to software process. These process models are generally characterized as ÒagileÓ be-
cause they emphasize maneuverability and adaptability. They are appropriate for many

types of projects and are particularly useful when Web applications are engineered.
1.5S
OFTWARE
ENGINEERINGPRACTICEIn Section 1.4, I introduced a generic software process model composed of a set of
activities that establish a framework for software engineering practice. Generic
framework activitiesÑcommunication, planning, modeling, construction,anddeployment
Ñand umbrella activities establish a skeleton architecture for software
engineering work. But how does the practice of software engineering fit in? In the
sections that follow, youÕll gain a basic understanding of the generic concepts and

principles that apply to framework activities.121.5.1The Essence of Practice
In a classic book, How to Solve It,written before modern computers existed, GeorgePolya [Pol45] outlined the essence of problem solving, and consequently, the essence

of software engineering practice:1.Understand the problem(communication and analysis).2.Plan a solution(modeling and software design).CHAPTER 1SOFTWARE AND SOFTWARE ENGINEERING17Whatcharacterizesan ÒagileÓ
process??uote:ÒI feel a recipe is
only a theme which
an intelligent cook
can play each time
with a variation.ÓMadameBenoit
WebRef
A variety of thought-provoking quotes on
the practice of software
engineering can be
found at www
.literateprogramming
.comYou might argue that
PolyaÕs approach is

simply common sense.
True. But itÕs amazing

how often common
sense is uncommon in
the software world.12You should revisit relevant sections within this chapter as specific software engineering methods
and umbrella activities are discussed later in this book.pre75977_ch01.qxd  11/27/08  3:11 PM  Page 17
3.Carry out the plan(code generation).4.Examine the result for accuracy
(testing and quality assurance).In the context of software engineering, these commonsense steps lead to a series ofessential questions [adapted from Pol45]:Understand the problem.
ItÕs sometimes difficult to admit, but most of us suffer
from hubris when weÕre presented with a problem. We listen for a few seconds and
then think, Oh yeah, I understand, letÕs get on with solving this thing.
Unfortunately,
understanding isnÕt always that easy. ItÕs worth spending a little time answering a

few simple questions:¥Who has a stake in the solution to the problem?
That is, who are the stake-holders?¥What are the unknowns?What data, functions, and features are required toproperly solve the problem?¥Can the problem be compartmentalized?Is it possible to represent smallerproblems that may be easier to understand?¥Can the problem be represented graphically?
Can an analysis model be created?Plan the solution.Now you understand the problem (or so you think) and youcanÕt wait to begin coding. Before you do, slow down just a bit and do a little

design:¥Have you seen similar problems before?Are there patterns that are recogniz-able in a potential solution? Is there existing software that implements the
data, functions, and features that are required?¥Has a similar problem been solved?If so, are elements of the solutionreusable?¥Can subproblems be defined?If so, are solutions readily apparent for thesubproblems?¥Can you represent a solution in a manner that leads to effective implementation?
Can a design model be created?Carry out the plan.The design youÕve created serves as a road map for thesystem you want to build. There may be unexpected detours, and itÕs possible that

youÕll discover an even better route as you go, but the ÒplanÓ will allow you to

proceed without getting lost.¥Does the solution conform to the plan?Is source code traceable to the designmodel?¥Is each component part of the solution provably correct?
Have the design andcode been reviewed, or better, have correctness proofs been applied to the

algorithm?18CHAPTER 1SOFTWARE AND SOFTWARE ENGINEERINGuote:ÒThere is a grain ofdiscovery in the

solution of any
problem.ÓGeorgePolya
pre75977_ch01.qxd  11/27/08  3:11 PM  Page 18
Examine the result.
You canÕt be sure that your solution is perfect, but you can be
sure that youÕve designed a sufficient number of tests to uncover as many errors as
possible.¥Is it possible to test each component part of the solution?
Has a reasonabletesting strategy been implemented?¥Does the solution produce results that conform to the data, functions, and
features that are required?Has the software been validated against allstakeholder requirements?It shouldnÕt surprise you that much of this approach is common sense. In fact, itÕs

reasonable to state that a commonsense approach to software engineering will
never lead you astray.
1.5.2General Principles
The dictionary defines the word principleas Òan important underlying law or as-
sumption required in a system of thought.Ó Throughout this book IÕll discuss princi-
ples at many different levels of abstraction. Some focus on software engineering as a
whole, others consider a specific generic framework activity (e.g., 
communication),and still others focus on software engineering actions (e.g., architectural design) or
technical tasks (e.g., write a usage scenario). Regardless of their level of focus, prin-
ciples help you establish a mind-set for solid software engineering practice. They are
important for that reason.David Hooker [Hoo96] has proposed seven principles that focus on softwareengineering practice as a whole. They are reproduced in the following
paragraphs:13The First Principle: The Reason It All ExistsA software system exists for one reason: to provide value to its users
. Alldecisions should be made with this in mind. Before specifying a system require-
ment, before noting a piece of system functionality, before determining the hard-

ware platforms or development processes, ask yourself questions such as: ÒDoes
this add real value to the system?Ó If the answer is Òno,Ó donÕt do it. All other

principles support this one.The Second Principle: KISS (Keep It Simple, Stupid!)
Software design is not a haphazard process. There are many factors to considerin any design effort. All design should be as simple as possible, but no simpler. Thisfacilitates having a more easily understood and easily maintained system. This isCHAPTER 1SOFTWARE AND SOFTWARE ENGINEERING1913Reproduced with permission of the author [Hoo96]. Hooker defines patterns for these principles at
http://c2.com/cgi/wiki?SevenPrinciplesOfSoftwareDevelopment.
Before beginning asoftware project, be
sure the software has
a business purpose and
that users perceive
value in it.pre75977_ch01.qxd  11/27/08  3:11 PM  Page 19
not to say that features, even internal features, should be discarded in the name ofsimplicity. Indeed, the more elegant designs are usually the more simple ones. Sim-

ple also does not mean Òquick and dirty.Ó In fact, it often takes a lot of thought and

work over multiple iterations tosimplify. The payoff is software that is more main-

tainable and less error-prone.The Third Principle: 
Maintain the Vision
A clear vision is essential to the success of a software project. Without one, a
project almost unfailingly ends up being Òof two [or more] mindsÓ about itself.
Without conceptual integrity, a system threatens to become a patchwork of in-

compatible designs, held together by the wrong kind of screws. . . . Compromis-
ing the architectural vision of a software system weakens and will eventually
break even the well-designed systems. Having an empowered architect who can
hold the vision and enforce compliance helps ensure a very successful software
project.The Fourth Principle: 
What You Produce, Others Will Consume
Seldom is an industrial-strength software system constructed and used in avacuum. In some way or other, someone else will use, maintain, document, or

otherwise depend on being able to understand your system. So, always specify,

design, and implement knowing someone else will have to understand what you are
doing. The audience for any product of software development is potentially large.
Specify with an eye to the users. Design, keeping the implementers in mind. Code
with concern for those that must maintain and extend the system. Someone may
have to debug the code you write, and that makes them a user of your code.

Making their job easier adds value to the system.The Fifth Principle: Be Open to the Future
A system with a long lifetime has more value. In todayÕs computing environ-
ments, where specifications change on a momentÕs notice and hardware platforms

are obsolete just a few months old, software lifetimes are typically measured in
months instead of years. However, true Òindustrial-strengthÓ software systems

must endure far longer. To do this successfully, these systems must be ready to

adapt to these and other changes. Systems that do this successfully are those that
have been designed this way from the start. Never design yourself into a corner.
Always ask Òwhat if,Ó and prepare for all possible answers by creating systems that
solve the general problem, not just the specific one.14This could very possibly leadto the reuse of an entire system.20CHAPTER 1SOFTWARE AND SOFTWARE ENGINEERINGIf software has value,it will change over its
useful life. For that
reason, software must
be built to be
maintainable.14This advice can be dangerous if it is taken to extremes. Designing for the Ògeneral problemÓ some-
times requires performance compromises and can make specific solutions inefficient.uote:ÒThere is a certain
majesty in
simplicity which is
far above all the
quaintness of wit.ÓAlexanderPope
(1688Ð1744)pre75977_ch01.qxd  11/27/08  3:11 PM  Page 20
The Sixth Principle: Plan Ahead for ReuseReuse saves time and effort.15Achieving a high level of reuse is arguably thehardest goal to accomplish in developing a software system. The reuse of code anddesigns has been proclaimed as a major benefit of using object-oriented technolo-
gies. However, the return on this investment is not automatic. To leverage the

reuse possibilities that object-oriented [or conventional] programming provides

requires forethought and planning. There are many techniques to realize reuse
atevery level of the system development process. . . . 
Planning ahead for reusereduces the cost and increases the value of both the reusable components and the
systems into which they are incorporated
.The Seventh principle: 
Think!This last principle is probably the most overlooked. 
Placing clear, complete
thought before action almost always produces better results. When you think aboutsomething, you are more likely to do it right. You also gain knowledge about how

to do it right again. If you do think about something and still do it wrong, it be-
comes a valuable experience. A side effect of thinking is learning to recognize
when you donÕt know something, at which point you can research the answer.

When clear thought has gone into a system, value comes out. Applying the first six
principles requires intense thought, for which the potential rewards are enormous.If every software engineer and every software team simply followed HookerÕs seven
principles, many of the difficulties we experience in building complex computer-
based systems would be eliminated.1.6S
OFTWARE
MYTHSSoftware mythsÑerroneous beliefs about software and the process that is used to
build itÑcan be traced to the earliest days of computing. Myths have a number of
attributes that make them insidious. For instance, they appear to be reasonable

statements of fact (sometimes containing elements of truth), they have an intuitive
feel, and they are often promulgated by experienced practitioners who Òknow the
score.ÓToday, most knowledgeable software engineering professionals recognize myths
for what they areÑmisleading attitudes that have caused serious problems for
managers and practitioners alike. However, old attitudes and habits are difficult to

modify, and remnants of software myths remain.
CHAPTER 1SOFTWARE AND SOFTWARE ENGINEERING2115Although this is true for those who reuse the software on future projects, reuse can be expensive
for those who must design and build reusable components. Studies indicate that designing andbuilding reusable components can cost between 25 to 200 percent more than targeted software. In
some cases, the cost differential cannot be justified.uote:ÒIn the absence ofmeaningful
standards, a new
industry like

software comes to
depend instead on
folklore.ÓTomDeMarco
pre75977_ch01.qxd  11/27/08  3:11 PM  Page 21
Management myths.Managers with software responsibility, like managers in
most disciplines, are often under pressure to maintain budgets, keep schedules fromslipping, and improve quality. Like a drowning person who grasps at a straw, a soft-

ware manager often grasps at belief in a software myth, if that belief will lessen the
pressure (even temporarily).Myth:We already have a book thatÕs full of standards and procedures for

building software. WonÕt that provide my people with everything they

need to know?Reality:The book of standards may very well exist, but is it used? Are soft-
ware practitioners aware of its existence? Does it reflect modern

software engineering practice? Is it complete? Is it adaptable? Is it
streamlined to improve time-to-delivery while still maintaining a

focus on quality? In many cases, the answer to all of these questions
is Òno.ÓMyth:If we get behind schedule, we can add more programmers and catch up

(sometimes called the ÒMongolian hordeÓ concept).
Reality:Software development is not a mechanistic process like manufactur-
ing. In the words of Brooks [Bro95]: Òadding people to a late soft-
ware project makes it later.Ó At first, this statement may seem

counterintuitive. However, as new people are added, people who

were working must spend time educating the newcomers, thereby
reducing the amount of time spent on productive development
effort. People can be added but only in a planned and well-
coordinated manner.
Myth:If I decide to outsource the software project to a third party, I can just

relax and let that firm build it.Reality:If an organization does not understand how to manage and control
software projects internally, it will invariably struggle when it out-

sources software projects.Customer myths.A customer who requests computer software may be a personat the next desk, a technical group down the hall, the marketing/sales department,
or an outside company that has requested software under contract. In many cases,
the customer believes myths about software because software managers and prac-
titioners do little to correct misinformation. Myths lead to false expectations (by the
customer) and, ultimately, dissatisfaction with the developer.
Myth:A general statement of objectives is sufficient to begin writing

programsÑwe can fill in the details later.
Reality:Although a comprehensive and stable statement of requirements is
not always possible, an ambiguous Òstatement of objectivesÓ is a

recipe for disaster. Unambiguous requirements (usually derived
22CHAPTER 1SOFTWARE AND SOFTWARE ENGINEERINGWebRef
The Software ProjectManagers Network at
www.spmn.com

can help you dispel
these and other myths.Work very hard to
understand what you
have to do before you
start. You may not be

able to develop every

detail, but the more
you know, the less risk

you take.pre75977_ch01.qxd  11/27/08  3:11 PM  Page 22
iteratively) are developed only through effective and continuouscommunication between customer and developer.
Myth:Software requirements continually change, but change can be easily

accommodated because software is flexible.Reality:It is true that software requirements change, but the impact of

change varies with the time at which it is introduced. When require-
ments changes are requested early (before design or code has been
started), the cost impact is relatively small.16However, as time
passes, the cost impact grows rapidlyÑresources have been commit-
ted, a design framework has been established, and change can
causeupheaval that requires additional resources and major design

modification.PractitionerÕs myths.
Myths that are still believed by software practitioners havebeen fostered by over 50 years of programming culture. During the early days, pro-

gramming was viewed as an art form. Old ways and attitudes die hard.Myth:Once we write the program and get it to work, our job is done.
Reality:Someone once said that Òthe sooner you begin Ôwriting code,Õ the

longer itÕll take you to get done.Ó Industry data indicate that between
60 and 80 percent of all effort expended on software will be ex-
pended after it is delivered to the customer for the first time.Myth:Until I get the program ÒrunningÓ I have no way of assessing its quality.
Reality:One of the most effective software quality assurance mechanisms
can be applied from the inception of a projectÑthe technical review.
Software reviews (described in Chapter 15) are a Òquality filterÓ that
have been found to be more effective than testing for finding certain
classes of software defects.Myth:The only deliverable work product for a successful project is the working

program.
Reality:A working program is only one part of a software configuration that
includes many elements. A variety of work products (e.g., models,
documents, plans) provide a foundation for successful engineering

and, more important, guidance for software support.Myth:Software engineering will make us create voluminous and unnecessary

documentation and will invariably slow us down.
Reality:Software engineering is not about creating documents. It is about
creating a quality product. Better quality leads to reduced rework.
And reduced rework results in faster delivery times.CHAPTER 1SOFTWARE AND SOFTWARE ENGINEERING23Whenever you think,we donÕt have time for
software engineering,
ask yourself, ÒWill we

have time to do it over
again?Ó16Many software engineers have adopted an ÒagileÓ approach that accommodates change incre-
mentally, thereby controlling its impact and cost. Agile methods are discussed in Chapter 3.pre75977_ch01.qxd  11/27/08  3:11 PM  Page 23
Many software professionals recognize the fallacy of the myths just described.Regrettably, habitual attitudes and methods foster poor management and technical
practices, even when reality dictates a better approach. Recognition of software
realities is the first step toward formulation of practical solutions for software
engineering.1.7H
OWITALLSTARTS
Every software project is precipitated by some business needÑthe need to correct a
defect in an existing application; the need to adapt a Òlegacy systemÓ to a changing
business environment; the need to extend the functions and features of an existing

application; or the need to create a new product, service, or system.
At the beginning of a software project, the business need is often expressedinformally as part of a simple conversation. The conversation presented in the

sidebar is typical.24CHAPTER 1SOFTWARE AND SOFTWARE ENGINEERINGHow a Project Starts
The scene:Meeting room at CPICorporation, a (fictional) company that makes consumerproducts for home and commercial use.The players:Mal Golden, senior manager, product
development; Lisa Perez, marketing manager; LeeWarren, engineering manager; Joe Camalleri, executive

VP, business development
The conversation:
Joe:Okay, Lee, whatÕs this I hear about your folks
developing a what? A generic universal wireless box?
Lee:ItÕs pretty cool . . . about the size of a small
matchbook . . . we can attach it to sensors of all kinds, adigital camera, just about anything. Using the 802.11g
wireless protocol. It allows us to access the deviceÕs output

without wires. We think itÕll lead to a whole new

generation of products.Joe:You agree, Mal?
Mal:I do. In fact, with sales as flat as theyÕve been thisyear, we need something new. Lisa and I have been
doing a little market research, and we think weÕve got a
line of products that could be big.Joe:How big . . . bottom line big?Mal(avoiding a direct commitment):
Tell him
about our idea, Lisa.Lisa:ItÕs a whole new generation of what we call Òhome
management products.Ó We call Õem 
SafeHome.They usethe new wireless interface, provide homeowners or small-
business people with a system thatÕs controlled by their

PCÑhome security, home surveillance, appliance and

device controlÑyou know, turn down the home air

conditioner while youÕre driving home, that sort of thing.
Lee (jumping in):EngineeringÕs done a technical
feasibility study of this idea, Joe. ItÕs doable at low
manufacturing cost. Most hardware is off-the-shelf.

Software is an issue, but itÕs nothing that we canÕt do.
Joe:Interesting. Now, I asked about the bottom line.
Mal:PCs have penetrated over 70 percent of allhouseholds in the USA. If we could price this thing right, it could be a killer-App. Nobody else has our wireless
box . . . itÕs proprietary. WeÕll have a 2-year jump on

thecompetition. Revenue? Maybe as much as 30 to 

40 million dollars in the second year.
Joe (smiling):LetÕs take this to the next level. IÕm
interested.SAFEHOME1717The 
SafeHomeproject will be used throughout this book to illustrate the inner workings of a projectteam as it builds a software product. The company, the project, and the people are purely fictitious,but the situations and problems are real.pre75977_ch01.qxd  11/27/08  3:11 PM  Page 24
CHAPTER 1SOFTWARE AND SOFTWARE ENGINEERING25With the exception of a passing reference, software was hardly mentioned as part
of the conversation. And yet, software will make or break the 
SafeHomeproduct line.The engineering effort will succeed only if SafeHomesoftware succeeds. The marketwill accept the product only if the software embedded within it properly meets thecustomerÕs (as yet unstated) needs. WeÕll follow the progression of 
SafeHome
software engineering in many of the chapters that follow.
1.8S
UMMARYSoftware is the key element in the evolution of computer-based systems and
products and one of the most important technologies on the world stage. Over the
past 50 years, software has evolved from a specialized problem solving and infor-
mation analysis tool to an industry in itself. Yet we still have trouble developing high-

quality software on time and within budget.SoftwareÑprograms, data, and descriptive informationÑaddresses a wide arrayof technology and application areas. Legacy software continues to present special
challenges to those who must maintain it.Web-based systems and applications have evolved from simple collections of in-
formation content to sophisticated systems that present complex functionality and
multimedia content. Although these WebApps have unique features and require-

ments, they are software nonetheless.Software engineering encompasses process, methods, and tools that enablecomplex computer-based systems to be built in a timely manner with quality. The

software process incorporates five framework activitiesÑcommunication, planning,
modeling, construction, and deploymentÑthat are applicable to all software proj-
ects. Software engineering practice is a problem solving activity that follows a set of
core principles.A wide array of software myths continue to lead managers and practitionersastray, even as our collective knowledge of software and the technologies required

to build it grows. As you learn more about software engineering, youÕll begin to un-
derstand why these myths should be debunked whenever they are encountered.PROBLEMSAND
POINTSTO
PONDER1.1.Provide at least five additional examples of how the law of unintended consequences
applies to computer software.1.2.Provide a number of examples (both positive and negative) that indicate the impact of
software on our society.

1.3.Develop your own answers to the five questions asked at the beginning of Section 1.1.Discuss them with your fellow students.
1.4.Many modern applications change frequentlyÑbefore they are presented to the end userand then after the first version has been put into use. Suggest a few ways to build software tostop deterioration due to change.pre75977_ch01.qxd  11/27/08  3:11 PM  Page 25
1.5.Consider the seven software categories presented in Section 1.1.2. Do you think that thesame approach to software engineering can be applied for each? Explain your answer.
1.6.Figure 1.3places the three software engineering layers on top of a layer entitled Òa quality
focus.Ó This implies an organizational quality program such as total quality management.Do abit of research and develop an outline of the key tenets of a total quality management program.
1.7.Is software engineering applicable when WebApps are built? If so, how might it be modi-
fied to accommodate the unique characteristics of WebApps?

1.8.As software becomes more pervasive, risks to the public (due to faulty programs) become
an increasingly significant concern. Develop a doomsday but realistic scenario in which the fail-ure of a computer program could do great harm (either economic or human).1.9.Describe a process framework in your own words. When we say that framework activitiesare applicable to all projects, does this mean that the same work tasks are applied for allprojects, regardless of size and complexity? Explain.1.10.Umbrella activities occur throughout the software process. Do you think they are appliedevenly across the process, or are some concentrated in one or more framework activities.
1.11.Add two additional myths to the list presented in Section 1.6. Also state the reality thataccompanies the myth.FURTHER
READINGSAND
INFORMATION
SOURCES18There are literally thousands of books written about computer software. The vast majoritydiscuss programming languages or software applications, but a few discuss software itself.
Pressman and Herron (Software Shock,
Dorset House, 1991) presented an early discussion
(directed at the layperson) of software and the way professionals build it. NegroponteÕs best-

selling book (Being Digital, Alfred A. Knopf, Inc., 1995) provides a view of computing and its

overall impact in the twenty-first century. DeMarco (
Why Does Software Cost So Much?
DorsetHouse, 1995) has produced a collection of amusing and insightful essays on software and the

process through which it is developed.Minasi (The Software Conspiracy: Why Software Companies Put out Faulty Products, How They
Can Hurt You, and What You Can Do,
McGraw-Hill, 2000) argues that the Òmodern scourgeÓ of
software bugs can be eliminated and suggests ways to accomplish this. Compaine (DigitalDivide: Facing a Crisis or Creating a Myth,MIT Press, 2001) argues that the ÒdivideÓ between thosewho have access to information resources (e.g., the Web) and those that do not is narrowing as

we move into the first decade of this century. Books by Greenfield (
Everyware: The Dawning Age
of Ubiquitous Computing,New Riders Publishing, 2006) and Loke (Context-Aware Pervasive
Systems: Architectures for a New Breed of Applications,
Auerbach, 2006) introduce the concept of
Òopen-worldÓ software and predict a wireless environment in which software must adapt to

requirements that emerge in real time.The current state of the software engineering and the software process can best be deter-mined from publications such as IEEE Software, IEEE Computer,CrossTalk,
and IEEE Transactions
on Software Engineering.Industry periodicals such as Application Development Trends
andCutter26CHAPTER 1SOFTWARE AND SOFTWARE ENGINEERING18The 
Further Reading and Information Sourcessection presented at the conclusion of each chapterpresents a brief overview of print sources that can help to expand your understanding of the majortopics presented in the chapter. I have created a comprehensive website to support Software
Engineering: A PractitionerÕs Approach atwww.mhhe.com/compsci/pressman. Among themany topics addressed within the website are chapter-by-chapter software engineering resources
to Web-based information that can complement the material presented in each chapter. An
Amazon.com link to every book noted in this section is contained within these resources.pre75977_ch01.qxd  11/27/08  3:11 PM  Page 26
IT Journal
often contain articles on software engineering topics. The discipline is ÒsummarizedÓevery year in the Proceeding of the International Conference on Software Engineering,sponsoredby the IEEE and ACM, and is discussed in depth in journals such as 
ACM Transactions on Software
Engineering and Methodology, ACM Software Engineering Notes,
andAnnals of Software Engineer-ing.Tens of thousands of websites are dedicated to software engineering and the software
process.Many books addressing the software process and software engineering have been publishedin recent years. Some present an overview of the entire process, while others delve into a few

important topics to the exclusion of others. Among the more popular offerings (in addition to
this book!) areAbran, A., and J. Moore, 
SWEBOK: Guide to the Software Engineering Body of Knowledge,IEEE,2002.Andersson, E., et al., Software Engineering for Internet Applications,The MIT Press, 2006.Christensen, M., and R. Thayer, 
A Project ManagerÕs Guide to Software Engineering Best Prac-
tices,IEEE-CS Press (Wiley), 2002.
Glass, R., Fact and Fallacies of Software Engineering,Addison-Wesley, 2002.
Jacobson, I., Object-Oriented Software Engineering: A Use Case Driven Approach,
2d ed.,Addison-Wesley, 2008.
Jalote, P., 
An Integrated Approach to Software Engineering,
Springer, 2006.
Pfleeger, S., 
Software Engineering: Theory and Practice,
3d ed., Prentice-Hall, 2005.Schach, S., Object-Oriented and Classical Software Engineering,7th ed., McGraw-Hill, 2006.
Sommerville, I., 
Software Engineering,8th ed., Addison-Wesley, 2006.
Tsui, F., and O. Karam, 
Essentials of Software Engineering,Jones & Bartlett Publishers, 2006.Many software engineering standards have been published by the IEEE, ISO, and their stan-
dards organizations over the past few decades. Moore (
The Road Map to Software Engineering:
A Standards-Based Guide,
Wiley-IEEE Computer Society Press, 2006) provides a useful survey of
relevant standards and how they apply to real projects.A wide variety of information sources on software engineering and the software process areavailable on the Internet. An up-to-date list of World Wide Web references that are relevant to

the software process can be found at the SEPA website: 
www.mhhe.com/engcs/compsci/

pressman/professional/olc/ser.htm.
CHAPTER 1SOFTWARE AND SOFTWARE ENGINEERING27pre75977_ch01.qxd  11/27/08  3:11 PM  Page 27
pre75977_ch01.qxd  11/27/08  3:11 PM  Page 28
THESOFTWARE
PROCESS29PART
OneIn this part of Software Engineering: A PractitionerÕs Approach 
youÕll learn about the process that provides a framework for

software engineering practice. These questions are addressedin the chapters that follow:¥What is a software process?¥What are the generic framework activities that are present in
every software process?¥How are processes modeled and what are process patterns?¥What are the prescriptive process models and what are their
strengths and weaknesses?¥Why is agilitya watchword in modern software engineeringwork?¥What is agile software development and how does it differ
from more traditional process models?Once these questions are answered youÕll be better prepared to
understand the context in which software engineering practice is
applied.pre75977_ch02.qxd  11/27/08  3:21 PM  Page 29
In a fascinating book that provides an economistÕs view of software and soft-
ware engineering, Howard Baetjer, Jr. [Bae98], comments on the software

process: Because software, like all capital, is embodied knowledge, and because that knowl-
edge is initially dispersed, tacit, latent, and incomplete in large measure, software de-

velopment is a social learning process. The process is a dialogue in which the
knowledge that must become the software is brought together and embodied in the
software. The process provides interaction between users and designers, between

users and evolving tools, and between designers and evolving tools [technology]. It is
an iterative process in which the evolving tool itself serves as the medium for com-
munication, with each new round of the dialogue eliciting more useful knowledge
from the people involved.
Indeed, building computer software is an iterative social learning process, andthe outcome, something that Baetjer would call Òsoftware capital,Ó is an embodi-
ment of knowledge collected, distilled, and organized as the process is conducted.30CHAPTER2PROCESSMODELSKEYCONCEPTScomponent-baseddevelopment . . . . . .50

concurrent models . .48

evolutionary process
models . . . . . . . . . .42

formal methods 
model . . . . . . . . . . .51

generic process 
model . . . . . . . . . . .31

incremental process
models . . . . . . . . . .41

personal software
process . . . . . . . . . .57

prescriptive process
models . . . . . . . . . .38

process patterns . . .35

task set . . . . . . . . .34

team software 
process . . . . . . . . . .58

Unified Process . . . .53
What is it?When you work to builda product or system, itÕs important to
go through a series of predictable
stepsÑa road map that helps youcreate a timely, high-quality result. The road map

that you follow is called a Òsoftware process.Ó Who does it?Software engineers and theirmanagers adapt the process to their needs and
then follow it. In addition, the people who have
requested the software have a role to play in the
process of defining, building, and testing it. Why is it important?
Because it providesstability, control, and organization to an activity

that can, if left uncontrolled, become quite
chaotic. However, a modern software engineer-

ing approach must be Òagile.Ó It must demand
only those activities, controls, and work products
that are appropriate for the project team and the
product that is to be produced.QUICKLOOKWhatarethesteps?
Atadetailedlevel,the
processthatyouadoptdependsonthesoftware

thatyouÕrebuilding.Oneprocessmightbeap-

propriateforcreatingsoftwareforanaircraft

avionicssystem,whileanentirelydifferentprocess

wouldbeindicatedforthecreationofawebsite.
What is the work product?
From the point ofview of a software engineer, the work products

are the programs, documents, and data that are
produced as a consequence of the activities and
tasks defined by the process. How do I ensure that IÕve done it right?There are a number of software process
assessment mechanisms that enable organiza-
tions todetermine the ÒmaturityÓ of their soft-

ware process. However, the quality, timeliness,

and long-term viability of the product you

build are the best indicators of the efficacy of

the process that you use.pre75977_ch02.qxd  11/27/08  3:21 PM  Page 30
CHAPTER 2PROCESS MODELS31But what exactly is a software process from a technical point of view? Within the
context of this book, I define a software processas a framework for the activities, ac-tions, and tasks that are required to build high-quality software. Is ÒprocessÓ syn-onymous with software engineering? The answer is Òyes and no.Ó A software process
defines the approach that is taken as software is engineered. But software engi-
neering also encompasses technologies that populate the processÑtechnical meth-
ods and automated tools.More important, software engineering is performed by creative, knowledgeable
people who should adapt a mature software process so that it is appropriate for the
products that they build and the demands of their marketplace.2.1A G
ENERICPROCESSMODELIn Chapter 1, a process was defined as a collection of work activities, actions, andtasks that are performed when some work product is to be created. Each of these
activities, actions, and tasks reside within a framework or model that defines their
relationship with the process and with one another.
The software process is represented schematically in Figure 2.1. Referring to thefigure, each framework activity is populated by a set of software engineering actions.

Each software engineering action is defined by a task setthat identifies the worktasks that are to be completed, the work products that will be produced, the quality
assurance points that will be required, and the milestones that will be used to indi-
cate progress.As I discussed in Chapter 1, a generic process framework for software engineer-ing defines five framework activitiesÑcommunication, planning, modeling,
construction,and deployment.
In addition, a set of umbrella activitiesÑprojecttracking and control, risk management, quality assurance, configuration manage-

ment, technical reviews, and othersÑare applied throughout the process.Youshouldnotethatoneimportantaspectofthesoftwareprocesshasnot
yetbeendiscussed.ThisaspectÑcalled
processflow
Ñdescribeshowtheframe-
workactivitiesandtheactionsandtasksthatoccurwithineachframework

activityareorganizedwithrespecttosequenceandtimeandisillustratedin

Figure2.2.
A linear process flowexecutes each of the five framework activities in sequence,
beginning with communication and culminating with deployment (Figure 2.2a). An
iterative process flow
repeats one or more of the activities before proceeding to thenext (Figure 2.2b). An evolutionary process flowexecutes the activities in a ÒcircularÓmanner. Each circuit through the five activities leads to a more complete version

of the software (Figure 2.2c). A parallel process flow
(Figure 2.2d) executes one ormore activities in parallel with other activities (e.g., modeling for one aspect of the
software might be executed in parallel with construction of another aspect of the
software).The hierarchy oftechnical work within
the software process is
activities,
encompassing actions,
populated by tasks.uote:ÒWe think that

software
developers are
missing a vital
truth: most
organizations donÕt
know what they
do. They think they
know, but they

donÕt know.Ó
TomDeMarco
pre75977_ch02.qxd  11/27/08  3:21 PM  Page 31
2.1.1Defining a Framework Activity
Although I have described five framework activities and provided a basic defini-
tion of each in Chapter 1, a software team would need significantly more infor-
mation before it could properly execute any one of these activities as part of the
software process. Therefore, you are faced with a key question:
What actions areappropriate for a framework activity, given the nature of the problem to be solved, the

characteristics of the people doing the work, and the stakeholders who are sponsor-

ing the project?32PART ONETHE SOFTWARE PROCESSProcess frameworkUmbrella activitiesframework activity # 1Task sets
work taskswork products
quality assurance points
project milestonessoftware engineering action #1.1Task sets
work tasks
work products
quality assurance points
project milestonessoftware engineering action #1.kframework activity # nTask sets
work tasks
work products
quality assurance points
project milestonessoftware engineering action #n.1Task sets
work tasks
work products
quality assurance points
project milestonessoftware engineering action #n.mSoftware processFIGURE2.1A software
process

frameworkpre75977_ch02.qxd  11/27/08  3:21 PM  Page 32
CHAPTER 2PROCESS MODELS33(d) Parallel process flow(c) Evolutionary process flow
CommunicationPlanning
Modeling(a) Linear process flowConstructionDeployment
CommunicationPlanning
ModelingConstructionDeployment
ConstructionDeployment
CommunicationPlanning
ModelingTime
(b) Iterative process flowPlanningModelingConstructionDeploymentIncrementreleasedCommunicationFIGURE2.2Process flow
For a small software project requested by one person (at a remote location) withsimple, straightforward requirements, the communication activity might encompass
little more than a phone call with the appropriate stakeholder. Therefore, the only

necessary action is phone conversation,
and the work tasks (the task set) that thisaction encompasses are:1.Make contact with stakeholder via telephone.2.Discuss requirements and take notes.How does aframeworkactivity change as
the nature of the
project changes??pre75977_ch02.qxd  11/27/08  3:21 PM  Page 33
3.Organize notes into a brief written statement of requirements.4.E-mail to stakeholder for review and approval.
If the project was considerably more complex with many stakeholders, each witha different set of (sometime conflicting) requirements, the communication activitymight have six distinct actions (described in Chapter 5): inception, elicitation, elabo-
ration, negotiation, specification,
andvalidation. Each of these software engineeringactions would have many work tasks and a number of distinct work products.2.1.2Identifying a Task Set
Referring again to Figure 2.1, each software engineering action (e.g., elicitation,anaction associated with the communication activity) can be represented by a number
of different task setsÑeach a collection of software engineering work tasks, related
work products, quality assurance points, and project milestones. You should choose

a task set that best accommodates the needs of the project and the characteristics of
your team. This implies that a software engineering action can be adapted to the spe-
cific needs of the software project and the characteristics of the project team. 34PART ONETHE SOFTWARE PROCESSTask Set
A task set defines the actual work to be doneto accomplish the objectives of a softwareengineering action. For example,elicitation(morecommonly called Òrequirements gatheringÓ) is animportant software engineering action that occurs during

the communication activity. The goal of requirements

gathering is to understand what various stakeholders want
from the software that is to be built.For a small, relatively simple project, the task set forrequirements gathering might look like this:1.Make a list of stakeholders for the project.

2.Invite all stakeholders to an informal meeting.

3.Ask each stakeholder to make a list of features and
functions required.4.Discuss requirements and build a final list.

5.Prioritize requirements.

6.Note areas of uncertainty.
For a larger, more complex software project, a
different task set would be required. It might encompass

the following work tasks:1.Make a list of stakeholders for the project.

2.Interview each stakeholder separately to determine
overall wants and needs.3.Build a preliminary list of functions and features
based on stakeholder input.4.Schedule a series of facilitated application
specification meetings.5.Conduct meetings.

6.Produce informal user scenarios as part of each
meeting.7.Refine user scenarios based on stakeholder
feedback.8.Build a revised list of stakeholder requirements.

9.Use quality function deployment techniques to
prioritize requirements.10.Package requirements so that they can be delivered
incrementally.
11.Note constraints and restrictions that will be placed
on the system.12.Discuss methods for validating the system.
Both of these task sets achieve Òrequirements gathering,Óbut they are quite different in their depth and formality. The

software team chooses the task set that will allow it to
achieve the goal of each action and still maintain quality
and agility.
INFODifferent projectsdemand different task
sets. The software
team chooses the task
set based on problem
and project
characteristics.pre75977_ch02.qxd  11/27/08  3:21 PM  Page 34
2.1.3Process Patterns
Every software team encounters problems as it moves through the software process.
It would be useful if proven solutions to these problems were readily available to the

team so that the problems could be addressed and resolved quickly. A 
processpattern1describes a process-related problem that is encountered during software en-gineering work, identifies the environment in which the problem has been encoun-

tered, and suggests one or more proven solutions to the problem. Stated in more

general terms, a process pattern provides you with a template [Amb98]Ña consis-

tent method for describing problem solutions within the context of the software
process. By combining patterns, a software team can solve problems and construct
a process that best meets the needs of a project.Patterns can be defined at any level of abstraction.2In some cases, a pattern mightbe used to describe a problem (and solution) associated with a complete process
model (e.g., prototyping). In other situations, patterns can be used to describe a prob-
lem (and solution) associated with a framework activity (e.g., planning) or an action
within a framework activity (e.g., project estimating).Ambler [Amb98] has proposed a template for describing a process pattern:Pattern Name.The pattern is given a meaningful name describing itwithin the context of the software process (e.g., TechnicalReviews
).Forces.
The environment in which the pattern is encountered and the
issues that make the problem visible and may affect its solution.Type.
The pattern typeis specified. Ambler [Amb98] suggests three types:
1.Stagepattern
Ñdefinesaproblemassociatedwithaframeworkactivityfor
theprocess.Sinceaframeworkactivityencompassesmultipleactionsand

worktasks,astagepatternincorporatesmultipletaskpatterns(seethefol-

lowing)thatarerelevanttothestage(frameworkactivity).Anexampleofa

stagepatternmightbe
EstablishingCommunication.Thispatternwould
incorporatethetaskpattern
RequirementsGathering
andothers.
2.Task pattern
Ñdefines a problem associated with a software engineering
action or work task and relevant to successful software engineering
practice (e.g., RequirementsGathering
is a task pattern).3.Phase patternÑdefine the sequence of framework activities that occurs
within the process, even when the overall flow of activities is iterative

in nature. An example of a phase pattern might be SpiralModel
orPrototyping.
3CHAPTER 2PROCESS MODELS351A detailed discussion of patterns is presented in Chapter 12.
2Patterns are applicable to many software engineering activities. Analysis, design, and testing
patterns are discussed in Chapters 7, 9, 10, 12, and 14. Patterns and ÒantipatternsÓ for project
management activities are discussed in Part 4 of this book.3These phase patterns are discussed in Section 2.3.3.
What is aprocesspattern??uote:ÒThe repetition of
patterns is quite a
different thing than
the repetition of
parts. Indeed, the
different parts will
be unique because
the patterns are the
same.ÓChristopherAlexanderA pattern template
provides a consistent
means for describing a
pattern.
pre75977_ch02.qxd  11/27/08  3:21 PM  Page 35
Initial context.Describes the conditions under which the pattern applies.Prior to the initiation of the pattern: (1) What organizational or team-related ac-tivities have already occurred? (2) What is the entry state for the process?
(3)What software engineering information or project information already exists?
For example, the 
Planningpattern (a stage pattern) requires that (1) cus-tomers and software engineers have established a collaborative communi-
cation; (2) successful completion of a number of task patterns [specified] for
the Communicationpattern has occurred; and (3) the project scope, basic
business requirements, and project constraints are known.Problem.
The specific problem to be solved by the pattern.Solution.Describes how to implement the pattern successfully. This sec-
tion describes how the initial state of the process (that exists before the pat-tern is implemented) is modified as a consequence of the initiation of the
pattern. It also describes how software engineering information or project
information that is available before the initiation of the pattern is transformed
as a consequence of the successful execution of the pattern.Resulting Context.Describes the conditions that will result once the pat-tern has been successfully implemented. Upon completion of the pattern:(1)What organizational or team-related activities must have occurred?

(2)What is the exit state for the process? (3) What software engineering

information or project information has been developed? Related Patterns.Provide a list of all process patterns that are directly
related to this one. This may be represented as a hierarchy or in some otherdiagrammatic form. For example, the stage pattern 
Communicationencompasses the task patterns: ProjectTeam,CollaborativeGuidelines,

ScopeIsolation, RequirementsGathering, ConstraintDescription,
andScenarioCreation.
Known Uses and Examples.
Indicate the specific instances in which thepattern is applicable. For example, 
Communicationis mandatory at thebeginning of every software project, is recommended throughout the softwareproject, and is mandatory once the deployment activity is underway.
Process patterns provide an effective mechanism for addressing problems asso-
ciated with any software process. The patterns enable you to develop a hierarchical
process description that begins at a high level of abstraction (a phase pattern). The
description is then refined into a set of stage patterns that describe framework
activities and are further refined in a hierarchical fashion into more detailed task
patterns for each stage pattern. Once process patterns have been developed, they
can be reused for the definition of process variantsÑthat is, a customized process
model can be defined by a software team using the patterns as building blocks for
the process model.36PART ONETHE SOFTWARE PROCESSWebRef
Comprehensiveresources on process
patterns can be found

at www.

ambysoft.com/
processPatternsPage
.html
.pre75977_ch02.qxd  11/27/08  3:21 PM  Page 36
2.2P
ROCESSASSESSMENTAND
IMPROVEMENTThe existence of a software process is no guarantee that software will be deliveredon time, that it will meet the customerÕs needs, or that it will exhibit the technical

characteristics that will lead to long-term quality characteristics (Chapters 14 and
16). Process patterns must be coupled with solid software engineering practice
(Part2 of this book). In addition, the process itself can be assessed to ensure that it

meets a set of basic process criteria that have been shown to be essential for a suc-
cessful software engineering.4A number of different approaches to software process assessmentand
improvement have been proposed over the past few decades:
Standard CMMI Assessment Method forProcess Improvement

(SCAMPI)Ñprovides a five-step process assessment model that incorporates

five phases: initiating, diagnosing, establishing, acting, and learning. The
SCAMPI method uses the SEI CMMI as the basis for assessment [SEI00].CHAPTER 2PROCESS MODELS374The SEIÕs CMMI [CMM07] describes the characteristics of a software process and the criteria for a
successful process in voluminous detail.Assessment attempts tounderstand the current

state of the software
process with the intent
of improving it.What formal
techniquesare available for
assessing the
software process??INFOAn Example Process Pattern
The following abbreviated process pattern
describes an approach that may be applicablewhen stakeholders have a general idea of what must be
done but are unsure of specific software requirements.Pattern name.RequirementsUnclearIntent.This pattern describes an approach for building a
model (a prototype) that can be assessed iteratively bystakeholders in an effort to identify or solidify software

requirements.Type.
Phase pattern.
Initial context.The following conditions must be metprior to the initiation of this pattern: (1) stakeholders have
been identified; (2) a mode of communication between
stakeholders and the software team has been established;
(3) the overriding software problem to be solved has been
identified by stakeholders; (4) an initial understanding of
project scope, basic business requirements, and project
constraints has been developed.Problem.
Requirements are hazy or nonexistent, yetthere is clear recognition that there is a problem to besolved, and the problem must be addressed with asoftware solution. Stakeholders are unsure of what they
want; that is, they cannot describe software requirements
in any detail.Solution.A description of the prototyping processwouldbe presented here and is described later in
Section 2.3.3.Resulting context.A software prototype that identifiesbasic requirements (e.g., modes of interaction,computational features, processing functions) is approved
by stakeholders. Following this, (1) the prototype may
evolve through a series of increments to become the
production software or (2) the prototype may be discarded
and the production software built using some other process
pattern.
Related patterns.The following patterns are related to
this pattern: 
CustomerCommunication,IterativeDesign,IterativeDevelopment,

CustomerAssessment, RequirementExtraction.Known uses and examples.Prototyping isrecommended when requirements are uncertain. 
pre75977_ch02.qxd  11/27/08  3:21 PM  Page 37
CMM-Based Appraisal for Internal Process Improvement (CBA IPI)
Ñprovides a diagnostic technique for assessing the relative maturity of a
software organization; uses the SEI CMM as the basis for the assessment
[Dun01].SPICE (ISO/IEC15504)Ña standard that defines a set of requirements forsoftware process assessment. The intent of the standard is to assist organi-
zations in developing an objective evaluation of the efficacy of any defined
software process [ISO08].ISO 9001:2000 for Software
Ña generic standard that applies to any or-ganization that wants to improve the overall quality of the products, systems,

or services that it provides. Therefore, the standard is directly applicable to

software organizations and companies [Ant06].A more detailed discussion of software assessment and process improvement
methods is presented in Chapter 30.2.3P
RESCRIPTIVEPROCESSMODELSPrescriptive process models were originally proposed to bring order to the chaos
ofsoftware development. History has indicated that these traditional models

havebrought a certain amount of useful structure to software engineering work and

have provided a reasonably effective road map for software teams. However, software

engineering work and the product that it produces remain on Òthe edge of chaos.ÓIn an intriguing paper on the strange relationship between order and chaos in thesoftware world, Nogueira and his colleagues [Nog00] stateThe edge of chaos is defined as Òa natural state between order and chaos, a grand com-promise between structure and surpriseÓ [Kau95]. The edge of chaos can be visualized as
an unstable, partially structured state. . . . It is unstable because it is constantly attracted

to chaos or to absolute order.
We have the tendency to think that order is the ideal state of nature. This could be a mis-
take. Research . . . supports the theory that operation away from equilibrium generates cre-

ativity, self-organized processes, and increasing returns [Roo96]. Absolute order means the

absence of variability, which could be an advantage under unpredictable environments.

Change occurs when there is some structure so that the change can be organized, but not
so rigid that it cannot occur. Too much chaos, on the other hand, can make coordination

and coherence impossible. Lack of structure does not always mean disorder.
The philosophical implications of this argument are significant for software engineer-ing. If prescriptive process models5strive for structure and order, are they inappropri-
ate for a software world that thrives on change? Yet, if we reject traditional process
38PART ONETHE SOFTWARE PROCESS5Prescriptive process models are sometimes referred to as ÒtraditionalÓ process models.
uote:ÒSoftwareorganizations have
exhibited
significant
shortcomings in
their ability to
capitalize on the
experiences gained
from completed
projects.ÓNASAuote:ÒIf the process isright, the results
will take care of
themselves.ÓTakashiOsada
pre75977_ch02.qxd  11/27/08  3:21 PM  Page 38
models (and the order they imply) and replace them with something less structured,do we make it impossible to achieve coordination and coherence in software work?There are no easy answers to these questions, but there are alternatives availableto software engineers. In the sections that follow, I examine the prescriptive process

approach in which order and project consistency are dominant issues. I call them
ÒprescriptiveÓ because they prescribe a set of process elementsÑframework activi-
ties, software engineering actions, tasks, work products, quality assurance, and

change control mechanisms for each project. Each process model also prescribes a
process flow (also called a work flow)Ñthat is, the manner in which the process
elements are interrelated to one another.
All software process models can accommodate the generic framework activitiesdescribed in Chapter 1, but each applies a different emphasis to these activities and
defines a process flow that invokes each framework activity (as well as software

engineering actions and tasks) in a different manner.
2.3.1The Waterfall Model
There are times when the requirements for a problem are well understoodÑwhen
work flows from communicationthrough deployment
in a reasonably linear fash-ion. This situation is sometimes encountered when well-defined adaptations or en-
hancements to an existing system must be made (e.g., an adaptation to accounting
software that has been mandated because of changes to government regulations). It

may also occur in a limited number of new development efforts, but only when
requirements are well defined and reasonably stable.The waterfall model,sometimes called the classic life cycle, suggests a systematic,
sequential approach6to software development that begins with customer specifica-tion of requirements and progresses through planning, modeling, construction, and
deployment, culminating in ongoing support of the completed software (Figure 2.3).A variation in the representation of the waterfall model is called the V-model
.Represented in Figure 2.4, the V-model [Buc99] depicts the relationship of quality
CHAPTER 2PROCESS MODELS39Communication project initiation
 requirements gathering
Planning estimating
 scheduling
 trackingModeling analysis
 designDeployment delivery

 support

 feedbackConstruction code
 testFIGURE2.3The waterfall model
6Although the original waterfall model proposed by Winston Royce [Roy70] made provision for
Òfeedback loops,Ó the vast majority of organizations that apply this process model treat it as if itwere strictly linear.Prescriptive processmodels define a
prescribed set of
process elements and
a predictable process
work flow.
pre75977_ch02.qxd  11/27/08  3:21 PM  Page 39
assurance actions to the actions associated with communication, modeling, andearly construction activities. As a software team moves down the left side of the V,

basic problem requirements are refined into progressively more detailed and techni-
cal representations of the problem and its solution. Once code has been generated,
the team moves up the right side of the V, essentially performing a series of tests

(quality assurance actions) that validate each of the models created as the team
moved down the left side.
7In reality, there is no fundamental difference between the
classic life cycle and the V-model. The V-model provides a way of visualizing how

verification and validation actions are applied to earlier engineering work.The waterfall model is the oldest paradigm for software engineering. However,
over the past three decades, criticism of this process model has caused even ardent

supporters to question its efficacy [Han95]. Among the problems that are sometimes
encountered when the waterfall model is applied are:1.Real projects rarely follow the sequential flow that the model proposes.
Although the linear model can accommodate iteration, it does so indirectly.

As a result, changes can cause confusion as the project team proceeds.40PART ONETHE SOFTWARE PROCESS7A detailed discussion of quality assurance actions is presented in Part 3 of this book.
The V-model illustrates
how verification and
validation actions are
associated with earlier
engineering actions.Why does
the waterfallmodel sometimes
fail??CodegenerationArchitecturaldesignComponentdesignRequirementsmodelingAcceptancetestingSystemtestingIntegrationtestingUnittestingExecutablesoftwareFIGURE2.4The V-model
pre75977_ch02.qxd  11/27/08  3:21 PM  Page 40
2.It is often difficult for the customer to state all requirements explicitly. The
waterfall model requires this and has difficulty accommodating the natural
uncertainty that exists at the beginning of many projects.3.The customer must have patience. A working version of the program(s) will
not be available until late in the project time span. A major blunder, if unde-

tected until the working program is reviewed, can be disastrous.In an interesting analysis of actual projects, Bradac [Bra94] found that the linearnature of the classic life cycle leads to Òblocking statesÓ in which some project team
members must wait for other members of the team to complete dependent tasks. In
fact, the time spent waiting can exceed the time spent on productive work! The
blocking states tend to be more prevalent at the beginning and end of a linear
sequential process.Today, software work is fast-paced and subject to a never-ending stream of
changes (to features, functions, and information content). The waterfall model is
often inappropriate for such work. However, it can serve as a useful process model

in situations where requirements are fixed and work is to proceed to completion in
a linear manner.
2.3.2Incremental Process Models
There are many situations in which initial software requirements are reasonably well
defined, but the overall scope of the development effort precludes a purely linear

process. In addition, there may be a compelling need to provide a limited set of soft-

ware functionality to users quickly and then refine and expand on that functionality
in later software releases. In such cases, you can choose a process model that is
designed to produce the software in increments.The incrementalmodel combines elements of linear and parallel process flowsdiscussed in Section 2.1. Referring to Figure 2.5, the incremental model applies linear
sequences in a staggered fashion as calendar time progresses. Each linear sequence
produces deliverable ÒincrementsÓ of the software [McD93] in a manner that is sim-
ilar to the increments produced by an evolutionary process flow (Section 2.3.3).For example, word-processing software developed using the incremental para-
digm might deliver basic file management, editing, and document production func-
tions in the first increment; more sophisticated editing and document production
capabilities in the second increment; spelling and grammar checking in the third in-
crement; and advanced page layout capability in the fourth increment. It should be
noted that the process flow for any increment can incorporate the prototyping
paradigm. When an incremental model is used, the first increment is often a core product.That is, basic requirements are addressed but many supplementary features (some
known, others unknown) remain undelivered. The core product is used by the cus-
tomer (or undergoes detailed evaluation). As a result of use and/or evaluation, aCHAPTER 2PROCESS MODELS41uote:ÒToo often,
software work
follows the first law
of bicycling: No
matter where
youÕre going, itÕs

uphill and against
the wind.ÓAuthor unknownThe incremental modeldelivers a series of
releases, called
increments, that
provide progressively
more functionality for
the customer as each
increment is delivered.Your customer

demands delivery by a

date that is impossible
to meet. Suggest deliv-
ering one or more
increments by that
date and the rest of
the software (addi-
tional increments)
later.
pre75977_ch02.qxd  11/27/08  3:21 PM  Page 41
plan is developed for the next increment. The plan addresses the modification of thecore product to better meet the needs of the customer and the delivery of additional
features and functionality. This process is repeated following the delivery of each

increment, until the complete product is produced.The incremental process model focuses on the delivery of an operational productwith each increment. Early increments are stripped-down versions of the final prod-
uct, but they do provide capability that serves the user and also provide a platform

for evaluation by the user.
8Incremental development is particularly useful when staffing is unavailable for acomplete implementation by the business deadline that has been established for the
project. Early increments can be implemented with fewer people. If the core product
is well received, then additional staff (if required) can be added to implement the next
increment. In addition, increments can be planned to manage technical risks. For ex-
ample, a major system might require the availability of new hardware that is under

development and whose delivery date is uncertain. It might be possible to plan early
increments in a way that avoids the use of this hardware, thereby enabling partial

functionality to be delivered to end users without inordinate delay.
2.3.3Evolutionary Process Models
Software, like all complex systems, evolves over a period of time. Business and prod-

uct requirements often change as development proceeds, making a straight line path
to an end product unrealistic; tight market deadlines make completion of a compre-
hensive software product impossible, but a limited version must be introduced to
42PART ONETHE SOFTWARE PROCESSEvolutionary process
models produce an
increasingly more
complete version of
the software with each
iteration.8It is important to note that an incremental philosophy is also used for all ÒagileÓ process models dis-
cussed in Chapter 3.increment # 1increment # 2delivery of
1st incrementdelivery of

2nd incrementdelivery of 

nth incrementincrement # nProject Calendar Time
Software Functionality and FeaturesCommunicationPlanningModeling (analysis, design)Construction (code, test)Deployment (delivery, feedback)
FIGURE2.5The incremental

modelpre75977_ch02.qxd  11/27/08  3:21 PM  Page 42
meet competitive or business pressure; a set of core product or system requirementsis well understood, but the details of product or system extensions have yet to be
defined. In these and similar situations, you need a process model that has been
explicitly designed to accommodate a product that evolves over time.
Evolutionary models are iterative. They are characterized in a manner thatenables you to develop increasingly more complete versions of the software. In the
paragraphs that follow, I present two common evolutionary process models.
Prototyping.
Often, a customer defines a set of general objectives for software,
but does not identify detailed requirements for functions and features. In othercases, the developer may be unsure of the efficiency of an algorithm, the adapt-
ability of an operating system, or the form that human-machine interaction should
take. In these, and many other situations, a 
prototyping paradigm
may offer the bestapproach.Although prototyping can be used as a stand-alone process model, it is more com-monly used as a technique that can be implemented within the context of any one
of the process models noted in this chapter. Regardless of the manner in which it is

applied, the prototyping paradigm assists you and other stakeholders to better
understand what is to be built when requirements are fuzzy.
The prototyping paradigm (Figure 2.6) begins with communication. You meet with
other stakeholders to define the overall objectives for the software, identify whatever

requirements are known, and outline areas where further definition is mandatory. A

prototyping iteration is planned quickly, and modeling (in the form of a Òquick de-

signÓ) occurs. A quick design focuses on a representation of those aspects of the soft-
ware that will be visible to end users (e.g., human interface layout or output displayCHAPTER 2PROCESS MODELS43uote:ÒPlan to throw oneaway. You will do

that, anyway. Your

only choice is
whether to try to

sell the throwaway
to customers.ÓFrederickP.
BrooksWhen your customerhas a legitimate need,
but is clueless about
the details, develop a
prototype as a first
step.CommunicationQuick planConstructionof
prototypeModeling
 Quick design  Deployment
  Delivery 

  & FeedbackFIGURE2.6The prototyping

paradigmpre75977_ch02.qxd  11/27/08  3:21 PM  Page 43
formats). The quick design leads to the construction of a prototype. The prototype isdeployed and evaluated by stakeholders, who provide feedback that is used to fur-

ther refine requirements. Iteration occurs as the prototype is tuned to satisfy the
needs of various stakeholders, while at the same time enabling you to better under-
stand what needs to be done.Ideally, the prototype serves as a mechanism for identifying software require-
ments. If a working prototype is to be built, you can make use of existing program
fragments or apply tools (e.g., report generators and window managers) that enable
working programs to be generated quickly.
But what do you do with the prototype when it has served the purpose describedearlier? Brooks [Bro95] provides one answer:
In most projects, the first system built is barely usable. It may be too slow, too big, awk-
ward in use or all three. There is no alternative but to start again, smarting but smarter,

and build a redesigned version in which these problems are solved.The prototype can serve as Òthe first system.Ó The one that Brooks recommendsyou throw away. But this may be an idealized view. Although some prototypes are
built as Òthrowaways,Ó others are evolutionary in the sense that the prototype slowly

evolves into the actual system.Both stakeholders and software engineers like the prototyping paradigm. Usersget a feel for the actual system, and developers get to build something immediately.

Yet, prototyping can be problematic for the following reasons:
1.Stakeholders see what appears to be a working version of the software,

unaware that the prototype is held together haphazardly, unaware that in the

rush to get it working you havenÕt considered overall software quality or

long-term maintainability. When informed that the product must be rebuilt so

that high levels of quality can be maintained, stakeholders cry foul and
demand that Òa few fixesÓ be applied to make the prototype a working
product. Too often, software development management relents.
2.As a software engineer, you often make implementation compromises in

order to get a prototype working quickly. An inappropriate operating system

or programming language may be used simply because it is available and
known; an inefficient algorithm may be implemented simply to demonstrate
capability. After a time, you may become comfortable with these choices and

forget all the reasons why they were inappropriate. The less-than-ideal
choice has now become an integral part of the system.Although problems can occur, prototyping can be an effective paradigm for soft-
ware engineering. The key is to define the rules of the game at the beginning; that is,
all stakeholders should agree that the prototype is built to serve as a mechanism for
defining requirements. It is then discarded (at least in part), and the actual software
is engineered with an eye toward quality.
44PART ONETHE SOFTWARE PROCESSResist pressure toextend a rough
prototype into a
production product.
Quality almost always
suffers as a result.pre75977_ch02.qxd  11/27/08  3:21 PM  Page 44
The Spiral Model.
Originally proposed by Barry Boehm [Boe88], thespiral model
is an evolutionary software process model that couples the iterative nature of proto-typing with the controlled and systematic aspects of the waterfall model. It provides

the potential for rapid development of increasingly more complete versions of the
software. Boehm [Boe01a] describes the model in the following manner:The spiral development model is a risk-driven process model generator that is used toguide multi-stakeholder concurrent engineering of software intensive systems. It has twomain distinguishing features. One is a cyclic approach for incrementally growing a sys-temÕs degree of definition and implementation while decreasing its degree of risk. The

other is a set of anchor point milestones 
for ensuring stakeholder commitment to feasibleand mutually satisfactory system solutions.Using the spiral model, software is developed in a series of evolutionary releases.During early iterations, the release might be a model or prototype. During later iter-
ations, increasingly more complete versions of the engineered system are produced.CHAPTER 2PROCESS MODELS45The scene:Meeting room for thesoftware engineering group at CPI Corporation, a(fictional) company that makes consumer products for
home and commercial use.The players:Lee Warren, engineering manager; Doug
Miller, software engineering manager; Jamie Lazar,
software team member; Vinod Raman, software team

member; and Ed Robbins, software team member.
The conversation:
Lee:So letÕs recapitulate. IÕve spent some time discussing
the SafeHomeproduct line as we see it at the moment.No doubt, weÕve got a lot of work to do to simply definethe thing, but IÕd like you guys to begin thinking about
how youÕre going to approach the software part of this

project.Doug:Seems like weÕve been pretty disorganized in ourapproach to software in the past.
Ed:I donÕt know, Doug, we always got product out
thedoor.

Doug:True, but not without a lot of grief, and this
project looks like itÕs bigger and more complex than
anything weÕve done in the past.Jamie:DoesnÕt look that hard, but I agree . . . our
adhoc approach to past projects wonÕt work here,
particularly if we have a very tight time line.
Doug(smiling):
I want to be a bit more professional inour approach. I went to a short course last week and

learned a lot about software engineering . . . good stuff.

We need a process here.
Jamie (with a frown):
My job is to build computerprograms, not push paper around.
Doug:Give it a chance before you go negative onme.HereÕs what I mean. [Doug proceeds to describe
theprocess framework described in this chapter and

theprescriptive process models presented to this 

point.]Doug:So anyway, it seems to me that a linear model is
not for us . . . assumes we have all requirements up frontand, knowing this place, thatÕs not likely.
Vinod:
Yeah, and it sounds way too IT-oriented . . .
probably good for building an inventory control system
or something, but itÕs just not right for 
SafeHome.Doug:I agree.Ed:That prototyping approach seems OK. A lot like whatwe do here anyway.
Vinod:
ThatÕs a problem. IÕm worried that it doesnÕt
provide us with enough structure.
Doug:Not to worry. WeÕve got plenty of other options,
and I want you guys to pick whatÕs best for the team and
best for the project.SAFEHOMESelecting a Process Model, Part 1
pre75977_ch02.qxd  11/27/08  3:21 PM  Page 45
A spiral model is divided into a set of framework activities defined by the softwareengineering team. For illustrative purposes, I use the generic framework activitiesdiscussed earlier.
9Each of the framework activities represent one segment of the spi-ral path illustrated in Figure 2.7. As this evolutionary process begins, the software
team performs activities that are implied by a circuit around the spiral in a clockwise
direction, beginning at the center. Risk (Chapter 28) is considered as each revolution

is made. Anchor point milestones
Ña combination of work products and conditionsthat are attained along the path of the spiralÑare noted for each evolutionary pass.The first circuit around the spiral might result in the development of a productspecification; subsequent passes around the spiral might be used to develop a pro-
totype and then progressively more sophisticated versions of the software. Each pass
through the planning region results in adjustments to the project plan. Cost and
schedule are adjusted based on feedback derived from the customer after delivery.

In addition, the project manager adjusts the planned number of iterations required
to complete the software.Unlike other process models that end when software is delivered, the spiral modelcan be adapted to apply throughout the life of the computer software. Therefore, the

first circuit around the spiral might represent a Òconcept development projectÓ that
starts at the core of the spiral and continues for multiple iterations10until concept46PART ONETHE SOFTWARE PROCESS9The spiral model discussed in this section is a variation on the model proposed by Boehm. For
further information on the original spiral model, see [Boe88]. More recent discussion of BoehmÕsspiral model can be found in [Boe98].10The arrows pointing inward along the axis separating the 
deploymentregion from the commu-nicationregion indicate a potential for local iteration along the same spiral path.CommunicationPlanning ModelingConstructionDeployment delivery 
feedbackStart
analysis designcode 
testestimation 
scheduling risk analysisFIGURE2.7A typicalspiral modelThe spiral model canbe adapted to apply
throughout the entire
life cycle of an
application, from
concept development
to maintenance.WebRef
Useful information
about the spiral model
can be obtained at:
www.sei.cmu

.edu/publications/
documents/00
.reports/00sr008
.html.pre75977_ch02.qxd  11/27/08  3:21 PM  Page 46
development is complete. If the concept is to be developed into an actual product,the process proceeds outward on the spiral and a Ònew product development proj-
ectÓ commences. The new product will evolve through a number of iterations around
the spiral. Later, a circuit around the spiral might be used to represent a Òproduct en-

hancement project.Ó In essence, the spiral, when characterized in this way, remains

operative until the software is retired. There are times when the process is dormant,
but whenever a change is initiated, the process starts at the appropriate entry point
(e.g., product enhancement).The spiral model is a realistic approach to the development of large-scale systemsand software. Because software evolves as the process progresses, the developer
and customer better understand and react to risks at each evolutionary level. The
spiral model uses prototyping as a risk reduction mechanism but, more important,
enables you to apply the prototyping approach at any stage in the evolution of the
product. It maintains the systematic stepwise approach suggested by the classic life
cycle but incorporates it into an iterative framework that more realistically reflects
the real world. The spiral model demands a direct consideration of technical risks at
all stages of the project and, if properly applied, should reduce risks before they
become problematic.But like other paradigms, the spiral model is not a panacea. It may be difficult toconvince customers (particularly in contract situations) that the evolutionary

approach is controllable. It demands considerable risk assessment expertise and
relies on this expertise for success. If a major risk is not uncovered and managed,

problems will undoubtedly occur.
CHAPTER 2PROCESS MODELS47If your managementdemands fixed-budget
development
(generally a bad idea),
the spiral can be a
problem. As each
circuit is completed,
project cost is revisited
and revised.uote:ÒIÕm only this farand only tomorrow
leads my way.Ó
Dave MatthewsBandThe scene:Meeting room for thesoftware engineering group at CPI Corporation, acompany that makes consumer products for home and
commercial use.The players:Lee Warren, engineering manager; Doug
Miller, software engineering manager; Vinod and Jamie,
members of the software engineering team.The conversation:[Doug describes evolutionary
process options.]
Jamie:Now I see something I like. An incrementalapproach makes sense, and I really like the flow of thatspiral model thing. ThatÕs keepinÕ it real.
Vinod:
I agree. We deliver an increment, learn from
customer feedback, replan, and then deliver anotherincrement. It also fits into the nature of the product. We
can have something on the market fast and then add
functionality with each version, er, increment.
Lee:Wait a minute. Did you say that we regenerate the
plan with each tour around the spiral, Doug? ThatÕs not so
great; we need one plan, one schedule, and weÕve got to
stick to it.Doug:ThatÕs old-school thinking, Lee. Like the guys said,
weÕve got to keep it real. I submit that itÕs better to tweak
the plan as we learn more and as changes are requested.

ItÕs way more realistic. WhatÕs the point of a plan if it

doesnÕt reflect reality?
Lee(frowning): I suppose so, but . . . senior managementÕs
not going to like this . . . they want a fixed plan.
Doug(smiling): Then youÕll have to reeducate them,buddy.
SAFEHOMESelecting a Process Model, Part 2
pre75977_ch02.qxd  11/27/08  3:21 PM  Page 47
2.3.4Concurrent Models
The concurrent development model,sometimes called concurrent engineering,allowsa software team to represent iterative and concurrent elements of any of the processmodels described in this chapter. For example, the modeling activity defined for the

spiral model is accomplished by invoking one or more of the following software

engineering actions: prototyping, analysis, and design.11Figure 2.8provides a schematic representation of one software engineering
activity within the modeling activity using a concurrent modeling approach. The
activityÑmodelingÑmay be in any one of the states12noted at any given time. Sim-ilarly, other activities, actions, or tasks (e.g., 
communicationor construction) canbe represented in an analogous manner. All software engineering activities exist

concurrently but reside in different states.48PART ONETHE SOFTWARE PROCESS11It should be noted that analysis and design are complex tasks that require substantial discussion.
Part 2 of this book considers these topics in detail.12A 
stateis some externally observable mode of behavior.Under reviewBaselinedUnderrevisionAwaiting
changesUnderdevelopmentInactiveModeling activityRepresents the state of a software engineering 
activity or task DoneFIGURE2.8One element ofthe concurrent

process model
The concurrent model
is often more appro-
priate for product engi-
neering projects where
different engineering
teams are involved.pre75977_ch02.qxd  11/27/08  3:21 PM  Page 48
Forexample,earlyinaprojectthecommunicationactivity(notshowninthefigure)
hascompleteditsfirstiterationandexistsinthe
awaitingchanges
state.Themodel-
ingactivity(whichexistedinthe
inactive
statewhileinitialcommunicationwascom-
pleted,nowmakesatransitionintothe
underdevelopment
state.If,however,the
customerindicatesthatchangesinrequirementsmustbemade,themodelingactivity
movesfromthe
underdevelopment
stateintothe
awaitingchanges
state.Concurrentmodelingdefinesaseriesofeventsthatwilltriggertransitionsfrom
statetostateforeachofthesoftwareengineeringactivities,actions,ortasks.For

example,duringearlystagesofdesign(amajorsoftwareengineeringactionthat

occursduringthemodelingactivity),aninconsistencyintherequirementsmodelis

uncovered.Thisgeneratestheevent
analysismodelcorrection,
whichwilltriggerthe
requirementsanalysisactionfromthe
donestateintothe
awaitingchanges
state.Concurrent modeling is applicable to all types of software development and pro-vides an accurate picture of the current state of a project. Rather than confining soft-
ware engineering activities, actions, and tasks to a sequence of events, it defines a
process network. Each activity, action, or task on the network exists simultaneously

with other activities, actions, or tasks. Events generated at one point in the process
network trigger transitions among the states.2.3.5A Final Word on Evolutionary Processes
I have already noted that modern computer software is characterized by continual
change, by very tight time lines, and by an emphatic need for customerÐuser

satisfaction. In many cases, time-to-market is the most important management
requirement. If a market window is missed, the software project itself may be
meaningless.13Evolutionary process models were conceived to address these issues, and yet, asa general class of process models, they too have weaknesses. These are summarized
by Nogueira and his colleagues [Nog00] : Despite the unquestionable benefits of evolutionary software processes, we have someconcerns. The first concern is that prototyping [and other more sophisticated evolution-
ary processes] poses a problem to project planning because of the uncertain number of
cycles required to construct the product. Most project management and estimation tech-
niques are based on linear layouts of activities, so they do not fit completely. 
Second, evolutionary software processes do not establish the maximum speed of theevolution. If the evolutions occur too fast, without a period of relaxation, it is certain that
the process will fall into chaos. On the other hand if the speed is too slow then produc-
tivity could be affected . . .CHAPTER 2PROCESS MODELS4913It is important to note, however, that being the first to reach a market is no guarantee of success.
In fact, many very successful software products have been second or even third to reach the market(learning from the mistakes of their predecessors).uote:ÒEvery process in
your organization
has a customer,

and without a
customer a process
has no purpose.ÓV.DanielHunt
pre75977_ch02.qxd  11/27/08  3:21 PM  Page 49
Third, software processes should be focused on flexibility and extensibility rather thanon high quality. This assertion sounds scary. However, we should prioritize the speed of
the development over zero defects. Extending the development in order to reach high

quality could result in a late delivery of the product, when the opportunity niche has
disappeared. This paradigm shift is imposed by the competition on the edge of chaos.Indeed, a software process that focuses on flexibility, extensibility, and speed of de-
velopment over high quality does sound scary. And yet, this idea has been proposed

by a number of well-respected software engineering experts (e.g., [You95], [Bac97]).
The intent of evolutionary models is to develop high-quality software14in an iter-ative or incremental manner. However, it is possible to use an evolutionary process

to emphasize flexibility, extensibility, and speed of development. The challenge for

software teams and their managers is to establish a proper balance between these
critical project and product parameters and customer satisfaction (the ultimate
arbiter of software quality).2.4S
PECIALIZEDPROCESSMODELSSpecialized process models take on many of the characteristics of one or more of the
traditional models presented in the preceding sections. However, these models tend

to be applied when a specialized or narrowly defined software engineering approach
is chosen.152.4.1Component-Based Development
Commercial off-the-shelf (COTS) software components, developed by vendors who
offer them as products, provide targeted functionality with well-defined interfaces

that enable the component to be integrated into the software that is to be built. The
component-based development modelincorporates many of the characteristics of thespiral model. It is evolutionary in nature [Nie92], demanding an iterative approach to
the creation of software. However, the component-based development model con-

structs applications from prepackaged software components.Modeling and construction activities begin with the identification of candidatecomponents. These components can be designed as either conventional software

modules or object-oriented classes or packages16of classes. Regardless of the50PART ONETHE SOFTWARE PROCESS14In this context software quality is defined quite broadly to encompass not only customer satisfac-
tion, but also a variety of technical criteria discussed in Chapters 14 and 16.15In some cases, these specialized process models might better be characterized as a collection of
techniques or a ÒmethodologyÓ for accomplishing a specific software development goal. However,they do imply a process.16Object-oriented concepts are discussed in Appendix 2 and are used throughout Part 2 of this book.
In this context, a class encompasses a set of data and the procedures that process the data. A pack-
age of classes is a collection of related classes that work together to achieve some end result.WebRef
Useful information on
component-based
development can be
obtained at: www
.cbd-hq.com.pre75977_ch02.qxd  11/27/08  3:21 PM  Page 50
technology that is used to create the components, the component-based develop-ment model incorporates the following steps (implemented using an evolutionary
approach):1.Available component-based products are researched and evaluated for the

application domain in question.2.Component integration issues are considered.3.A software architecture is designed to accommodate the components.4.Components are integrated into the architecture.5.Comprehensive testing is conducted to ensure proper functionality.
The component-based development model leads to software reuse, and reusabil-
ity provides software engineers with a number of measurable benefits. Your software

engineering team can achieve a reduction in development cycle time as well as a
reduction in project cost if component reuse becomes part of your culture. Component-
based development is discussed in more detail in Chapter 10.2.4.2The Formal Methods Model
The formal methods modelencompasses a set of activities that leads to formal math-ematical specification of computer software. Formal methods enable you to specify,

develop, and verify a computer-based system by applying a rigorous, mathematical
notation. A variation on this approach, called cleanroom software engineering[Mil87,Dye92], is currently applied by some software development organizations.When formal methods (Chapter 21) are used during development, they provide a
mechanism for eliminating many of the problems that are difficult to overcome using

other software engineering paradigms. Ambiguity, incompleteness, and inconsis-

tency can be discovered and corrected more easilyÑnot through ad hoc review, but

through the application of mathematical analysis. When formal methods are used
during design, they serve as a basis for program verification and therefore enable
you to discover and correct errors that might otherwise go undetected.
Although not a mainstream approach, the formal methods model offers the prom-ise of defect-free software. Yet, concern about its applicability in a business envi-

ronment has been voiced:¥The development of formal models is currently quite time consuming and
expensive.¥Because few software developers have the necessary background to apply
formal methods, extensive training is required.¥It is difficult to use the models as a communication mechanism for techni-
cally unsophisticated customers.These concerns notwithstanding, the formal methods approach has gainedadherents among software developers who must build safety-critical software CHAPTER 2PROCESS MODELS51If formalmethods candemonstrate
software
correctness, why
is it they are not
widely used??pre75977_ch02.qxd  11/27/08  3:21 PM  Page 51
(e.g., developers of aircraft avionics and medical devices) and among developersthat would suffer severe economic hardship should software errors occur. 
2.4.3Aspect-Oriented Software Development
Regardless of the software process that is chosen, the builders of complex software
invariably implement a set of localized features, functions, and information content.

These localized software characteristics are modeled as components (e.g., object-
oriented classes) and then constructed within the context of a system architecture.
As modern computer-based systems become more sophisticated (and complex),
certain concernsÑcustomer required properties or areas of technical interestÑspanthe entire architecture. Some concerns are high-level properties of a system (e.g.,
security, fault tolerance). Other concerns affect functions (e.g., the application of

business rules), while others are systemic (e.g., task synchronization or memory
management).When concerns cut across multiple system functions, features, and information,they are often referred to as crosscutting concerns. Aspectual requirements define
those crosscutting concerns that have an impact across the software architecture.
Aspect-oriented software development (AOSD), often referred to as 
aspect-orientedprogramming
(AOP), is a relatively new software engineering paradigm that provides
a process and methodological approach for defining, specifying, designing, and con-
structing aspectsÑÒmechanisms beyond subroutines and inheritance for localizingthe expression of a crosscutting concernÓ [Elr01].Grundy [Gru02] provides further discussion of aspects in the context of what he
calls aspect-oriented component engineering(AOCE):
AOCE uses a concept of horizontal slices through vertically-decomposed software com-
ponents, called Òaspects,Ó to characterize cross-cutting functional and non-functional
properties of components. Common, systemic aspects include user interfaces, collabora-
tive work, distribution, persistency, memory management, transaction processing, secu-

rity, integrity and so on. Components may provide or require one or more Òaspect detailsÓ

relating to a particular aspect, such as a viewing mechanism, extensible affordance and
interface kind (user interface aspects); event generation, transport and receiving
(distribution aspects); data store/retrieve and indexing (persistency aspects); authentica-
tion, encoding and access rights (security aspects); transaction atomicity, concurrency

control and logging strategy (transaction aspects); and so on. Each aspect detail has a
number of properties, relating to functional and/or non-functional characteristics of the
aspect detail.A distinct aspect-oriented process has not yet matured. However, it is likely that
such a process will adopt characteristics of both evolutionary and concurrentprocess models. The evolutionary model is appropriate as aspects are identified and
then constructed. The parallel nature of concurrent development is essential be-
cause aspects are engineered independently of localized software components and
yet, aspects have a direct impact on these components. Hence, it is essential to
52PART ONETHE SOFTWARE PROCESSWebRef
A wide array of
resources and
information on AOP

can be found at:
aosd.net.AOSD definesÒaspectsÓ that express
customer concerns that

cut across multiple
system functions,
features, and
information.
pre75977_ch02.qxd  11/27/08  3:21 PM  Page 52
instantiate asynchronous communication between the software process activitiesapplied to the engineering and construction of aspects and components.A detailed discussion of aspect-oriented software development is best left tobooks dedicated to the subject. If you have further interest, see [Saf08], [Cla05],
[Jac04], and [Gra03].CHAPTER 2PROCESS MODELS5317Tools noted here do not represent an endorsement, but rather a sampling of tools in this category.
In most cases, tool names are trademarked by their respective developers.Process Management
Objective:To assist in the definition,
execution, and management of prescriptiveprocess models.Mechanics:Process management tools allow a softwareorganization or team to define a complete softwareprocess model (framework activities, actions, tasks, QA
checkpoints, milestones, and work products). In addition,
the tools provide a road map as software engineers do
technical work and a template for managers who must
track and control the software process.Representative Tools:
17GDPA, a research process definition tool suite,
developed atBremen University in Germany (
www.informatik
.uni-bremen.de/uniform/gdpa/home.htm),provides a wide array of process modeling andmanagement functions.SpeeDev, 
developed by SpeeDev Corporation(www.speedev.com
) encompasses a suite of tools
for process definition, requirements management, issue
resolution, project planning, and tracking.ProVision BPMx,
developed by Proforma
(www.proformacorp.com
), is representative ofmany tools that assist in process definition and
workflow automation.A worthwhile listing of many different tools associated 
with the software process can be found at www.processwave.net/Links/tool_links.htm
.SOFTWARE
TOOLS2.5T
HEUNIFIEDPROCESSIn their seminal book on the Unified Process,Ivar Jacobson, Grady Booch, and JamesRumbaugh [Jac99] discuss the need for a Òuse case driven, architecture-centric, iter-
ative and incrementalÓ software process when they state:Today, the trend in software is toward bigger, more complex systems. That is due in part
to the fact that computers become more powerful every year, leading users to expect

more from them. This trend has also been influenced by the expanding use of the Inter-
net for exchanging all kinds of information.... Our appetite for ever-more sophisticated

software grows as we learn from one product release to the next how the product could
be improved. We want software that is better adapted to our needs, but that, in turn,

merely makes the software more complex. In short, we want more.In some ways the Unified Process is an attempt to draw on the best features and
characteristics of traditional software process models, but characterize them in a
way that implements many of the best principles of agile software developmentpre75977_ch02.qxd  11/27/08  3:21 PM  Page 53
(Chapter 3). The Unified Process recognizes the importance of customer communi-cation and streamlined methods for describing the customerÕs view of a system

(theuse case
18). It emphasizes the important role of software architecture andÒhelpsthe architect focus on the right goals, such as understandability, reliance to

future changes, and reuseÓ [Jac99]. It suggests a process flow that is iterative and
incremental, providing the evolutionary feel that is essential in modern software

development.2.5.1A Brief History
During the early 1990s James Rumbaugh [Rum91], Grady Booch [Boo94], and Ivar
Jacobson [Jac92] began working on a Òunified methodÓ that would combine the best
features of each of their individual object-oriented analysis and design methods and
adopt additional features proposed by other experts (e.g., [Wir90]) in object-oriented

modeling. The result was UMLÑa unified modeling languagethat contains a robustnotation for the modeling and development of object-oriented systems. By 1997,
UML became a de facto industry standard for object-oriented software development.UML is used throughout Part 2 of this book to represent both requirements anddesign models. Appendix 1 presents an introductory tutorial for those who are unfa-
miliar with basic UML notation and modeling rules. A comprehensive presentation
of UML is best left to textbooks dedicated to the subject. Recommended books are
listed in Appendix 1.UML provided the necessary technology to support object-oriented software engi-
neering practice, but it did not provide the process framework to guide project teams

in their application of the technology. Over the next few years, Jacobson, Rumbaugh,

and Booch developed the Unified Process,a framework for object-oriented softwareengineering using UML. Today, the Unified Process (UP) and UML are widely used on

object-oriented projects of all kinds. The iterative, incremental model proposed by the

UP can and should be adapted to meet specific project needs. 2.5.2Phases of the Unified Process
19Earlier in this chapter, I discussed five generic framework activities and argued that

they may be used to describe any software process model. The Unified Process is no
exception. Figure 2.9depicts the ÒphasesÓ of the UP and relates them to the generic

activities that have been discussed in Chapter 1 and earlier in this chapter. 
54PART ONETHE SOFTWARE PROCESS18A 
use case(Chapter 5) is a text narrative or template that describes a system function or featurefrom the userÕs point of view. A use case is written by the user and serves as a basis for the creationof a more comprehensive requirements model.19The Unified Process is sometimes called the 
Rational Unified Process(RUP) after the Rational Cor-poration (subsequently acquired by IBM), an early contributor to the development and refinement
of the UP and a builder of complete environments (tools and technology) that support the process.pre75977_ch02.qxd  11/27/08  3:21 PM  Page 54
The inception phaseof the UP encompasses both customer communication andplanning activities. By collaborating with stakeholders, business requirements forthe software are identified; a rough architecture for the system is proposed; and a
plan for the iterative, incremental nature of the ensuing project is developed.

Fundamental business requirements are described through a set of preliminary use
cases (Chapter 5) that describe which features and functions each major class of
users desires. Architecture at this point is nothing more than a tentative outline of
major subsystems and the function and features that populate them. Later, the ar-

chitecture will be refined and expanded into a set of models that will represent
different views of the system. Planning identifies resources, assesses major risks,
defines a schedule, and establishes a basis for the phases that are to be applied as

the software increment is developed.The elaboration phase
encompasses the communication and modeling activities ofthe generic process model (Figure 2.9). Elaboration refines and expands the prelimi-
nary use cases that were developed as part of the inception phase and expands the
architectural representation to include five different views of the softwareÑthe use
case model, the requirements model, the design model, the implementation model,
and the deployment model. In some cases, elaboration creates an Òexecutable
architectural baselineÓ [Arl02] that represents a Òfirst cutÓ executable system.20Thearchitectural baseline demonstrates the viability of the architecture but does not
provide all features and functions required to use the system. In addition, the plan is

carefully reviewed at the culmination of the elaboration phase to ensure that scope,

risks, and delivery dates remain reasonable. Modifications to the plan are often made
at this time.CHAPTER 2PROCESS MODELS55Transition
Production
software incrementReleasemodelingconstructionplanningcommunicationdeploymentConstructionInceptionElaborationFIGURE2.9The UnifiedProcess
UP phases are similarin intent to the genericframework activities
defined in this book.20It is important to note that the architectural baseline is not a prototype in that it is not thrown away.
Rather, the baseline is fleshed out during the next UP phase.pre75977_ch02.qxd  11/27/08  3:21 PM  Page 55
The construction phaseof the UP is identical to the construction activity definedfor the generic software process. Using the architectural model as input, the con-struction phase develops or acquires the software components that will make each
use case operational for end users. To accomplish this, requirements and design

models that were started during the elaboration phase are completed to reflect the
final version of the software increment. All necessary and required features and
functions for the software increment (i.e., the release) are then implemented in
source code. As components are being implemented, unit tests21are designed andexecuted for each. In addition, integration activities (component assembly and inte-
gration testing) are conducted. Use cases are used to derive a suite of acceptance
tests that are executed prior to the initiation of the next UP phase.The transition phase
of the UP encompasses the latter stages of the generic con-struction activity and the first part of the generic deployment (delivery and feedback)
activity. Software is given to end users for beta testing and user feedback reports

both defects and necessary changes. In addition, the software team creates the nec-
essary support information (e.g., user manuals, troubleshooting guides, installation
procedures) that is required for the release. At the conclusion of the transition phase,

the software increment becomes a usable software release.The production phaseof the UP coincides with the deployment activity of thegeneric process. During this phase, the ongoing use of the software is monitored,

support for the operating environment (infrastructure) is provided, and defect reports

and requests for changes are submitted and evaluated.It is likely that at the same time the construction, transition, and productionphases are being conducted, work may have already begun on the next software
increment. This means that the five UP phases do not occur in a sequence, but rather

with staggered concurrency.
A software engineering workflow is distributed across all UP phases. In the con-text of UP, a 
workflowis analogous to a task set (described earlier in this chapter).That is, a workflow identifies the tasks required to accomplish an important software
engineering action and the work products that are produced as a consequence of
successfully completing the tasks. It should be noted that not every task identified for
a UP workflow is conducted for every software project. The team adapts the process
(actions, tasks, subtasks, and work products) to meet its needs. 2.6P
ERSONALAND
TEAMPROCESSMODELSThe best software process is one that is close to the people who will be doing the
work. If a software process model has been developed at a corporate or organiza-
tional level, it can be effective only if it is amenable to significant adaptation to meet56PART ONETHE SOFTWARE PROCESS21A comprehensive discussion of software testing (including 
unit tests) is presented in Chapters 17through 20.WebRef
An interestingdiscussion of the UP in
the context of agile
development can be
found at
www.ambysoft

.com/
unifiedprocess/
agileUP.html
.pre75977_ch02.qxd  11/27/08  3:21 PM  Page 56
the needs of the project team that is actually doing software engineering work. In anideal setting, you would create a process that best fits your needs, and at the same
time, meets the broader needs of the team and the organization. Alternatively, the

team itself can create its own process, and at the same time meet the narrower needs
of individuals and the broader needs of the organization. Watts Humphrey ([Hum97]

and [Hum00]) argues that it is possible to create a Òpersonal software processÓ
and/or a Òteam software process.Ó Both require hard work, training, and coordina-
tion, but both are achievable.222.6.1Personal Software Process(PSP)
Every developer uses some process to build computer software. The process may be
haphazard or ad hoc; may change on a daily basis; may not be efficient, effective, or

even successful; but a ÒprocessÓ does exist. Watts Humphrey [Hum97] suggests that

in order to change an ineffective personal process, an individual must move through

four phases, each requiring training and careful instrumentation. The Personal Soft-
ware Process(PSP) emphasizes personal measurement of both the work product thatis produced and the resultant quality of the work product. In addition PSP makes the
practitioner responsible for project planning (e.g., estimating and scheduling) and
empowers the practitioner to control the quality of all software work products that
are developed. The PSP model defines five framework activities: Planning.This activity isolates requirements and develops both size andresource estimates. In addition, a defect estimate (the number of defects
projected for the work) is made. All metrics are recorded on worksheets or
templates. Finally, development tasks are identified and a project schedule is

created.High-level design.
External specifications for each component to be con-structed are developed and a component design is created. Prototypes arebuilt when uncertainty exists. All issues are recorded and tracked.High-level design review.
Formal verification methods (Chapter 21) areapplied to uncover errors in the design. Metrics are maintained for all impor-
tant tasks and work results.Development.
The component-level design is refined and reviewed. Codeis generated, reviewed, compiled, and tested. Metrics are maintained for allimportant tasks and work results.Postmortem.
Using the measures and metrics collected (this is a substan-tial amount of data that should be analyzed statistically), the effectiveness ofthe process is determined. Measures and metrics should provide guidance for

modifying the process to improve its effectiveness.
CHAPTER 2PROCESS MODELS5722ItÕs worth noting the proponents of agile software development (Chapter 3) also argue that the
process should remain close to the team. They propose an alternative method for achieving this.uote:ÒA person who issuccessful has
simply formed the
habit of doing
things that
unsuccessful people
will not do.ÓDexterYager
WebRef
A wide array of
resources for PSP can
befound at 
www
.ipd.uka.de/PSP/.Whatframeworkactivities are used
during PSP??pre75977_ch02.qxd  11/27/08  3:21 PM  Page 57
PSP stresses the need to identify errors early and, just as important, to understandthe types of errors that you are likely to make. This is accomplished through a rigor-ous assessment activity performed on all work products you produce.PSP represents a disciplined, metrics-based approach to software engineeringthat may lead to culture shock for many practitioners. However, when PSP is prop-

erly introduced to software engineers [Hum96], the resulting improvement in soft-

ware engineering productivity and software quality are significant [Fer97]. However,

PSP has not been widely adopted throughout the industry. The reasons, sadly, have

more to do with human nature and organizational inertia than they do with the
strengths and weaknesses of the PSP approach. PSP is intellectually challenging and
demands a level of commitment (by practitioners and their managers) that is not al-
ways possible to obtain. Training is relatively lengthy, and training costs are high.

The required level of measurement is culturally difficult for many software people.Can PSP be used as an effective software process at a personal level? The answeris an unequivocal Òyes.Ó But even if PSP is not adopted in its entirely, many of the

personal process improvement concepts that it introduces are well worth learning. 
2.6.2Team Software Process(TSP)
Because many industry-grade software projects are addressed by a team of practi-
tioners, Watts Humphrey extended the lessons learned from the introduction of PSP

and proposed a Team Software Process
(TSP). The goal of TSP is to build a Òself-directedÓ project team that organizes itself to produce high-quality software.
Humphrey [Hum98] defines the following objectives for TSP:¥Build self-directed teams that plan and track their work, establish goals, and
own their processes and plans. These can be pure software teams or inte-
grated product teams (IPTs) of 3 to about 20 engineers. ¥Show managers how to coach and motivate their teams and how to help
them sustain peak performance. ¥Accelerate software process improvement by making CMM
23Level 5behavior normal and expected. ¥Provide improvement guidance to high-maturity organizations. 
¥Facilitate university teaching of industrial-grade team skills.A self-directed team has a consistent understanding of its overall goals and objec-

tives; defines roles and responsibilities for each team member; tracks quantitative
project data (about productivity and quality); identifies a team process that is appro-
priate for the project and a strategy for implementing the process; defines local stan-
dards that are applicable to the teamÕs software engineering work; continually

assesses risk and reacts to it; and tracks, manages, and reports project status.58PART ONETHE SOFTWARE PROCESSPSP emphasizes theneed to record and
analyze the types of
errors you make, so

that you can develop
strategies to eliminate
them.To form a self-directed

team, you must collab-
orate well internally

and communicate well
externally.
WebRef
Information on building
high-performance teams

using TSP and PSP can
be obtained at:
www.sei.cmu

.edu/tsp/.23The Capability Maturity Model (CMM), a measure of the effectiveness of a software process, is
discussed in Chapter 30.pre75977_ch02.qxd  11/27/08  3:21 PM  Page 58
TSP defines the following framework activities: project launch, high-level
design, implementation, integration and test,
and postmortem.Like theircounterparts in PSP (note that terminology is somewhat different), these activitiesenable the team to plan, design, and construct software in a disciplined manner
while at the same time quantitatively measuring the process and the product. The
postmortem sets the stage for process improvements.
TSPmakesuseofawidevarietyofscripts,forms,andstandardsthatservetoguide
teammembersintheirwork.ÒScriptsÓdefinespecificprocessactivities(i.e.,project

launch,design,implementation,integrationandsystemtesting,postmortem)andother

moredetailedworkfunctions(e.g.,developmentplanning,requirementsdevelopment,

softwareconfigurationmanagement,unittest)thatarepartoftheteamprocess.
TSP recognizes that the best software teams are self-directed.24Team members
set project objectives, adapt the process to meet their needs, control the project
schedule, and through measurement and analysis of the metrics collected, work con-

tinually to improve the teamÕs approach to software engineering.
Like PSP, TSP is a rigorous approach to software engineering that provides dis-
tinct and quantifiable benefits in productivity and quality. The team must make a full

commitment to the process and must undergo thorough training to ensure that the
approach is properly applied. 2.7P
ROCESSTECHNOLOGYOne or more of the process models discussed in the preceding sections must be
adapted for use by a software team. To accomplish this, 
process technology tools
havebeen developed to help software organizations analyze their current process,
organize work tasks, control and monitor progress, and manage technical quality.
Process technology tools allow a software organization to build an automatedmodel of the process framework, task sets, and umbrella activities discussed in
Section 2.1. The model, normally represented as a network, can then be analyzed to
determine typical workflow and examine alternative process structures that might
lead to reduced development time or cost.Once an acceptable process has been created, other process technology tools canbe used to allocate, monitor, and even control all software engineering activities,

actions, and tasks defined as part of the process model. Each member of a software
team can use such tools to develop a checklist of work tasks to be performed, work
products to be produced, and quality assurance activities to be conducted. The
process technology tool can also be used to coordinate the use of other software en-
gineering tools that are appropriate for a particular work task.CHAPTER 2PROCESS MODELS5924In Chapter 3 I discuss the importance of Òself-organizingÓ teams as a key element in agile software
development.TSP scripts defineelements of the team
process and activities
that occur within the
process.pre75977_ch02.qxd  11/27/08  3:21 PM  Page 59
60PART ONETHE SOFTWARE PROCESS25Tools noted here do not represent an endorsement, but rather a sampling of tools in this category.
In most cases, tool names are trademarked by their respective developers.Process Modeling Tools
Objective:If an organization works toimprove a business (or software) process, itmust first understand it. Process modeling tools (also calledprocess technologyor process management tools) areused to represent the key elements of a process so that it
can be better understood. Such tools can also provide links
to process descriptions that help those involved in the
process to understand the actions and work tasks that are
required to perform it. Process modeling tools provide links

to other tools that provide support to defined process

activities.Mechanics:Tools in this category allow a team to define
the elements of a unique process model (actions, tasks,work products, QA points), provide detailed guidance onthe content or description of each process element, and
then manage the process as it is conducted. In some cases,
the process technology tools incorporate standard project
management tasks such as estimating, scheduling,
tracking, and control.Representative Tools:
25Igrafx Process Tools
Ñtools that enable a team to map,measure, and model the software process(www.micrografx.com
)Adeptia BPM Server
Ñdesigned to manage, automate, and
optimize business processes (www.adeptia.com
)SpeedDev SuiteÑa collection of six tools with a heavy
emphasis on the management of communication and
modeling activities (www.speedev.com
)SOFTWARE
TOOLS2.8P
RODUCTAND
PROCESSIf the process is weak, the end product will undoubtedly suffer. But an obsessive over-
reliance on process is also dangerous. In a brief essay written many years ago, Mar-
garet Davis [Dav95a] makes timeless comments on the duality of product and process:About every ten years give or take five, the software community redefines Òthe problemÓ
by shifting its focus from product issues to process issues. Thus, we have embraced
structured programming languages (product) followed by structured analysis methods
(process) followed by data encapsulation (product) followed by the current emphasis
onthe Software Engineering InstituteÕs Software Development Capability Maturity 

Model (process) [followed by object-oriented methods, followed by agile software
development].While the natural tendency of a pendulum is to come to rest at a point midway be-tween two extremes, the software communityÕs focus constantly shifts because new force

is applied when the last swing fails. These swings are harmful in and of themselves be-
cause they confuse the average software practitioner by radically changing what it means
to perform the job let alone perform it well. The swings also do not solve Òthe problemÓ
for they are doomed to fail as long as product and process are treated as forming a
dichotomy instead of a duality.
There is precedence in the scientific community to advance notions of duality whencontradictions in observations cannot be fully explained by one competing theory or
another. The dual nature of light, which seems to be simultaneously particle and wave,

has been accepted since the 1920s when Louis de Broglie proposed it. I believe that thepre75977_ch02.qxd  11/27/08  3:21 PM  Page 60
observations we can make on the artifacts of software and its development demonstratea fundamental duality between product and process. You can never derive or understand

the full artifact, its context, use, meaning, and worth if you view it as only a process or

only a product . . .All of human activity may be a process, but each of us derives a sense of self-worthfrom those activities that result in a representation or instance that can be used or
appreciated either by more than one person, used over and over, or used in some other

context not considered. That is, we derive feelings of satisfaction from reuse of our prod-
ucts by ourselves or others.Thus, while the rapid assimilation of reuse goals into software development poten-tially increases the satisfaction software practitioners derive from their work, it also in-
creases the urgency for acceptance of the duality of product and process. Thinking of a
reusable artifact as only product or only process either obscures the context and ways to
use it or obscures the fact that each use results in product that will, in turn, be used as
input to some other software development activity. Taking one view over the other

dramatically reduces the opportunities for reuse and, hence, loses the opportunity for

increasing job satisfaction.People derive as much (or more) satisfaction from the creative process as they dofrom the end product. An artist enjoys the brush strokes as much as the framed re-
sult. A writer enjoys the search for the proper metaphor as much as the finished
book. As creative software professional, you should also derive as much satisfaction
from the process as the end product. The duality of product and process is one
important element in keeping creative people engaged as software engineering
continues to evolve.2.9S
UMMARYA generic process model for software engineering encompasses a set of framework
and umbrella activities, actions, and work tasks. Each of a variety of process models
can be described by a different process flowÑa description of how the framework
activities, actions, and tasks are organized sequentially and chronologically. Process

patterns can be used to solve common problems that are encountered as part of the
software process.Prescriptive process models have been applied for many years in an effort to bringorder and structure to software development. Each of these models suggests a some-
what different process flow, but all perform the same set of generic framework

activities: communication, planning, modeling, construction, and deployment.Sequential process models, such as the waterfall and V models, are the oldestsoftware engineering paradigms. They suggest a linear process flow that is often in-
consistent with modern realities (e.g., continuous change, evolving systems, tight

time lines) in the software world. They do, however, have applicability in situations

where requirements are well defined and stable.CHAPTER 2PROCESS MODELS61pre75977_ch02.qxd  11/27/08  3:21 PM  Page 61
Incremental process models are iterative in nature and produce working versionsof software quite rapidly. Evolutionary process models recognize the iterative, in-
cremental nature of most software engineering projects and are designed to accom-
modate change. Evolutionary models, such as prototyping and the spiral model,
produce incremental work products (or working versions of the software) quickly.

These models can be adopted to apply across all software engineering activitiesÑ
from concept development to long-term system maintenance.The concurrent process model allows a software team to represent iterativeandconcurrent elements of any process model. Specialized models include the

component-based model that emphasizes component reuse and assembly; the for-
mal methods model that encourages a mathematically based approach to software
development and verification; and the aspect-oriented model that accommodates
crosscutting concerns spanning the entire system architecture. The Unified Process
is a Òuse case driven, architecture-centric, iterative and incrementalÓ software

process designed as a framework for UML methods and tools.Personal and team models for the software process have been proposed. Bothemphasize measurement, planning, and self-direction as key ingredients for a suc-
cessful software process.PROBLEMSAND
POINTSTO
PONDER2.1.In the introduction to this chapter Baetjer notes: ÒThe process provides interaction
between users and designers, between users and evolving tools, and between designers andevolving tools [technology].Ó List five questions that (a) designers should ask users, (b) users
should ask designers, (c) users should ask themselves about the software product that is to be
built, (d) designers should ask themselves about the software product that is to be built and the
process that will be used to build it.2.2.Try to develop a set of actions for the communication activity. Select one action and define
a task set for it.
2.3.A common problem during communicationoccurs when you encounter two stakehold-ers who have conflicting ideas about what the software should be. That is, you have mutuallyconflicting requirements.Develop a process pattern (this would be a stage pattern) using thetemplate presented in Section 2.1.3 that addresses this problem and suggest an effective
approach to it.2.4.Do some research on PSP and present a brief presentation that describes the types ofmeasurements that an individual software engineer is asked to make and how those measure-ment can be used to improve personal effectiveness.
2.5.The use of ÒscriptsÓ (a required mechanism in TSP) is not universally praised within thesoftware community. Make a list of pros and cons regarding scripts and suggest at least two sit-
uations in which they would be useful and another two situations where they might provide less

benefit.2.6.Read [Nog00] and write a two- or three-page paper that discusses the impact of ÒchaosÓon software engineering.
2.7.Provide three examples of software projects that would be amenable to the waterfall
model. Be specific.62PART ONETHE SOFTWARE PROCESSpre75977_ch02.qxd  11/27/08  3:21 PM  Page 62
2.8.Provide three examples of software projects that would be amenable to the prototyping
model. Be specific.2.9.What process adaptations are required if the prototype will evolve into a deliverablesystem or product?
2.10.Provide three examples of software projects that would be amenable to the incremental
model. Be specific.
2.11.As you move outward along the spiral process flow, what can you say about the software
that is being developed or maintained?
2.12.Is it possible to combine process models? If so, provide an example.
2.13.The concurrent process model defines a set of Òstates.Ó Describe what these states rep-resent in your own words, and then indicate how they come into play within the concurrentprocess model.2.14.What are the advantages and disadvantages of developing software in which quality isÒgood enoughÓ? That is, what happens when we emphasize development speed over product
quality?2.15.Provide three examples of software projects that would be amenable to the component-
based model. Be specific.
2.16.It is possible to prove that a software component and even an entire program is correct.
So why doesnÕt everyone do this?

2.17.Are the Unified Process and UML the same thing? Explain your answer.
FURTHER
READINGSAND
INFORMATION
SOURCESMost software engineering textbooks consider traditional process models in some detail. Booksby Sommerville (Software Engineering,8th ed., Addison-Wesley, 2006), Pfleeger and Atlee
(Software Engineering, 3d ed., Prentice-Hall, 2005), and Schach (Object-Oriented and ClassicalSoftware Engineering,7th ed., McGraw-Hill, 2006) consider traditional paradigms and discuss
their strengths and weaknesses. Glass (Facts and Fallacies of Software Engineering,Prentice-Hall,2002) provides an unvarnished, pragmatic view of the software engineering process. Although

not specifically dedicated to process, Brooks (The Mythical Man-Month,2d ed., Addison-Wesley,
1995) presents age-old project wisdom that has everything to do with process.Firesmith and Henderson-Sellers (The OPEN Process Framework: An Introduction,
Addison-Wesley, 2001) present a general template for creating Òflexible, yet discipline software

processesÓ and discuss process attributes and objectives. Madachy (Software Process Dynamics,
Wiley-IEEE, 2008) discusses modeling techniques that allow the interrelated technical and

social elements of the software process to be analyzed. Sharpe and McDermott (Workflow Mod-

eling: Tools for Process Improvement and Application Development,
Artech House, 2001) present
tools for modeling both software and business processes.Lim (Managing Software Reuse,Prentice Hall, 2004) discusses reuse from a managerÕs
perspective. Ezran, Morisio, and Tully (
Practical Software Reuse, 
Springer, 2002) and Jacobson,

Griss, and Jonsson (Software Reuse,Addison-Wesley, 1997) present much useful information on
component-based development. Heineman and Council (Component-Based Software Engineer-
ing, Addison-Wesley, 2001) describe the process required to implement component-based
systems. Kenett and Baker (
Software Process Quality: Management and Control, Marcel Dekker,

1999) consider how quality management and process design are intimately connected to one
another.
Nygard (Release It!: Design and Deploy Production-Ready Software,
Pragmatic Bookshelf,2007) and Richardson and Gwaltney (Ship it! A Practical Guide to Successful Software Projects,
Pragmatic Bookshelf, 2005) present a broad collection of useful guidelines that are applicable to
the deployment activity.
CHAPTER 2PROCESS MODELS63pre75977_ch02.qxd  11/27/08  3:21 PM  Page 63
In addition to Jacobson, Rumbaugh, and BoochÕs seminal book on the Unified Process
[Jac99], books by Arlow and Neustadt (UML 2 and the Unified Process,Addison-Wesley, 2005),
Kroll and Kruchten (The Rational Unified Process Made Easy,
Addison-Wesley, 2003), and Farve
(UML and the Unified Process,IRM Press, 2003) provide excellent complementary information.
Gibbs (Project Management with the IBM Rational Unified Process,IBM Press, 2006) discussesproject management within the context of the UP.
A wide variety of information sources on software engineering and the software process areavailable on the Internet. An up-to-date list of World Wide Web references that are relevant to
the software process can be found at the SEPA website: 
www.mhhe.com/engcs/compsci/

pressman/professional/olc/ser.htm
.64PART ONETHE SOFTWARE PROCESSpre75977_ch02.qxd  11/27/08  3:21 PM  Page 64
In 2001, Kent Beck and 16 other noted software developers, writers, and con-
sultants [Bec01a] (referred to as the ÒAgile AllianceÓ) signed the ÒManifesto for
Agile Software Development.Ó It stated:We are uncovering better ways of developing software by doing it and helping others
do it. Through this work we have come to value: Individuals and interactions
over processes and tools
Working software
over comprehensive documentation
Customer collaboration
over contract negotiation
Responding to change
over following a plan
That is, while there is value in the items on the right, we value the items on the left more.65CHAPTER3AGILEDEVELOPMENTWhat is it?Agile software engi-neering combines a philosophy anda set of development guidelines. The
philosophy encourages customersatisfaction and early incremental delivery of

software; small, highly motivated project teams;
informal methods; minimal software engineer-

ing work products; and overall development
simplicity. The development guidelines stress

delivery over analysis and design (although

these activities are not discouraged), and active
and continuous communication between devel-
opers and customers.Who does it?Software engineers and otherproject stakeholders (managers, customers, end
users) work together on an agile teamÑa team
that is self-organizing and in control of its own
destiny. An agile team fosters communication

and collaboration among all who serve on it.
Why is it important?
The modern business envi-
ronment that spawns computer-based systems
and software products is fast-paced and ever-
changing. Agile software engineering repre-
sents a reasonable alternative to conventional
QUICKLOOKsoftware engineering for certain classes of soft-

ware and certain types of software projects. It

has been demonstrated to deliver successful sys-
tems quickly.
Whatarethesteps?
Agiledevelopmentmightbest
betermedÒsoftwareengineeringlite.ÓThebasic

frameworkactivitiesÑcommunication,planning,

modeling,construction,anddeploymentÑ

remain. But they morph into a minimal task set
that pushes the project team toward construction
and delivery (some would argue that this is

done at the expense of problem analysis and
solution design).What is the work product?
Both the customerand the software engineer have the same
viewÑthe only really important work product

isan operational Òsoftware incrementÓ that is

delivered to the customer on the appropriate
commitment date.How do I ensure that IÕve done it right?If theagile team agrees that the process works, and
the team produces deliverable software
increments that satisfy the customer, youÕve

done it right.KEYCONCEPTSAdaptive SoftwareDevelopment . . .81
agile process . . .68

Agile UnifiedProcess . . . . . . .89
agility . . . . . . . .67

Crystal . . . . . . . .85

DSDM . . . . . . . .84

Extreme Programming . . .72
pre75977_ch03.qxd  11/27/08  3:24 PM  Page 65
A manifesto is normally associated with an emerging political movementÑone
that attacks the old guard and suggests revolutionary change (hopefully for thebetter). In some ways, thatÕs exactly what agile development is all about.
Although the underlying ideas that guide agile development have been with us formany years, it has been less than two decades since these ideas have crystallized
into a Òmovement.Ó In essence, agile
1methods were developed in an effort to over-
come perceived and actual weaknesses in conventional software engineering. Agile

development can provide important benefits, but it is not applicable to all projects,

all products, all people, and all situations. It is also 
notantithetical to solid softwareengineering practice and can be applied as an overriding philosophy for all software

work.In the modern economy, it is often difficult or impossible to predict how a
computer-based system (e.g., a Web-based application) will evolve as time passes.

Market conditions change rapidly, end-user needs evolve, and new competitive

threats emerge without warning. In many situations, you wonÕt be able to define

requirements fully before the project begins. You must be agile enough to respond to

a fluid business environment.
Fluidity implies change, and change is expensive. Particularly if it is uncontrolled
or poorly managed. One of the most compelling characteristics of the agile approach
is its ability to reduce the costs of change throughout the software process.Does this mean that a recognition of challenges posed by modern realities causesyou to discard valuable software engineering principles, concepts, methods, and
tools? Absolutely not! Like all engineering disciplines, software engineering contin-
ues to evolve. It can be adapted easily to meet the challenges posed by a demand for
agility.
In a thought-provoking book on agile software development, Alistair Cockburn
[Coc02] argues that the prescriptive process models introduced in Chapter 2 have a
major failing: they forget the frailties of the people who build computer software.
Softwareengineers are not robots. They exhibit great variation in working styles; significant dif-
ferences in skill level, creativity, orderliness, consistency, and spontaneity. Some com-

municate well in written form, others do not. Cockburn argues that process models
can Òdeal with peopleÕs common weaknesses with [either] discipline or toleranceÓ and

that most prescriptive process models choose discipline. He states: ÒBecause consis-
tency in action is a human weakness, high discipline methodologies are fragile.ÓIf process models are to work, they must provide a realistic mechanism for en-
couraging the discipline that is necessary, or they must be characterized in a man-

ner that shows ÒtoleranceÓ for the people who do software engineering work.
Invariably, tolerant practices are easier for software people to adopt and sustain, but

(as Cockburn admits) they may be less productive. Like most things in life, trade-offs

must be considered.66PART ONETHE SOFTWARE PROCESSFDD . . . . . . . . . .86
Industrial XP . . .77

Lean SoftwareDevelopment . . .87
pair programming . . .76
project velocity . . . . . . .74
refactoring . . . . .75

Scrum . . . . . . . .82

stories . . . . . . . .74

XP process . . . . .73
1Agile methods are sometimes referred to as 
light methodsor leanmethods
.uote:ÒAgility: 1,everything else: 0.Ó
TomDeMarco
pre75977_ch03.qxd  11/27/08  3:24 PM  Page 66
3.1W
HAT
ISAGILITY?Just what is agility in the context of software engineering work? Ivar Jacobson[Jac02a] provides a useful discussion:
Agilityhas become todayÕs buzzword when describing a modern software process. Every-
one is agile. An agile team is a nimble team able to appropriately respond to changes.Change is what software development is very much about. Changes in the software be-
ing built, changes to the team members, changes because of new technology, changes of

all kinds that may have an impact on the product they build or the project that creates the
product. Support for changes should be built-in everything we do in software, something

we embrace because it is the heart and soul of software. An agile team recognizes that
software is developed by individuals working in teams and that the skills of these people,

their ability to collaborate is at the core for the success of the project.In JacobsonÕs view, the pervasiveness of change is the primary driver for agility. Soft-
ware engineers must be quick on their feet if they are to accommodate the rapid
changes that Jacobson describes.But agility is more than an effective response to change. It also encompasses thephilosophy espoused in the manifesto noted at the beginning of this chapter. It

encourages team structures and attitudes that make communication (among team
members, between technologists and business people, between software engineers

and their managers) more facile. It emphasizes rapid delivery of operational soft-
ware and de-emphasizes the importance of intermediate work products (not always
a good thing); it adopts the customer as a part of the development team and works
to eliminate the Òus and themÓ attitude that continues to pervade many software
projects; it recognizes that planning in an uncertain world has its limits and that a
project plan must be flexible.Agility can be applied to any software process. However, to accomplish this, it is
essential that the process be designed in a way that allows the project team to adapt
tasks and to streamline them, conduct planning in a way that understands the fluid-
ity of an agile development approach, eliminate all but the most essential work prod-
ucts and keep them lean, and emphasize an incremental delivery strategy that gets
working software to the customer as rapidly as feasible for the product type and
operational environment.
3.2A
GILITYANDTHE
COSTOF
CHANGEThe conventional wisdom in software development (supported by decades of expe-

rience) is that the cost of change increases nonlinearly as a project progresses
(Figure 3.1, solid black curve). It is relatively easy to accommodate a change when a
software team is gathering requirements (early in a project). A usage scenario might
have to be modified, a list of functions may be extended, or a written specification
can be edited. The costs of doing this work are minimal, and the time required willCHAPTER 3AGILE DEVELOPMENT67DonÕt make themistake of assuming
that agility gives you
license to hack out
solutions. A process is
required and discipline
is essential.pre75977_ch03.qxd  11/27/08  3:24 PM  Page 67
not adversely affect the outcome of the project. But what if we fast-forward a num-ber of months? The team is in the middle of validation testing (something that occurs
relatively late in the project), and an important stakeholder is requesting a major
functional change. The change requires a modification to the architectural design of
the software, the design and construction of three new components, modifications

to another five components, the design of new tests, and so on. Costs escalate
quickly, and the time and cost required to ensure that the change is made without

unintended side effects is nontrivial.Proponents of agility (e.g., [Bec00], [Amb04]) argue that a well-designed agileprocess ÒflattensÓ the cost of change curve (Figure 3.1, shaded, solid curve), allowing
a software team to accommodate changes late in a software project without dramatic
cost and time impact. YouÕve already learned that the agile process encompasses in-

cremental delivery. When incremental delivery is coupled with other agile practices

such as continuous unit testing and pair programming (discussed later in this chap-
ter), the cost of making a change is attenuated. Although debate about the degree to
which the cost curve flattens is ongoing, there is evidence [Coc01a] to suggest that a
significant reduction in the cost of change can be achieved.3.3W
HAT
ISAN
AGILEPROCESS?Any agile software process is characterized in a manner that addresses a number of
key assumptions [Fow02] about the majority of software projects: 1.It is difficult to predict in advance which software requirements will persist
and which will change. It is equally difficult to predict how customer
priorities will change as the project proceeds.68PART ONETHE SOFTWARE PROCESSCost of changeusing conventional
software processesCost of change
using agile processesIdealized cost of change
using agile processDevelopment schedule progress
Development costFIGURE3.1Change costs
as a function
of time in
developmentuote:ÒAgility is dynamic,content specific,
aggressively
change embracing,
and growth
oriented.ÓÐStevenGoldman et al.An agile processreduces the cost of
change because
software is released in
increments and change
can be better
controlled within an
increment.pre75977_ch03.qxd  11/27/08  3:24 PM  Page 68
2.For many types of software, design and construction are interleaved. That is,
both activities should be performed in tandem so that design models are
proven as they are created. It is difficult to predict how much design is

necessary before construction is used to prove the design.
3.Analysis, design, construction, and testing are not as predictable (from a
planning point of view) as we might like.Given these three assumptions, an important question arises: How do we create a
process that can manage unpredictability?The answer, as I have already noted, lies
in process adaptability (to rapidly changing project and technical conditions). An
agile process, therefore, must be 
adaptable.But continual adaptation without forward progress accomplishes little. Therefore,
an agile software process must adapt incrementally.
To accomplish incremental adap-
tation, an agile team requires customer feedback (so that the appropriate adaptations
can be made). An effective catalyst for customer feedback is an operational prototype
or a portion of an operational system. Hence, an 
incremental development strategy

should be instituted. Software increments(executable prototypes or portions of an op-erational system) must be delivered in short time periods so that adaptation keeps pace
with change (unpredictability). This iterative approach enables the customer to evalu-
ate the software increment regularly, provide necessary feedback to the software team,

and influence the process adaptations that are made to accommodate the feedback.3.3.1Agility Principles
The Agile Alliance (see [Agi03], [Fow01]) defines 12 agility principles for those who
want to achieve agility: 1.Our highest priority is to satisfy the customer through early and continuous
delivery of valuable software.2.Welcome changing requirements, even late in development. Agile processes

harness change for the customerÕs competitive advantage.
3.Deliver working software frequently, from a couple of weeks to a couple of

months, with a preference to the shorter timescale.4.Business people and developers must work together daily throughout the
project.5.Build projects around motivated individuals. Give them the environment and

support they need, and trust them to get the job done.6.The most efficient and effective method of conveying information to and

within a development team is face-to-face conversation.
7.Working software is the primary measure of progress.
8.Agile processes promote sustainable development. The sponsors, developers,
and users should be able to maintain a constant pace indefinitely.
CHAPTER 3AGILE DEVELOPMENT69WebRef
A comprehensivecollection of articles on

the agile process 
can be found at
www.aanpo.org/

articles/index.Although agileprocesses embrace
change, it is still
important to examine

the reasons for
change.Working software is

important, but donÕt

forget that it must also
exhibit a variety of
quality attributes
including reliability,

usability, and 

maintainability.
pre75977_ch03.qxd  11/27/08  3:24 PM  Page 69
9.Continuous attention to technical excellence and good design enhancesagility.
10.SimplicityÑthe art of maximizing the amount of work not doneÑis 
essential.11.The best architectures, requirements, and designs emerge from selfÐ
organizing teams.12.At regular intervals, the team reflects on how to become more effective, then

tunes and adjusts its behavior accordingly.
Not every agile process model applies these 12 principles with equal weight, and
some models choose to ignore (or at least downplay) the importance of one or more
of the principles. However, the principles define an 
agile spiritthat is maintained ineach of the process models presented in this chapter.
3.3.2The Politicsof Agile Development
There is considerable debate (sometimes strident) about the benefits and applicabil-
ity of agile software development as opposed to more conventional software engi-

neering processes. Jim Highsmith [Hig02a] (facetiously) states the extremes when he
characterizes the feeling of the pro-agility camp (ÒagilistsÓ). ÒTraditional methodolo-

gists are a bunch of stick-in-the-muds whoÕd rather produce flawless documentation

than a working system that meets business needs.Ó As a counterpoint, he states
(again, facetiously) the position of the traditional software engineering camp: ÒLight-
weight, er, ÔagileÕ methodologists are a bunch of glorified hackers who are going to

be in for a heck of a surprise when they try to scale up their toys into enterprise-wide
software.ÓLike all software technology arguments, this methodology debate risks degener-ating into a religious war. If warfare breaks out, rational thought disappears and

beliefs rather than facts guide decision making.No one is against agility. The real question is: What is the best way to achieve it?
As important, how do you build software that meets customersÕ needs today and
exhibits the quality characteristics that will enable it to be extended and scaled to
meet customersÕ needs over the long term?
There are no absolute answers to either of these questions. Even within the agileschool itself, there are many proposed process models (Section 3.4), each with a
subtly different approach to the agility problem. Within each model there is a set of

ÒideasÓ (agilists are loath to call them Òwork tasksÓ) that represent a significant
departure from traditional software engineering. And yet, many agile concepts are
simply adaptations of good software engineering concepts. Bottom line: there is
much that can be gained by considering the best of both schools and virtually
nothing to be gained by denigrating either approach.If you have further interest, see [Hig01], [Hig02a], and [DeM02] for an entertain-ing summary of other important technical and political issues.70PART ONETHE SOFTWARE PROCESSYou donÕt have to
choose between agility
and software engi-
neering. Rather, define

a software engineering
approach that is agile.pre75977_ch03.qxd  11/27/08  3:24 PM  Page 70
3.3.3Human Factors
Proponents of agile software development take great pains to emphasize the impor-tance of Òpeople factors.Ó As Cockburn and Highsmith [Coc01a] state, ÒAgile devel-

opment focuses on the talents and skills of individuals, molding the process to
specific people and teams.Ó The key point in this statement is that the process molds
to the needs of the peopleand team,
not the other way around.2If members of the software team are to drive the characteristics of the process thatis applied to build software, a number of key traits must exist among the people on

an agile team and the team itself:Competence.In an agile development (as well as software engineering)context, ÒcompetenceÓ encompasses innate talent, specific software-related
skills, and overall knowledge of the process that the team has chosen to

apply. Skill and knowledge of process can and should be taught to all people

who serve as agile team members.Common focus.
Although members of the agile team may perform differ-ent tasks and bring different skills to the project, all should be focused on onegoalÑto deliver a working software increment to the customer within the
time promised. To achieve this goal, the team will also focus on continual

adaptations (small and large) that will make the process fit the needs of the
team.Collaboration.
Software engineering (regardless of process) is about as-sessing, analyzing, and using information that is communicated to the soft-ware team; creating information that will help all stakeholders understand
the work of the team; and building information (computer software and rele-
vant databases) that provides business value for the customer. To accomplish

these tasks, team members must collaborateÑwith one another and all other
stakeholders.Decision-making ability.
Any good software team (including agile teams)must be allowed the freedom to control its own destiny. This implies that the
team is given autonomyÑdecision-making authority for both technical and
project issues.Fuzzy problem-solving ability.
Software managers must recognize thatthe agile team will continually have to deal with ambiguity and will continu-
ally be buffeted by change. In some cases, the team must accept the fact that
the problem they are solving today may not be the problem that needs to be
solved tomorrow. However, lessons learned from any problem-solving
CHAPTER 3AGILE DEVELOPMENT712Successful software engineering organizations recognize this reality regardless of the process
model they choose.uote:ÒAgile methodsderive much of
their agility by
relying on the
tacitknowledge

embodied in the
team, rather than
writing the
knowledge down
inplans.Ó
BarryBoehm
What keytraits mustexist among the
people on an
effective software
team??uote:ÒWhat counts as
barely sufficient
for one team is
either overly
sufficient or
insufficient for
another.Ó
AlistairCockburnpre75977_ch03.qxd  11/27/08  3:24 PM  Page 71
activity (including those that solve the wrong problem) may be of benefit tothe team later in the project.Mutual trust and respect.
The agile team must become what DeMarcoand Lister [DeM98] call a ÒjelledÓ team (Chapter 24). A jelled team exhibitsthe trust and respect that are necessary to make them Òso strongly knit that
the whole is greater than the sum of the parts.Ó [DeM98]Self-organization.
In the context of agile development, self-organizationimplies three things: (1) the agile team organizes itself for the work to bedone, (2) the team organizes the process to best accommodate its local envi-

ronment, (3) the team organizes the work schedule to best achieve delivery
of the software increment. Self-organization has a number of technical bene-
fits, but more importantly, it serves to improve collaboration and boost team

morale. In essence, the team serves as its own management. Ken Schwaber

[Sch02] addresses these issues when he writes: ÒThe team selects how much
work it believes it can perform within the iteration, and the team commits to
the work. Nothing demotivates a team as much as someone else making
commitments for it. Nothing motivates a team as much as accepting the
responsibility for fulfilling commitments that it made itself.Ó3.4E
XTREMEPROGRAMMING(XP)In order to illustrate an agile process in a bit more detail, IÕll provide you with an

overview of 
Extreme Programming
(XP), the most widely used approach to agile soft-ware development. Although early work on the ideas and methods associated with
XP occurred during the late 1980s, the seminal work on the subject has been written
by Kent Beck [Bec04a]. More recently, a variant of XP, called 
Industrial XP(IXP) hasbeen proposed [Ker05]. IXP refines XP and targets the agile process specifically for

use within large organizations.3.4.1XP Values
Beck [Bec04a] defines a set of five valuesthat establish a foundation for all work per-formed as part of XPÑcommunication, simplicity, feedback, courage, and respect. Each

of these values is used as a driver for specific XP activities, actions, and tasks.In order to achieve effective communication
between software engineers andother stakeholders (e.g., to establish required features and functions for the soft-
ware), XP emphasizes close, yet informal (verbal) collaboration between customers

and developers, the establishment of effective metaphors3for communicatingimportant concepts, continuous feedback, and the avoidance of voluminous docu-
mentation as a communication medium.72PART ONETHE SOFTWARE PROCESSA self-organizing teamis in control of the
work it performs. The

team makes its own
commitments and
defines plans to
achieve them.3In the XP context, a 
metaphoris Òa story that everyoneÑcustomers, programmers, and managersÑcan tell about how the system worksÓ [Bec04a].pre75977_ch03.qxd  11/27/08  3:24 PM  Page 72
To achieve 
simplicity,
XP restricts developers to design only for immediate needs,rather than consider future needs. The intent is to create a simple design that can beeasily implemented in code). If the design must be improved, it can be 
refactored4ata later time.Feedback
is derived from three sources: the implemented software itself, thecustomer, and other software team members. By designing and implementing an

effective testing strategy (Chapters 17 through 20), the software (via test results) pro-
vides the agile team with feedback. XP makes use of the unit testas its primary test-ing tactic. As each class is developed, the team develops a unit test to exercise each
operation according to its specified functionality. As an increment is delivered to a

customer, the 
user storiesor use cases(Chapter 5) that are implemented by theincrement are used as a basis for acceptance tests. The degree to which the software
implements the output, function, and behavior of the use case is a form of feedback.
Finally, as new requirements are derived as part of iterative planning, the team pro-

vides the customer with rapid feedback regarding cost and schedule impact.Beck [Bec04a] argues that strict adherence to certain XP practices demandscourage.
A better word might be discipline.For example, there is often significant
pressure to design for future requirements. Most software teams succumb, arguing

that Òdesigning for tomorrowÓ will save time and effort in the long run. An agile XP
team must have the discipline (courage) to design for today, recognizing that future

requirements may change dramatically, thereby demanding substantial rework of

the design and implemented code.By following each of these values, the agile team inculcates respectamong itmembers, between other stakeholders and team members, and indirectly, for the

software itself. As they achieve successful delivery of software increments, the team
develops growing respect for the XP process.3.4.2The XP Process
Extreme Programming uses an object-oriented approach (Appendix 2) as its pre-
ferred development paradigm and encompasses a set of rules and practices that
occur within the context of four framework activities: planning, design, coding, and
testing. Figure 3.2illustrates the XP process and notes some of the key ideas and

tasks that are associated with each framework activity. Key XP activities are sum-

marized in the paragraphs that follow.
Planning.The planning activity (also called the planning game) begins withlisteningÑa requirements gathering activity that enables the technical members ofthe XP team to understand the business context for the software and to get a broadCHAPTER 3AGILE DEVELOPMENT734Refactoring allows a software engineer to improve the internal structure of a design (or source
code) without changing its external functionality or behavior. In essence, refactoring can be usedto improve the efficiency, readability, or performance of a design or the code that implements a
design.Keep it simplewhenever you can, but
recognize that
continual ÒrefactoringÓ
can absorb significant
time and resources.uote:ÒXP is the answerto the question,
ÔHow little can we
do and still build
great software?ÕÒAnonymousWebRef
An excellent overview
of ÒrulesÓ for XP can

be found at www
.extremeprogramm

ing.org/rules.html.pre75977_ch03.qxd  11/27/08  3:24 PM  Page 73
feel for required output and major features and functionality. Listening leads to the
creation of a set of ÒstoriesÓ (also called user stories) that describe required output,
features, and functionality for software to be built. Each story(similar to use casesdescribed in Chapter 5) is written by the customer and is placed on an index card.
The customer assigns a value(i.e., a priority) to the story based on the overall busi-
ness value of the feature or function.5Members of the XP team then assess eachstory and assign a costÑmeasured in development weeksÑto it. If the story is esti-
mated to require more than three development weeks, the customer is asked to split
the story into smaller stories and the assignment of value and cost occurs again. It
is important to note that new stories can be written at any time.Customers and developers work together to decide how to group stories into thenext release (the next software increment) to be developed by the XP team. Once a
basic commitment(agreement on stories to be included, delivery date, and other
project matters) is made for a release, the XP team orders the stories that will be de-

veloped in one of three ways: (1) all stories will be implemented immediately (within
a few weeks), (2) the stories with highest value will be moved up in the schedule and

implemented first, or (3) the riskiest stories will be moved up in the schedule and

implemented first.After the first project release (also called a software increment) has been deliv-ered, the XP team computes project velocity. Stated simply, 
project velocityis the74PART ONETHE SOFTWARE PROCESSuser stories values
 acceptance test criteria

iteration plansimple design
 CRC cardsunit test
 continuous integrationsoftware increment
 project velocity computedspike solutions
 prototypesrefactoringpair programmingacceptance testingReleasedesigncodingplanningtestFIGURE3.2The Extreme
Programming

process
5The value of a story may also be dependent on the presence of another story.
WebRef
A worthwhile XP
Òplanning gameÓ can
be found at:
c2.com/cgi/
wiki?planningGame.What is anXP ÒstoryÓ?
?pre75977_ch03.qxd  11/27/08  3:24 PM  Page 74
number of customer stories implemented during the first release. Project velocity canthen be used to (1) help estimate delivery dates and schedule for subsequent releases
and (2) determine whether an overcommitment has been made for all stories across

the entire development project. If an overcommitment occurs, the content of releases

is modified or end delivery dates are changed.As development work proceeds, the customer can add stories, change the valueof an existing story, split stories, or eliminate them. The XP team then reconsiders all

remaining releases and modifies its plans accordingly.
Design.XP design rigorously follows the KIS (keep it simple) principle. A simpledesign is always preferred over a more complex representation. In addition, the de-
sign provides implementation guidance for a story as it is writtenÑnothing less,

nothing more. The design of extra functionality (because the developer assumes it
will be required later) is discouraged.6XP encourages the use of CRC cards (Chapter 7) as an effective mechanism forthinking about the software in an object-oriented context. CRC (class-responsibility-
collaborator) cards identify and organize the object-oriented classes7that are rele-vant to the current software increment. The XP team conducts the design exercise
using a process similar to the one described in Chapter 8. The CRC cards are the only
design work product produced as part of the XP process.If a difficult design problem is encountered as part of the design of a story, XP rec-
ommends the immediate creation of an operational prototype of that portion of the
design. Called a spike solution
, the design prototype is implemented and evaluated.
The intent is to lower risk when true implementation starts and to validate the orig-
inal estimates for the story containing the design problem.In the preceding section, we noted that XP encourages refactoringÑa constructiontechnique that is also a method for design optimization. Fowler [Fow00] describes
refactoring in the following manner:Refactoring is the process of changing a software system in such a way that it does notalter the external behavior of the code yet improves the internal structure. It is a disci-

plined way to clean up code [and modify/simplify the internal design] that minimizes the
chances of introducing bugs. In essence, when you refactor you are improving the design

of the code after it has been written.Because XP design uses virtually no notation and produces few, if any, work prod-
ucts other than CRC cards and spike solutions, design is viewed as a transient arti-
fact that can and should be continually modified as construction proceeds. The intent
of refactoring is to control these modifications by suggesting small design changesCHAPTER 3AGILE DEVELOPMENT75Project velocity is asubtle measure of
team productivity.
6These design guidelines should be followed in every software engineering method, although there
are times when sophisticated design notation and terminology may get in the way of simplicity.7Object-oriented classes are discussed in Appendix 2, in Chapter 8, and throughout Part 2 of this
book.XP deemphasizes the
importance of design.

Not everyone agrees.

In fact, there are times
when design should be
emphasized.WebRef
Refactoring techniquesand tools can be
foundat:

www.refactoring

.com.pre75977_ch03.qxd  11/27/08  3:24 PM  Page 75
that Òcan radically improve the designÓ [Fow00]. It should be noted, however, that
the effort required for refactoring can grow dramatically as the size of an application
grows.A central notion in XP is that design occurs both before and aftercoding com-mences. Refactoring means that design occurs continuously as the system is con-
structed. In fact, the construction activity itself will provide the XP team with

guidance on how to improve the design.
Coding.After stories are developed and preliminary design work is done, the team
does notmove to code, but rather develops a series of unit tests that will exercise
each of the stories that is to be included in the current release (software increment).8Once the unit test9has been created, the developer is better able to focus on whatmust be implemented to pass the test. Nothing extraneous is added (KIS). Once thecode is complete, it can be unit-tested immediately, thereby providing instantaneous

feedback to the developers.A key concept during the coding activity (and one of the most talked about aspectsof XP) is pair programming
. XP recommends that two people work together at one
computer workstation to create code for a story. This provides a mechanism for real-

time problem solving (two heads are often better than one) and real-time quality as-
surance (the code is reviewed as it is created). It also keeps the developers focused
on the problem at hand. In practice, each person takes on a slightly different role. For

example, one person might think about the coding details of a particular portion of

the design while the other ensures that coding standards (a required part of XP) are
being followed or that the code for the story will satisfy the unit test that has been
developed to validate the code against the story.
As pair programmers complete their work, the code they develop is integratedwith the work of others. In some cases this is performed on a daily basis by an inte-
gration team. In other cases, the pair programmers have integration responsibility.

This Òcontinuous integrationÓ strategy helps to avoid compatibility and interfacing
problems and provides a Òsmoke testingÓ environment (Chapter 17) that helps to

uncover errors early.
Testing.
I have already noted that the creation of unit tests before coding com-mences is a key element of the XP approach. The unit tests that are created shouldbe implemented using a framework that enables them to be automated (hence, they

can be executed easily and repeatedly). This encourages a regression testing strat-
egy (Chapter 17) whenever code is modified (which is often, given the XP refactor-
ing philosophy).76PART ONETHE SOFTWARE PROCESSRefactoring improvesthe internal structure of

a design (or source
code) without
changing its external

functionality or
behavior.
WebRef
Useful information on
XP can be obtained 
at www
.xprogramming.
com.8This approach is analogous to knowing the exam questions before you begin to study. It makes
studying much easier by focusing attention only on the questions that will be asked.9Unit testing, discussed in detail in Chapter 17, focuses on an individual software component, exer-
cising the componentÕs interface, data structures, and functionality in an effort to uncover errorsthat are local to the component.What is pairprogramming??Many software teams
are populated by indi-
vidualists. YouÕll have

to work to change that
culture if pair program-
ming is to work effec-
tively.
How are unittests used inXP??pre75977_ch03.qxd  11/27/08  3:24 PM  Page 76
As the individual unit tests are organized into a Òuniversal testing suiteÓ [Wel99],
integration and validation testing of the system can occur on a daily basis. This pro-vides the XP team with a continual indication of progress and also can raise warn-
ing flags early if things go awry. Wells [Wel99] states: ÒFixing small problems every

few hours takes less time than fixing huge problems just before the deadline.ÓXP acceptance tests, also called customer tests,are specified by the customer andfocus on overall system features and functionality that are visible and reviewable by

the customer. Acceptance tests are derived from user stories that have been imple-

mented as part of a software release.3.4.3Industrial XP
Joshua Kerievsky [Ker05] describes 
Industrial Extreme Programming
(IXP) in the fol-lowing manner: ÒIXP is an organic evolution of XP. It is imbued with XPÕs minimal-

ist, customer-centric, test-driven spirit. IXP differs most from the original XP in its

greater inclusion of management, its expanded role for customers, and its upgraded
technical practices.Ó IXP incorporates six new practices that are designed to help
ensure that an XP project works successfully for significant projects within a large
organization.Readiness assessment.Prior to the initiation of an IXP project, the organ-ization should conduct a readiness assessment.The assessment ascertainswhether (1) an appropriate development environment exists to support IXP,

(2) the team will be populated by the proper set of stakeholders, (3) the or-
ganization has a distinct quality program and supports continuous improve-

ment, (4) the organizational culture will support the new values of an agile
team, and (5) the broader project community will be populated appropriately.
Project community.
Classic XP suggests that the right people be used topopulate the agile team to ensure success. The implication is that people onthe team must be well-trained, adaptable and skilled, and have the proper
temperament to contribute to a self-organizing team. When XP is to be
applied for a significant project in a large organization, the concept of the
ÒteamÓ should morph into that of a community.
A community may have atechnologist and customers who are central to the success of a project as
well as many other stakeholders (e.g., legal staff, quality auditors, manufac-
turing or sales types) who Òare often at the periphery of an IXP project yet
they may play important roles on the projectÓ [Ker05]. In IXP, the community

members and their roles should be explicitly defined and mechanisms for
communication and coordination between community members should be
established.Project chartering.
The IXP team assesses the project itself to determinewhether an appropriate business justification for the project exists andwhether the project will further the overall goals and objectives of the
CHAPTER 3AGILE DEVELOPMENT77XP acceptance testsare derived from user
stories.What new
practices areappended to XP
to create IXP??uote:ÒAbility is what
youÕre capable of
doing. Motivation
determines what
you do. Attitude
determines how
well you do it.ÓLouHoltz
pre75977_ch03.qxd  11/27/08  3:24 PM  Page 77
organization. Chartering also examines the context of the project to deter-mine how it complements, extends, or replaces existing systems or
processes.Test-driven management.
An IXP project requires measurable criteria forassessing the state of the project and the progress that has been made todate. Test-driven management establishes a series of measurable Òdestina-

tionsÓ [Ker05] and then defines mechanisms for determining whether or not

these destinations have been reached.Retrospectives.
An IXP team conducts a specialized technical review(Chapter 15) after a software increment is delivered. Called a retrospective,the review examines Òissues, events, and lessons-learnedÓ [Ker05] across a

software increment and/or the entire software release. The intent is to
improve the IXP process.
Continuous learning.Because learning is a vital part of continuousprocess improvement, members of the XP team are encouraged (and possi-
bly, incented) to learn new methods and techniques that can lead to a higher-

quality product.In addition to the six new practices discussed, IXP modifies a number of existingXP practices. Story-driven development(SDD) insists that stories for acceptance testsbe written before a single line of code is generated. Domain-driven design(DDD) isan improvement on the Òsystem metaphorÓ concept used in XP. DDD [Eva03] sug-

gests the evolutionary creation of a domain model that Òaccurately represents how
domain experts think about their subjectÓ [Ker05]. 
Pairing
extends the XP pair-programming concept to include managers and other stakeholders. The intent is to
improve knowledge sharing among XP team members who may not be directly in-

volved in technical development. Iterative usability
discourages front-loaded inter-face design in favor of usability design that evolves as software increments are
delivered and usersÕ interaction with the software is studied.IXP makes smaller modifications to other XP practices and redefines certain rolesand responsibilities to make them more amenable to significant projects for large
organizations. For further discussion of IXP, visit 
http://industrialxp.org
.3.4.4The XP Debate
All new process models and methods spur worthwhile discussion and in some in-
stances heated debate. Extreme Programming has done both. In an interesting book
that examines the efficacy of XP, Stephens and Rosenberg [Ste03] argue that many

XP practices are worthwhile, but others have been overhyped, and a few are prob-

lematic. The authors suggest that the codependent nature of XP practices are both
its strength and its weakness. Because many organizations adopt only a subset of XP
practices, they weaken the efficacy of the entire process. Proponents counter that
XPis continuously evolving and that many of the issues raised by critics have been
78PART ONETHE SOFTWARE PROCESSpre75977_ch03.qxd  11/27/08  3:24 PM  Page 78
addressed as XP practice matures. Among the issues that continue to trouble somecritics of XP are:10¥Requirements volatility. Because the customer is an active member of the XP
team, changes to requirements are requested informally. As a consequence,

the scope of the project can change and earlier work may have to be
modified to accommodate current needs. Proponents argue that this happens
regardless of the process that is applied and that XP provides mechanisms for

controlling scope creep.¥Conflicting customer needs. Many projects have multiple customers, each with
his own set of needs. In XP, the team itself is tasked with assimilating the

needs of different customers, a job that may be beyond their scope of
authority.
¥Requirements are expressed informally. User stories and acceptance tests arethe only explicit manifestation of requirements in XP. Critics argue that a

more formal model or specification is often needed to ensure that omissions,
inconsistencies, and errors are uncovered before the system is built. Propo-

nents counter that the changing nature of requirements makes such models
and specification obsolete almost as soon as they are developed.¥Lack of formal design
. XP deemphasizes the need for architectural design and
in many instances, suggests that design of all kinds should be relatively
informal. Critics argue that when complex systems are built, design must be
emphasized to ensure that the overall structure of the software will exhibit

quality and maintainability. XP proponents suggest that the incremental

nature of the XP process limits complexity (simplicity is a core value) and
therefore reduces the need for extensive design.You should note that every software process has flaws and that many software or-

ganizations have used XP successfully. The key is to recognize where a process may

have weaknesses and to adapt it to the specific needs of your organization.CHAPTER 3AGILE DEVELOPMENT7910For a detailed look at some thoughtful criticism that has been leveled at XP, visit
www.softwarereality.com/ExtremeProgramming.jsp.What aresome of theissues that lead to
an XP debate??The scene:Doug MillerÕs office.
The Players:Doug Miller, software engineering
manager; Jamie Lazar, software team member; Vinod
Raman, software team member.
The conversation:(A knock on the door, Jamie and Vinod enter DougÕs office)

Jamie:Doug, you got a minute?SAFEHOMEConsidering Agile Software Development
pre75977_ch03.qxd  11/27/08  3:24 PM  Page 79
3.5O
THERAGILEPROCESSMODELSThe history of software engineering is littered with dozens of obsolete processdescriptions and methodologies, modeling methods and notations, tools, and
technology. Each flared in notoriety and was then eclipsed by something new and

(purportedly) better. With the introduction of a wide array of agile process modelsÑ

each contending for acceptance within the software development communityÑthe
agile movement is following the same historical path.
11As I noted in the last section, the most widely used of all agile process modelsisExtreme Programming (XP). But many other agile process models have been

proposed and are in use across the industry. Among the most common are:
¥Adaptive Software Development (ASD)¥Scrum¥Dynamic Systems Development Method (DSDM)80PART ONETHE SOFTWARE PROCESSDoug:Sure Jamie, whatÕs up?
Jamie:WeÕve been thinking about our process
discussion yesterday . . . you know, what process weÕre
going to choose for this new SafeHomeproject.Doug:And?Vinod:
I was talking to a friend at another company,
and he was telling me about Extreme Programming. ItÕs

an agile process model . . . heard of it?Doug:Yeah, some good, some bad.
Jamie:Well, it sounds pretty good to us. Lets you
develop software really fast, uses something called pairprogramming to do real-time quality checks . . . itÕs pretty

cool, I think.Doug:It does have a lot of really good ideas. I like thepair-programming concept, for instance, and the ideathat stakeholders should be part of the team.
Jamie:Huh? You mean that marketing will work on the
project team with us?
Doug (nodding):TheyÕre a stakeholder, arenÕt they?
Jamie:Jeez . . . theyÕll be requesting changes every five
minutes.
Vinod:
Not necessarily. My friend said that there are
ways to ÒembraceÓ changes during an XP project.Doug:So you guys think we should use XP?Jamie:ItÕs definitely worth considering.
Doug:I agree. And even if we choose an incrementalmodel as our approach, thereÕs no reason why we canÕt
incorporate much of what XP has to offer.
Vinod:
Doug, before you said Òsome good, some bad.ÓWhat was the ÒbadÓ?
Doug:The thing I donÕt like is the way XP downplays
analysis and design . . . sort of says that writing code is
where the action is . . . (The team members look at one another and smile.)
Doug:So you agree with the XP approach?Jamie (speaking for both):Writing code is what
we do, Boss!
Doug (laughing):True, but IÕd like to see you spend a
little less time coding and then recoding and a little moretime analyzing what has to be done and designing a
solution that works.Vinod:
Maybe we can have it both ways, agility with alittle discipline.
Doug:I think we can, Vinod. In fact, IÕm sure of it.
uote:ÒOur professiongoes through
methodologies like
a 14-year-old goes

through clothing.ÓStephenHawrysh and

JimRuprecht
11This is not a bad thing. Before one or more models or methods are accepted as a de facto standard,
all must contend for the hearts and minds of software engineers. The ÒwinnersÓ evolve into bestpractice, while the ÒlosersÓ either disappear or merge with the winning models.pre75977_ch03.qxd  11/27/08  3:24 PM  Page 80
¥Crystal¥Feature Drive Development (FDD)¥Lean Software Development (LSD)¥Agile Modeling (AM)¥Agile Unified Process (AUP)
In the sections that follow, I present a very brief overview of each of these agile
process models. It is important to note that allagile process models conform (to agreater or lesser degree) to the Manifesto for Agile Software Developmentand the prin-ciples noted in Section 3.3.1. For additional detail, refer to the references noted in
each subsection or for a survey, examine the Òagile software developmentÓ entry

inWikipedia.
123.5.1Adaptive Software Development(ASD)
Adaptive Software Development(ASD) has been proposed by Jim Highsmith [Hig00] asa technique for building complex software and systems. The philosophical under-
pinnings of ASD focus on human collaboration and team self-organization.Highsmith argues that an agile, adaptive development approach based on collab-
oration is Òas much a source of order
in our complex interactions as discipline andengineering.Ó He defines an ASD Òlife cycleÓ (Figure 3.3) that incorporates three
phases, speculation, collaboration, and learning.CHAPTER 3AGILE DEVELOPMENT8112See http:/
/en.wikipedia.org/wiki/Agile_software_development#Agile_methods.WebRef
Useful resources forASD can be found at
www.adaptivesd

.com.adaptive cycle planning mission statement

 project constraints

 basic requirements

time-boxed release plancomponents implemented/tested
 focus groups for feedback

 formal technical reviews

postmortems
Requirements gathering
 JAD
 mini-specssoftware increment
 adjustments for subsequent cyclesReleasecollaborationspeculationlearningFIGURE3.3Adaptivesoftware

developmentpre75977_ch03.qxd  11/27/08  3:24 PM  Page 81
During speculation,the project is initiated and adaptive cycle planningis con-ducted. Adaptive cycle planning uses project initiation informationÑthe customerÕs
mission statement, project constraints (e.g., delivery dates or user descriptions), and
basic requirementsÑto define the set of release cycles (software increments) that
will be required for the project.No matter how complete and farsighted the cycle plan, it will invariably change.
Based on information obtained at the completion of the first cycle, the plan is re-

viewed and adjusted so that planned work better fits the reality in which an ASD
team is working.Motivated people use collaboration
in a way that multiplies their talent and cre-ative output beyond their absolute numbers. This approach is a recurring theme in
all agile methods. But collaboration is not easy. It encompasses communication and

teamwork, but it also emphasizes individualism, because individual creativity plays
an important role in collaborative thinking. It is, above all, a matter of trust. People

working together must trust one another to (1) criticize without animosity, (2) assist

without resentment, (3) work as hard as or harder than they do, (4) have the skill set
to contribute to the work at hand, and (5) communicate problems or concerns in a
way that leads to effective action.As members of an ASD team begin to develop the components that are part of anadaptive cycle, the emphasis is on ÒlearningÓ as much as it is on progress toward

acompleted cycle. In fact, Highsmith [Hig00] argues that software developers often

overestimate their own understanding (of the technology, the process, and the proj-

ect) and that learning will help them to improve their level of real understanding.

ASD teams learn in three ways: focus groups (Chapter 5), technical reviews (Chap-
ter 14), and project postmortems.The ASD philosophy has merit regardless of the process model that is used. ASDÕs
overall emphasis on the dynamics of self-organizing teams, interpersonal collabo-

ration, and individual and team learning yield software project teams that have a
much higher likelihood of success.3.5.2Scrum
Scrum (the name is derived from an activity that occurs during a rugby match13)is
an agile software development method that was conceived by Jeff Sutherland and his
development team in the early 1990s. In recent years, further development on the
Scrum methods has been performed by Schwaber and Beedle [Sch01a].Scrum principles are consistent with the agile manifesto and are used to guidedevelopment activities within a process that incorporates the following framework
activities: requirements, analysis, design, evolution, and delivery. Within each
82PART ONETHE SOFTWARE PROCESSEffective collaborationwith your customer will
only occur if you
jettison any Òus and
themÓ attitudes.ASD emphasizeslearning as a key

element in achieving 
a Òself-organizingÓ
team.13A group of players forms around the ball and the teammates work together (sometimes violently!)
to move the ball downfield.WebRef
Useful Scrum
information and

resources can be found
at www
.controlchaos.com.pre75977_ch03.qxd  11/27/08  3:24 PM  Page 82
every 24
hours30 daysScrum: 15 minute daily meeting.Team members respond to basics:

1) What did you do since last Scrum
 meeting?
2) Do you have any obstacles?
3) What will you do before next
 meeting?Sprint Backlog:Feature(s)
assigned
to sprintProduct Backlog:Prioritized product features desired by the customerBacklogitemsexpandedby teamNew functionalityis demonstratedat end of sprintframework activity, work tasks occur within a process pattern (discussed in the fol-
lowing paragraph) called a sprint.The work conducted within a sprint (the numberof sprints required for each framework activity will vary depending on product com-
plexity and size) is adapted to the problem at hand and is defined and often modified
in real time by the Scrum team. The overall flow of the Scrum process is illustrated

in Figure 3.4.Scrum emphasizes the use of a set of software process patterns [Noy02] that haveproven effective for projects with tight timelines, changing requirements, and business

criticality. Each of these process patterns defines a set of development actions:
Backlog
Ña prioritized list of project requirements or features that provide busi-
ness value for the customer. Items can be added to the backlog at any time (this is

how changes are introduced). The product manager assesses the backlog and
updates priorities as required.SprintsÑconsist of work units that are required to achieve a requirement de-fined in the backlog that must be fit into a predefined time-box14(typically 30 days).CHAPTER 3AGILE DEVELOPMENT8314A 
time-boxis a project management term (see Part 4 of this book) that indicates a period of timethat has been allocated to accomplish some task.FIGURE3.4Scrum process
flowScrum incorporates a
set of process patterns

that emphasize project
priorities,
compartmentalized

work units,
communication, and
frequent customer
feedback.pre75977_ch03.qxd  11/27/08  3:24 PM  Page 83
Changes (e.g., backlog work items) are not introduced during the sprint. Hence, the
sprint allows team members to work in a short-term, but stable environment.
Scrum meetingsÑare short (typically 15 minutes) meetings held daily by the Scrumteam. Three key questions are asked and answered by all team members [Noy02]:¥What did you do since the last team meeting?¥What obstacles are you encountering?¥What do you plan to accomplish by the next team meeting?A team leader, called a 
Scrum master,
leads the meeting and assesses the responsesfrom each person. The Scrum meeting helps the team to uncover potential problems

as early as possible. Also, these daily meetings lead to Òknowledge socializationÓ
[Bee99] and thereby promote a self-organizing team structure.DemosÑdeliver the software increment to the customer so that functionality thathas been implemented can be demonstrated and evaluated by the customer. It is im-

portant to note that the demo may not contain all planned functionality, but rather

those functions that can be delivered within the time-box that was established.Beedle and his colleagues [Bee99] present a comprehensive discussion of these pat-terns in which they state: ÒScrum assumes up-front the existence of chaos. . . . Ó The
Scrum process patterns enable a software team to work successfully in a world
where the elimination of uncertainty is impossible.3.5.3Dynamic Systems Development Method (DSDM)
The Dynamic Systems Development Method(DSDM) [Sta97] is an agile software devel-opment approach that Òprovides a framework for building and maintaining systems

which meet tight time constraints through the use of incremental prototyping in a con-
trolled project environmentÓ [CCS02]. The DSDM philosophy is borrowed from a mod-

ified version of the Pareto principleÑ80 percent of an application can be delivered in
20 percent of the time it would take to deliver the complete (100 percent) application.DSDM is an iterative software process in which each iteration follows the 80 per-cent rule. That is, only enough work is required for each increment to facilitate
movement to the next increment. The remaining detail can be completed later when

more business requirements are known or changes have been requested and
accommodated.The DSDM Consortium (www.dsdm.org
) is a worldwide group of member com-panies that collectively take on the role of ÒkeeperÓ of the method. The consortium
has defined an agile process model, called the DSDM life cyclethat defines three dif-ferent iterative cycles, preceded by two additional life cycle activities:Feasibility studyÑestablishes the basic business requirements and constraintsassociated with the application to be built and then assesses whether the applica-
tion is a viable candidate for the DSDM process.84PART ONETHE SOFTWARE PROCESSWebRef
Useful resources forDSSD can be found at
www.dsdm.org
.pre75977_ch03.qxd  11/27/08  3:24 PM  Page 84
Business studyÑestablishes the functional and information requirements thatwill allow the application to provide business value; also, defines the basic
application architecture and identifies the maintainability requirements for the
application.Functional model iterationÑ
produces a set of incremental prototypes thatdemonstrate functionality for the customer. (Note: All DSDM prototypes are in-

tended to evolve into the deliverable application.) The intent during this iterative
cycle is to gather additional requirements by eliciting feedback from users as they
exercise the prototype.Design and build iterationÑ
revisits prototypes built duringfunctional modeliteration
to ensure that each has been engineered in a manner that will enable it toprovide operational business value for end users. In some cases,
functional modeliteration
and design and build iteration
occur concurrently.
ImplementationÑplaces the latest software increment (an ÒoperationalizedÓ pro-totype) into the operational environment. It should be noted that (1) the increment

may not be 100 percent complete or (2) changes may be requested as the incre-
ment is put into place. In either case, DSDM development work continues by

returning to the functional model iteration activity.
DSDM can be combined with XP (Section 3.4) to provide a combination approach
that defines a solid process model (the DSDM life cycle) with the nuts and bolts prac-
tices (XP) that are required to build software increments. In addition, the ASD con-
cepts of collaboration and self-organizing teams can be adapted to a combined
process model.3.5.4Crystal
Alistair Cockburn [Coc05] and Jim Highsmith [Hig02b] created the Crystal family ofagile methods15in order to achieve a software development approach that puts apremium on ÒmaneuverabilityÓ during what Cockburn characterizes as Òa resource-
limited, cooperative game of invention and communication, with a primary goal of

delivering useful, working software and a secondary goal of setting up for the next
gameÓ [Coc02].To achieve maneuverability, Cockburn and Highsmith have defined a set of
methodologies, each with core elements that are common to all, and roles, process
patterns, work products, and practice that are unique to each. The Crystal family is
actually a set of example agile processes that have been proven effective for differ-

ent types of projects. The intent is to allow agile teams to select the member of the
crystal family that is most appropriate for their project and environment.
CHAPTER 3AGILE DEVELOPMENT8515The name ÒcrystalÓ is derived from the characteristics of geological crystals, each with its own
color, shape, and hardness.Crystal is a family of
process models with
the same Ògenetic
codeÓ but different
methods for adapting
to project
characteristics.DSDM is a processframework that can
adopt the tactics of
another agile approach
such as XP.
pre75977_ch03.qxd  11/27/08  3:24 PM  Page 85
3.5.5Feature Driven Development (FDD)
Feature Driven Development(FDD) was originally conceived by Peter Coad and hiscolleagues [Coa99] as a practical process model for object-oriented software engi-neering. Stephen Palmer and John Felsing [Pal02] have extended and improved

CoadÕs work, describing an adaptive, agile process that can be applied to moderately

sized and larger software projects.Likeotheragileapproaches,FDDadoptsaphilosophythat(1)emphasizescol-
laborationamongpeopleonanFDDteam;(2)managesproblemandproject

complexityusingfeature-baseddecompositionfollowedbytheintegrationof

softwareincrements,and(3)communicationoftechnicaldetailusingverbal,

graphical,andtext-basedmeans.FDDemphasizessoftwarequalityassurance

activitiesbyencouraginganincrementaldevelopmentstrategy,theuseofdesign

andcodeinspections,theapplicationofsoftwarequalityassuranceaudits(Chap-

ter16),thecollectionofmetrics,andtheuseofpatterns(foranalysis,design,and

construction).In the context of FDD, a 
featureÒis a client-valued function that can be imple-mented in two weeks or lessÓ [Coa99]. The emphasis on the definition of features
provides the following benefits:
¥Because features are small blocks of deliverable functionality, users can

describe them more easily; understand how they relate to one another more
readily; and better review them for ambiguity, error, or omissions.
¥Features can be organized into a hierarchical business-related grouping.¥Since a feature is the FDD deliverable software increment, the team develops
operational features every two weeks.¥Because features are small, their design and code representations are easier
to inspect effectively.
¥Project planning, scheduling, and tracking are driven by the feature
hierarchy, rather than an arbitrarily adopted software engineering 

task set.Coad and his colleagues [Coa99] suggest the following template for defining a
feature:<action> the<result> <by for of to> 
a(n)<object>where an <object>is Òa person, place, or thing (including roles, moments in time or
intervals of time, or catalog-entry-like descriptions).Ó Examples of features for an 

e-commerce application might be:Add the product to shopping cartDisplay the technical-specifications of the product

Store the shipping-information for the customer86PART ONETHE SOFTWARE PROCESSWebRef
A wide variety ofarticles and

presentations on FDD
can be found at:
www.featuredrive

ndevelopment

.com/.pre75977_ch03.qxd  11/27/08  3:24 PM  Page 86
A feature set groups related features into business-related categories and is defined[Coa99] as:<action><-ing> a(n)<object>For example: Making a product saleis a feature set that would encompass the fea-tures noted earlier and others.The FDD approach defines five ÒcollaboratingÓ [Coa99] framework activities (inFDD these are called ÒprocessesÓ) as shown in Figure 3.5.FDD provides greater emphasis on project management guidelines and tech-
niques than many other agile methods. As projects grow in size and complexity,

adhoc project management is often inadequate. It is essential for developers, their

managers, and other stakeholders to understand project statusÑwhat accomplish-
ments have been made and problems have been encountered. If deadline pressure
is significant, it is critical to determine if software increments (features) are properly
scheduled. To accomplish this, FDD defines six milestones during the design and

implementation of a feature: Òdesign walkthrough, design, design inspection, code,

code inspection, promote to buildÓ [Coa99].3.5.6Lean Software Development(LSD)
Lean Software Development(LSD) has adapted the principles of lean manufacturingto the world of software engineering. The lean principles that inspire the LSD process
can be summarized ([Pop03], [Pop06a]) as eliminate waste, build quality in, createknowledge, defer commitment, deliver fast, respect people,and optimize the whole.Each of these principles can be adapted to the software process. For example,
eliminate wastewithin the context of an agile software project can be interpretedtomean [Das05]: (1) adding no extraneous features or functions, (2) assessing the

cost and schedule impact of any newly requested requirement, (3) removing any

superfluous process steps, (4) establishing mechanisms to improve the way team

members find information, (5) ensuring the testing finds as many errors as possible,
CHAPTER 3AGILE DEVELOPMENT87DevelopanOverallModelBuild aFeaturesListPlanByFeatureDesignByFeatureBuildByFeature(more shapethan content)A list of features
grouped into sets
and subject areasA development plan
Class owners
Feature Set OwnersA design
package
(sequences)Completed
client-value
functionFIGURE3.5Feature Driven
Development
[Coa99] (with
permission)
pre75977_ch03.qxd  11/27/08  3:24 PM  Page 87
(6)reducing the time required to request and get a decision that affects the software
or the process that is applied to create it, and (7) streamlining the manner in which
information is transmitted to all stakeholders involved in the process.
For a detailed discussion of LSD and pragmatic guidelines for implementing theprocess, you should examine [Pop06a] and [Pop06b].3.5.7Agile Modeling (AM)
There are many situations in which software engineers must build large, business-

critical systems. The scope and complexity of such systems must be modeled so that
(1) all constituencies can better understand what needs to be accomplished, (2) the
problem can be partitioned effectively among the people who must solve it, and
(3)quality can be assessed as the system is being engineered and built.
Over the past 30 years, a wide variety of software engineering modeling methodsand notation have been proposed for analysis and design (both architectural and
component-level). These methods have merit, but they have proven to be difficult

toapply and challenging to sustain (over many projects). Part of the problem is the

ÒweightÓ of these modeling methods. By this I mean the volume of notation required,
the degree of formalism suggested, the sheer size of the models for large projects,
and the difficulty in maintaining the model(s) as changes occur. Yet analysis and de-

sign modeling have substantial benefit for large projectsÑif for no other reason than
to make these projects intellectually manageable. Is there an agile approach to soft-
ware engineering modeling that might provide an alternative?
At ÒThe Official Agile Modeling Site,Ó Scott Ambler [Amb02a] describes 
agile mod-eling(AM) in the following manner:Agile Modeling (AM) is a practice-based methodology for effective modeling and documen-tation of software-based systems. Simply put, Agile Modeling (AM) is a collection of values,
principles, and practices for modeling software that can be applied on a software develop-
ment project in an effective and light-weight manner. Agile models are more effective than

traditional models because they are just barely good, they donÕt have to be perfect.
Agile modeling adopts all of the values that are consistent with the agile manifesto.The agile modeling philosophy recognizes that an agile team must have the courage
to make decisions that may cause it to reject a design and refactor. The team must

also have the humility to recognize that technologists do not have all the answers and
that business experts and other stakeholders should be respected and embraced.Although AM suggests a wide array of ÒcoreÓ and ÒsupplementaryÓ modeling prin-ciples, those that make AM unique are [Amb02a]:Model with a purpose.A developer who uses AM should have a specificgoal (e.g., to communicate information to the customer or to help better un-
derstand some aspect of the software) in mind before creating the model.
Once the goal for the model is identified, the type of notation to be used and
level of detail required will be more obvious.88PART ONETHE SOFTWARE PROCESSWebRef
Comprehensiveinformation on agile

modeling can be found
at: www
.agilemodeling.com.uote:ÒI was in the drugstore the other day
trying to get a cold

medication . . . not
easy. ThereÕs an

entire wall of
products you need.
You stand there

going, Well, this

one is quick acting
but this is long
lasting. . . . Which
is more important,
the present or the
future?ÓJerrySeinfeld
pre75977_ch03.qxd  11/27/08  3:24 PM  Page 88
Use multiple models.There are many different models and notations thatcan be used to describe software. Only a small subset is essential for mostprojects. AM suggests that to provide needed insight, each model should

present a different aspect of the system and only those models that provide

value to their intended audience should be used.Travel light.
As software engineering work proceeds, keep only those mod-els that will provide long-term value and jettison the rest. Every work product
that is kept must be maintained as changes occur. This represents work that

slows the team down. Ambler [Amb02a] notes that ÒEvery time you decide to
keep a model you trade-off agility for the convenience of having that informa-

tion available to your team in an abstract manner (hence potentially enhanc-
ing communication within your team as well as with project stakeholders).ÓContent is more important than representation.
Modeling should im-part information to its intended audience. A syntactically perfect model thatimparts little useful content is not as valuable as a model with flawed nota-

tion that nevertheless provides valuable content for its audience.
Know the models and the tools you use to create them.
Understandthe strengths and weaknesses of each model and the tools that are used tocreate it.Adapt locally.
The modeling approach should be adapted to the needs ofthe agile team.A major segment of the software engineering community has adopted the UnifiedModeling Language (UML)16as the preferred method for representing analysis anddesign models. The Unified Process (Chapter 2) has been developed to provide a

framework for the application of UML. Scott Ambler [Amb06] has developed a sim-
plified version of the UP that integrates his agile modeling philosophy.
3.5.8Agile Unified Process(AUP)
The Agile Unified Process(AUP) adopts a Òserial in the largeÓ and Òiterative in the
smallÓ [Amb06] philosophy for building computer-based systems. By adopting the
classic UP phased activitiesÑinception, elaboration, construction,
and transition
ÑAUP
provides a serial overlay (i.e., a linear sequence of software engineering activities)

that enables a team to visualize the overall process flow for a software project. How-

ever, within each of the activities, the team iterates to achieve agility and to deliver

meaningful software increments to end users as rapidly as possible. Each AUP iter-

ation addresses the following activities [Amb06]: ¥Modeling.UML representations of the business and problem domains arecreated. However, to stay agile, these models should be Òjust barely good

enoughÓ [Amb06] to allow the team to proceed.CHAPTER 3AGILE DEVELOPMENT89ÒTraveling lightÓ is an
appropriate philosophy
for all software engi-
neering work. Build
only those models that
provide value É no
more, no less.16A brief tutorial on UML is presented in Appendix 1.
pre75977_ch03.qxd  11/27/08  3:24 PM  Page 89
¥Implementation.Models are translated into source code.¥Testing.
Like XP, the team designs and executes a series of tests to uncover
errors and ensure that the source code meets its requirements.¥Deployment.
Like the generic process activity discussed in Chapters 1 and 2,deployment in this context focuses on the delivery of a software incrementand the acquisition of feedback from end users.¥Configuration and project management.
In the context of AUP, configuration
management (Chapter 22) addresses change management, risk manage-
ment, and the control of any persistent work products17that are produced bythe team. Project management tracks and controls the progress of the team
and coordinates team activities.¥Environment management.
Environment management coordinates a process
infrastructure that includes standards, tools, and other support technology
available to the team.Although the AUP has historical and technical connections to the Unified Modeling

Language, it is important to note that UML modeling can be using in conjunction

with any of the agile process models described in Section 3.5.90PART ONETHE SOFTWARE PROCESS17A 
persistent work productis a model or document or test case produced by the team that will be keptfor an indeterminate period of time. It will notbe discarded once the software increment isdelivered.18Tools noted here do not represent an endorsement, but rather a sampling of tools in this category.
In most cases, tool names are trademarked by their respective developers.Agile DevelopmentObjective:The objective of agile developmenttools is to assist in one or more aspects of agiledevelopment with an emphasis on facilitating the rapidgeneration of operational software. These tools can also
be used when prescriptive process models (Chapter 2) are
applied.Mechanics:Tool mechanics vary. In general, agile tool
sets encompass automated support for project planning,
use case development and requirements gathering, rapid
design, code generation, and testing.Representative Tools:
18Note:Because agile development is a hot topic, mostsoftware tools vendors purport to sell tools that support 
the agile approach. The tools noted here havecharacteristics that make them particularly useful for

agile projects.OnTime,
developed by Axosoft (www.axosoft.com
),provides agile process management support for

various technical activities within the process.Ideogramic UML,developed by Ideogramic(www.ideogramic.com
) is a UML tool set
specifically developed for use within an agile 
process.Together Tool Set,
distributed by Borland(www.borland.com
), provides a tools suite that
supports many technical activities within XP and other

agile processes.SOFTWARE
TOOLSpre75977_ch03.qxd  11/27/08  3:24 PM  Page 90
3.6A T
OOLSETFORTHE
AGILEPROCESSSome proponents of the agile philosophy argue that automated software tools (e.g.,design tools) should be viewed as a minor supplement to the teamÕs activities, and

not at all pivotal to the success of the team. However, Alistair Cockburn [Coc04] sug-

gests that tools can have a benefit and that Òagile teams stress using tools that per-
mit the rapid flow of understanding. Some of those tools are social, starting even at
the hiring stage. Some tools are technological, helping distributed teams simulate
being physically present. Many tools are physical, allowing people to manipulate
them in workshops.ÓBecause acquiring the right people (hiring), team collaboration, stakeholder com-munication, and indirect management are key elements in virtually all agile process
models, Cockburn argues that ÒtoolsÓ that address these issues are critical success
factors for agility. For example, a hiring ÒtoolÓ might be the requirement to have a

prospective team member spend a few hours pair programming with an existing
member of the team. The ÒfitÓ can be assessed immediately.
Collaborative and communication ÒtoolsÓ are generally low tech and incorporateany mechanism (Òphysical proximity, whiteboards, poster sheets, index cards, and

sticky notesÓ [Coc04]) that provides information and coordination among agile de-

velopers. Active communication is achieved via the team dynamics (e.g., pair pro-
gramming), while passive communication is achieved by Òinformation radiatorsÓ
(e.g., a flat panel display that presents the overall status of different components of

an increment). Project management tools deemphasize the Gantt chart and replace
it with earned value charts or Ògraphs of tests created versus passed . . . other agile
tools are used to optimize the environment in which the agile team works (e.g., more

efficient meeting areas), improve the team culture by nurturing social interactions

(e.g., collocated teams), physical devices (e.g., electronic whiteboards), and process
enhancement (e.g., pair programming or time-boxing)Ó [Coc04].Are any of these things really tools? They are, if they facilitate the work performed
by an agile team member and enhance the quality of the end product.3.7S
UMMARYIn a modern economy, market conditions change rapidly, customer and end-user

needs evolve, and new competitive threats emerge without warning. Practitioners

must approach software engineering in a manner that allows them to remain agileÑ
to define maneuverable, adaptive, lean processes that can accommodate the needs

of modern business.An agile philosophy for software engineering stresses four key issues: the impor-tance of self-organizing teams that have control over the work they perform, com-

munication and collaboration between team members and between practitioners
and their customers, a recognition that change represents an opportunity, and
CHAPTER 3AGILE DEVELOPMENT91The Òtool setÓ thatsupports agile

processes focuses
more on people issues
than it does on
technology issues.pre75977_ch03.qxd  11/27/08  3:24 PM  Page 91
anemphasis on rapid delivery of software that satisfies the customer. Agile process
models have been designed to address each of these issues.Extreme programming (XP) is the most widely used agile process. Organized asfour framework activitiesÑplanning, design, coding, and testingÑXP suggests a
number of innovative and powerful techniques that allow an agile team to create

frequent software releases that deliver features and functionality that have been de-
scribed and then prioritized by stakeholders.Other agile process models also stress human collaboration and team self-organization, but define their own framework activities and select different points of
emphasis. For example, ASD uses an iterative process that incorporates adaptive

cycle planning, relatively rigorous requirement gathering methods, and an iterative
development cycle that incorporates customer focus groups and formal technical re-
views as real-time feedback mechanisms. Scrum emphasizes the use of a set of soft-
ware process patterns that have proven effective for projects with tight time lines,

changing requirements, and business criticality. Each process pattern defines a set

of development tasks and allows the Scrum team to construct a process that is
adapted to the needs of the project. The Dynamic Systems Development Method
(DSDM) advocates the use of time-box scheduling and suggests that only enough
work is required for each software increment to facilitate movement to the next

increment. Crystal is a family of agile process models that can be adopted to the spe-
cific characteristics of a project.Feature Driven Development (FDD) is somewhat more ÒformalÓ than other agilemethods, but still maintains agility by focusing the project team on the development
of featuresÑa client-valued function that can be implemented in two weeks or less.
Lean Software Development (LSD) has adapted the principles of lean manufacturing
to the world of software engineering. Agile modeling (AM) suggests that modeling is
essential for all systems, but that the complexity, type, and size of the model must be

tuned to the software to be built. The Agile Unified Process (AUP) adopts a Òserial in

the largeÓ and Òiterative in the smallÓ philosophy for building software.PROBLEMSAND
POINTSTO
PONDER3.1.Reread ÒThe Manifesto for Agile Software DevelopmentÓ at the beginning of this chapter.
Can you think of a situation in which one or more of the four ÒvaluesÓ could get a software teaminto trouble?3.2.Describe agility (for software projects) in your own words.3.3.Why does an iterative process make it easier to manage change? Is every agile process dis-cussed in this chapter iterative? Is it possible to complete a project in just one iteration and stillbe agile? Explain your answers.3.4.Could each of the agile processes be described using the generic framework activitiesnoted in Chapter 2? Build a table that maps the generic activities into the activities defined foreach agile process.3.5.Try to come up with one more Òagility principleÓ that would help a software engineering
team become even more maneuverable.92PART ONETHE SOFTWARE PROCESSpre75977_ch03.qxd  11/27/08  3:24 PM  Page 92
3.6.Select one agility principle noted in Section 3.3.1 and try to determine whether each of theprocess models presented in this chapter exhibits the principle. [Note: I have presented anoverview of these process models only, so it may not be possible to determine whether a prin-

ciple has been addressed by one or more of the models, unless you do additional research
(which is not required for this problem).]3.7.Why do requirements change so much? After all, donÕt people know what they want?
3.8.Most agile process models recommend face-to-face communication. Yet today, members
of a software team and their customers may be geographically separated from one another. Do
you think this implies that geographical separation is something to avoid? Can you think of ways
to overcome this problem?
3.9.Write an XP user story that describes the Òfavorite placesÓ or ÒbookmarksÓ feature avail-able on most Web browsers.

3.10.What is a spike solution in XP?3.11.Describe the XP concepts of refactoring and pair programming in your own words.3.12.Do a bit more reading and describe what a time-box is. How does this assist an ASD teamin delivering software increments in a short time period?
3.13.Do the 80 percent rule in DSDM and the time-boxing approach defined for ASD achievethe same result?
3.14.Using the process pattern template presented in Chapter 2, develop a process pattern forany one of the Scrum patterns presented in Section 3.5.2.
3.15.Why is Crystal called a family of agile methods?3.16.Using the FDD feature template described in Section 3.5.5, define a feature set for a Web
browser. Now develop a set of features for the feature set.

3.17.Visit the Official Agile Modeling Site and make a complete list of all core and supple-
mentary AM principles.
3.18.The tool set proposed in Section 3.6 supports many of the ÒsoftÓ aspects of agile meth-ods. Since communication is so important, recommend an actual tool set that might be used toenhance communication among stakeholders on an agile team.FURTHER
READINGSAND
INFORMATION
SOURCESThe overall philosophy and underlying principles of agile software development are considered

in depth in many of the books referenced in the body of this chapter. In addition, books by Shaw

and Warden (
The Art of Agile Development,OÕReilly Media, Inc., 2008), Hunt (Agile Software Con-struction,Springer, 2005), and Carmichael and Haywood (
Better Software Faster,
Prentice-Hall,2002) present useful discussions of the subject. Aguanno (Managing Agile Projects,Multi-Media Publications, 2005), Highsmith (Agile Project Management: Creating Innovative Products,
Addison-Wesley, 2004), and Larman (
Agile and Iterative Development: A ManagerÕs Guide,

Addison-Wesley, 2003) present a management overview and consider project management

issues. Highsmith (Agile Software Development Ecosystems,Addison-Wesley, 2002) presents a
survey of agile principles, processes, and practices. A worthwhile discussion of the delicate bal-
ance between agility and discipline is presented by Booch and his colleagues (Balancing Agility
and Discipline,Addison-Wesley, 2004).
Martin (Clean Code: A Handbook of Agile Software Craftsmanship,
Prentice-Hall, 2009) pres-ents the principles, patterns, and practices required to develop Òclean codeÓ in an agile software
engineering environment. Leffingwell (
Scaling Software Agility: Best Practices for Large Enter-

prises,Addison-Wesley, 2007) discusses strategies for scaling up agile practices for large proj-
ects. Lippert and Rook (Refactoring in Large Software Projects: Performing Complex Restructurings
Successfully,
Wiley, 2006) discuss the use of refactoring when applied in large, complex systems.
CHAPTER 3AGILE DEVELOPMENT93pre75977_ch03.qxd  11/27/08  3:24 PM  Page 93
Stamelos and Sfetsos (Agile Software Development Quality Assurance,
IGI Global, 2007) discussSQA techniques that conform to the agile philosophy.
Dozens of books have been written about Extreme Programming over the past decade. Beck
(Extreme Programming Explained: Embrace Change,
2d ed., Addison-Wesley, 2004) remains the
definitive treatment of the subject. In addition, Jeffries and his colleagues (Extreme Programming
Installed,Addison-Wesley, 2000), Succi and Marchesi (
Extreme Programming Examined,
Addison-Wesley, 2001), Newkirk and Martin (
Extreme Programming in Practice,
Addison-Wesley,
2001), and Auer and his colleagues (
Extreme Programming Applied: Play to Win,
Addison-Wesley,
2001) provide a nuts-and-bolts discussion of XP along with guidance on how best to apply it.
McBreen (Questioning Extreme Programming,
Addison-Wesley, 2003) takes a critical look at XP,
defining when and where it is appropriate. An in-depth consideration of pair programming is
presented by McBreen (Pair Programming Illuminated,
Addison-Wesley, 2003).
ASD is addressed in depth by Highsmith [Hig00]. Schwaber (The Enterprise and Scrum,Microsoft Press, 2007) discusses the use of Scrum for projects that have a major business
impact. The nuts and bolts of Scrum are discussed by Schwaber and Beedle (Agile Software
Development with SCRUM,Prentice-Hall, 2001). Worthwhile treatments of DSDM have been
written by the DSDM Consortium (DSDM: Business Focused Development,2d ed., Pearson Edu-cation, 2003) and Stapleton (DSDM: The Method in Practice,
Addison-Wesley, 1997). Cockburn
(Crystal Clear,
Addison-Wesley, 2005) presents an excellent overview of the Crystal family of
processes. Palmer and Felsing [Pal02] present a detailed treatment of FDD. Carmichael and

Haywood (Better Software Faster,
Prentice-Hall, 2002) provides another useful treatment of FDD
that includes a step-by-step journey through the mechanics of the process. Poppendieck and 
Poppendieck (Lean Development: An Agile Toolkit for Software Development Managers,
Addison-Wesley, 2003) provide guidelines for managing and controlling agile projects. Ambler and

Jeffries (Agile Modeling,Wiley, 2002) discuss AM in some depth.
A wide variety of information sources on agile software development are available on theInternet. An up-to-date list of World Wide Web references that are relevant to the agile process

can be found at the SEPA website:
www.mhhe.com/engcs/compsci/pressman/
professional/olc/ser.htm
.94PART ONETHE SOFTWARE PROCESSpre75977_ch03.qxd  11/27/08  3:24 PM  Page 94
MODELING95PART
Two
In this part of Software Engineering: A PractitionerÕs Approach
youÕll learn about the principles, concepts, and methods that are
used to create high-quality requirements and design models.These questions are addressed in the chapters that follow:¥What concepts and principles guide software engineering
practice?¥What is requirements engineering and what are the underly-
ing concepts that lead to good requirements analysis?¥How is the requirements model created and what are its
elements?¥What are the elements of a good design?¥How does architectural design establish a framework for all
other design actions and what models are used?¥How do we design high-quality software components?¥What concepts, models, and methods are applied as a user
interface is designed?¥What is pattern-based design?¥What specialized strategies and methods are used to design
WebApps?
Once these questions are answered youÕll be better prepared toapply software engineering practice.pre75977_ch04.qxd  11/27/08  3:27 PM  Page 95
In a book that explores the lives and thoughts of software engineers, EllenUllman [Ull97] depicts a slice of life as she relates the thoughts of practitioner
under pressure:I have no idea what time it is. There are no windows in this office and no clock, onlythe blinking red LED display of a microwave, which flashes 12:00, 12:00, 12:00, 12:00.

Joel and I have been programming for days. We have a bug, a stubborn demon of a

bug. So the red pulse no-time feels right, like a read-out of our brains, which have
somehow synchronized themselves at the same blink rate . . . What are we working on? . . . The details escape me just now. We may be helping
poor sick people or tuning a set of low-level routines to verify bits on a distributed
database protocolÑI donÕt care. I should care; in another part of my beingÑlater, per-

haps when we emerge from this room full of computersÑI will care very much why
and for whom and for what purpose I am writing software. But just now: no. I have
passed through a membrane where the real world and its uses no longer matter. I am

a software engineer. . . .
96CHAPTER4PRINCIPLESTHAT
GUIDEPRACTICEKEYCONCEPTSCore principles . . .98
Principlesthat govern:
coding . . . . . . . .111
communication . .101
deployment . . .113

design . . . . . . .109

modeling . . . . .105

planning . . . . . .103

requirements . .107

testing . . . . . . .112
What is it?Software engineeringpractice is a broad array of princi-ples, concepts, methods, and tools
that you must consider as software isplanned and developed. Principles that guide
practice establish a foundation from which soft-
ware engineering is conducted.Who does it?Practitioners (software engineers)and their managers conduct a variety of soft-
ware engineering tasks.Why is it important?
The software process pro-vides everyone involved in the creation of a

computer-based system or product with a road
map for getting to a successful destination.
Practice provides you with the detail youÕll need
to drive along the road. It tells you where the
bridges, the roadblocks, and the forks are located.
It helps you understand the concepts and princi-
ples that must be understood and followed to
drive safely and rapidly. It instructs you on how

to drive, where to slow down, and where to
speed up. In the context of software engineering,QUICKLOOKpractice is what you do day in and day out as
software evolves from an idea to a reality.
What are the steps?Three elements of practiceapply regardless of the process model that is cho-
sen. They are: principles, concepts, and methods.
A fourth element of practiceÑtoolsÑsupports

the application of methods.What is the work product?
Practice encom-passes the technical activities that produce all
work products that are defined by the software
process model that has been chosen.HowdoIensurethatIÕvedoneitright?
First,haveafirmunderstandingoftheprinciplesthat

applytothework(e.g.,design)thatyouÕredoing

atthemoment.Then,becertainthatyouÕvecho-

senanappropriatemethodforthework,besure

thatyouunderstandhowtoapplythemethod,use

automatedtoolswhentheyÕreappropriateforthe

task,andbeadamantabouttheneedfortech-

niquestoensurethequalityofworkproductsthat

areproduced.
pre75977_ch04.qxd  11/27/08  3:27 PM  Page 96
CHAPTER 4PRINCIPLES THAT GUIDE PRACTICE97A dark image of software engineering practice to be sure, but upon reflection,
many of the readers of this book will be able to relate to it.People who create computer software practice the art or craft or discipline1thatis software engineering. But what is software engineering ÒpracticeÓ? In a genericsense, 
practice
is a collection of concepts, principles, methods, and tools that a soft-ware engineer calls upon on a daily basis. Practice allows managers to manage soft-
ware projects and software engineers to build computer programs. Practice
populates a software process model with the necessary technical and management
how-toÕs to get the job done. Practice transforms a haphazard unfocused approach

into something that is more organized, more effective, and more likely to achieve

success.Various aspects of software engineering practice will be examined throughout the
remainder of this book. In this chapter, my focus is on principles and concepts that

guide software engineering practice in general.4.1S
OFTWARE
ENGINEERINGKNOWLEDGEIn an editorial published in IEEE Softwarea decade ago, Steve McConnell [McC99]made the following comment:Many software practitioners think of software engineering knowledge almost exclusivelyas knowledge of specific technologies: Java, Perl, html, C, Linux, Windows NT, and so
on. Knowledge of specific technology details is necessary to perform computer program-
ming. If someone assigns you to write a program in C, you have to know somethingabout Cto get your program to work.You often hear people say that software development knowledge has a 3-year 
half-life: half of what you need to know today will be obsolete within 3 years. In the
domain of technology-related knowledge, thatÕs probably about right. But there is

another kind of software development knowledgeÑa kind that I think of as Òsoftware
engineering principlesÓÑthat does not have a three-year half-life. These software engi-
neering principles are likely to serve a professional programmer throughout his or her
career.
McConnell goes on to argue that the body of software engineering knowledge(circa the year 2000) had evolved to a Òstable coreÓ that he estimated representedabout Ò75 percent of the knowledge needed to develop a complex system.Ó But what
resides within this stable core?As McConnell indicates, core principlesÑthe elemental ideas that guide softwareengineers in the work that they doÑnow provide a foundation from which software

engineering models, methods, and tools can be applied and evaluated.1Some writers argue for one of these terms to the exclusion of the others. In reality, software
engineering is all three.pre75977_ch04.qxd  11/27/08  3:27 PM  Page 97
4.2C
OREPRINCIPLESSoftware engineering is guided by a collection of core principles that help in the ap-plication of a meaningful software process and the execution of effective software
engineering methods. At the process level, core principles establish a philosophical
foundation that guides a software team as it performs framework and umbrella ac-
tivities, navigates the process flow, and produces a set of software engineering work

products. At the level of practice, core principles establish a collection of values and

rules that serve as a guide as you analyze a problem, design a solution, implement
and test the solution, and ultimately deploy the software in the user community.
In Chapter 1, I identified a set of general principles that span software engineeringprocess and practice: (1) provide value to end users, (2) keep it simple, (3) maintain

the vision (of the product and the project), (4) recognize that others consume (and
must understand) what you produce, (5) be open to the future, (6) plan ahead for

reuse, and (7) think! Although these general principles are important, they are char-

acterized at such a high level of abstraction that they are sometimes difficult to trans-
late into day-to-day software engineering practice. In the subsections that follow, I

take a more detailed look at the core principles that guide process and practice.4.2.1Principles That Guide Process
In Part 1 of this book I discussed the importance of the software process and
described the many different process models that have been proposed for software
engineering work. Regardless of whether a model is linear or iterative, prescriptive

or agile, it can be characterized using the generic process framework that is appli-

cable for all process models. The following set of core principles can be applied to
the framework, and by extension, to every software process.Principle 1.Be agile.Whether the process model you choose is prescrip-tive or agile, the basic tenets of agile development should govern your

approach. Every aspect of the work you do should emphasize economy of
actionÑkeep your technical approach as simple as possible, keep the work

products youproduce as concise as possible, and make decisions locally

whenever possible.Principle 2.Focus on quality at every step.The exit condition for everyprocess activity, action, and task should focus on the quality of the work
product that has been produced.Principle 3.Be ready to adapt.
Process is not a religious experience, and
dogma has no place in it. When necessary, adapt your approach to con-
straints imposed by the problem, the people, and the project itself.
Principle 4.Build an effective team.Software engineering process andpractice are important, but the bottom line is people. Build a self-organizingteam that has mutual trust and respect.98PART TWOMODELINGuote:ÒIn theory there is
no difference
between theory and

practice. But, in
practice, there is.ÓJan van deSnepscheutEvery project and
every team is unique.

That means that you
must adapt your
process to best fit your
needs.pre75977_ch04.qxd  11/27/08  3:27 PM  Page 98
Principle 5.Establish mechanisms for communication and coordination.
Projects fail because important information falls into the cracks and/orstakeholders fail to coordinate their efforts to create a successful end prod-
uct. These are management issues and they must be addressed.Principle 6.Manage change.
The approach may be either formal or infor-mal, but mechanisms must be established to manage the way changes arerequested, assessed, approved, and implemented.
Principle 7.Assess risk.Lots of things can go wrong as software is beingdeveloped. ItÕs essential that you establish contingency plans.
Principle 8.Create work products that provide value for others.
Create only those work products that provide value for other process
activities, actions, or tasks. Every work product that is produced as part of
software engineering practice will be passed on to someone else. A list of
required functions and features will be passed along to the person (people)
who will develop a design, the design will be passed along to those who
generate code, and so on. Be sure that the work product imparts the necessary

information without ambiguity or omission.Part 4 of this book focuses on project and process management issues andconsiders various aspects of each of these principles in some detail.4.2.2Principles That Guide Practice
Software engineering practice has a single overriding goalÑto deliver on-time, high-

quality, operational software that contains functions and features that meet the

needs of all stakeholders. To achieve this goal, you should adopt a set of core prin-

ciples that guide your technical work. These principles have merit regardless of the
analysis and design methods that you apply, the construction techniques (e.g., pro-

gramming language, automated tools) that you use, or the verification and valida-

tion approach that you choose. The following set of core principles are fundamental
to the practice of software engineering:Principle 1.Divide and conquer.
Stated in a more technical manner,
analysis and design should always emphasize separation of concerns
(SoC). Alarge problem is easier to solve if it is subdivided into a collection of elements
(or concerns). Ideally, each concern delivers distinct functionality that can be
developed, and in some cases validated, independently of other concerns.Principle 2.Understand the use of abstraction.
At its core, an abstrac-
tion is a simplification of some complex element of a system used to commu-nicate meaning in a single phrase. When I use the abstraction spreadsheet, it
is assumed that you understand what a spreadsheet is, the general structure
of content that a spreadsheet presents, and the typical functions that can be
applied to it. In software engineering practice, you use many different levels
CHAPTER 4PRINCIPLES THAT GUIDE PRACTICE99uote:ÒThe truth of thematter is that you
always know the
right thing to do.
The hard part is
doing it.ÓGeneral H.Norman
Schwarzkopf
Problems are easier tosolve when they are
subdivided into
separate concerns,

each distinct,
individually solvable,
and verifiable.pre75977_ch04.qxd  11/27/08  3:27 PM  Page 99
of abstraction, each imparting or implying meaning that must be communi-cated. In analysis and design work, a software team normally begins with
models that represent high levels of abstraction (e.g., a spreadsheet) and
slowly refines those models into lower levels of abstraction (e.g., a column
orthe 
SUMfunction).Joel Spolsky [Spo02] suggests that Òall non-trivial abstractions, to somedegree, are leaky.Ó The intent of an abstraction is to eliminate the need to

communicate details. But sometimes, problematic effects precipitated by
these details ÒleakÓ through. Without an understanding of the details, the

cause of a problem cannot be easily diagnosed.Principle 3.Strive for consistency.
Whether itÕs creating a requirements
model, developing a software design, generating source code, or creating
test cases, the principle of consistency suggests that a familiar context makes
software easier to use. As an example, consider the design of a user interface

for a WebApp. Consistent placement of menu options, the use of a consistent

color scheme, and the consistent use of recognizable icons all help to make

the interface ergonomically sound.Principle 4.Focus on the transfer of information.
Software is aboutinformation transferÑfrom a database to an end user, from a legacy system
to a WebApp, from an end user into a graphic user interface (GUI), from an

operating system to an application, from one software component to an-
otherÑthe list is almost endless. In every case, information flows across an

interface, and as a consequence, there are opportunities for error, or omis-

sion, or ambiguity. The implication of this principle is that you must pay spe-

cial attention to the analysis, design, construction, and testing of interfaces.Principle 5.Build software that exhibits effective modularity.
Separation of concerns (Principle 1) establishes a philosophy for software.Modularityprovides a mechanism for realizing the philosophy. Any complex
system can be divided into modules (components), but good software engi-
neering practice demands more. Modularity must be effective. That is, each
module should focus exclusively on one well-constrained aspect of the
systemÑit should be cohesive in its function and/or constrained in the
content it represents. Additionally, modules should be interconnected in a

relatively simple mannerÑeach module should exhibit low coupling to other
modules, to data sources, and to other environmental aspects.
Principle 6.Look for patterns.Brad Appleton [App00] suggests that: The goal of patterns within the software community is to create a body of literatureto help software developers resolve recurring problems encountered throughout
all of software development. Patterns help create a shared language for commu-
nicating insight and experience about these problems and their solutions. Formally
codifying these solutions and their relationships lets us successfully capture the100PART TWOMODELINGUse patterns 
(Chapter 12) to
capture knowledge and
experience for future
generations of
software engineers.pre75977_ch04.qxd  11/27/08  3:27 PM  Page 100
body of knowledge which defines our understanding of good architectures thatmeet the needs of their users.Principle 7.When possible, represent the problem and its solution
from a number of different perspectives.
When a problem and its solutionare examined from a number of different perspectives, it is more likely thatgreater insight will be achieved and that errors and omissions will be uncov-

ered. For example, a requirements model can be represented using a data-

oriented viewpoint, a function-oriented viewpoint, or a behavioral viewpoint
(Chapters 6 and 7). Each provides a different view of the problem and its

requirements.Principle 8.Remember that someone will maintain the software.
Overthe long term, software will be corrected as defects are uncovered, adapted
as its environment changes, and enhanced as stakeholders request more

capabilities. These maintenance activities can be facilitated if solid software
engineering practice is applied throughout the software process.These principles are not all youÕll need to build high-quality software, but they do
establish a foundation for every software engineering method discussed in this book.4.3P
RINCIPLESTHAT
GUIDEEACHFRAMEWORKACTIVITYIn the sections that follow I consider principles that have a strong bearing on the suc-
cess of each generic framework activity defined as part of the software process. In
many cases, the principles that are discussed for each of the framework activities are
a refinement of the principles presented in Section 4.2. They are simply core princi-
ples stated at a lower level of abstraction.4.3.1Communication Principles
Before customer requirements can be analyzed, modeled, or specified they must
begathered through the communication activity. A customer has a problem that may

be amenable to a computer-based solution. You respond to the customerÕs request

for help. Communication has begun. But the road from communication to under-
standing is often full of potholes.Effective communication (among technical peers, with the customer and otherstakeholders, and with project managers) is among the most challenging activities
that you will confront. In this context, I discuss communication principles as they
apply to customer communication. However, many of the principles apply equally to

all forms of communication that occur within a software project.Principle1.
Listen.TrytofocusonthespeakerÕswords,ratherthanformu-
latingyourresponsetothosewords.Askforclarificationifsomethingisun-

clear,butavoidconstantinterruptions.
Neverbecomecontentiousinyourwords
oractions(e.g.,rollingyoureyesorshakingyourhead)asapersonistalking.
CHAPTER 4PRINCIPLES THAT GUIDE PRACTICE101uote:ÒThe ideal engineeris a composite. . . .
He is not a
scientist, he is not a
mathematician, he
is not a sociologist
or a writer; but he
may use the
knowledge and
techniques of any
or all of these
disciplines in
solving engineering
problems.ÓN. W.
Doughertypre75977_ch04.qxd  11/27/08  3:27 PM  Page 101
Principle 2.Prepare before you communicate.
Spend the time to under-stand the problem before you meet with others. If necessary, do some re-
search to understand business domain jargon. If you have responsibility for
conducting a meeting, prepare an agenda in advance of the meeting.Principle 3.Someone should facilitate the activity.
Every communica-tion meeting should have a leader (a facilitator) to keep the conversation
moving in a productive direction, (2) to mediate any conflict that does occur,

and (3) to ensure than other principles are followed.Principle 4.Face-to-face communication is best.
But it usually worksbetter when some other representation of the relevant information is present.For example, a participant may create a drawing or a ÒstrawmanÓ document

that serves as a focus for discussion.Principle 5.Take notes and document decisions.
Things have a way offalling into the cracks. Someone participating in the communication shouldserve as a ÒrecorderÓ and write down all important points and decisions.Principle 6.Strive for collaboration.
Collaboration and consensus occurwhen the collective knowledge of members of the team is used todescribeproduct or system functions or features. Each small collaboration

serves to build trust among team members and creates a common goal for
the team.Principle 7.Stay focused; modularize your discussion.
The morepeople involved in any communication, the more likely that discussion will
bounce from one topic to the next. The facilitator should keep the conversation

modular, leaving one topic only after it has been resolved (however, see

Principle 9).Principle 8.If something is unclear, draw a picture.
Verbal communica-
tion goes only so far. A sketch or drawing can often provide clarity when
words fail to do the job.
Principle 9.(a) Once you agree to something, move on. (b) If you canÕt
agree to something, move on. (c) If a feature or function is unclear
and cannot be clarified at the moment, move on.
Communication, likeany software engineering activity, takes time. Rather than iterating endlessly,

the people who participate should recognize that many topics require discus-
sion (see Principle 2) and that Òmoving onÓ is sometimes the best way to

achieve communication agility.
Principle 10.Negotiation is not a contest or a game. It works best
when both parties win.There are many instances in which you and otherstakeholders must negotiate functions and features, priorities, and deliverydates. If the team has collaborated well, all parties have a common goal. Still,
negotiation will demand compromise from all parties.102PART TWOMODELINGBefore communicatingbe sure you under-
stand the point of view
of the other party,

know a bit about his or
her needs, and then
listen.uote:ÒPlain questionsand plain answers
make the shortest
road to most
perplexities.ÓMarkTwain
Whathappens if IcanÕt come to an
agreement with
the customer on
some project-
related issue??pre75977_ch04.qxd  11/27/08  3:27 PM  Page 102
CHAPTER 4PRINCIPLES THAT GUIDE PRACTICE103Communication Mistakes
The scene:Software engineeringteam workspaceThe players:Jamie Lazar, software team member;
Vinod Raman, software team member; Ed Robbins,
software team member.
The conversation:
Ed:ÒWhat have you heard about this SafeHomeproject?Ó
Vinod:
ÒThe kick-off meeting is scheduled for next
week.Ó
Jamie:ÒIÕve already done a little bit of investigation, butit didnÕt go well.Ó

Ed:ÒWhat do you mean?ÓJamie:ÒWell, I gave Lisa Perez a call. SheÕs the
marketing honcho on this thing.Ó
Vinod:
ÒAnd . . . ?ÓJamie:ÒI wanted her to tell me about SafeHomefeaturesand functions . . . that sort of thing. Instead, she began
asking me questions about security systems, surveillance
systems . . . IÕm no expert.Ó
Vinod:
ÒWhat does that tell you?Ó(Jamie shrugs.)
Vinod:
ÒThat marketing will need us to act as consultantsand that weÕd better do some homework on this productarea before our kick-off meeting. Doug said that he

wanted us to ÔcollaborateÕ with our customer, so weÕd

better learn how to do that.Ó
Ed:ÒProbably would have been better to stop by her office.
Phone calls just donÕt work as well for this sort of thing.Ó

Jamie:ÒYouÕre both right. WeÕve got to get our act
together or our early communications will be a struggle.Ó
Vinod:
ÒI saw Doug reading a book on Ôrequirementsengineering.Õ IÕll bet that lists some principles of goodcommunication. IÕm going to borrow it from him.ÓJamie:ÒGood idea . . . then you can teach us.ÓVinod (smiling):
ÒYeah, right.Ó
SAFEHOME4.3.2Planning Principles
The communication activity helps you to define your overall goals and objectives
(subject, of course, to change as time passes). However, understanding these goals

and objectives is not the same as defining a plan for getting there. The planning
activity encompasses a set of management and technical practices that enable the
software team to define a road map as it travels toward its strategic goal and tacti-
cal objectives.The Difference Between Customers and End Users
Software engineers communicate with manydifferent stakeholders, but customers and end
users have the most significant impact on the technicalwork that follows. In some cases the customer and the end
user are one and the same, but for many projects, the
customer and the end user are different people, working

for different managers, in different business organizations.
A customeris the person or group who (1) originallyrequested the software to be built, (2) defines overall
business objectives for the software, (3) provides basicproduct requirements, and (4) coordinates funding for the
project. In a product or system business, the customer
isoften the marketing department. In an information

technology (IT) environment, the customer might be a
business component or department.
An end useris the person or group who (1) willactually use the software that is built to achieve some
business purpose and (2) will define operational 
details of the software so the business purpose can be
achieved.INFOpre75977_ch04.qxd  11/27/08  3:27 PM  Page 103
Try as we might, itÕs impossible to predict exactly how a software project will
evolve. There is no easy way to determine what unforeseen technical problems willbe encountered, what important information will remain undiscovered until late in

the project, what misunderstandings will occur, or what business issues will change.

And yet, a good software team must plan its approach.There are many different planning philosophies.2Some people are Òminimalists,Óarguing that change often obviates the need for a detailed plan. Others are Òtradi-
tionalists,Ó arguing that the plan provides an effective road map and the more detail

it has, the less likely the team will become lost. Still others are Òagilists,Ó arguing that
a quick Òplanning gameÓ may be necessary, but that the road map will emerge as

Òreal workÓ on the software begins.What to do? On many projects, overplanning is time consuming and fruitless (too
many things change), but underplanning is a recipe for chaos. Like most things in
life, planning should be conducted in moderation, enough to provide useful guidance

for the teamÑno more, no less. Regardless of the rigor with which planning is con-

ducted, the following principles always apply:Principle 1.Understand the scope of the project.
ItÕs impossible to use
a road map if you donÕt know where youÕre going. Scope provides the soft-

ware team with a destination.Principle 2.Involve stakeholders in the planning activity.
Stakeholdersdefine priorities and establish project constraints. To accommodate these
realities, software engineers must often negotiate order of delivery, time

lines, and other project-related issues.Principle 3.Recognize that planning is iterative.
A project plan is neverengraved in stone. As work begins, it is very likely that things will change. Asa consequence, the plan must be adjusted to accommodate these changes. In

addition, iterative, incremental process models dictate replanning after the

delivery of each software increment based on feedback received from users.Principle 4.Estimate based on what you know.
The intent of estimationis to provide an indication of effort, cost, and task duration, based on the
teamÕs current understanding of the work to be done. If information is vague

or unreliable, estimates will be equally unreliable.
Principle 5.Consider risk as you define the plan.
If you have identifiedrisks that have high impact and high probability, contingency planning is
necessary. In addition, the project plan (including the schedule) should be

adjusted to accommodate the likelihood that one or more of these risks will
occur.
104PART TWOMODELINGuote:ÒIn preparing forbattle I have
always found that
plans are useless,
but planning is
indispensable.ÓGeneral DwightD.Eisenhower
WebRef
An excellent repository
of planning and project
management
information can be

found at
www.4pm.com/

repository.htm
.2A detailed discussion of software project planning and management is presented in Part 4 of this
book.uote:ÒSuccess is moreafunction of

consistent common
sense than it is of
genius.ÓAnWang
pre75977_ch04.qxd  11/27/08  3:27 PM  Page 104
Principle 6.Be realistic.
People donÕt work 100 percent of every day.
Noise always enters into any human communication. Omissions andambiguity are facts of life. Change will occur. Even the best software

engineers make mistakes. These and other realities should be considered
asa project plan is established.
Principle 7.Adjust granularity as you define the plan.
Granularity
refers to the level of detail that is introduced as a project plan is developed.AÒhigh-granularityÓ plan provides significant work task detail that is planned

over relatively short time increments (so that tracking and control occur

frequently). A Òlow-granularityÓ plan provides broader work tasks that are

planned over longer time periods. In general, granularity moves from high to

low as the project time line moves away from the current date. Over the

nextfew weeks or months, the project can be planned in significant detail.

Activities that wonÕt occur for many months do not require high granularity

(too much can change).Principle 8.Define how you intend to ensure quality.
The plan shouldidentify how the software team intends to ensure quality. If technical
reviews3are to be conducted, they should be scheduled. If pair programming(Chapter 3) is to be used during construction, it should be explicitly defined
within the plan.Principle 9.Describe how you intend to accommodate change.
Eventhe best planning can be obviated by uncontrolled change. You should iden-
tify how changes are to be accommodated as software engineering work
proceeds. For example, can the customer request a change at any time? If a

change is requested, is the team obliged to implement it immediately? How is
the impact and cost of the change assessed?Principle 10.Track the plan frequently and make adjustments as re-
quired.
Software projects fall behind schedule one day at a time. Therefore,
it makes sense to track progress on a daily basis, looking for problem areasand situations in which scheduled work does not conform to actual work
conducted. When slippage is encountered, the plan is adjusted accordingly.
To be most effective, everyone on the software team should participate in the
planning activity. Only then will team members Òsign upÓ to the plan.
4.3.3Modeling Principles
We create models to gain a better understanding of the actual entity to be built. When

the entity is a physical thing (e.g., a building, a plane, a machine), we can build a

model that is identical in form and shape but smaller in scale. However, when the
CHAPTER 4PRINCIPLES THAT GUIDE PRACTICE105The term 
granularityrefers to the detail
with which some
element of planning is
represented or
conducted.3Technical reviews are discussed in Chapter 15.
pre75977_ch04.qxd  11/27/08  3:27 PM  Page 105
entity to be built is software, our model must take a different form. It must be capa-
ble of representing the information that software transforms, the architecture and
functions that enable the transformation to occur, the features that users desire, and

the behavior of the system as the transformation is taking place. Models must
accomplish these objectives at different levels of abstractionÑfirst depicting the soft-
ware from the customerÕs viewpoint and later representing the software at a more

technical level.In software engineering work, two classes of models can be created: require-ments models and design models. Requirements models(also called analysis models)represent customer requirements by depicting the software in three different do-
mains: the information domain, the functional domain, and the behavioral domain.
Design modelsrepresent characteristics of the software that help practitioners toconstruct it effectively: the architecture, the user interface, and component-level

detail.In their book on agile modeling, Scott Ambler and Ron Jeffries [Amb02b] define aset of modeling principles4that are intended for those who use the agile processmodel (Chapter 3) but are appropriate for all software engineers who perform mod-
eling actions and tasks: Principle 1.The primary goal of the software team is to build soft-
ware, not create models.
Agility means getting software to the customerin the fastest possible time. Models that make this happen are worth creat-
ing, but models that slow the process down or provide little new insight

should be avoided.Principle 2.Travel lightÑdonÕt create more models than you need.
Every model that is created must be kept up-to-date as changes occur. More
importantly, every new model takes time that might otherwise be spent on

construction (coding and testing). Therefore, create only those models that

make it easier and faster to construct the software.Principle 3.Strive to produce the simplest model that will describe the
problem or the software.
DonÕt overbuild the software [Amb02b]. By
keeping models simple, the resultant software will also be simple. The result
is software that is easier to integrate, easier to test, and easier to maintain (to

change). In addition, simple models are easier for members of the software
team to understand and critique, resulting in an ongoing form of feedback

that optimizes the end result.Principle 4.Build models in a way that makes them amenable to change.
Assume that your models will change, but in making this assumption donÕt
106PART TWOMODELINGRequirements modelsrepresent customer
requirements. Design
models provide a
concrete specification
for the construction of

the software.4The principles noted in this section have been abbreviated and rephrased for the purposes of this
book.The intent of any
model is to communi-
cate information. To

accomplish this, use a
consistent format.

Assume that you wonÕt
be there to explain the
model. It should stand
on its own.pre75977_ch04.qxd  11/27/08  3:27 PM  Page 106
get sloppy. For example, since requirements will change, there is a tendency
to give requirements models short shrift. Why? Because you know that theyÕll
change anyway. The problem with this attitude is that without a reasonably

complete requirements model, youÕll create a design (design model) that will
invariably miss important functions and features.
Principle 5.Be able to state an explicit purpose for each model that
is created.
Every time you create a model, ask yourself why youÕre doingso. If you canÕt provide solid justification for the existence of the model,
donÕt spend time on it.
Principle 6.Adapt the models you develop to the system at hand.
Itmay be necessary to adapt model notation or rules to the application; for ex-ample, a video game application might require a different modeling technique

than real-time, embedded software that controls an automobile engine.
Principle 7.Try to build useful models, but forget about building per-
fect models.When building requirements and design models, a softwareengineer reaches a point of diminishing returns. That is, the effort required tomake the model absolutely complete and internally consistent is not worth
the benefits of these properties. Am I suggesting that modeling should be
sloppy or low quality? The answer is Òno.Ó But modeling should be conducted
with an eye to the next software engineering steps. Iterating endlessly to
make a model ÒperfectÓ does not serve the need for agility.
Principle 8.DonÕt become dogmatic about the syntax of the model. If
it communicates content successfully, representation is secondary.
Although everyone on a software team should try to use consistent notation
during modeling, the most important characteristic of the model is to com-
municate information that enables the next software engineering task. If a
model does this successfully, incorrect syntax can be forgiven.
Principle 9.If your instincts tell you a model isnÕt right even though it
seems okay on paper, you probably have reason to be concerned.
Ifyou are an experienced software engineer, trust your instincts. Software
work teaches many lessonsÑsome of them on a subconscious level. If some-
thing tells you that a design model is doomed to fail (even though you canÕt

prove it explicitly), you have reason to spend additional time examining the

model or developing a different one.Principle 10.Get feedback as soon as you can.
Every model should bereviewed by members of the software team. The intent of these reviews is toprovide feedback that can be used to correct modeling mistakes, change mis-

interpretations, and add features or functions that were inadvertently omitted.Requirements modeling principles.
Over the past three decades, a large num-ber of requirements modeling methods have been developed. Investigators have
CHAPTER 4PRINCIPLES THAT GUIDE PRACTICE107pre75977_ch04.qxd  11/27/08  3:27 PM  Page 107
identified requirements analysis problems and their causes and have developedavariety of modeling notations and corresponding sets of heuristics to overcome

them. Each analysis method has a unique point of view. However, all analysis meth-

ods are related by a set of operational principles:Principle 1.The information domain of a problem must be represented
and understood.The information domainencompasses the data that flowinto the system (from end users, other systems, or external devices), the data
that flow out of the system (via the user interface, network interfaces, reports,

graphics, and other means), and the data stores that collect and organize per-
sistent data objects (i.e., data that are maintained permanently).Principle 2.The functions that the software performs must be defined.
Software functions provide direct benefit to end users and also provide inter-
nal support for those features that are user visible. Some functions transform
data that flow into the system. In other cases, functions effect some level of
control over internal software processing or external system elements. Func-

tions can be described at many different levels of abstraction, ranging from a
general statement of purpose to a detailed description of the processing
elements that must be invoked.
Principle 3.The behavior of the software (as a consequence of external
events) must be represented.
The behavior of computer software is drivenby its interaction with the external environment. Input provided by end users,
control data provided by an external system, or monitoring data collected

over a network all cause the software to behave in a specific way.
Principle 4.The models that depict information, function, and behaviormust be partitioned in a manner that uncovers detail in a layered (or
hierarchical) fashion.
Requirements modeling is the first step in softwareengineering problem solving. It allows you to better understand the problem
and establishes a basis for the solution (design). Complex problems are difficult
to solve in their entirety. For this reason, you should use a divide-and-conquer

strategy. A large, complex problem is divided into subproblems until each sub-

problem is relatively easy to understand. This concept is called partitioningorseparation of concerns,
and it is a key strategy in requirements modeling.Principle 5.The analysis task should move from essential information
toward implementation detail.
Requirements modeling begins by describ-ing the problem from the end-userÕs perspective. The ÒessenceÓ of the

problem is described without any consideration of how a solution will be
implemented. For example, a video game requires that the player ÒinstructÓ

its protagonist on what direction to proceed as she moves into a dangerous

maze. That is the essence of the problem. Implementation detail (normally
described as part of the design model) indicates how the essence will be
implemented. For the video game, voice input might be used. Alternatively,
108PART TWOMODELINGAnalysis modelingfocuses on three
attributes of software:
information to be

processed, function to
be delivered, and
behavior to be
exhibited.uote:ÒThe engineerÕs

first problem in
any design
situation is to
discover what the
problem really is.ÓAuthor unknownpre75977_ch04.qxd  11/27/08  3:27 PM  Page 108
akeyboard command might be typed, a joystick (or mouse) might be pointed
in a specific direction, or a motion-sensitive device might be waved in the air.
By applying these principles, a software engineer approaches a problem system-atically. But how are these principles applied in practice? This question will be an-

swered in Chapters 5 through 7.Design Modeling Principles.The software design model is analogous to anarchitectÕs plans for a house. It begins by representing the totality of the thing to be
built (e.g., a three-dimensional rendering of the house) and slowly refines the thing
to provide guidance for constructing each detail (e.g., the plumbing layout). Similarly,

the design model that is created for software provides a variety of different views of

the system.There is no shortage of methods for deriving the various elements of a softwaredesign. Some methods are data driven, allowing the data structure to dictate the pro-
gram architecture and the resultant processing components. Others are pattern
driven, using information about the problem domain (the requirements model) to de-
velop architectural styles and processing patterns. Still others are object oriented,
using problem domain objects as the driver for the creation of data structures and
the methods that manipulate them. Yet all embrace a set of design principles that can

be applied regardless of the method that is used:Principle 1.Design should be traceable to the requirements model.
The requirements model describes the information domain of the problem,
user-visible functions, system behavior, and a set of requirements classes

that package business objects with the methods that service them. The de-
sign model translates this information into an architecture, a set of subsys-

tems that implement major functions, and a set of components that are the
realization of requirements classes. The elements of the design model should
be traceable to the requirements model.Principle 2.Always consider the architecture of the system to be built.
Software architecture (Chapter 9) is the skeleton of the system to be built. Itaffects interfaces, data structures, program control flow and behavior, the

manner in which testing can be conducted, the maintainability of the result-
ant system, and much more. For all of these reasons, design should start with
architectural considerations. Only after the architecture has been established
should component-level issues be considered.Principle 3.Design of data is as important as design of processing
functions.Data design is an essential element of architectural design. Themanner in which data objects are realized within the design cannot be left tochance. A well-structured data design helps to simplify program flow, makes

the design and implementation of software components easier, and makes

overall processing more efficient.
CHAPTER 4PRINCIPLES THAT GUIDE PRACTICE109uote:ÒSee first that thedesign is wise
andjust: that

ascertained, pursue
it resolutely; do not
for one repulse
forego the purpose
that you resolved
to effect.ÓWilliamShakespeareWebRef
Insightful commentsonthe design process,

along with a discussion
of design aesthetics,
can be found at
cs.wwc.edu/
~aabyan/Design/.pre75977_ch04.qxd  11/27/08  3:27 PM  Page 109
Principle 4.Interfaces (both internal and external) must be designed
with care.
The manner in which data flows between the components of asystem has much to do with processing efficiency, error propagation, and
design simplicity. A well-designed interface makes integration easier and

assists the tester in validating component functions.Principle 5. User interface design should be tuned to the needs of theend user. However, in every case, it should stress ease of use.
Theuserinterface is the visible manifestation of the software. No matter how
sophisticated its internal functions, no matter how comprehensive its data
structures, no matter how well designed its architecture, a poor interface

design often leads to the perception that the software is Òbad.ÓPrinciple 6. Component-level design should be functionally independ-ent.Functional independence is a measure of the Òsingle-mindednessÓ of asoftware component. The functionality that is delivered by a componentshould be cohesiveÑthat is, it should focus on one and only one function or
subfunction.5Principle 7. Components should be loosely coupled to one anotherand to the external environment.
Coupling is achieved in many waysÑvia a component interface, by messaging, through global data. As the level of

coupling increases, the likelihood of error propagation also increases and the
overall maintainability of the software decreases. Therefore, component cou-

pling should be kept as low as is reasonable.Principle 8. Design representations (models) should be easily under-
standable.
The purpose of design is to communicate information to practi-tioners who will generate code, to those who will test the software, and to
others who may maintain the software in the future. If the design is difficult
to understand, it will not serve as an effective communication medium.Principle 9. The design should be developed iteratively. With each
iteration, the designer should strive for greater simplicity.
Like almostall creative activities, design occurs iteratively. The first iterations work to
refine the design and correct errors, but later iterations should strive to make
the design as simple as is possible.When these design principles are properly applied, you create a design that exhibitsboth external and internal quality factors [Mye78]. External quality factorsare thoseproperties of the software that can be readily observed by users (e.g., speed, reliability,

correctness, usability). Internal quality factorsare of importance to software engineers.They lead to a high-quality design from the technical perspective. To achieve internal

quality factors, the designer must understand basic design concepts (Chapter 8).110PART TWOMODELINGuote:ÒThe differencesare not minorÑ
they are rather like
the differences
between Salieri
and Mozart. Study
after study shows
that the very best

designers produce
structures that are
faster, smaller,

simpler, clearer,

and produced with
less effort.ÓFrederick P.
Brooks5Additional discussion of cohesion can be found in Chapter 8.
pre75977_ch04.qxd  11/27/08  3:27 PM  Page 110
4.3.4Construction Principles
The construction activity encompasses a set of coding and testing tasks that lead tooperational software that is ready for delivery to the customer or end user. In mod-

ern software engineering work, coding may be (1) the direct creation of program-
ming language source code (e.g., Java), (2) the automatic generation of source code
using an intermediate design-like representation of the component to be built, or
(3)the automatic generation of executable code using a Òfourth-generation pro-

gramming languageÓ (e.g., Visual C
).The initial focus of testing is at the component level, often called unit testing.Otherlevels of testing include (1) integration testing
(conducted as the system is con-structed), validation testingthat assesses whether requirements have been met forthe complete system (or software increment), and (3) acceptance testingthat is con-ducted by the customer in an effort to exercise all required features and functions.
The following set of fundamental principles and concepts are applicable to coding
and testing:CodingPrinciples.
The principles that guide the coding task are closely alignedwith programming style, programming languages, and programming methods.
However, there are a number of fundamental principles that can be stated:
Preparation principles: 
Before you write one line of code, be sure you
¥Understand of the problem youÕre trying to solve.¥Understand basic design principles and concepts.¥Pick a programming language that meets the needs of the software to be
built and the environment in which it will operate.
¥Select a programming environment that provides tools that will make your

work easier.
¥Create a set of unit tests that will be applied once the component you code is
completed.Programming principles: 
As you begin writing code, be sure you
¥Constrain your algorithms by following structured programming [Boh00]
practice.¥Consider the use of pair programming.¥Select data structures that will meet the needs of the design.¥Understand the software architecture and create interfaces that are
consistent with it.¥Keep conditional logic as simple as possible.
¥Create nested loops in a way that makes them easily testable.¥Select meaningful variable names and follow other local coding standards.CHAPTER 4PRINCIPLES THAT GUIDE PRACTICE111uote:ÒFor much of mylife, I have been a
software voyeur,

peeking furtively
at other peopleÕs

dirty code.
Occasionally, I find

a real jewel, a well-
structured program
written in a
consistent style,
free of kludges,
developed so that
each component is
simple and
organized, and
designed so that
the product is easy
to change.ÓDavidParnas
Avoid developing an
elegant program that
solves the wrong
problem. Pay particular

attention to the first
preparation principle.pre75977_ch04.qxd  11/27/08  3:27 PM  Page 111
¥Write code that is self-documenting.¥Create a visual layout (e.g., indentation and blank lines) that aidsunderstanding.Validation Principles: 
After youÕve completed your first coding pass, 
be sure you
¥Conduct a code walkthrough when appropriate.¥Perform unit tests and correct errors youÕve uncovered.
¥Refactor the code.More books have been written about programming (coding) and the principles and
concepts that guide it than about any other topic in the software process. Books on
the subject include early works on programming style [Ker78], practical software

construction [McC04], programming pearls [Ben99], the art of programming
[Knu98], pragmatic programming issues [Hun99], and many, many other subjects.

A comprehensive discussion of these principles and concepts is beyond the scope
of this book. If you have further interest, examine one or more of the references
noted.Testing Principles.
In a classic book on software testing, Glen Myers [Mye79]states a number of rules that can serve well as testing objectives:¥Testing is a process of executing a program with the intent of finding
anerror.
¥A good test case is one that has a high probability of finding an as-yet-
undiscovered error.
¥A successful test is one that uncovers an as-yet-undiscovered error.
These objectives imply a dramatic change in viewpoint for some software develop-
ers. They move counter to the commonly held view that a successful test is one in

which no errors are found. Your objective is to design tests that systematically un-

cover different classes of errors and to do so with a minimum amount of time and

effort.If testing is conducted successfully (according to the objectives stated previously),it will uncover errors in the software. As a secondary benefit, testing demonstrates

that software functions appear to be working according to specification, and that
behavioral and performance requirements appear to have been met. In addition, the
data collected as testing is conducted provide a good indication of software reliabil-

ity and some indication of software quality as a whole. But testing cannot show the
absence of errors and defects; it can show only that software errors and defects are
present. It is important to keep this (rather gloomy) statement in mind as testing is
being conducted.112PART TWOMODELINGWebRef
A wide variety of linksto coding standards can
be found at www
.literateprogramm
ing.com/fpstyle
.html.What are theobjectives ofsoftware testing??In a broader software
design context, recall
that you begin Òin the
largeÓ by focusing on
software architecture
and end Òin the smallÒ
focusing on compo-
nents. For testing, you
simply reverse the
focus and test your
way out.pre75977_ch04.qxd  11/27/08  3:27 PM  Page 112
Davis [Dav95b] suggests a set of testing principles6that have been adapted for usein this book:Principle 1.All tests should be traceable to customer requirements.
7The objective of software testing is to uncover errors. It follows that the most
severe defects (from the customerÕs point of view) are those that cause the

program to fail to meet its requirements.Principle 2.Tests should be planned long before testing begins.
Test
planning (Chapter 17) can begin as soon as the requirements model is com-plete. Detailed definition of test cases can begin as soon as the design model
has been solidified. Therefore, all tests can be planned and designed before

any code has been generated.Principle 3.The Pareto principle applies to software testing.
In thiscontext the Pareto principle implies that 80 percent of all errors uncovered
during testing will likely be traceable to 20 percent of all program compo-
nents. The problem, of course, is to isolate these suspect components and to

thoroughly test them.Principle 4.Testing should begin Òin the smallÓ and progress toward
testing Òin the large.ÓThe first tests planned and executed generally focuson individual components. As testing progresses, focus shifts in an attemptto find errors in integrated clusters of components and ultimately in the
entire system.Principle 5.Exhaustive testing is not possible.
The number of path per-mutations for even a moderately sized program is exceptionally large. Forthis reason, it is impossible to execute every combination of paths during
testing. It is possible, however, to adequately cover program logic and to en-

sure that all conditions in the component-level design have been exercised.4.3.5Deployment Principles
As I noted earlier in Part 1 of this book, the deployment activity encompasses three
actions: delivery, support, and feedback. Because modern software process models

are evolutionary or incremental in nature, deployment happens not once, but a num-

ber of times as software moves toward completion. Each delivery cycle provides the

customer and end users with an operational software increment that provides usable

functions and features. Each support cycle provides documentation and human

assistance for all functions and features introduced during all deployment cycles toCHAPTER 4PRINCIPLES THAT GUIDE PRACTICE1136Only a small subset of DavisÕs testing principles are noted here. For more information, see
[Dav95b].7This principle refers to 
functional tests, i.e., tests that focus on requirements. Structural tests(teststhat focus on architectural or logical detail) may not address specific requirements directly.pre75977_ch04.qxd  11/27/08  3:27 PM  Page 113
date. Each feedback cycle provides the software team with important guidance that
results in modifications to the functions, features, and approach taken for the next
increment.The delivery of a software increment represents an important milestone for anysoftware project. A number of key principles should be followed as the team pre-
pares to deliver an increment:Principle 1.Customer expectations for the software must be managed.
Too often, the customer expects more than the team has promised to deliver,

and disappointment occurs immediately. This results in feedback that is not

productive and ruins team morale. In her book on managing expectations,
Naomi Karten [Kar94] states: ÒThe starting point for managing expectations
is to become more conscientious about what you communicate and how.Ó

She suggests that a software engineer must be careful about sending the cus-
tomer conflicting messages (e.g., promising more than you can reasonably
deliver in the time frame provided or delivering more than you promise for

one software increment and then less than promised for the next).Principle 2.A complete delivery package should be assembled and
tested.A CD-ROM or other media (including Web-based downloads)
containing all executable software, support data files, support documents,
and other relevant information should be assembled and thoroughly 
beta-tested with actual users. All installation scripts and other operational
features should be thoroughly exercised in as many different computing
configurations (i.e., hardware, operating systems, peripheral devices, net-

working arrangements) as possible.Principle 3.A support regime must be established before the software
is delivered.
An end user expects responsiveness and accurate informationwhen a question or problem arises. If support is ad hoc, or worse, nonexist-
ent, the customer will become dissatisfied immediately. Support should be

planned, support materials should be prepared, and appropriate record-
keeping mechanisms should be established so that the software team can
conduct a categorical assessment of the kinds of support requested.Principle 4.Appropriate instructional materials must be provided to
end users.The software team delivers more than the software itself.Appropriate training aids (if required) should be developed; troubleshootingguidelines should be provided, and when necessary, a ÒwhatÕs different about

this software incrementÓ description should be published.8114PART TWOMODELINGBe sure that your cus-tomer knows what to
expect before a soft-
ware increment is
delivered. Otherwise,

you can bet the cus-
tomer will expect more
than you deliver.
8During the communication activity, the software team should determine what types of help mate-
rials users want.pre75977_ch04.qxd  11/27/08  3:27 PM  Page 114
Principle 5.Buggy software should be fixed first, delivered later.
Undertime pressure, some software organizations deliver low-quality increments
with a warning to the customer that bugs Òwill be fixed in the next release.Ó
This is a mistake. ThereÕs a saying in the software business: ÒCustomers will

forget you delivered a high-quality product a few days late, but they will

never forget the problems that a low-quality product caused them. The soft-
ware reminds them every day.Ó
The delivered software provides benefit for the end user, but it also provides use-
ful feedback for the software team. As the increment is put into use, end users should

be encouraged to comment on features and functions, ease of use, reliability, and

any other characteristics that are appropriate.4.4S
UMMARYSoftware engineering practice encompasses principles, concepts, methods, and
tools that software engineers apply throughout the software process. Every software
engineering project is different. Yet, a set of generic principles apply to the process

as a whole and to the practice of each framework activity regardless of the project
or the product.A set of core principles help in the application of a meaningful software processand the execution of effective software engineering methods. At the process level,
core principles establish a philosophical foundation that guides a software team as
it navigates through the software process. At the level of practice, core principles

establish a collection of values and rules that serve as a guide as you analyze a prob-
lem, design a solution, implement and test the solution, and ultimately deploy the
software in the user community.
Communication principles focus on the need to reduce noise and improve band-
width as the conversation between developer and customer progresses. Both parties

must collaborate for the best communication to occur.
Planning principles provide guidelines for constructing the best map for the
journey to a completed system or product. The plan may be designed solely for a
single software increment, or it may be defined for the entire project. Regardless,
it must address what will be done, who will do it, and when the work will be

completed.Modeling encompasses both analysis and design, describing representations ofthe software that progressively become more detailed. The intent of the models isto

solidify understanding of the work to be done and to provide technical guidance to

those who will implement the software. Modeling principles serve as a founda-
tionfor the methods and notation that are used to create representations of the

software.Construction incorporates a coding and testing cycle in which source code for acomponent is generated and tested. Coding principles define generic actions thatCHAPTER 4PRINCIPLES THAT GUIDE PRACTICE115pre75977_ch04.qxd  11/27/08  3:27 PM  Page 115
should occur before code is written, while it is being created, and after it has beencompleted. Although there are many testing principles, only one is dominant: test-
ing is a process of executing a program with the intent of finding an error.
Deployment occurs as each software increment is presented to the customer andencompasses delivery, support, and feedback. Key principles for delivery consider

managing customer expectations and providing the customer with appropriate sup-

port information for the software. Support demands advance preparation. Feedback
allows the customer to suggest changes that have business value and provide the

developer with input for the next iterative software engineering cycle.PROBLEMSAND
POINTSTO
PONDER4.1.Since a focus on quality demands resources and time, is it possible to be agile and still
maintain a quality focus?4.2.Of the eight core principles that guide process (discussed in Section 4.2.1), which do youbelieve is most important?
4.3.Describe the concept of separation of concerns
in your own words.4.4.An important communication principle states Òprepare before you communicate.Ó Howshould this preparation manifest itself in the early work that you do? What work products mightresult as a consequence of early preparation?4.5.Do some research on ÒfacilitationÓ for the communication activity (use the references pro-vided or others) and prepare a set of guidelines that focus solely on facilitation.
4.6.How does agile communication differ from traditional software engineering communica-tion? How is it similar?
4.7.Why is it necessary to Òmove onÓ?
4.8.Do some research on ÒnegotiationÓ for the communication activity and prepare a set ofguidelines that focus solely on negotiation.
4.9.Describe what granularity
means in the context of a project schedule.4.10.Why are models important in software engineering work? Are they always necessary?Are there qualifiers to your answer about necessity?
4.11.What three ÒdomainsÓ are considered during requirements modeling?4.12.Try to add one additional principle to those stated for coding in Section 4.3.4.
4.13.What is a successful test?4.14.Do you agree or disagree with the following statement: ÒSince we deliver multiple incre-ments to the customer, why should we be concerned about quality in the early incrementsÑwe
can fix problems in later iterations.Ó Explain your answer.
4.15.Why is feedback important to the software team?FURTHER
READINGSAND
INFORMATION
SOURCESCustomer communication is a critically important activity in software engineering, yet few prac-titioners spend any time reading about it. Withall (
Software Requirements Patterns,
MicrosoftPress, 2007) presents a variety of useful patterns that address communications problems. Sutliff116PART TWOMODELINGpre75977_ch04.qxd  11/27/08  3:27 PM  Page 116
(User-Centred Requirements Engineering,
Springer, 2002) focuses heavily on communications-
related challenges. Books by Weigers (
Software Requirements,2d ed., Microsoft Press, 2003),Pardee (To Satisfy and Delight Your Customer,
Dorset House, 1996), and Karten [Kar94] provide
much insight into methods for effective customer interaction. Although their book does notfocus on software, Hooks and Farry (
Customer Centered Products, American Management Asso-
ciation, 2000) present useful generic guidelines for customer communication. Young (
Effective
Requirements Practices,
Addison-Wesley, 2001) emphasizes a Òjoint teamÓ of customers and
developers who develop requirements collaboratively. Somerville and Kotonya (
RequirementsEngineering: Processes and Techniques,
Wiley, 1998) discuss ÒelicitationÓ concepts and tech-
niques and other requirements engineering principles.Communication and planning concepts and principles are considered in many project man-agement books. Useful project management offerings include books by Bechtold (Essentials ofSoftware Project Management,2d ed., Management Concepts, 2007), Wysocki (
Effective ProjectManagement: Traditional, Adaptive, Extreme,
4th ed., Wiley, 2006), Leach (
Lean Project Manage-ment: Eight Principles for Success,BookSurge Publishing, 2006), Hughes (Software Project Man-agement,McGraw-Hill, 2005), and Stellman and Greene (
Applied Software Project Management,OÕReilly Media, Inc., 2005).Davis [Dav95] has compiled an excellent collection of software engineering principles. In ad-dition, virtually every book on software engineering contains a useful discussion of concepts
and principles for analysis, design, and testing. Among the most widely used offerings (in addi-
tion to this book!) are:Abran, A., and J. Moore, 
SWEBOK: Guide to the Software Engineering Body of Knowledge,IEEE,2002.Christensen, M., and R. Thayer, 
A Project ManagerÕs Guide to Software Engineering Best Prac-
tices,IEEE-CS Press (Wiley), 2002.
Jalote, P., 
An Integrated Approach to Software Engineering,
Springer, 2006.
Pfleeger, S., 
Software Engineering: Theory and Practice,
3d ed., Prentice-Hall, 2005.Schach, S., Object-Oriented and Classical Software Engineering,McGraw-Hill, 7th ed., 2006.
Sommerville, I., 
Software Engineering,8th ed., Addison-Wesley, 2006.
These books also present detailed discussion of modeling and construction principles.Modelingprinciplesareconsideredinmanybooksdedicatedtorequirementsanalysis
and/orsoftwaredesign.BooksbyLieberman(
TheArtofSoftwareModeling,
Auerbach,2007),
RosenbergandStephens(
UseCaseDrivenObjectModelingwithUML:TheoryandPractice,

Apress,2007),Roques(
UMLinPractice,
Wiley,2004),PenkerandEriksson(
BusinessModelingwithUML:BusinessPatternsatWork,
Wiley,2001)discussmodelingprinciplesand
methods.NormanÕs (
The Design of Everyday Things,Currency/Doubleday, 1990) is must reading for
every software engineer who intends to do design work. Winograd and his colleagues (
Bringing
Design to Software,Addison-Wesley, 1996) have edited an excellent collection of essays that
address practical issues for software design. Constantine and Lockwood (Software for Use,
Addison-Wesley, 1999) present the concepts associated with Òuser centered design.Ó Tognazzini

(Tog on Software Design,
Addison-Wesley, 1995) presents a worthwhile philosophical discussion
of the nature of design and the impact of decisions on quality and a teamÕs ability to produce

software that provides great value to its customer. Stahl and his colleagues (
Model-Driven Software Development: Technology, Engineering,
Wiley, 2006) discuss the principles of
model-driven development.Hundredsofbooksaddressoneormoreelementsoftheconstructionactivity.Kernighan
andPlauger[Ker78]havewrittenaclassictextonprogrammingstyle,McConnell[McC93]

presentspragmaticguidelinesforpracticalsoftwareconstruction,Bentley[Ben99]suggests

awidevarietyofprogrammingpearls,Knuth[Knu99]haswrittenaclassicthree-volume

seriesontheartofprogramming,andHunt[Hun99]suggestspragmaticprogramming

guidelines.Myers and his colleagues (The Art of Software Testing,
2d ed., Wiley, 2004) have developed a
major revision of his classic text and discuss many important testing principles. Books by PerryCHAPTER 4PRINCIPLES THAT GUIDE PRACTICE117pre75977_ch04.qxd  11/27/08  3:27 PM  Page 117
(Effective Methods for Software Testing,
3d ed., Wiley, 2006), Whittaker (
How to Break Software,Addison-Wesley, 2002), Kaner and his colleagues (
Lessons Learned in Software Testing,
Wiley,
2001), and Marick (The Craft of Software Testing,
Prentice-Hall, 1997) each present important testingconcepts and principles and much pragmatic guidance.A wide variety of information sources on software engineering practice are available on theInternet. An up-to-date list of World Wide Web references that are relevant to software engi-
neering practice can be found at the SEPA website:
www.mhhe.com/engcs/compsci/
pressman/professional/olc/ser.htm
.118PART TWOMODELINGpre75977_ch04.qxd  11/27/08  3:27 PM  Page 118
Understanding the requirements of a problem is among the most difficulttasks that face a software engineer. When you first think about it, devel-

oping a clear understanding of requirements doesnÕt seem that hard. After
all, doesnÕt the customer know what is required? ShouldnÕt the end users have

agood understanding of the features and functions that will provide benefit?

Surprisingly, in many instances the answer to these questions is Òno.Ó And even if

customers and end-users are explicit in their needs, those needs will change
throughout the project.In the forward to a book by Ralph Young [You01] on effective requirements
practices, I wrote:ItÕs your worst nightmare. A customer walks into your office, sits down, looks you
straight in the eye, and says, ÒI know you think you understand what I said, but what

you donÕt understand is what I said is not what I meant.Ó Invariably, this happens late
119CHAPTER5UNDERSTANDING
REQUIREMENTSWhat is it?Before you begin anytechnical work, itÕs a good idea to
apply a set of requirements engi-
neering tasks. These tasks lead to anunderstanding of what the business impact of the
software will be, what the customer wants, and
how end users will interact with the software.Who does it?Software engineers (sometimesreferred to as system engineers or ÒanalystsÓ in
the IT world) and other project stakeholders
(managers, customers, end users) all participate

in requirements engineering.Why is it important?
Designing and building anelegant computer program that solves the wrong
problem serves no oneÕs needs. ThatÕs why itÕs

important to understand what the customer

wants before you begin to design and build a
computer-based system.What are the steps?Requirements engineeringbegins with inceptionÑa task that defines the
scope and nature of the problem to be solved. It
moves onwards to elicitationÑa task that helps
stakeholders define what is required, and thenQUICKLOOKelaborationÑwhere basic requirements are
refined and modified. As stakeholders define the
problem, negotiation occursÑwhat are the
priorities, what is essential, when is it required?
Finally, the problem is specified in some manner

and then reviewed or validated to ensure that
your understanding of the problem and the
stakeholdersÕ understanding of the problem
coincide.What is the work product?
The intent of require-ments engineering is to provide all parties with

a written understanding of the problem. This can
be achieved though a number of work products:
usage scenarios, functions and features lists,
requirements models, or a specification.How do I ensure that IÕve done it right?Requirements engineering work products are
reviewed with stakeholders to ensure that what
you have learned is what they really meant. A

word of warning: even after all parties agree,

things will change, and they will continue to
change throughout the project.KEYCONCEPTSanalysis model . . . . . . .138
analysis patterns . . . . . .142
collaboration . .126

elaboration . . . .122

elicitation . . . . .121

inception . . . . .121

negotiation . . . .122

quality functiondeployment . . .131
pre75977_ch05.qxd  11/27/08  3:30 PM  Page 119
ItÕs reasonable to argue that the techniques IÕll discuss in this chapter are not a
true ÒsolutionÓ to the challenges just noted. But they do provide a solid approach for
addressing these challenges.5.1R
EQUIREMENTSENGINEERINGDesigning and building computer software is challenging, creative, and just plain

fun. In fact, building software is so compelling that many software developers want
to jump right in before they have a clear understanding of what is needed. They argue
that things will become clear as they build, that project stakeholders will be able to
understand need only after examining early iterations of the software, that things

change so rapidly that any attempt to understand requirements in detail is a waste
of time, that the bottom line is producing a working program and all else is second-

ary. What makes these arguments seductive is that they contain elements of truth.
1But each is flawed and can lead to a failed software project.
The broad spectrum of tasks and techniques that lead to an understanding of re-quirements is called requirements engineering.From a software process perspective,
requirements engineering is a major software engineering action that begins during
the communication activity and continues into the modeling activity. It must be

adapted to the needs of the process, the project, the product, and the people doing
the work.Requirements engineering builds a bridge to design and construction. But wheredoes the bridge originate? One could argue that it begins at the feet of the project
stakeholders (e.g., managers, customers, end users), where business need is
defined, user scenarios are described, functions and features are delineated, and
project constraints are identified. Others might suggest that it begins with a broader
system definition, where software is but one component of the larger system
domain. But regardless of the starting point, the journey across the bridge takes you120PART TWOMODELINGuote:ÒThehardestsingle
partofbuildinga

softwaresystem

isdecidingwhatto

build.Nopartofthe

worksocripplesthe

resultingsystemif

donewrong.No

otherpartismore

difficulttorectify

later.Ó
FredBrooks
Requirementsengineering establishes
a solid base for design
and construction.

Without it, the

resulting software has
a high probability of
not meeting
customerÕs needs.
1This is particularly true for small projects (less than one month) and smaller, relatively simple soft-
ware efforts. As software grows in size and complexity, these arguments begin to break down.requirementsengineering . . .120
requirementsgathering . . . . .128
requirementsmanagement . .124
specification . . .122

stakeholders . .125

use cases . . . . .133

validatingrequirements . .144
validation . . . . .123

viewpoints . . . .126

work products . . . . . .133
in the project, after deadline commitments have been made, reputations are on the line,
and serious money is at stake.Allofuswhohaveworkedinthesystemsandsoftwarebusinessformorethanafew
yearshavelivedthisnightmare,andyet,fewofushavelearnedtomakeitgoaway.We

strugglewhenwetrytoelicitrequirementsfromourcustomers.Wehavetroubleunder-

standingtheinformationthatwedoacquire.Weoftenrecordrequirementsinadisor-

ganizedmanner,andwespendfartoolittletimeverifyingwhatwedorecord.Weallow

changetocontrolus,ratherthanestablishingmechanismstocontrolchange.Inshort,we

failtoestablishasolidfoundationforthesystemorsoftware.Eachoftheseproblemsis

challenging.Whentheyarecombined,theoutlookisdauntingforeventhemostexperi-

encedmanagersandpractitioners.Butsolutionsdoexist.
pre75977_ch05.qxd  11/27/08  3:30 PM  Page 120
high above the project, allowing you to examine the context of the software work to
be performed; the specific needs that design and construction must address; the pri-
orities that guide the order in which work is to be completed; and the information,
functions, and behaviors that will have a profound impact on the resultant design.Requirementsengineeringprovidestheappropriatemechanismforunderstand-
ingwhatthecustomerwants,analyzingneed,assessingfeasibility,negotiatingarea-

sonablesolution,specifyingthesolutionunambiguously,validatingthespecification,

andmanagingtherequirementsastheyaretransformedintoanoperationalsystem

[Tha97].Itencompassessevendistincttasks:inception,elicitation,elaboration,

negotiation,specification,validation,andmanagement.Itisimportanttonotethat

someofthesetasksoccurinparallelandallareadaptedtotheneedsoftheproject.
Inception.How does a software project get started? Is there a single event thatbecomes the catalyst for a new computer-based system or product, or does the needevolve over time? There are no definitive answers to these questions. In some cases,

a casual conversation is all that is needed to precipitate a major software engineer-

ing effort. But in general, most projects begin when a business need is identified
orapotential new market or service is discovered. Stakeholders from the business

community (e.g., business managers, marketing people, product managers) define

abusiness case for the idea, try to identify the breadth and depth of the market, do a

rough feasibility analysis, and identify a working description of the projectÕs scope.

All of this information is subject to change, but it is sufficient to precipitate discus-

sions with the software engineering organization.2Atprojectinception,
3youestablishabasicunderstandingoftheproblem,thepeo-
plewhowantasolution,thenatureofthesolutionthatisdesired,andtheeffective-

nessofpreliminarycommunicationandcollaborationbetweentheotherstakeholders

andthesoftwareteam.
Elicitation.ItcertainlyseemssimpleenoughÑaskthecustomer,theusers,and
otherswhattheobjectivesforthesystemorproductare,whatistobeaccomplished,
howthesystemorproductfitsintotheneedsofthebusiness,andfinally,howthesys-

temorproductistobeusedonaday-to-daybasis.ButitisnÕtsimpleÑitÕsveryhard.
Christel and Kang [Cri92] identify a number of problems that are encountered aselicitation occurs.¥Problems of scope.
The boundary of the system is ill-defined or thecustomers/users specify unnecessary technical detail that may confuse,

rather than clarify, overall system objectives.
CHAPTER 5UNDERSTANDING REQUIREMENTS121Expect to do a bit ofdesign during require-
ments work and a bit
of requirements work
during design.uote:ÒThe seeds ofmajor software
disasters are
usually sown in the
first three months
of commencing the
software project.ÓCaperJones
2If a computer-based system is to be developed, discussions begin within the context of a system
engineering process. For a detailed discussion of system engineering, visit the website thataccompanies this book.3Recall that the Unified Process (Chapter 2) defines a more comprehensive Òinception phaseÓ that
encompasses the inception, elicitation, and elaboration tasks discussed in this chapter.Why is itdifficult togain a clear
understanding of
what the
customer wants??pre75977_ch05.qxd  11/27/08  3:30 PM  Page 121
122PART TWOMODELING¥Problems of understanding.
The customers/users are not completely sureof what is needed, have a poor understanding of the capabilities and limita-tions of their computing environment, donÕt have a full understanding of the

problem domain, have trouble communicating needs to the system engineer,

omit information that is believed to be Òobvious,Ó specify requirements that
conflict with the needs of other customers/users, or specify requirements
that are ambiguous or untestable.¥Problems of volatility.
The requirements change over time.
To help overcome these problems, you must approach requirements gathering in an

organized manner.
Elaboration.
The information obtained from the customer during inception andelicitation is expanded and refined during elaboration. This task focuses on devel-oping a refined requirements model (Chapters 6 and 7) that identifies various aspects
of software function, behavior, and information.
Elaboration is driven by the creation and refinement of user scenarios that de-scribe how the end user (and other actors) will interact with the system. Each user
scenario is parsed to extract analysis classesÑbusiness domain entities that are
visible to the end user. The attributes of each analysis class are defined, and the serv-

ices4that are required by each class are identified. The relationships and collabora-tion between classes are identified, and a variety of supplementary diagrams are
produced.Negotiation.
It isnÕt unusual for customers and users to ask for more than can be
achieved, given limited business resources. ItÕs also relatively common for different
customers or users to propose conflicting requirements, arguing that their version is
Òessential for our special needs.ÓYouhavetoreconciletheseconflictsthroughaprocessofnegotiation.Customers,
users,andotherstakeholdersareaskedtorankrequirementsandthendiscusscon-

flictsinpriority.Usinganiterativeapproachthatprioritizesrequirements,assesses

theircostandrisk,andaddressesinternalconflicts,requirementsareeliminated,

combined,and/ormodifiedsothateachpartyachievessomemeasureofsatisfaction.
Specification.In the context of computer-based systems (and software), the termspecificationmeans different things to different people. A specification can be a writ-ten document, a set of graphical models, a formal mathematical model, a collectionof usage scenarios, a prototype, or any combination of these.
Some suggest that a Òstandard templateÓ [Som97] should be developed and usedfor a specification, arguing that this leads to requirements that are presented in aElaboration is a goodthing, but you have to
know when to stop.
The key is to describe
the problem in a way
that establishes a firm

base for design. If you
work beyond that
point, youÕre doing
design.4A 
servicemanipulates the data encapsulated by the class. The terms operationand methodare alsoused. If you are unfamiliar with object-oriented concepts, a basic introduction is presented inAppendix 2.There should be nowinner and no loser in
an effective negotia-
tion. Both sides win,
because a ÒdealÓ that
both can live with is
solidified.pre75977_ch05.qxd  11/27/08  3:30 PM  Page 122
Theformalityand
formatofaspecifica-

tionvarieswiththesize

andthecomplexityof

thesoftwaretobebuilt.
consistent and therefore more understandable manner. However, it is sometimes
necessary to remain flexible when a specification is to be developed. For large sys-
tems, a written document, combining natural language descriptions and graphical
models may be the best approach. However, usage scenarios may be all that are re-

quired for smaller products or systems that reside within well-understood technical
environments.
CHAPTER 5UNDERSTANDING REQUIREMENTS123Software Requirements Specification Template
A software requirements specification(SRS) isadocument that is created when a detailed
description of all aspects of the software to be built must bespecified before the project is to commence. It is important

to note that a formal SRS is not always written. In fact,

there are many instances in which effort expended on an

SRS might be better spent in other software engineering
activities. However, when software is to be developed by

athird party, when a lack of specification would create

severe business issues, or when a system is extremely
complex or business critical, an SRS may be justified.Karl Wiegers [Wie03] of Process Impact Inc. hasdeveloped a worthwhile template (available at

www.processimpact.com/process_assets/srs_

template.doc) that can serve as a guideline for those

who must create a complete SRS. A topic outline follows:Table of Contents
Revision History
1.Introduction

1.1Purpose

1.2Document Conventions

1.3Intended Audience and Reading Suggestions

1.4Project Scope

1.5References
2.Overall Description
2.1Product Perspective
2.2Product Features

2.3User Classes and Characteristics

2.4Operating Environment

2.5Design and Implementation Constraints

2.6User Documentation

2.7Assumptions and Dependencies
3.System Features
3.1System Feature 1

3.2System Feature 2 (and so on)
4.External Interface Requirements
4.1User Interfaces

4.2Hardware Interfaces

4.3Software Interfaces

4.4Communications Interfaces
5.Other Nonfunctional Requirements
5.1Performance Requirements

5.2Safety Requirements

5.3Security Requirements

5.4Software Quality Attributes
6.Other Requirements

Appendix A: Glossary
Appendix B: Analysis Models
Appendix C: Issues ListA detailed description of each SRS topic can be obtained
by downloading the SRS template at the URL noted earlier
in this sidebar.
INFOValidation.
The work products produced as a consequence of requirements engi-neering are assessed for quality during a validation step. Requirements validationexamines the specification5to ensure that all software requirements have been5Recall that the nature of the specification will vary with each project. In some cases, the Òspecifi-
cationÓ is a collection of user scenarios and little else. In others, the specification may be a docu-ment that contains scenarios, models, and written descriptions.pre75977_ch05.qxd  11/27/08  3:30 PM  Page 123
stated unambiguously; that inconsistencies, omissions, and errors have beendetected and corrected; and that the work products conform to the standards estab-
lished for the process, the project, and the product.Theprimaryrequirementsvalidationmechanismisthetechnicalreview(Chap-
ter15).Thereviewteamthatvalidatesrequirementsincludessoftwareengineers,

customers,users,andotherstakeholderswhoexaminethespecificationlooking

forerrorsincontentorinterpretation,areaswhereclarificationmayberequired,

missinginformation,inconsistencies(amajorproblemwhenlargeproductsor

systemsareengineered),conflictingrequirements,orunrealistic(unachievable)

requirements.124PART TWOMODELINGINFORequirements management.
Requirements for computer-based systemschange, and the desire to change requirements persists throughout the life of the
system. Requirements management is a set of activities that help the project team
identify, control, and track requirements and changes to requirements at any time as

the project proceeds.6Many of these activities are identical to the software configu-ration management (SCM) techniques discussed in Chapter 22.6Formal requirements management is initiated only for large projects that have hundreds of identi-
fiable requirements. For small projects, this requirements engineering action is considerably lessformal.Requirements Validation
ChecklistIt is often useful to examine each requirementagainst a set of checklist questions. Here is a small subsetof those that might be asked:¥Are requirements stated clearly? Can they be
misinterpreted?¥Is the source (e.g., a person, a regulation, a document)
of the requirement identified? Has the final statement of
the requirement been examined by or against the
original source?¥Is the requirement bounded in quantitative terms?
¥What other requirements relate to this requirement? Are
they clearly noted via a cross-reference matrix or other
mechanism?¥Does the requirement violate any system domain
constraints?¥Is the requirement testable? If so, can we specify tests
(sometimes called validation criteria) to exercise the
requirement?¥Is the requirement traceable to any system model that
has been created?¥Is the requirement traceable to overall system/product
objectives?¥Is the specification structured in a way that leads to
easy understanding, easy reference, and easy
translation into more technical work products?¥Has an index for the specification been created?¥Have requirements associated with performance,

behavior, and operational characteristics been clearly

stated? What requirements appear to be implicit?A key concern during
requirements valida-
tion is consistency. Use

the analysis model to
ensure that require-
ments have been con-
sistently stated.pre75977_ch05.qxd  11/27/08  3:30 PM  Page 124
5.2E
STABLISHINGTHE
GROUNDWORKIn an ideal setting, stakeholders and software engineers work together on the sameteam.8In such cases, requirements engineering is simply a matter of conductingmeaningful conversations with colleagues who are well-known members of the

team. But reality is often quite different.Customer(s) or end users may be located in a different city or country, may have
only a vague idea of what is required, may have conflicting opinions about the sys-
tem to be built, may have limited technical knowledge, and may have limited time to

interact with the requirements engineer. None of these things are desirable, but all

are fairly common, and you are often forced to work within the constraints imposed
by this situation.In the sections that follow, I discuss the steps required to establish the ground-
work for an understanding of software requirementsÑto get the project started in a
way that will keep it moving forward toward a successful solution.
5.2.1Identifying Stakeholders
Sommerville and Sawyer [Som97] define a stakeholder as Òanyone who benefits

inadirect or indirect way from the system which is being developed.Ó I have already
CHAPTER 5UNDERSTANDING REQUIREMENTS125Requirements Engineering
Objective:Requirements engineering toolsassist in requirements gathering, requirementsmodeling, requirements management, and requirementsvalidation.Mechanics:Toolmechanicsvary.Ingeneral,
requirementsengineeringtoolsbuildavarietyof
graphical(e.g.,UML)modelsthatdepicttheinformational,

functional,andbehavioralaspectsofasystem.These

modelsformthebasisforallotheractivitiesinthe

softwareprocess.
Representative Tools:
7A reasonably comprehensive (and up-to-date) listing ofrequirements engineering tools can be found at the Volvere

Requirements resources site at www.volere.co.uk/
tools.htm. Requirements modeling tools are discussed inChapters 6 and 7. Tools noted below focus on requirement

management.EasyRM,developed by Cybernetic Intelligence GmbH
(www.easy-rm.com
), builds a project-specificdictionary/glossary that contains detailed requirements

descriptions and attributes.Rational RequisitePro,developed by Rational Software(www-306.ibm.com/software/awdtools/
reqpro/
), allows users to build a requirements
database; represent relationships among requirements;
and organize, prioritize, and trace requirements.Many additional requirements management tools can be
found at the Volvere site noted earlier and at 

www.jiludwig.com/Requirements_

Management_Tools.html
.SOFTWARE
TOOLS7Tools noted here do not represent an endorsement, but rather a sampling of tools in this category.
In most cases, tool names are trademarked by their respective developers.8This approach is strongly recommended for projects that adopt an agile software development
philosophy.A stakeholderisanyone who has adirect interest in or
benefits from the
system that is to be
developed.pre75977_ch05.qxd  11/27/08  3:30 PM  Page 125
identified the usual suspects: business operations managers, product managers,marketing people, internal and external customers, end users, consultants, product

engineers, software engineers, support and maintenance engineers, and others.
Each stakeholder has a different view of the system, achieves different benefits when
the system is successfully developed, and is open to different risks if the development
effort should fail.At inception, you should create a list of people who will contribute input as re-quirements are elicited (Section 5.3). The initial list will grow as stakeholders are
contacted because every stakeholder will be asked: ÒWhom else do you think I
should talk to?Ó5.2.2Recognizing Multiple Viewpoints
Because many different stakeholders exist, the requirements of the system will be
explored from many different points of view. For example, the marketing group is in-

terested in functions and features that will excite the potential market, making the
new system easy to sell. Business managers are interested in a feature set that can
be built within budget and that will be ready to meet defined market windows. End
users may want features that are familiar to them and that are easy to learn and use.
Software engineers may be concerned with functions that are invisible to nontech-

nical stakeholders but that enable an infrastructure that supports more marketable
functions and features. Support engineers may focus on the maintainability of the
software.Each of these constituencies (and others) will contribute information to the re-quirements engineering process. As information from multiple viewpoints is col-
lected, emerging requirements may be inconsistent or may conflict with one
another. You should categorize all stakeholder information (including inconsistent

and conflicting requirements) in a way that will allow decision makers to choose an
internally consistent set of requirements for the system.5.2.3Working toward Collaboration
If five stakeholders are involved in a software project, you may have five (or more)

different opinions about the proper set of requirements. Throughout earlier chapters,
I have noted that customers (and other stakeholders) must collaborate among them-
selves (avoiding petty turf battles) and with software engineering practitioners if a
successful system is to result. But how is this collaboration accomplished?Thejobofarequirementsengineeristoidentifyareasofcommonality(i.e.,re-
quirementsonwhichallstakeholdersagree)andareasofconflictorinconsistency

(i.e.,requirementsthataredesiredbyonestakeholderbutconflictwiththe

needsofanotherstakeholder).Itis,ofcourse,thelattercategorythatpresentsa

challenge.126PART TWOMODELINGuote:ÒPut threestakeholders in a
room and ask them
what kind of
system they want.
YouÕre likely to get

four or more
different opinions.ÓAuthor unknownpre75977_ch05.qxd  11/27/08  3:30 PM  Page 126
Collaboration does not necessarily mean that requirements are defined bycommittee. In many cases, stakeholders collaborate by providing their view of
requirements, but a strong Òproject championÓ(e.g., a business manager or a senior
technologist) may make the final decision about which requirements make the cut.5.2.4Asking the First Questions
Questions asked at the inception of the project should be Òcontext freeÓ [Gau89]. The
first set of context-free questions focuses on the customer and other stakeholders,
the overall project goals and benefits. For example, you might ask:
¥Who is behind the request for this work?¥Who will use the solution?¥What will be the economic benefit of a successful solution?¥Is there another source for the solution that you need?Thesequestionshelptoidentifyallstakeholderswhowillhaveinterestinthe

softwaretobebuilt.Inaddition,thequestionsidentifythemeasurablebenefitof

asuccessfulimplementationandpossiblealternativestocustomsoftwaredevel-

opment.The next set of questions enables you to gain a better understanding of the prob-lem and allows the customer to voice his or her perceptions about a solution:¥How would you characterize ÒgoodÓ output that would be generated by a
successful solution?¥What problem(s) will this solution address?¥Can you show me (or describe) the business environment in which the

solution will be used?¥Will special performance issues or constraints affect the way the solution is

approached?CHAPTER 5UNDERSTANDING REQUIREMENTS127INFOuote:ÒIt is better toknow some of the
questions than all
of the answers.ÓJamesThurber
Whatquestionswill help you gain
a preliminary

understanding of
the problem??Using ÒPriority PointsÓOnewayofresolvingconflicting
requirementsandatthesametimebetter
understandingtherelativeimportanceofallrequirements
istouseaÒvotingÓschemebasedon
prioritypoints.
Allstakeholdersareprovidedwithsomenumberof

prioritypointsthatcanbeÒspentÓonanynumberof

requirements.Alistofrequirementsispresented,and

eachstakeholderindicatestherelativeimportanceof
each(fromhisorherviewpoint)byspendingoneor

moreprioritypointsonit.Pointsspentcannotbereused.

OnceastakeholderÕsprioritypointsareexhausted,

nofurtheractiononrequirementscanbetakenbythat

person.Overallpointsspentoneachrequirementby

allstakeholdersprovideanindicationoftheoverall

importanceofeachrequirement.
pre75977_ch05.qxd  11/27/08  3:30 PM  Page 127
The final set of questions focuses on the effectiveness of the communicationactivity itself. Gause and Weinberg [Gau89] call these Òmeta-questionsÓ and propose
the following (abbreviated) list:¥Are you the right person to answer these questions? Are your answers
ÒofficialÓ?¥Are my questions relevant to the problem that you have?¥Am I asking too many questions?¥Can anyone else provide additional information?
¥Should I be asking you anything else?These questions (and others) will help to Òbreak the iceÓ and initiate the communi-
cation that is essential to successful elicitation. But a question-and-answer meeting
format is not an approach that has been overwhelmingly successful. In fact, the Q&A

session should be used for the first encounter only and then replaced by a require-
ments elicitation format that combines elements of problem solving, negotiation,
and specification. An approach of this type is presented in Section 5.3.5.3E
LICITINGREQUIREMENTSRequirements elicitation (also called requirements gathering) combines elements of
problem solving, elaboration, negotiation, and specification. In order to encourage
a collaborative, team-oriented approach to requirements gathering, stakeholders

work together to identify the problem, propose elements of the solution, negotiate
different approaches and specify a preliminary set of solution requirements [Zah90].95.3.1Collaborative Requirements Gathering
Many different approaches to collaborative requirements gathering have been pro-
posed. Each makes use of a slightly different scenario, but all apply some variation
on the following basic guidelines:¥Meetings are conducted and attended by both software engineers and other
stakeholders.¥Rules for preparation and participation are established.¥An agenda is suggested that is formal enough to cover all important points

but informal enough to encourage the free flow of ideas.¥A ÒfacilitatorÓ (can be a customer, a developer, or an outsider) controls the

meeting.¥A Òdefinition mechanismÓ (can be work sheets, flip charts, or wall stickers or
an electronic bulletin board, chat room, or virtual forum) is used.128PART TWOMODELING9This approach is sometimes called a 
facilitated application specification technique(FAST).uote:ÒHe who asks aquestion is a fool
for five minutes;
he who does not
ask a question is a
fool forever.Ó
Chineseproverb
What are the basicguidelines for
conducting a
collaborative
requirements
gathering
meeting??pre75977_ch05.qxd  11/27/08  3:30 PM  Page 128
The goal is to identify the problem, propose elements of the solution, negotiatedifferent approaches, and specify a preliminary set of solution requirements in an at-mosphere that is conducive to the accomplishment of the goal. To better understand

the flow of events as they occur, I present a brief scenario that outlines the sequence

of events that lead up to the requirements gathering meeting, occur during the meet-
ing, and follow the meeting.During inception (Section 5.2) basic questions and answers establish the scope ofthe problem and the overall perception of a solution. Out of these initial meetings,

the developer and customers write a one- or two-page Òproduct request.Ó A meeting place, time, and date are selected; a facilitator is chosen; and attendees
from the software team and other stakeholder organizations are invited to partici-

pate. The product request is distributed to all attendees before the meeting date.As an example,
10consider an excerpt from a product request written by a mar-keting person involved in the 
SafeHomeproject. This person writes the following nar-rative about the home security function that is to be part of SafeHome:Our research indicates that the market for home management systems is growing at arate of 40 percent per year. The first 
SafeHomefunction we bring to market should be thehome security function. Most people are familiar with Òalarm systemsÓ so this would be
an easy sell.The home security function would protect against and/or recognize a variety of un-desirable ÒsituationsÓ such as illegal entry, fire, flooding, carbon monoxide levels, and

others. ItÕll use our wireless sensors to detect each situation. It can be programmed by the
homeowner, and will automatically telephone a monitoring agency when a situation is

detected.In reality, others would contribute to this narrative during the requirements gath-
ering meeting and considerably more information would be available. But even withadditional information, ambiguity would be present, omissions would likely exist,
and errors might occur. For now, the preceding Òfunctional descriptionÓ will suffice.
While reviewing the product request in the days before the meeting, each at-tendee is asked to make a list of objects that are part of the environment that sur-

rounds the system, other objects that are to be produced by the system, and objects
that are used by the system to perform its functions. In addition, each attendee is
asked to make another list of services (processes or functions) that manipulate or in-
teract with the objects. Finally, lists of constraints (e.g., cost, size, business rules) and

performance criteria (e.g., speed, accuracy) are also developed. The attendees are in-
formed that the lists are not expected to be exhaustive but are expected to reflect
each personÕs perception of the system.
CHAPTER 5UNDERSTANDING REQUIREMENTS129uote:ÒWe spend a lot of
timeÑthe
majority of project
effortÑnot
implementing or
testing, but trying

to decide what to
build.ÓBrianLawrence
WebRef
Joint ApplicationDevelopment(JAD) isa popular technique 
for requirements
gathering. A good
description can be
found at
www.carolla.com/

wp-jad.htm.If a system or productwill serve many users,

be absolutely certain

that requirements are
elicited from a repre-
sentative cross section
of users. If only one
user defines all require-
ments, acceptance risk
is high.10This example (with extensions and variations) is used to illustrate important software engineering
methods in many of the chapters that follow. As an exercise, it would be worthwhile to conductyour own requirements gathering meeting and develop a set of lists for it.pre75977_ch05.qxd  11/27/08  3:30 PM  Page 129
Objects described for SafeHomemight include the control panel, smoke detectors,window and door sensors, motion detectors, an alarm, an event (a sensor has beenactivated), a display, a PC, telephone numbers, a telephone call, and so on. The list

of services might include configuringthe system, settingthe alarm, monitoringthesensors, dialingthe phone, 
programming
the control panel, and readingthe display(note that services act on objects). In a similar fashion, each attendee will develop
lists of constraints (e.g., the system must recognize when sensors are not operating,
must be user-friendly, must interface directly to a standard phone line) and perform-

ance criteria (e.g., a sensor event should be recognized within one second, and an
event priority scheme should be implemented).The lists of objects can be pinned to the walls of the room using large sheets ofpaper, stuck to the walls using adhesive-backed sheets, or written on a wall board.

Alternatively, the lists may have been posted on an electronic bulletin board, at an

internal website, or posed in a chat room environment for review prior to the meet-

ing. Ideally, each listed entry should be capable of being manipulated separately so

that lists can be combined, entries can be modified, and additions can be made. At
this stage, critique and debate are strictly prohibited.
After individual lists are presented in one topic area, the group creates a com-bined list by eliminating redundant entries, adding any new ideas that come up dur-
ing the discussion, but not deleting anything. After you create combined lists for all
topic areas, discussionÑcoordinated by the facilitatorÑensues. The combined list is
shortened, lengthened, or reworded to properly reflect the product/system to be de-
veloped. The objective is to develop a consensus list of objects, services, constraints,
and performance for the system to be built.In many cases, an object or service described on a list will require further expla-nation. To accomplish this, stakeholders develop 
mini-specificationsfor entries onthe lists.11Each mini-specification is an elaboration of an object or service. Forexample, the mini-spec for the 
SafeHomeobject Control Panel
might be:The control panel is a wall-mounted unit that is approximately 9 5 inches in size. Thecontrol panel has wireless connectivity to sensors and a PC. User interaction occursthrough a keypad containing 12 keys. A 3 3 inch LCD color display provides user feed-
back. Software provides interactive prompts, echo, and similar functions.
The mini-specs are presented to all stakeholders for discussion. Additions, deletions,and further elaboration are made. In some cases, the development of mini-specs will
uncover new objects, services, constraints, or performance requirements that will be

added to the original lists. During all discussions, the team may raise an issue that
cannot be resolved during the meeting. An issues listis maintained so that theseideas will be acted on later.
130PART TWOMODELINGAvoid the impulse to
shoot down a cus-
tomerÕs idea as Òtoo

costlyÓ or Òimpracti-
cal.Ó The idea here is
to negotiate a list that
is acceptable to all. To

do this, you must keep
an open mind.11Rather than creating a mini-specification, many software teams elect to develop user scenarios
called use cases.These are considered in detail in Section 5.4 and in Chapter 6.uote:ÒFacts do not ceaseto exist because
they are ignored.ÓAldousHuxley
pre75977_ch05.qxd  11/27/08  3:30 PM  Page 130
5.3.2Quality Function Deployment
Quality function deployment
(QFD) is a quality management technique that translatesthe needs of the customer into technical requirements for software. QFD Òconcen-trates on maximizing customer satisfaction from the software engineering processÓ
[Zul92]. To accomplish this, QFD emphasizes an understanding of what is valuable

to the customer and then deploys these values throughout the engineering process.
QFD identifies three types of requirements [Zul92]:Normal requirements.
The objectives and goals that are stated for a prod-uct or system during meetings with the customer. If these requirements are

present, the customer is satisfied. Examples of normal requirements might be
requested types of graphical displays, specific system functions, and defined
levels of performance.Expected requirements.
These requirements are implicit to the productor system and may be so fundamental that the customer does not explicitlystate them. Their absence will be a cause for significant dissatisfaction.
Examples of expected requirements are: ease of human/machine interaction,
overall operational correctness and reliability, and ease of software

installation.CHAPTER 5UNDERSTANDING REQUIREMENTS131The scene:A meeting room. The firstrequirements gathering meeting is in progress.The players:Jamie Lazar, software team member;
Vinod Raman, software team member; Ed Robbins,
software team member; Doug Miller, software

engineering manager; three members of marketing; a
product engineering representative; and a facilitator.
The conversation:
Facilitator (pointing at whiteboard):So thatÕs the
current list of objects and services for the home security
function.Marketing person:That about covers it from ourpoint of view.

Vinod:
DidnÕt someone mention that they wanted all
SafeHomefunctionality to be accessible via the Internet?
That would include the home security function, no?
Marketing person:Yes, thatÕs right
...weÕll have to
add that functionality and the appropriate objects.
Facilitator:Does that also add some constraints?Jamie:It does, both technical and legal.Production rep:
Meaning?Jamie:We better make sure an outsider canÕt hack into
the system, disarm it, and rob the place or worse. Heavy
liability on our part.
Doug:Very true.
Marketing:But we still need that...just be sure to stop
an outsider from getting in.
Ed:ThatÕs easier said than done and...
Facilitator (interrupting):I donÕt want to debate this
issue now. LetÕs note it as an action item and proceed.

(Doug, serving as the recorder for the meeting, makes an
appropriate note.)Facilitator:I have a feeling thereÕs still more to consider
here.
(The group spends the next 20 minutes refining andexpanding the details of the home security function.)SAFEHOMEQFD defines require-ments in a way that
maximizes customer
satisfaction.Everyone wants to
implement lots of
exciting requirements,
but be careful. ThatÕs

how Òrequirements
creepÓ sets in. On the
other hand, exciting
requirements lead to a
breakthrough product!ConductingaRequirementsGatheringMeeting
pre75977_ch05.qxd  11/27/08  3:30 PM  Page 131
Exciting requirements.
These features go beyond the customerÕs expecta-
tions and prove to be very satisfying when present. For example, software for
a new mobile phone comes with standard features, but is coupled with a set
of unexpected capabilities (e.g., multitouch screen, visual voice mail) that
delight every user of the product.Although QFD concepts can be applied across the entire software process [Par96a],
specific QFD techniques are applicable to the requirements elicitation activity. QFD

uses customer interviews and observation, surveys, and examination of historical
data (e.g., problem reports) as raw data for the requirements gathering activity.

These data are then translated into a table of requirementsÑcalled the customer
voice tableÑthat is reviewed with the customer and other stakeholders. A variety of
diagrams, matrices, and evaluation methods are then used to extract expected re-
quirements and to attempt to derive exciting requirements [Aka04].5.3.3Usage Scenarios
As requirements are gathered, an overall vision of system functions and features be-

gins to materialize. However, it is difficult to move into more technical software en-

gineering activities until you understand how these functions and features will be
used by different classes of end users. To accomplish this, developers and users can

create a set of scenarios that identify a thread of usage for the system to be con-
structed. The scenarios, often called use cases[Jac92], provide a description of how
the system will be used. Use cases are discussed in greater detail in Section 5.4.132PART TWOMODELINGWebRef
Useful information on
QFD can be obtained at
www.qfdi.org
.The scene:A meeting room,continuing the first requirements gathering meeting.The players:Jamie Lazar, software team member;
Vinod Raman, software team member; Ed Robbins,
software team member; Doug Miller, software

engineering manager; three members of marketing; a
product engineering representative; and a facilitator.
The conversation:
Facilitator:WeÕve been talking about security for
access to SafeHomefunctionality that will be accessiblevia the Internet. IÕd like to try something. LetÕs develop a
usage scenario for access to the home security function.Jamie:How?Facilitator:We can do it a couple of different ways, but
for now, IÕd like to keep things really informal. Tell us (he
points at a marketing person) how you envision accessing
the system.Marketing person:Um...well, this is the kind of
thing IÕd do if I was away from home and I had to let
someone into the house, say a housekeeper or repair guy,

who didnÕt have the security code.
Facilitator (smiling):ThatÕs the reason youÕd do it...
tell me how youÕd actually do this.
Marketing person:Um...the first thing IÕd need is a
PC. IÕd log on to a website weÕd maintain for all users ofSafeHome.IÕd provide my user id and...
Vinod(interrupting):
TheWebpagewouldhavetobe
secure,encrypted,toguaranteethatweÕresafeand...

Facilitator (interrupting):ThatÕs good information,
Vinod, but itÕs technical. LetÕs just focus on how the end
user will use this capability. OK?
Vinod:
No problem.Marketingperson:
SoasIwassaying,IÕdlogontoa
websiteandprovidemyuserIDandtwolevelsofpasswords.
SAFEHOMEDeveloping a Preliminary User Scenario
pre75977_ch05.qxd  11/27/08  3:30 PM  Page 132
5.3.4Elicitation Work Products
The work products produced as a consequence of requirements elicitation will varydepending on the size of the system or product to be built. For most systems, the
work products include¥A statement of need and feasibility.
¥A bounded statement of scope for the system or product.¥A list of customers, users, and other stakeholders who participated in
requirements elicitation.¥A description of the systemÕs technical environment.
¥A list of requirements (preferably organized by function) and the domain
constraints that apply to each.¥A set of usage scenarios that provide insight into the use of the system or

product under different operating conditions.¥Any prototypes developed to better define requirements.Each of these work products is reviewed by all people who have participated in re-
quirements elicitation.5.4D
EVELOPINGUSECASESIn a book that discusses how to write effective use cases, Alistair Cockburn
[Coc01b] notes that Òa use case captures a contract ... [that] describes the systemÕs

behavior under various conditions as the system responds to a request from one of
its stakeholders...Ó In essence, a use case tells a stylized story about how an end

user (playing one of a number of possible roles) interacts with the system under a
specific set of circumstances. The story may be narrative text, an outline of tasks
or interactions, a template-based description, or a diagrammatic representation.
Regardless of its form, a use case depicts the software or system from the end
userÕs point of view.
CHAPTER 5UNDERSTANDING REQUIREMENTS133Jamie:What if I forget my password?Facilitator (interrupting):Good point, Jamie, butletÕs not address that now. WeÕll make a note of that and
call it an exception.IÕm sure thereÕll be others.
Marketing person:After I enter the passwords, ascreen representing all SafeHomefunctions will appear.
IÕd select the home security function. The system mightrequest that I verify who I am, say, by asking for my

address or phone number or something. It would then
display a picture of the security system control panelalong with a list of functions that I can performÑarm the

system, disarm the system, disarm one or more sensors.

Isuppose it might also allow me to reconfigure security

zones and other things like that, but IÕm not sure.(As the marketing person continues talking, Doug takescopious notes; these form the basis for the first informal

usage scenario. Alternatively, the marketing person could

have been asked to write the scenario, but this would be
done outside the meeting.)Whatinformationis produced as a
consequence of
requirements
gathering??pre75977_ch05.qxd  11/27/08  3:30 PM  Page 133
The first step in writing a use case is to define the set of ÒactorsÓ that will beinvolved in the story. 
Actorsare the different people (or devices) that use the systemor product within the context of the function and behavior that is to be described.Actors represent the roles that people (or devices) play as the system operates.
Defined somewhat more formally, an actor is anything that communicates with the

system or product and that is external to the system itself. Every actor has one or
more goals when using the system.It is important to note that an actor and an end user are not necessarily the samething. A typical user may play a number of different roles when using a system,
whereas an actor represents a class of external entities (often, but not always, peo-
ple) that play just one role in the context of the use case. As an example, consider a

machine operator (a user) who interacts with the control computer for a manufac-
turing cell that contains a number of robots and numerically controlled machines.
After careful review of requirements, the software for the control computer requires
four different modes (roles) for interaction: programming mode, test mode, moni-

toring mode, and troubleshooting mode. Therefore, four actors can be defined: pro-

grammer, tester, monitor, and troubleshooter. In some cases, the machine operator

can play all of these roles. In others, different people may play the role of each actor.
Because requirements elicitation is an evolutionary activity, not all actors are
identified during the first iteration. It is possible to identify primary actors [Jac92]

during the first iteration and secondary actors as more is learned about the system.
Primary actorsinteract to achieve required system function and derive the intendedbenefit from the system. They work directly and frequently with the software.
Secondary actorssupport the system so that primary actors can do their work.Once actors have been identified, use cases can be developed. Jacobson [Jac92]
suggests a number of questions12that should be answered by a use case:¥Who is the primary actor, the secondary actor(s)?
¥What are the actorÕs goals?
¥What preconditions should exist before the story begins?¥What main tasks or functions are performed by the actor?¥What exceptions might be considered as the story is described?¥What variations in the actorÕs interaction are possible?
¥What system information will the actor acquire, produce, or change?
¥Will the actor have to inform the system about changes in the external

environment?
¥What information does the actor desire from the system?¥Does the actor wish to be informed about unexpected changes?134PART TWOMODELINGUse cases are definedfrom an actorÕs point

of view. An actor is

arole that people

(users) or devices play
as they interact with
the software.WebRef
An excellent paper onuse cases can be
downloaded from
www.ibm.com/

developerworks/

webservices/

library/

codesign7.html.What do Ineed toknow in order to
develop an
effective use
case??12JacobsonÕs questions have been extended to provide a more complete view of use-case content.
pre75977_ch05.qxd  11/27/08  3:30 PM  Page 134
Recalling basic SafeHomerequirements, we define four actors: homeowner
(auser), 
setup manager(likely the same person as homeowner,
but playing a dif-ferent role), sensors(devices attached to the system), and the monitoring andresponse subsystem
(the central station that monitors the SafeHomehome secu-rity function). For the purposes of this example, we consider only the 
homeowner
actor. The 
homeowner
actor interacts with the home security function in a numberof different ways using either the alarm control panel or a PC:¥Enters a password to allow all other interactions.¥Inquires about the status of a security zone.¥Inquires about the status of a sensor.
¥Presses the panic button in an emergency.
¥Activates/deactivates the security system.Considering the situation in which the homeowner uses the control panel, the basic
use case for system activation follows:131.The homeowner observes the 
SafeHomecontrol panel (Figure 5.1) to determine if thesystem is ready for input. If the system is not ready, a 
not readymessage is displayedon the LCD display, and the homeowner must physically close windows or doors so
that the not readymessage disappears. [Anot readymessage implies that a sensor isopen; i.e., that a door or window isopen.]
CHAPTER 5UNDERSTANDING REQUIREMENTS135123456789*0offSAFEHOMEawaystay
maxtestbypass
instantcodechime
ready#armedpower
alarm
checkfireawaystay
instant
bypass
not readypanicFIGURE5.1SafeHome
control panel
13Note that this use case differs from the situation in which the system is accessed via the Internet.
In this case, interaction occurs via the control panel, not the graphical user interface (GUI) providedwhen a PC is used.pre75977_ch05.qxd  11/27/08  3:30 PM  Page 135
2.Thehomeownerusesthekeypadtokeyinafour-digitpassword.Thepasswordiscom-
paredwiththevalidpasswordstoredinthesystem.Ifthepasswordisincorrect,thecon-
trolpanelwillbeeponceandresetitselfforadditionalinput.Ifthepasswordiscorrect,

thecontrolpanelawaitsfurtheraction.
3.The homeowner selects and keys in 
stayor away(see Figure 5.1) to activate the system.Stayactivates only perimeter sensors (inside motion detecting sensors are deacti-vated). Away
activates all sensors.4.When activation occurs, a red alarm light can be observed by the homeowner.
The basic use case presents a high-level story that describes the interaction betweenthe actor and the system.In many instances, uses cases are further elaborated to provide considerably
more detail about the interaction. For example, Cockburn [Coc01b] suggests the fol-

lowing template for detailed descriptions of use cases:Use case:InitiateMonitoringPrimary actor:Homeowner.
Goal in context:To set the system to monitor sensors when the homeowner
leaves the house or remains inside.Preconditions:
System has been programmed for a password and to recognize
various sensors.Trigger:
The homeowner decides to ÒsetÓ the system, i.e., to turn on the
alarm functions.Scenario:1.Homeowner: observes control panel
2.Homeowner: enters password

3.Homeowner: selects ÒstayÓ or ÒawayÓ

4.Homeowner: observes read alarm light to indicate that 
SafeHomehas been armedExceptions:1.Control panel is 
not ready:homeowner checks all sensors to determine which areopen; closes them.2.Password is incorrect (control panel beeps once): homeowner reenters correct password.
3.Password not recognized: monitoring and response subsystem must be contacted to
reprogram password.4.Stayis selected: control panel beeps twice and a staylight is lit; perimeter sensors areactivated.5.Away
is selected: control panel beeps three times and an awaylight is lit; all sensorsare activated.Priority:Essential, must be implementedWhen available:
First increment136PART TWOMODELINGUse cases are oftenwritten informally.

However, use the tem-

plate shown here to
ensure that youÕve
addressed all key
issues.pre75977_ch05.qxd  11/27/08  3:30 PM  Page 136
Frequency of use:
Many times per dayChannel to actor:Via control panel interface
Secondary actors:Support technician, sensorsChannels to secondary actors:Support technician: phone lineSensors: hardwired and radio frequency interfacesOpen issues:
1.Should there be a way to activate the system without the use of a password or with an
abbreviated password?2.Should the control panel display additional text messages?

3.How much time does the homeowner have to enter the password from the time the
first key is pressed?4.Is there a way to deactivate the system before it actually activates?
Usecasesforother
homeowner
interactionswouldbedevelopedinasimilarmanner.
Itisimportanttorevieweachusecasewithcare.Ifsomeelementoftheinteraction
isambiguous,itislikelythatareviewoftheusecasewillindicateaproblem.
CHAPTER 5UNDERSTANDING REQUIREMENTS137The scene:A meeting room,continuing the requirements gathering meetingThe players:Jamie Lazar, software team member;
Vinod Raman, software team member; Ed Robbins,
software team member; Doug Miller, software

engineering manager; three members of marketing; a
product engineering representative; and a facilitator.
The conversation:
Facilitator:WeÕvespentafairamountoftimetalking
aboutSafeHomehomesecurityfunctionality.Duringthe
breakIsketchedausecasediagramtosummarizethe
importantscenariosthatarepartofthisfunction.Take

alook.
(All attendees look at Figure 5.2.)
Jamie:IÕm just beginning to learn UML notation.
14Sothe home security function is represented by the big boxwith the ovals inside it? And the ovals represent use cases
that weÕve written in text?Facilitator:Yep.AndthestickfiguresrepresentactorsÑ
thepeopleorthingsthatinteractwiththesystemasdescribed

bytheusecase
...oh,Iusethelabeledsquaretorepresent
anactorthatÕsnotaperson
...in
thiscase,sensors.
Doug:Is that legal in UML?Facilitator:LegalityisnÕttheissue.Thepointisto
communicateinformation.Iviewtheuseofahumanlike

stickfigureforrepresentingadevicetobemisleading.So

IÕveadaptedthingsabit.IdonÕtthinkitcreatesaproblem.
Vinod:
Okay, so we have use-case narratives for each
of the ovals. Do we need to develop the more detailedtemplate-based narratives IÕve read about?Facilitator:Probably, but that can wait until weÕve
considered other SafeHomefunctions.Marketingperson:
Wait,IÕvebeenlookingatthis
diagramandallofasuddenIrealizewemissedsomething.

Facilitator:Oh really. Tell me what weÕve missed.
(The meeting continues.)SAFEHOME14A brief UML tutorial is presented in Appendix 1 for those who are unfamiliar with the notation.Developing a High-Level Use-Case Diagram
pre75977_ch05.qxd  11/27/08  3:30 PM  Page 137
138PART TWOMODELING15Tools noted here do not represent an endorsement, but rather a sampling of tools in this category.In most cases, tool names are trademarked by their respective developers.16Throughout this book, I use the terms 
analysis modeland requirements modelsynonymously. Bothrefer to representations of the information, functional, and behavioral domains that describe prob-
lem requirements.Use-Case DevelopmentObjective:Assist in the development ofusecases by providing automated templates
and mechanisms for assessing clarity and consistency.
Mechanics:Toolmechanicsvary.Ingeneral,use-case
toolsprovidefill-in-the-blanktemplatesforcreatingeffective
usecases.Mostuse-casefunctionalityisembeddedintoa

setofbroaderrequirementsengineeringfunctions.
Representative Tools:
15The vast majority of UML-based analysis modeling tools
provide both text and graphical support for use-case

development and modeling.
Objects by Design(www.objectsbydesign.com/tools/

umltools_byCompany.html
) providescomprehensive links to tools of this type.SOFTWARE
TOOLS5.5B
UILDINGTHE
REQUIREMENTSMODEL16Theintentoftheanalysismodelistoprovideadescriptionoftherequiredinformational,
functional,andbehavioraldomainsforacomputer-basedsystem.Themodelchanges

dynamicallyasyoulearnmoreaboutthesystemtobebuilt,andotherstakeholdersun-

derstandmoreaboutwhattheyreallyrequire.Forthatreason,theanalysismodelisa

snapshotofrequirementsatanygiventime.Youshouldexpectittochange.
HomeownerSystem administratorArms/disarms
systemResponds to alarm event
Accessessystemvia Internet
Encountersan errorconditionReconfiguressensors andrelated system featuresSensorsFIGURE5.2UML use casediagram for
SafeHome
home security
functionpre75977_ch05.qxd  11/27/08  3:30 PM  Page 138
As the requirements model evolves, certain elements will become relativelystable, providing a solid foundation for the design tasks that follow. However, other
elements of the model may be more volatile, indicating that stakeholders do not yet

fully understand requirements for the system. The analysis model and the methods
that are used to build it are presented in detail in Chapters 6 and 7. I present a brief
overview in the sections that follow.
5.5.1Elements of the Requirements Model
There are many different ways to look at the requirements for a computer-based
system. Some software people argue that itÕs best to select one mode of represen-

tation (e.g., the use case) and apply it to the exclusion of all other modes. Other
practitioners believe that itÕs worthwhile to use a number of different modes of rep-

resentation to depict the requirements model. Different modes of representation
force you to consider requirements from different viewpointsÑan approach that has
a higher probability of uncovering omissions, inconsistencies, and ambiguity.
The specific elements of the requirements model are dictated by the analysismodeling method (Chapters 6 and 7) that is to be used. However, a set of generic

elements is common to most requirements models.Scenario-based elements.The system is described from the userÕs point of view
using a scenario-based approach. For example, basic use cases (Section 5.4) and
their corresponding use-case diagrams (Figure 5.2) evolve into more elaborate
template-based use cases. Scenario-based elements of the requirements model
areoften the first part of the model that is developed. As such, they serve as input for

the creation of other modeling elements. Figure 5.3depicts a UML activity diagram
17for eliciting requirements and representing them using use cases. Three levels of
elaboration are shown, culminating in a scenario-based representation.Class-basedelements.
Eachusagescenarioimpliesasetofobjectsthatare
manipulatedasanactorinteractswiththesystem.Theseobjectsarecategorizedinto
classesÑacollectionofthingsthathavesimilarattributesandcommonbehaviors.For

example,aUMLclassdiagramcanbeusedtodepicta
Sensorclassforthe
SafeHomesecurityfunction(Figure5.4).Notethatthediagramliststheattributesofsensors(e.g.,

name,type)andtheoperations(e.g.,
identify,enable
)thatcanbeappliedtomodify
theseattributes.Inadditiontoclassdiagrams,otheranalysismodelingelementsde-

pictthemannerinwhichclassescollaboratewithoneanotherandtherelationships

andinteractionsbetweenclasses.ThesearediscussedinmoredetailinChapter7.
Behavioral elements.
The behavior of a computer-based system can have a pro-found effect on the design that is chosen and the implementation approach that isapplied. Therefore, the requirements model must provide modeling elements that

depict behavior.
CHAPTER 5UNDERSTANDING REQUIREMENTS13917A brief UML tutorial is presented in Appendix 1 for those who are unfamiliar with the notation.
It is always a goodidea to get stakehold-
ers involved. One of
the best ways to do
this is to have each
stakeholder write use
cases that describe
how the software will
be used.One way to isolateclasses is to look for
descriptive nouns in a
use-case script. At least
some of the nouns will
be candidate classes.
More on this in the
Chapter 8.pre75977_ch05.qxd  11/27/08  3:30 PM  Page 139
140PART TWOMODELINGFormal prioritization?
Yes
NoConductmeetingsMake lists of functions, classesMake lists of constraints, etc.  Use QFD toprioritize requirementsInformally
prioritize requirementsCreateuse casesDraw use-casediagramDefineactorsWrite
scenarioCompletetemplateElicit requirementsFIGURE5.3UML activitydiagrams for
eliciting
requirements
NameType

Location
Area
CharacteristicsIdentify()
Enable()
Disable()
Reconfigure()SensorFIGURE5.4Class diagramfor sensorA state is an externally
observable mode of

behavior. External

stimuli cause transi-
tions between states.The state diagram
is one method for representing the behavior of a system by de-picting its states and the events that cause the system to change state. A stateis anyexternally observable mode of behavior. In addition, the state diagram indicates
actions (e.g., process activation) taken as a consequence of a particular event.To illustrate the use of a state diagram, consider software embedded within the
SafeHomecontrol panel that is responsible for reading user input. A simplified UMLstate diagram is shown in Figure 5.5.pre75977_ch05.qxd  11/27/08  3:30 PM  Page 140
Flow-oriented elements.
Information is transformed as it flows through acomputer-based system. The system accepts input in a variety of forms, applies func-tions to transform it, and produces output in a variety of forms. Input may be a control
signal transmitted by a transducer, a series of numbers typed by a human operator, a
CHAPTER 5UNDERSTANDING REQUIREMENTS141The scene:A meeting room,continuing the requirements meeting.Theplayers:
JamieLazar,softwareteammember;
VinodRaman,softwareteammember;EdRobbins,
softwareteammember;DougMiller,software

engineeringmanager;threemembersofmarketing;

aproductengineeringrepresentative;andafacilitator.
The conversation:
Facilitator:WeÕve just about finished talking about
SafeHomehome security functionality. But before we do,
Iwant to discuss the behavior of the function.

Marketing person:I donÕt understand what you mean
by behavior.

Ed (smiling):ThatÕs when you give the product a
ÒtimeoutÓ if it misbehaves.
Facilitator:Not exactly. Let me explain.
(The facilitator explains the basics of behavioral modelingto the requirements gathering team.)Marketing person:This seems a little technical. IÕmnot sure I can help here.Facilitator:Sure you can. What behavior do youobserve from the userÕs point of view?

Marketing person:Uh...well, the system will be
monitoringthe sensors. ItÕll be reading commandsfromthe homeowner. ItÕll be 
displayingits status.Facilitator:See, you can do it.Jamie:ItÕll also be pollingthe PC to determine if there is
any input from it, for example, Internet-based access or
configuration information.
Vinod:
Yeah, in fact, 
configuring the systemis a state inits own right.
Doug:You guys are rolling. LetÕs give this a bit more
thought...is there a way to diagram this stuff?

Facilitator:There is, but letÕs postpone that until after
the meeting.SAFEHOMESystem status = "Ready"Display msg = "enter cmd"
Display status = steadyState nameState variablesState activitiesEntry/subsystems ready
Do: poll user input panel
Do: read user input
Do: interpret user inputReadingcommandsFIGURE5.5UML statediagram
notationIn addition to behavioral representations of the system as a whole, the behavior
of individual classes can also be modeled. Further discussion of behavioral model-ing is presented in Chapter 7.Preliminary Behavioral Modeling
pre75977_ch05.qxd  11/27/08  3:30 PM  Page 141
packet of information transmitted on a network link, or a voluminous data fileretrieved from secondary storage. The transform(s) may comprise a single logical
comparison, a complex numerical algorithm, or a rule-inference approach of an expert
system. Output may light a single LED or produce a 200-page report. In effect, we can
create a flow model for any computer-based system, regardless of size and complex-
ity. A more detailed discussion of flow modeling is presented in Chapter 7.
5.5.2Analysis Patterns
Anyone who has done requirements engineering on more than a few software
projects begins to notice that certain problems reoccur across all projects within a
specific application domain.18These analysis patterns[Fow97] suggest solutions(e.g., a class, a function, a behavior) within the application domain that can be
reused when modeling many applications.Geyer-Schulz and Hahsler [Gey01] suggest two benefits that can be associatedwith the use of analysis patterns:First, analysis patterns speed up the development of abstract analysis models that cap-ture the main requirements of the concrete problem by providing reusable analysis mod-

els with examples as well as a description of advantages and limitations. Second, analysis
patterns facilitate the transformation of the analysis model into a design model by sug-
gesting design patterns and reliable solutions for common problems.Analysis patterns are integrated into the analysis model by reference to the patternname. They are also stored in a repository so that requirements engineers can use
search facilities to find and apply them. Information about an analysis pattern (and
other types of patterns) is presented in a standard template [Gey01]19that is dis-cussed in more detail in Chapter 12. Examples of analysis patterns and further dis-
cussion of this topic are presented in Chapter 7.5.6N
EGOTIATING
REQUIREMENTSIn an ideal requirements engineering context, the inception, elicitation, and elabo-
ration tasks determine customer requirements in sufficient detail to proceed to sub-
sequent software engineering activities. Unfortunately, this rarely happens. In reality,

you may have to enter into a negotiation with one or more stakeholders. In most
cases, stakeholders are asked to balance functionality, performance, and other prod-

uct or system characteristics against cost and time-to-market. The intent of this
negotiation is to develop a project plan that meets stakeholder needs while at the142PART TWOMODELING18In some cases, problems reoccur regardless of the application domain. For example, the features
and functions used to solve user interface problems are common regardless of the applicationdomain under consideration.19A variety of patterns templates have been proposed in the literature. If you have interest, see
[Fow97], [Gam95], [Yac03], and [Bus07] among many sources.uote:ÒA compromise isthe art of dividing
a cake in such a
way that everyone

believes he has the
biggest piece.ÓLudwigErhard
pre75977_ch05.qxd  11/27/08  3:30 PM  Page 142
same time reflecting the real-world constraints (e.g., time, people, budget) that have
been placed on the software team.The best negotiations strive for a Òwin-winÓ result.20That is, stakeholders win bygetting the system or product that satisfies the majority of their needs and you (as a
member of the software team) win by working to realistic and achievable budgets
and deadlines.Boehm [Boe98] defines a set of negotiation activities at the beginning of each soft-ware process iteration. Rather than a single customer communication activity, the

following activities are defined:1.Identification of the system or subsystemÕs key stakeholders.
2.Determination of the stakeholdersÕ Òwin conditions.Ó3.Negotiation of the stakeholdersÕ win conditions to reconcile them into a set
of win-win conditions for all concerned (including the software team).Successfulcompletionoftheseinitialstepsachievesawin-winresult,whichbecomes

thekeycriterionforproceedingtosubsequentsoftwareengineeringactivities.
CHAPTER 5UNDERSTANDING REQUIREMENTS14320Dozens of books have been written on negotiating skills (e.g., [Lew06], [Rai06], [Fis06]). It is one of
the more important skills that you can learn. Read one.WebRef
Abriefpaperon
negotiationforsoftware

requirementscanbe

downloadedfrom

www.alexander-

egyed.com/
publications/
Software_
Requirements_
Negotiation-
Some_Lessons_
Learned.html.The Art of NegotiationLearning how to negotiate effectively can serve
you well throughout your personal and technicallife. The following guidelines are well worth considering:
1.Recognize that itÕs not a competition.
To be
successful, both parties have to feel theyÕve won or

achieved something. Both will have to compromise.2.Map out a strategy.
Decide what youÕd like toachieve; what the other party wants to achieve, and

how youÕll go about making both happen.3.Listen actively.
DonÕt work on formulating your
response while the other party is talking. Listen
toher. ItÕs likely youÕll gain knowledge that will help

you to better negotiate your position.4.Focus on the other partyÕs interests.
DonÕt take hard
positions if you want to avoid conflict.5.DonÕt let it get personal.
Focus on the problem thatneeds to be solved.6.Be creative.DonÕt be afraid to think out of the box if
youÕre at an impasse.7.Be ready to commit.Once an agreement has beenreached, donÕt waffle; commit to it and move on.
INFOThe Start of a NegotiationThe scene:Lisa PerezÕs office, after
the first requirements gathering meeting.The players:Doug Miller, software engineering
manager and Lisa Perez, marketing manager.
The conversation:
Lisa:So, I hear the first meeting went really well.Doug:Actually, it did. You sent some good people to the
meeting...they really contributed.
SAFEHOMEpre75977_ch05.qxd  11/27/08  3:30 PM  Page 143
5.7V
ALIDATING
REQUIREMENTS144PART TWOMODELINGWhen Ireviewrequirements,
what questions
should I ask??As each element of the requirements model is created, it is examined for inconsis-tency, omissions, and ambiguity. The requirements represented by the model are pri-

oritized by the stakeholders and grouped within requirements packages that will be
implemented as software increments. A review of the requirements model addresses
the following questions:¥Is each requirement consistent with the overall objectives for the

system/product?¥Have all requirements been specified at the proper level of abstraction? That
is, do some requirements provide a level of technical detail that is inappro-

priate at this stage?¥Is the requirement really necessary or does it represent an add-on feature
that may not be essential to the objective of the system?¥Is each requirement bounded and unambiguous?¥Does each requirement have attribution? That is, is a source (generally, a

specific individual) noted for each requirement?¥Do any requirements conflict with other requirements?¥Is each requirement achievable in the technical environment that will house

the system or product?¥Is each requirement testable, once implemented?
¥Does the requirements model properly reflect the information, function, and
behavior of the system to be built?Lisa (smiling):Yeah, they actually told me they got into
it and it wasnÕt a Òpropeller head activity.Ó
Doug (laughing):IÕll be sure to take off my techie
beanie the next time I visit...Look, Lisa, I think we may
have a problem with getting all of the functionality for thehome security system out by the dates your management
is talking about. ItÕs early, I know, but IÕve already been

doing a little back-of-the-envelope planning and...
Lisa (frowning):
WeÕve got to have it by that date,
Doug. What functionality are you talking about?
Doug:I figure we can get full home security functionalityout by the drop-dead date, but weÕll have to delayInternet access Ôtil the second release.
Lisa:Doug, itÕs the Internet access that gives 
SafeHomeÒgee whizÓ appeal. WeÕre going to build our entire
marketing campaign around it. WeÕve gotta have it!
Doug:Iunderstandyoursituation,Ireallydo.The
problemisthatinordertogiveyouInternetaccess,

weÕllhavetohaveafullysecurewebsiteupand

running.Thattakestimeandpeople.WeÕllalsohave

tobuildalotofadditionalfunctionalityintothefirst

release...IdonÕtthinkwecandoitwiththeresources
weÕvegot.
Lisa (still frowning):
I see, but youÕve got to figure outa way to get it done. ItÕs pivotal to home security functions
and to other functions as well...those can wait until the

next releases...IÕll agree to that.
Lisa and Doug appear to be at an impasse, and yet theymust negotiate a solution to this problem. Can they both
ÒwinÓ here? Playing the role of a mediator, what would you

suggest?pre75977_ch05.qxd  11/27/08  3:30 PM  Page 144
¥Has the requirements model been ÒpartitionedÓ in a way that exposesprogressively more detailed information about the system?¥Have requirements patterns been used to simplify the requirements model?
Have all patterns been properly validated? Are all patterns consistent with
customer requirements?These and other questions should be asked and answered to ensure that the re-
quirements model is an accurate reflection of stakeholder needs and that it provides

a solid foundation for design.5.8S
UMMARYRequirements engineering tasks are conducted to establish a solid foundation for de-
sign and construction. Requirements engineering occurs during the communication
and modeling activities that have been defined for the generic software process.
Seven distinct requirements engineering functionsÑinception, elicitation, elabora-
tion, negotiation, specification, validation, and managementÑare conducted by
members of the software team.At project inception, stakeholders establish basic problem requirements, defineoverriding project constraints, and address major features and functions that must

be present for the system to meet its objectives. This information is refined and ex-
panded during elicitationÑa requirements gathering activity that makes use of facil-
itated meetings, QFD, and the development of usage scenarios.
Elaboration further expands requirements in a modelÑa collection of scenario-based, class-based, behavioral, and flow-oriented elements. The model may refer-
ence analysis patterns, solutions for analysis problems that have been seen to
reoccur across different applications.Asrequirementsareidentifiedandtherequirementsmodelisbeingcreated,the
softwareteamandotherprojectstakeholdersnegotiatethepriority,availability,and

relativecostofeachrequirement.Theintentofthisnegotiationistodeveloparealis-

ticprojectplan.Inaddition,eachrequirementandtherequirementsmodelasawhole

arevalidatedagainstcustomerneedtoensurethattherightsystemistobebuilt.
PROBLEMSAND
POINTSTO
PONDER5.1.Why is it that many software developers donÕt pay enough attention to requirements engi-
neering? Are there ever circumstances where you can skip it?5.2.You have been given the responsibility to elicit requirements from a customer who tells
you he is too busy to meet with you. What should you do?
5.3.Discuss some of the problems that occur when requirements must be elicited from threeor four different customers.
5.4.Why do we say that the requirements model represents a snapshot of a system in time?CHAPTER 5UNDERSTANDING REQUIREMENTS145pre75977_ch05.qxd  11/27/08  3:30 PM  Page 145
5.5.LetÕs assume that youÕve convinced the customer (youÕre a very good salesperson) to agree
to every demand that you have as a developer. Does that make you a master negotiator? Why?
5.6.Develop at least three additional Òcontext-free questionsÓ that you might ask a stakeholderduring inception.
5.7.Develop a requirements gathering Òkit.Ó The kit should include a set of guidelines for con-ducting a requirements gathering meeting and materials that can be used to facilitate the cre-ation of lists and any other items that might help in defining requirements.5.8.Yourinstructorwilldividetheclassintogroupsoffourtosixstudents.Halfofthegroup
willplaytheroleofthemarketingdepartmentandhalfwilltakeontheroleofsoftware
engineering.Yourjobistodefinerequirementsforthe
SafeHomesecurityfunctiondescribed
inthischapter.Conductarequirementsgatheringmeetingusingtheguidelinespresentedin

thischapter.
5.9.Develop a complete use case for one of the following activities:a.Making a withdrawal at an ATM
b.Using your charge card for a meal at a restaurant
c.Buying a stock using an on-line brokerage account
d.Searching for books (on a specific topic) using an on-line bookstore
e.An activity specified by your instructor.
5.10.What do use case ÒexceptionsÓ represent?5.11.Describe what an analysis patternis in your own words.5.12.Using the template presented in Section 5.5.2, suggest one or more analysis pattern forthe following application domains:a.Accounting software
b.E-mail software
c.Internet browsers
d.Word-processing software
e.Website creation software
f.An application domain specified by your instructor
5.13.What does win-winmean in the context of negotiation during the requirements engi-neering activity?
5.14.What do you think happens when requirement validation uncovers an error? Who is
involved in correcting the error?
FURTHER
READINGSAND
INFORMATION
SOURCESBecause it is pivotal to the successful creation of any complex computer-based system, re-quirements engineering is discussed in a wide array of books. Hood and his colleagues
(Requirements Management,Springer, 2007) discuss a variety of requirements engineering is-
sues that span both systems and software engineering. Young (
The Requirements EngineeringHandbook,Artech House Publishers, 2007) presents an in-depth discussion of requirements en-gineering tasks. Wiegers (
More About Software Requirements,Microsoft Press, 2006) provides
many practical techniques for requirements gathering and management. Hull and her
colleagues (Requirements Engineering,2d ed., Springer-Verlag, 2004), Bray (
An Introduction toRequirements Engineering,Addison-Wesley, 2002), Arlow (
Requirements Engineering,Addison-Wesley, 2001), Gilb (
Requirements Engineering,Addison-Wesley, 2000), Graham (
RequirementsEngineering and Rapid Development,Addison-Wesley, 1999), and Sommerville and Kotonya
(Requirement Engineering: Processes and Techniques,
Wiley, 1998) are but a few of many books
dedicated to the subject. Gottesdiener (Requirements by Collaboration: Workshops for Defining
146PART TWOMODELINGpre75977_ch05.qxd  11/27/08  3:30 PM  Page 146
Needs,Addison-Wesley, 2002) provides useful guidance for those who must establish a collab-
orative requirements gathering environment with stakeholders.
Lauesen (Software Requirements: Styles and Techniques,
Addison-Wesley, 2002) presents a
comprehensive survey of requirement analysis methods and notation. Weigers (
SoftwareRequirements,Microsoft Press, 1999) and Leffingwell and his colleagues (Managing SoftwareRequirements: A Use Case Approach,
2d ed., Addison-Wesley, 2003) present a useful collection of
requirement best practices and suggest pragmatic guidelines for most aspects of the require-ments engineering process.Apatterns-basedviewofrequirementsengineeringisdescribedbyWithall(
SoftwareRequire-
mentPatterns,
MicrosoftPress,2007).Ploesch(
Assertions,ScenariosandPrototypes,
Springer-Verlag,2003)discussesadvancedtechniquesfordevelopingsoftwarerequirements.Windleand

Abreo(
SoftwareRequirementsUsingtheUnifiedProcess,
Prentice-Hall,2002)discussrequire-
mentsengineeringwithinthecontextoftheUnifiedProcessandUMLnotation.Alexander and

Steven (Writing Better Requirements,Addison-Wesley, 2002) present a brief set of guidelines for
writing clear requirements, representing them as scenarios, and reviewing the end result.Use-case modeling is often the driver for the creation of all other aspects of the analysismodel. The subject is discussed at length by Rosenberg and Stephens (Use Case Driven Object
Modeling with UML: Theory and Practice,
Apress, 2007), Denny (Succeeding with Use Cases: Work-
ing Smart to Deliver Quality,
Addison-Wesley, 2005), Alexander and Maiden (eds.) (
Scenarios,Stories, Use Cases: Through the Systems Development Life-Cycle,Wiley, 2004), Leffingwell and his
colleagues (Managing Software Requirements: A Use Case Approach,
2d ed., Addison-Wesley,
2003) present a useful collection of requirement best practices. Bittner and Spence (UseCaseModeling,
Addison-Wesley, 2002), Cockburn [Coc01], Armour and Miller (
AdvancedUseCase Modeling: Software Systems,
Addison-Wesley, 2000), and Kulak and his colleagues (
UseCases: Requirements in Context,Addison-Wesley, 2000) discuss requirements gathering with an
emphasis on use-case modeling.A wide variety of information sources on requirements engineering and analysis is availableon the Internet. An up-to-date list of World Wide Web references that are relevant to require-

ments engineering and analysis can be found at the SEPA website: 
www.mhhe.com/engcs/

compsci/pressman/professional/olc/ser.htm
.CHAPTER 5UNDERSTANDING REQUIREMENTS147pre75977_ch05.qxd  11/27/08  3:30 PM  Page 147
At a technical level, software engineering begins with a series ofmodelingtasks that lead to a specification of requirements and a design

representation for the software to be built. The requirements model1Ñactually a set of modelsÑis the first technical representation of a system.In a seminal book on requirements modeling methods, Tom DeMarco [DeM79]
describes the process in this way:Looking back over the recognized problems and failings of the analysis phase, I sug-
gest that we need to make the following additions to our set of analysis phase goals.
The products of analysis must be highly maintainable. This applies particularly to the 148CHAPTER6REQUIREMENTSMODELING: SCENARIOS,INFORMATION
, ANDANALYSIS
CLASSESKEYCONCEPTSactivitydiagram . .161
analysisclasses . .167

analysispackages . . . . . .182
associations . . . .180

class-basedmodeling . . . . . .167
CRC modeling . . .173

data modeling . . .164

domainanalysis . .151

grammaticalparse . . . . . . . . .167
What is it?The written word is awonderful vehicle for communica-
tion, but it is not necessarily the best
way to represent the requirements forcomputer software. Requirements modeling uses
a combination of text and diagrammatic forms

to depict requirements in a way that is relatively
easy to understand, and more important,

straightforward to review for correctness, com-

pleteness, and consistency.
Who does it?A software engineer (sometimescalled an ÒanalystÓ) builds the model using
requirements elicited from the customer.
Why is it important?
To validate software require-
ments, you need to examine them from a number
of different points of view. In this chapter youÕll

consider requirements modeling from three dif-
ferent perspectives: scenario-based models, data
(information) models, and class-based models.

Each represents requirements in a different

Òdimension,Ó thereby increasing the probability
that errors will be found, that inconsistency will
surface, and that omissions will be uncovered.
QUICKLOOKWhatarethesteps?
Scenario-basedmodeling
representsthesystemfromtheuserÕspointofview.

Datamodelingrepresentstheinformationspace

anddepictsthedataobjectsthatthesoftwarewill

manipulateandtherelationshipsamongthem.

Class-basedmodelingdefinesobjects,attributes,

andrelationships.Oncepreliminarymodelsare

created,theyarerefinedandanalyzedtoassess

theirclarity,completeness,andconsistency.In

Chapter7,weextendthemodelingdimensions

notedherewithadditionalrepresentations,pro-

vidingamorerobustviewofrequirements.
What is the work product?
A wide array of text-based and diagrammatic forms may be chosen

for the requirements model. Each of these repre-
sentations provides a view of one or more of the
model elements.How do I ensure that IÕve done it right?Requirements modeling work products must be
reviewed for correctness, completeness, and
consistency. They must reflect the needs of all

stakeholders and establish a foundation from
which design can be conducted.1In past editions of this book, I used the term 
analysis model,rather than requirements model.In thisedition, IÕve decided to use both phrases to represent the modeling activity that defines various as-pects of the problem to be solved. Analysisis the action that occurs as requirementsare derived.pre75977_ch06.qxd  11/27/08  3:34 PM  Page 148
Target Document [software requirements specification]. Problems of size must be dealt
with using an effective method of partitioning. The Victorian novel specification is

out.Graphics have to be used whenever possible. We have to differentiate between log-

ical [essential] and physical [implementation] considerations....At the very least, we

need....Something to help us partition our requirements and document that partition-
ing before specification....Some means of keeping track of and evaluating interfaces....

Newtools to describe logic and policy, something better than narrative text.
Although DeMarco wrote about the attributes of analysis modeling more than aquarter century ago, his comments still apply to modern requirements modelingmethods and notation.6.1R
EQUIREMENTSANALYSIS
Requirements analysis results in the specification of softwareÕs operational charac-

teristics, indicates softwareÕs interface with other system elements, and establishes

constraints that software must meet. Requirements analysis allows you (regardless
of whether youÕre called a software engineer,
an analyst,or a modeler) to elaborate onbasic requirements established during the inception, elicitation, and negotiation
tasks that are part of requirements engineering (Chapter 5).The requirements modeling action results in one or more of the following typesof models:¥Scenario-based modelsof requirements from the point of view of varioussystem ÒactorsÓ¥Data modelsthat depict the information domain for the problem¥Class-oriented modelsthat represent object-oriented classes (attributes andoperations) and the manner in which classes collaborate to achieve system
requirements¥Flow-oriented modelsthat represent the functional elements of the systemand how they transform data as it moves through the system
¥Behavioral models
that depict how the software behaves as a consequence ofexternal ÒeventsÓThese models provide a software designer with information that can be translated

toarchitectural, interface, and component-level designs. Finally, the requirements

model (and the software requirements specification) provides the developer and the

customer with the means to assess quality once software is built.In this chapter, I focus on 
scenario-based modelingÑa technique that is growingincreasingly popular throughout the software engineering community; datamodelingÑa more specialized technique that is particularly appropriate when an
application must create or manipulate a complex information space; and classCHAPTER 6REQUIREMENTS MODELING: SCENARIOS, INFORMATION, AND ANALYSIS CLASSES149requirementsmodeling . . . . . .153
scenario-basedmodeling . . . . . .154
swimlanediagram . . . . . . .162
UML models . . . .161

use cases . . . . . .156
uote:ÒAny one ÔviewÕofrequirements

isinsufficient

tounderstand

ordescribe the

desired behavior of
a complex system.ÓAlanM.Davis
The analysis modeland requirements
specification provide
ameans for assessing

quality once the
software is built.pre75977_ch06.qxd  11/27/08  3:34 PM  Page 149
150PART TWOMODELINGmodelingÑa representation of the object-oriented classes and the resultant collabo-rations that allow a system to function. Flow-oriented models, behavioral models,
pattern-based modeling, and WebApp models are discussed in Chapter 7.
6.1.1Overall Objectives and Philosophy
Throughout requirements modeling, your primary focus is on what,not how.
Whatuser interaction occurs in a particular circumstance, what objects does the system

manipulate, what functions must the system perform, what behaviors does the sys-

tem exhibit, what interfaces are defined, and what constraints apply?2In earlier chapters, I noted that complete specification of requirements may notbe possible at this stage. The customer may be unsure of precisely what is required
for certain aspects of the system. The developer may be unsure that a specific ap-
proach will properly accomplish function and performance. These realities mitigate
in favor of an iterative approach to requirements analysis and modeling. The analyst
should model what is known and use that model as the basis for design of the soft-
ware increment.3The requirements model must achieve three primary objectives: (1) to describewhat the customer requires, (2) to establish a basis for the creation of a software de-
sign, and (3) to define a set of requirements that can be validated once the software
is built. The analysis model bridges the gap between a system-level description that
describes overall system or business functionality as it is achieved by applying soft-

ware, hardware, data, human, and other system elements and a software design

(Chapters 8 through 13) that describes the softwareÕs application architecture, userin-

terface, and component-level structure. This relationship is illustrated in Figure 6.1.
uote:ÒRequirements arenot architecture.
Requirements
arenot design, nor

are they the
userinterface.

Requirements are
need.ÓAndrewHunt
andDavid

Thomas2It should be noted that as customers become more technologically sophisticated, there is a trend
toward the specification of howas well as what.However, the primary focus should remain onwhat.3Alternatively, the software team may choose to create a prototype (Chapter 2) in an effort to better
understand requirements for the system.The analysis modelshould describe what
the customer wants,
establish a basis for
design, and establish a
target for validation.SystemdescriptionAnalysismodelDesignmodelFIGURE6.1Therequirements

model as
abridge

between the
system
description
and the design
modelpre75977_ch06.qxd  11/27/08  3:34 PM  Page 150
It is important to note that all elements of the requirements model will be directlytraceable to parts of the design model. A clear division of analysis and design tasksbetween these two important modeling activities is not always possible. Some
design invariably occurs as part of analysis, and some analysis will be conducted

during design.6.1.2Analysis Rules of Thumb
Arlow and Neustadt [Arl02] suggest a number of worthwhile rules of thumb that
should be followed when creating the analysis model:¥The model should focus on requirements that are visible within the problem or
business domain. The level of abstraction should be relatively high.
ÒDonÕt get
bogged down in detailsÓ [Arl02] that try to explain how the system will work.¥Each element of the requirements model should add to an overall understanding

of software requirements and provide insight into the information domain,

function, and behavior of the system.¥Delay consideration of infrastructure and other nonfunctional models until

design.That is, a database may be required, but the classes necessary toimplement it, the functions required to access it, and the behavior that will be
exhibited as it is used should be considered only after problem domain
analysis has been completed.¥Minimize coupling throughout the system.It is important to represent relation-ships between classes and functions. However, if the level of Òinterconnect-

ednessÓ is extremely high, effort should be made to reduce it.¥Be certain that the requirements model provides value to all stakeholders.
Eachconstituency has its own use for the model. For example, business stake-

holders should use the model to validate requirements; designers should use
the model as a basis for design; QA people should use the model to help plan
acceptance tests.¥Keep the model as simple as it can be.DonÕt create additional diagrams when
they add no new information. DonÕt use complex notational forms, when a

simple list will do.6.1.3Domain Analysis
In the discussion of requirements engineering (Chapter 5), I noted that analysis pat-
terns often reoccur across many applications within a specific business domain. If
these patterns are defined and categorized in a manner that allows you to recognize
and apply them to solve common problems, the creation of the analysis model is
expedited. More important, the likelihood of applying design patterns and executa-
ble software components grows dramatically. This improves time-to-market and

reduces development costs.CHAPTER 6REQUIREMENTS MODELING: SCENARIOS, INFORMATION, AND ANALYSIS CLASSES151uote:ÒProblems worthyof attack, prove
their worth by
hitting back.ÓPietHein
WebRef
Many useful resourcesfor domain analysis 
can be found at
www.iturls

.com/English/
Software
Engineering/
SE_mod5.asp.Are therebasic guidelines that
can helpus aswe

do requirements
analysis work??pre75977_ch06.qxd  11/27/08  3:34 PM  Page 151
152PART TWOMODELINGBut how are analysis patterns and classes recognized in the first place? Who de-fines them, categorizes them, and readies them for use on subsequent projects? Theanswers to these questions lie in domain analysis.Firesmith [Fir93] describes domainanalysis in the following way:Software domain analysis is the identification, analysis, and specification of common re-quirements from a specific application domain, typically for reuse on multiple projects
within that application domain....[Object-oriented domain analysis is] the identification,

analysis, and specification of common, reusable capabilities within a specific application
domain, in terms of common objects, classes, subassemblies, and frameworks.The Òspecific application domainÓ can range from avionics to banking, from multi-media video games to software embedded within medical devices. The goal of do-
main analysis is straightforward: to find or create those analysis classes and/or
analysis patterns that are broadly applicable so that they may be reused.4Using terminology that was introduced earlier in this book, domain analysis maybe viewed as an umbrella activity for the software process. By this I mean that do-
main analysis is an ongoing software engineering activity that is not connected to
any one software project. In a way, the role of a domain analyst is similar to the role

of a master toolsmith in a heavy manufacturing environment. The job of the tool-

smith is to design and build tools that may be used by many people doing similar but
not necessarily the same jobs. The role of the domain analyst5is to discover and de-
fine analysis patterns, analysis classes, and related information that may be used by
many people working on similar but not necessarily the same applications.Figure 6.2[Ara89] illustrates key inputs and outputs for the domain analysis
process. Sources of domain knowledge are surveyed in an attempt to identify objects
that can be reused across the domain.Domain analysisdoesnÕt look at a
specific application, but
rather at the domain in
which the application
resides. The intent is
toidentify common

problem solving
elements that are
applicable to all
applications within
thedomain.
DomainanalysisSources ofdomainknowledgeCustomer surveys
Expert advice

Current/future requirementsExisting applicationsTechnical literatureDomainanalysismodelFunctional modelsDomain languagesReuse standardsClass taxonomiesFIGURE6.2Input and output for domain analysis4A complementary view of domain analysis Òinvolves modeling the domain so that software engi-
neers and other stakeholders can better learn about it . . . not all domain classes necessarily resultin the development of reusable classes . . .Ó [Let03a].5Do not make the assumption that because a domain analyst is at work, a software engineer need
not understand the application domain. Every member of a software team should have some un-
derstanding of the domain in which the software is to be placed.pre75977_ch06.qxd  11/27/08  3:34 PM  Page 152
CHAPTER 6REQUIREMENTS MODELING: SCENARIOS, INFORMATION, AND ANALYSIS CLASSES153Domain AnalysisThe scene:Doug MillerÕs office, after
a meeting with marketing.The players:Doug Miller, software engineering
manager, and Vinod Raman, a member of the software
engineering team.The conversation:
Doug:I need you for a special project, Vinod. IÕm going
to pull you out of the requirements gathering meetings.
Vinod (frowning):
Too bad. That format actually
works . . . I was getting something out of it. WhatÕs up?

Doug:Jamie and Ed will cover for you. Anyway,
marketing insists that we deliver the Internet capability
along with the home security function in the first release of
SafeHome.WeÕre under the gun on this . . . not enough
time or people, so weÕve got to solve both problemsÑthe
PC interface and the Web interfaceÑat once.
Vinod (looking confused):
I didnÕt know the plan was
set . . . weÕre not even finished with requirements gathering.
Doug (a wan smile):I know, but the time lines are so
short that I decided to begin strategizing with marketing
right now . . . anyhow, weÕll revisit any tentative plan

once we have the info from all of the requirements
gathering meetings.Vinod:
Okay, whatÕs up? What do you want me to do?
Doug:Do you know what Òdomain analysisÓ is?Vinod:
Sort of. You look for similar patterns in Apps
that do the same kinds of things as the App youÕrebuilding. If possible, you then steal the patterns and reuse

them in your work.Doug:Not sure I like the word steal,but basically youhaveitright.WhatIÕdlikeyoutodoistobeginresearching
existing user interfaces for systems that control something

like SafeHome. I want you to propose a set of patterns and

analysis classes that can be common to both the PC-based
interface thatÕll sit in the house and the browser-based

interface that is accessible via the Internet.
Vinod:
We can save time by making them the same . . .
why donÕt we just do that?

Doug:Ah . . . itÕs nice to have people who think like you
do. ThatÕs the whole pointÑwe can save time and effort if
both interfaces are nearly identical, implemented with the

same code, blah, blah, that marketing insists on.Vinod:
So you want, whatÑclasses, analysis patterns,
design patterns?

Doug:AllofÔem.Nothingformalatthispoint.Ijustwant
togetaheadstartonourinternalanalysisanddesignwork.

Vinod:
IÕll go to our class library and see what weÕve
got. IÕll also use a patterns template I saw in a book I was
reading a few months back.Doug:Good. Go to work.SAFEHOME6.1.4Requirements Modeling Approaches
One view of requirements modeling, called structured analysis,considers data andthe processes that transform the data as separate entities. Data objects are modeledin a way that defines their attributes and relationships. Processes that manipulate
data objects are modeled in a manner that shows how they transform data as data
objects flow through the system.A second approach to analysis modeling, called object-oriented analysis,focuseson the definition of classes and the manner in which they collaborate with one an-
other to effect customer requirements. UML and the Unified Process (Chapter 2) are
predominantly object oriented.Although the requirements model proposed in this book combines features ofboth approaches, software teams often choose one approach and exclude all repre-
sentations from the other. The question is not which is best, but rather, what
uote:ÒÉanalysisis
frustrating,full

ofcomplex

interpersonal
relationships,
indefinite,and

difficult.Inaword,it

isfascinating.Once

youÕrehooked,the

oldeasypleasuresof

systembuildingare

neveragainenough

tosatisfyyou.Ó
TomDeMarco
pre75977_ch06.qxd  11/27/08  3:34 PM  Page 153
154PART TWOMODELINGcombination of representations will provide stakeholders with the best model of
software requirements and the most effective bridge to software design.Each element of the requirements model (Figure 6.3) presents the problem froma different point of view. Scenario-based elements depict how the user interacts with

the system and the specific sequence of activities that occur as the software is used.
Class-based elements model the objects that the system will manipulate, the opera-

tions that will be applied to the objects to effect the manipulation, relationships
(some hierarchical) between the objects, and the collaborations that occur between
the classes that are defined. Behavioral elements depict how external events change
the state of the system or the classes that reside within it. Finally, flow-oriented ele-

ments represent the system as an information transform, depicting how data objects
are transformed as they flow through various system functions.Analysis modeling leads to the derivation of each of these modeling elements.However, the specific content of each element (i.e., the diagrams that are used to

construct the element and the model) may differ from project to project. As we have
noted a number of times in this book, the software team must work to keep it sim-
ple. Only those modeling elements that add value to the model should be used.6.2S
CENARIO-BASEDMODELINGAlthough the success of a computer-based system or product is measured in many
ways, user satisfaction resides at the top of the list. If you understand how end users
(and other actors) want to interact with a system, your software team will be better
able to properly characterize requirements and build meaningful analysis and designWhatdifferentpoints of view 
can be used to
describe the
requirements
model??uote:ÒWhy should we
build models? Why
not just build the
system itself? The
answer is that we
can construct
models in such a
way as to highlight,
or emphasize,
certain critical
features of a
system, while
simultaneously
de-emphasizing
other aspects of
thesystem.Ó
EdYourdon
SoftwareRequirementsClassmodelse.g.,class diagrams
collaboration diagramsFlowmodelse.g.,DFDs
data modelsScenario-based
modelse.g.,use cases
user storiesBehavioralmodelse.g.,state diagrams
sequence diagramsFIGURE6.3Elements ofthe analysis
modelpre75977_ch06.qxd  11/27/08  3:34 PM  Page 154
models. Hence, requirements modeling with UML
6begins with the creation of sce-narios in the form of use cases, activity diagrams, and swimlane diagrams.6.2.1Creating a Preliminary Use Case
Alistair Cockburn characterizes a use case as a Òcontract for behaviorÓ [Coc01b]. Aswe discussed in Chapter 5, the ÒcontractÓ defines the way in which an actor7uses acomputer-based system to accomplish some goal. In essence, a use case captures

the interactions that occur between producers and consumers of information and
the system itself. In this section, I examine how use cases are developed as part
ofthe requirements modeling activity.
8In Chapter 5, I noted that a use case describes a specific usage scenario in straight-forward language from the point of view of a defined actor. But how do you know

(1)what to write about, (2) how much to write about it, (3) how detailed to make your

description, and (4) how to organize the description? These are the questions that
must be answered if use cases are to provide value as a requirements modeling tool.
What to write about?The first two requirements engineering tasksÑinceptionand elicitationÑprovide you with the information youÕll need to begin writing use
cases. Requirements gathering meetings, QFD, and other requirements engineering

mechanisms are used to identify stakeholders, define the scope of the problem, spec-
ify overall operational goals, establish priorities, outline all known functional re-

quirements, and describe the things (objects) that will be manipulated by the system.To begin developing a set of use cases, list the functions or activities performed
by a specific actor. You can obtain these from a list of required system functions,

through conversations with stakeholders, or by an evaluation of activity diagrams

(Section 6.3.1) developed as part of requirements modeling.CHAPTER 6REQUIREMENTS MODELING: SCENARIOS, INFORMATION, AND ANALYSIS CLASSES155uote:Ò[Use cases] aresimply an aid to
defining what
exists outside the
system (actors)
and what should be
performed by the
system (use
cases).ÓIvarJacobson
In some situations, usecases become the
dominant requirements
engineering
mechanism. However,

this does not mean
that you should discard
other modeling
methods when they
are appropriate.6UML will be used as the modeling notation throughout this book. Appendix 1 provides a brief tuto-
rial for those readers who may be unfamiliar with basic UML notation.7An actor is not a specific person, but rather a role that a person (or a device) plays within a specific
context. An actor Òcalls on the system to deliver one of its servicesÓ [Coc01b].8Use cases are a particularly important part of analysis modeling for user interfaces. Interface analy-
sis is discussed in detail in Chapter 11.The scene:A meeting room, duringthe second requirements gathering meeting.The players:Jamie Lazar, software team member; 
Ed Robbins, software team member; Doug Miller,
software engineering manager; three members of
marketing; a product engineering representative; and a
facilitator.
The conversation:Facilitator:ItÕs time that we begin talking about
theSafeHomesurveillance function. LetÕs develop 
a user scenario for access to the surveillance 
function.Jamie:Who plays the role of the actor on this?SAFEHOMEDeveloping Another Preliminary User Scenario
pre75977_ch06.qxd  11/27/08  3:34 PM  Page 155
156PART TWOMODELINGThe SafeHomehome surveillance function (subsystem) discussed in the sidebaridentifies the following functions (an abbreviated list) that are performed by thehomeowner
actor:¥Select camera to view.
¥Request thumbnails from all cameras.¥Display camera views in a PC window.
¥Control pan and zoom for a specific camera.¥Selectively record camera output.¥Replay camera output.¥Access camera surveillance via the Internet.As further conversations with the stakeholder (who plays the role of a homeowner)

progress, the requirements gathering team develops use cases for each of the func-
tions noted. In general, use cases are written first in an informal narrative fashion. If
more formality is required, the same use case is rewritten using a structured format
similar to the one proposed in Chapter 5 and reproduced later in this section as a
sidebar.
Facilitator:I think Meredith (a marketing person) hasbeen working on that functionality. Why donÕt you play
the role?Meredith:You want to do it the same way we did it last
time, right?
Facilitator:Right...same way.
Meredith:Well, obviously the reason for surveillance is
to allow the homeowner to check out the house while heor she is away, to record and play back video that is

captured...that sort of thing.
Ed:Will we use compression to store the video?Facilitator:Good question, Ed, but letÕs postpone
implementation issues for now. Meredith?

Meredith:Okay, so basically there are two parts to the
surveillance function...the first configures the system
including laying out a floor planÑwe have to have tools
to help the homeowner do thisÑand the second part is

the actual surveillance function itself. Since the layout is

part of the configuration activity, IÕll focus on the

surveillance function.
Facilitator (smiling):Took the words right out of my
mouth.Meredith:Um...I 
want to gain access to thesurveillance function either via the PC or via the Internet.
My feeling is that the Internet access would be more

frequently used. Anyway, I want to be able to display

camera views on a PC and control pan and zoom for a
specific camera. I specify the camera by selecting it from
the house floor plan. I want to selectively record camera
output and replay camera output. I also want to be able
to block access to one or more cameras with a specific
password. I also want the option of seeing small windows
that show views from all cameras and then be able to
pick the one I want enlarged.Jamie:Those are called thumbnail views.Meredith:Okay, then I want thumbnail views of
all the cameras. I also want the interface for the
surveillance function to have the same look and feel

as all other SafeHomeinterfaces. I want it to be
intuitive, meaning I donÕt want to have to read a manual

to use it.Facilitator:Good job. Now, letÕs go into this function in
a bit more detail...
pre75977_ch06.qxd  11/27/08  3:34 PM  Page 156
To illustrate, consider the function 
access camera surveillance via the InternetÑ
display camera views
(ACS-DCV).
The stakeholder who takes on the role of thehomeowner
actor might write the following narrative:Use case: Access camera surveillance via the InternetÑdisplay camera views
(ACS-DCV)
Actor: homeowner
If IÕm at a remote location, I can use any PC with appropriate browser software to logon to the SafeHome Productswebsite. I enter my user ID and two levels of passwords andonce IÕm validated, I have access to all functionality for my installed SafeHomesystem. To
access a specific camera view, I select ÒsurveillanceÓ from the major function buttons dis-
played. I then select Òpick a cameraÓ and the floor plan of the house is displayed. I then se-
lect the camera that IÕm interested in. Alternatively, I can look at thumbnail snapshots from

all cameras simultaneously by selecting Òall camerasÓ as my viewing choice. Once I choose
a camera, I select ÒviewÓ and a one-frame-per-second view appears in a viewing window
that is identified by the camera ID. If I want to switch cameras, I select Òpick a cameraÓ and

the original viewing window disappears and the floor plan of the house is displayed again.
I then select the camera that IÕm interested in. A new viewing window appears.A variation of a narrative use case presents the interaction as an ordered sequenceof user actions. Each action is represented as a declarative sentence. Revisiting the
ACS-DCV
function, you would write:Use case: Access camera surveillance via the InternetÑdisplay camera views
(ACS-DCV)
Actor: homeowner
1.The homeowner logs onto the 
SafeHome Productswebsite.2.The homeowner enters his or her user ID.
3.The homeowner enters two passwords (each at least eight characters in length).

4.The system displays all major function buttons.

5.The homeowner selects the ÒsurveillanceÓ from the major function buttons.

6.The homeowner selects Òpick a camera.Ó

7.The system displays the floor plan of the house.

8.The homeowner selects a camera icon from the floor plan.

9.The homeowner selects the ÒviewÓ button.
10.The system displays a viewing window that is identified by the camera ID.

11.The system displays video output within the viewing window at one frame per
second.It is important to note that this sequential presentation does not consider any alterna-tive interactions (the narrative is more free-flowing and did represent a few alterna-
tives). Use cases of this type are sometimes referred to as primary scenarios[Sch98a].CHAPTER 6REQUIREMENTS MODELING: SCENARIOS, INFORMATION, AND ANALYSIS CLASSES157uote:ÒUse cases can beused in many
[software]
processes. Our
favorite is a
process that is
iterative and risk
driven.ÓGeriSchneider
andJason

Winterspre75977_ch06.qxd  11/27/08  3:34 PM  Page 157
158PART TWOMODELING6.2.2Refining a Preliminary Use Case
A description of alternative interactions is essential for a complete understanding ofthe function that is being described by a use case. Therefore, each step in the primary

scenario is evaluated by asking the following questions [Sch98a]:¥Can the actor take some other action at this point?
¥Is it possible that the actor will encounter some error condition at this point?Ifso, what might it be?¥Is it possible that the actor will encounter some other behavior at this point (e.g.,
behavior that is invoked by some event outside the actorÕs control)?
If so, whatmight it be?Answers to these questions result in the creation of a set of secondary scenariosthatare part of the original use case but represent alternative behavior. For example, con-

sider steps 6 and 7 in the primary scenario presented earlier:6.The homeowner selects Òpick a camera.Ó
7.The system displays the floor plan of the house.
Can the actor take some other action at this point?
The answer is Òyes.Ó Referring tothe free-flowing narrative, the actor may choose to view thumbnail snapshots of all
cameras simultaneously. Hence, one secondary scenario might be  ÒView thumbnail

snapshots for all cameras.ÓIs it possible that the actor will encounter some error condition at this point?Anynumber of error conditions can occur as a computer-based system operates. In this
context, we consider only error conditions that are likely as a direct result of the ac-
tion described in step 6 or step 7. Again the answer to the question is Òyes.Ó A floor
plan with camera icons may have never been configured. Hence, selecting Òpick a

cameraÓ results in an error condition: ÒNo floor plan configured for this house.Ó9Thiserror condition becomes a secondary scenario.Is it possible that the actor will encounter some other behavior at this point?Againthe answer to the question is Òyes.Ó As steps 6 and 7 occur, the system may encounter

an alarm condition. This would result in the system displaying a special alarm noti-
fication (type, location, system action) and providing the actor with a number of op-

tions relevant to the nature of the alarm. Because this secondary scenario can occur
at any time for virtually all interactions, it will not become part of the ACS-DCV
usecase. Rather, a separate use caseÑ
Alarm condition encountered
Ñwould be de-veloped and referenced from other use cases as required.How do Iexaminealternative
courses of action
when I develop a
use case??9In this case, another actor, the 
system administrator,would have to configure the floor plan,install and initialize (e.g., assign an equipment ID) all cameras, and test each camera to be certainthat it is accessible via the system and through the floor plan.pre75977_ch06.qxd  11/27/08  3:34 PM  Page 158
CHAPTER 6REQUIREMENTS MODELING: SCENARIOS, INFORMATION, AND ANALYSIS CLASSES159Each of the situations described in the preceding paragraphs is characterized asa use-case exception. An exceptiondescribes a situation (either a failure condition oran alternative chosen by the actor) that causes the system to exhibit somewhatdifferent behavior.
Cockburn [Coc01b] recommends using a ÒbrainstormingÓ session to derive areasonably complete set of exceptions for each use case. In addition to the three
generic questions suggested earlier in this section, the following issues should also
be explored:¥Are there cases in which some Òvalidation functionÓ occurs during this use case?

This implies that validation function is invoked and a potential error condition

might occur.
¥Are there cases in which a supporting function (or actor) will fail to respond

appropriately?For example, a user action awaits a response but the function
that is to respond times out.¥Can poor system performance result in unexpected or improper user actions?Forexample, a Web-based interface responds too slowly, resulting in a user

making multiple selects on a processing button. These selects queue inap-
propriately and ultimately generate an error condition.The list of extensions developed as a consequence of asking and answering these
questions should be ÒrationalizedÓ [Co01b] using the following criteria: an exception
should be noted within the use case if the software can detect the condition
described and then handle the condition once it has been detected. In some cases,
an exception will precipitate the development of another use case (to handle the
condition noted).6.2.3Writing a Formal Use Case
The informal use cases presented in Section 6.2.1 are sometimes sufficient for
requirements modeling. However, when a use case involves a critical activity or

describes a complex set of steps with a significant number of exceptions, a more for-
mal approach may be desirable.The ACS-DCV
use case shown in the sidebar follows a typical outline for formaluse cases. The goal in contextidentifies the overall scope of the use case. The
preconditiondescribes what is known to be true before the use case is initiated.Thetriggeridentifies the event or condition that Ògets the use case startedÓ [Coc01b].The scenariolists the specific actions that are required by the actor and the appro-priate system responses. Exceptionsidentify the situations uncovered as the prelim-
inary use case is refined (Section 6.2.2). Additional headings may or may not be
included and are reasonably self-explanatory.
pre75977_ch06.qxd  11/27/08  3:34 PM  Page 159
160PART TWOMODELINGWebRef
When are you finishedwriting use cases? For
a worthwhile discussion

of this topic, see
ootips.org/use-
cases-done.html.In many cases, there is no need to create a graphical representation of a usagescenario. However, diagrammatic representation can facilitate understanding, par-
ticularly when the scenario is complex. As we noted earlier in this book, UML does
provide use-case diagramming capability. Figure 6.4depicts a preliminary use-case

diagram for the SafeHomeproduct. Each use case is represented by an oval. Only the
ACS-DCV
use case  has been discussed in this section.Use case: Access camera surveillance
via the InternetÑdisplay camera
views (ACS-DCV)Iteration:2, last modification: January 14 by

V. Raman.
Primary actor:
Homeowner.
Goal in context:To view output of camera placed

throughout the house from any
remote location via the Internet.
Preconditions:System must be fully configured;
appropriate user ID and passwords
must be obtained.Trigger:
The homeowner decides to take 
a look inside the house while 
away.
Scenario:1.The homeowner logs onto the 
SafeHome Productswebsite.2.The homeowner enters his or her user ID.

3.The homeowner enters two passwords (each at least
eight characters in length).4.The system displays all major function buttons.

5.The homeowner selects the ÒsurveillanceÓ from the
major function buttons.6.The homeowner selects Òpick a camera.Ó

7.The system displays the floor plan of the house.

8.The homeowner selects a camera icon from the floor
plan.9.The homeowner selects the ÒviewÓ button.
10.The system displays a viewing window that is
identified by the camera ID.11.The system displays video output within the viewing
window at one frame per second.Exceptions:1.ID or passwords are incorrect or not recognizedÑ
see use case Validate ID and passwords.
2.Surveillance function not configured for this
systemÑsystem displays appropriate error message;
see use case Configure surveillance function.
3.Homeowner selects ÒView thumbnail snapshots for
all cameraÓÑsee use case View thumbnail

snapshots for all cameras.4.A floor plan is not available or has not been
configuredÑdisplay appropriate error message and
see use case Configure floor plan.5.An alarm condition is encounteredÑsee use case
Alarm condition encountered.Priority:Moderate priority, to be

implemented after basic functions.When available:Third increment.Frequency of use:Moderate frequency.
Channel to actor:Via PC-based browser and

Internet connection.
Secondary actors:
System administrator, cameras.
Channels to secondary actors:
1.System administrator: PC-based system.

2.Cameras: wireless connectivity.
Open issues:1.What mechanisms protect unauthorized use of this
capability by employees of SafeHome Products?2.Is security sufficient? Hacking into this feature would
represent a major invasion of privacy.
3.Will system response via the Internet be acceptable
given the bandwidth required for camera views?4.Will we develop a capability to provide video at a
higher frames-per-second rate when high-
bandwidth connections are available?SAFEHOMEUse Case Template for Surveillance
pre75977_ch06.qxd  11/27/08  3:34 PM  Page 160
Every modeling notation has limitations, and the use case is no exception. Likeany other form of written description, a use case is only as good as its author(s). Ifthe description is unclear, the use case can be misleading or ambiguous. A use case

focuses on functional and behavioral requirements and is generally inappropriate for
nonfunctional requirements. For situations in which the requirements model must
have significant detail and precision (e.g., safety critical systems), a use case may not
be sufficient.However, scenario-based modeling is appropriate for a significant majority of all
situations that you will encounter as a software engineer. If developed properly, the

use case can provide substantial benefit as a modeling tool.
6.3UML M
ODELSTHAT
SUPPLEMENTTHE
USECASEThere are many requirements modeling situations in which a text-based modelÑ
even one as simple as a use caseÑmay not impart information in a clear and con-
cise manner. In such cases, you can choose from a broad array of UML graphical

models.6.3.1Developing an Activity Diagram
The UML activity diagram supplements the use case by providing a graphical repre-

sentation of the flow of interaction within a specific scenario. Similar to the flowchart,
an activity diagram uses rounded rectangles to imply a specific system function,
arrows to represent flow through the system, decision diamonds to depict a branch-
ing decision (each arrow emanating from the diamond is labeled), and solid horizon-
tal lines to indicate that parallel activities are occurring. An activity diagram for the
ACS-DCV
use case is shown in Figure 6.5. It should be noted that the activity dia-gramadds additional detail not directly mentioned (but implied) by the use case.
CHAPTER 6REQUIREMENTS MODELING: SCENARIOS, INFORMATION, AND ANALYSIS CLASSES161A UML activity diagramrepresents the actions
and decisions that
occur as some function
is performed.
Home-ownerAccess camera surveillance via the 
Internet
Configure SafeHome system parametersSet alarm
CamerasSafeHomeFIGURE6.4Preliminary
use-case
diagram for
the SafeHome
systempre75977_ch06.qxd  11/27/08  3:34 PM  Page 161
162PART TWOMODELINGForexample, a user may only attempt to enter 
userIDand password
a limited num-ber of times. This is represented by a decision diamond below ÒPrompt for reentry.Ó
6.3.2Swimlane Diagrams
The UML swimlane diagram
is a useful variation of the activity diagram and allowsyou to represent the flow of activities described by the use case and at the same timeindicate which actor (if there are multiple actors involved in a specific use case) or

analysis class (discussed later in this chapter) has responsibility for the action de-
scribed by an activity rectangle. Responsibilities are represented as parallel seg-
ments that divide the diagram vertically, like the lanes in a swimming pool.
Three analysis classesÑHomeowner, Camera,
and Interface
Ñhave direct orindirect responsibilities in the context of the activity diagram represented in Figure 6.5.Enter password and user IDSelect majorfunctionValid passwords/ID
Prompt for reentry
Invalid passwords/IDInput tries remainNo input tries remainSelect surveillance
Other functionsmay also be selected Thumbnail viewsSelect a specific cameraSelect camera iconPrompt for another viewSelect specific camera - thumbnailsExit this functionSee another cameraView camera output 
in labeled windowFIGURE6.5Activitydiagram for
Access
camera
surveillance
via the
InternetÑ

display
camera views
function.A UML swimlanediagram represents the
flow of actions and
decisions and indicates
which actors perform

each.pre75977_ch06.qxd  11/27/08  3:34 PM  Page 162
CHAPTER 6REQUIREMENTS MODELING: SCENARIOS, INFORMATION, AND ANALYSIS CLASSES163Enter password and user IDSelect major functionValid passwords/ID
Prompt for reentry
Invalid passwords/IDInput tries remainNo inputtries remainSelect surveillance
Other functionsmay also beselected Thumbnail viewsSelect a specific cameraSelect camera iconGenerate videooutputSelect specificcamera - thumbnailsExit thisfunctionSeeanothercameraHomeownerCameraInterface
Prompt foranother viewView camera output
in labelled window FIGURE6.6Swimlane diagram for Access camera surveillance via the InternetÑdisplay camera
views functionReferring to Figure 6.6, the activity diagram is rearranged so that activities associatedwith a particular analysis class fall inside the swimlane for that class. For example, the

Interface
class represents the user interface as seen by the homeowner. The activity
diagram notes two prompts that are the responsibility of the interfaceÑÒprompt for
reentryÓ and Òprompt for another view.Ó These prompts and the decisions associated

with them fall within the Interface
swimlane. However, arrows lead from that swim-
lane back to the Homeowner
swimlane, where homeowner actions occur.
Use cases, along with the activity and swimlane diagrams, are procedurally ori-ented. They represent the manner in which various actors invoke specific functions
uote:ÒA good modelguides your
thinking, a bad one
warps it.ÓBrianMarick
pre75977_ch06.qxd  11/27/08  3:34 PM  Page 163
164PART TWOMODELING(or other procedural steps) to meet the requirements of the system. But a proceduralview of requirements represents only a single dimension of a system. In Section 6.4,
I examine the information space and how data requirements can be represented.6.4D
ATA
MODELINGCONCEPTSIf software requirements include the need to create, extend, or interface with a data-

base or if complex data structures must be constructed and manipulated, the soft-
ware team may choose to create a data modelas part of overall requirements
modeling. A software engineer or analyst defines all data objects that are processed
within the system, the relationships between the data objects, and other information
that is pertinent to the relationships. The entity-relationship diagram
(ERD) addressesthese issues and represents all data objects that are entered, stored, transformed,
and produced within an application.6.4.1Data Objects
A data objectis a representation of composite information that must be understoodby software. By composite information,I mean something that has a number of dif-ferent properties or attributes. Therefore, width (a single value) would not be a valid

data object, but dimensions(incorporating height, width, and depth) could bedefined as an object.A data object can be an external entity (e.g., anything that produces or consumesinformation), a thing (e.g., a report or a display), an occurrence (e.g., a telephone
call) or event (e.g., an alarm), a role (e.g., salesperson), an organizational unit (e.g.,
accounting department), a place (e.g., a warehouse), or a structure (e.g., a file). For
example, a 
personor a carcan be viewed as a data object in the sense that eithercan be defined in terms of a set of attributes. The description of the data object
incorporates the data object and all of its attributes.A data object encapsulates data onlyÑthere is no reference within a data objectto operations that act on the data.10Therefore, the data object can be represented as
a table as shown in Figure 6.7. The headings in the table reflect attributes of the ob-
ject. In this case, a car is defined in terms of 
make, model, ID number, body type, color,

and owner. The body of the table represents specific instances of the data object. Forexample, a Chevy Corvette is an instance of the data object 
car.
6.4.2Data Attributes
Data attributesdefine the properties of a data object and take on one of three differentcharacteristics. They can be used to (1) name an instance of the data object, (2) describe
the instance, or (3) make reference to another instance in another table. In addition,

one or more of the attributes must be defined as an identifierÑthat is, the identifierWebRef
Useful information on
data modeling can be
found at www
.datamodel.org.How does adata objectmanifest itself
within the context
of an application??A data object is arepresentation of any
composite information

that is processed by
software.Attributes name a dataobject, describe its
characteristics, and in
some cases, make
reference to another
object.10This distinction separates the data object from the class or object defined as part of the object-
oriented approach (Appendix 2).pre75977_ch06.qxd  11/27/08  3:34 PM  Page 164
CHAPTER 6REQUIREMENTS MODELING: SCENARIOS, INFORMATION, AND ANALYSIS CLASSES16511Readers who are unfamiliar with object-oriented concepts and terminology should refer to the brief
tutorial presented in Appendix 2.MakeModelID#Body type ColorOwner
IdentifierInstanceLexusChevy
BMW
FordLS400
Corvette

750iL
Taurus
AB123. . .
X456. . .
XZ765. . .
Q12A45. . .Sedan
Sports

Coupe
SedanWhite
Red
White
BlueRSP
CCD
LJL
BLFTies one data object to another,

in this case, ownerNamingattributesDescriptiveattributesReferentialattributesFIGURE6.7Tabular

representation

of data objectsattribute becomes a ÒkeyÓ when we want to find an instance of the data object. In somecases, values for the identifier(s) are unique, although this is not a requirement. Refer-

ring to the data object car,
a reasonable identifier might be the ID number.The set of attributes that is appropriate for a given data object is determinedthrough an understanding of the problem context. The attributes for carmight servewell for an application that would be used by a department of motor vehicles, but
these attributes would be useless for an automobile company that needs manufac-
turing control software. In the latter case, the attributes for 
carmight also include IDnumber, body type,
and color,but many additional attributes (e.g., interior code, drive traintype, trim package designator, transmission type
) would have to be added to make carameaningful object in the manufacturing control context.A common question occurs when data objectsare discussed: Is a data object the same thingas an object-oriented11class? The answer is Òno.ÓA data object defines a composite data item; that is,itincorporates a collection of individual data items
(attributes) and gives the collection of items a name (the
name of the data object).An object-oriented class encapsulates data attributesbut also incorporates the operations (methods) thatmanipulate the data implied by those attributes.
Inaddition, the definition of classes implies a

comprehensive infrastructure that is part of the object-

oriented software engineering approach. Classes
communicate with one another via messages, they can
be organized into hierarchies, and they provide
inheritance characteristics for objects that are an
instance of a class.INFO6.4.3Relationships
Data objects are connected to one another in different ways. Consider the two dataobjects, personand car.
These objects can be represented using the simple notationWebRef
A concept called
ÒnormalizationÓ is

important to those who

intend to do thorough
data modeling. A
useful introduction
canbe found at

www
.datamodel.org.Data Objects and Object-Oriented ClassesÑAre They the Same Thing?
pre75977_ch06.qxd  11/27/08  3:34 PM  Page 165
166PART TWOMODELINGINFOpersoncar(a)  A basic connection between dataobjectsownsinsured todrive(b)  Relationships between data
objectspersoncarFIGURE6.8Relationshipsbetween data
objectsillustrated in Figure 6.8a. A connection is established between personand carbecause the two objects are related. But what are the relationships? To determine the
answer, you should understand the role of people (owners, in this case) and cars

within the context of the software to be built. You can establish a set of object/

relationship pairs that define the relevant relationships. For example,
¥A person ownsa car.
¥A person is insured to drivea car.
The relationships ownsand insured to drivedefine the relevant connections betweenpersonand car.
Figure 6.8billustrates these object-relationship pairs graphically.
The arrows noted in Figure 6.8bprovide important information about the direction-

ality of the relationship and often reduce ambiguity or misinterpretations.12Although the ERD is still used in some database design applications, UML notation (Appendix 1)
can now be used for data design.13The 
cardinalityof an object-relationship pair specifies Òthe number of occurrences of one [object]that can be related to the number of occurrences of another [object]Ó {Til93]. The modalityof a re-lationship is 0 if there is no explicit need for the relationship to occur or the relationship is optional.The modality is 1 if an occurrence of the relationship is mandatory.Relationships indicatethe manner in which
data objects are
connected to one
another.
Entity-Relationship DiagramsThe object-relationship pair is the cornerstone
of the data model. These pairs can berepresented graphically using the entity-relationship
diagram (ERD).12The ERD was originally proposed byPeter Chen [Che77] for the design of relational database
systems and has been extended by others. A set of
primary components is identified for the ERD: data objects,

attributes, relationships, and various type indicators. The
primary purpose of the ERD is to represent data objects

and their relationships.Rudimentary ERD notation has already been
introduced. Data objects are represented by a labeled
rectangle. Relationships are indicated with a labeled line
connecting objects. In some variations of the ERD, the
connecting line contains a diamond that is labeled with the
relationship. Connections between data objects and
relationships are established using a variety of special
symbols that indicate cardinality and modality.
13If youdesire further information about data modeling and the

entity-relationship diagram, see [Hob06] or [Sim05].pre75977_ch06.qxd  11/27/08  3:34 PM  Page 166
6.5C
LASS-BASEDMODELINGClass-based modeling represents the objects that the system will manipulate, the
operations (also called methods or services) that will be applied to the objects to
effect the manipulation, relationships (some hierarchical) between the objects, and
the collaborations that occur between the classes that are defined. The elements
ofa class-based model include classes and objects, attributes, operations, class-

responsibility-collaborator (CRC) models, collaboration diagrams, and packages.
The sections that follow present a series of informal guidelines that will assist in
their identification and representation.6.5.1Identifying Analysis Classes
If you look around a room, there is a set of physical objects that can be easily iden-
tified, classified, and defined (in terms of attributes and operations). But when you
Òlook aroundÓ the problem space of a software application, the classes (and objects)
may be more difficult to comprehend.We can begin to identify classes by examining the usage scenarios developed as
part of the requirements model and performing a Ògrammatical parseÓ [Abb83] on
the use cases developed for the system to be built. Classes are determined by un-
derlining each noun or noun phrase and entering it into a simple table. Synonyms
should be noted. If the class (noun) is required to implement a solution, then it is part
of the solution space; otherwise, if a class is necessary only to describe a solution, it

is part of the problem space.CHAPTER 6REQUIREMENTS MODELING: SCENARIOS, INFORMATION, AND ANALYSIS CLASSES167Data ModelingObjective:Data modeling tools provide asoftware engineer with the ability to representdata objects, their characteristics, and their relationships.Used primarily for large database applications and other
information systems projects, data modeling tools provide

an automated means for creating comprehensive entity-
relation diagrams, data object dictionaries, and related
models.Mechanics:Tools in this category enable the user to
describe data objects and their relationships. In some cases,the tools use ERD notation. In others, the tools model relations
using some other mechanism. Tools in this category are often

used as part of database design and enable the creation of

adatabase model by generating a database schema for

common database management systems (DBMS).Representative Tools:
14AllFusion ERWin,developed by Computer Associates(www3.ca.com), assists in the design of data objects,proper structure, and key elements for databases.ER/Studio,developed by Embarcadero Software(www.embarcadero.com
), supports entity-
relationship modeling.Oracle Designer,
developed by Oracle Systems(www.oracle.com
), Òmodels business processes,
data entities and relationships [that] are transformed

into designs from which complete applications and
databases are generated.ÓVisible Analyst,
developed by Visible Systems
(www.visible.com
), supports a variety of analysis

modeling functions including data modeling.SOFTWARE
TOOLS14Tools noted here do not represent an endorsement, but rather a sampling of tools in this category.
In most cases, tool names are trademarked by their respective developers.uote:ÒThe really hardproblem is
discovering what
are the right
objects [classes] in
the first place.ÓCarlArgila
pre75977_ch06.qxd  11/27/08  3:34 PM  Page 167
168PART TWOMODELINGBut what should we look for once all of the nouns have been isolated? Analysisclassesmanifest themselves in one of the following ways:¥External entities(e.g., other systems, devices, people) that produce orconsume information to be used by a computer-based system.¥Things(e.g., reports, displays, letters, signals) that are part of the informationdomain for the problem.¥Occurrences or events(e.g., a property transfer or the completion of a seriesof robot movements) that occur within the context of system operation.
¥Roles(e.g., manager, engineer, salesperson) played by people who interact
with the system.¥Organizational units(e.g., division, group, team) that are relevant to an appli-cation.¥Places(e.g., manufacturing floor or loading dock) that establish the context ofthe problem and the overall function of the system.
¥Structures(e.g., sensors, four-wheeled vehicles, or computers) that define aclass of objects or related classes of objects.This categorization is but one of many that have been proposed in the literature.15For example, Budd [Bud96] suggests a taxonomy of classes that includes 
producers(sources) and consumers(sinks) of data, data managers, viewor observer classes, andhelper classes.It is also important to note what classes or objects are not. In general, a classshould never have an Òimperative procedural nameÓ [Cas89]. For example, if the de-
velopers of software for a medical imaging system defined an object with the name
InvertImage
or even ImageInversion,
they would be making a subtle mistake. TheImageobtained from the software could, of course, be a class (it is a thing that is
part of the information domain). Inversion of the image is an operation that is ap-

plied to the object. It is likely that inversion would be defined as an operation for the

object Image,but it would not be defined as a separate class to connote Òimageinversion.Ó As Cashman [Cas89] states: Òthe intent of object-orientation is to encap-

sulate, but still keep separate, data and operations on the data.Ó
To illustrate how analysis classes might be defined during the early stages of mod-
eling, consider a grammatical parse (nouns are underlined, verbs italicized) for a
processing narrative16for the SafeHomesecurity function.How doanalysisclasses manifest
themselves as
elements of the
solution space??15Another important categorization, defining entity, boundary, and controller classes, is discussed in
Section 6.5.4.16A processing narrative is similar to the use case in style but somewhat different in purpose. The
processing narrative provides an overall description of the function to be developed. It is not a sce-nario written from one actorÕs point of view. It is important to note, however, that a grammatical
parse can also be used for every use case developed as part of requirements gathering (elicitation).pre75977_ch06.qxd  11/27/08  3:34 PM  Page 168
The SafeHome security functionenablesthe homeownerto configurethe security systemwhen it is installed, monitorsall sensorsconnectedto the security system, and interacts
with the homeowner through the Internet, a PC, or a control panel.During installation, the SafeHome PC is used to program
and configurethe system.Each sensor is assigned a numberand type, a master passwordis programmed for armingand disarmingthe system, and telephone number(s)are inputfor dialingwhen a sensoreventoccurs.When a sensor event is recognized, the software invokes
an audible alarmattached tothe system. After a delay timethat is specifiedby the homeowner during system configu-ration activities, the software dials a telephone number of a monitoring service, provides
informationabout the location, reportingthe nature of the event that has been detected.The telephone number will be redialedevery 20 seconds until telephone connectionisobtained.The homeowner receivessecurity informationvia a control panel, the PC, or a browser,
collectively called an interface. The interface displaysprompting messagesand systemstatus informationon the control panel, the PC ,or the browser window. Homeowner in-
teraction takes the following form . . . Extracting the nouns, we can propose a number of potential classes:Potential ClassGeneral Classificationhomeownerrole or external entity
sensorexternal entity
control panelexternal entity
installationoccurrencesystem (alias security system)thing
number, type
not objects, attributes of sensormaster passwordthingtelephone numberthingsensor eventoccurrenceaudible alarm
external entity
monitoring service
organizational unit or external entity
The list would be continued until all nouns in the processing narrative have beenconsidered. Note that I call each entry in the list a potential object. You must consider

each further before a final decision is made.Coad and Yourdon [Coa91] suggest six selection characteristics that should be
used as you consider each potential class for inclusion in the analysis model:1.Retained information.The potential class will be useful during analysis only ifinformation about it must be remembered so that the system can function.2.Needed services.The potential class must have a set of identifiable operationsthat can change the value of its attributes in some way.
CHAPTER 6REQUIREMENTS MODELING: SCENARIOS, INFORMATION, AND ANALYSIS CLASSES169The grammatical parseis not foolproof, but it
can provide you with
an excellent jump
start, if youÕre strug-

gling to define data
objects and the trans-
forms that operate on

them.How do Ideterminewhether a
potential class
should, in fact,
become an
analysis class??pre75977_ch06.qxd  11/27/08  3:34 PM  Page 169
170PART TWOMODELING3.Multiple attributes.During requirement analysis, the focus should be onÒmajorÓ information; a class with a single attribute may, in fact, be useful
during design, but is probably better represented as an attribute of another
class during the analysis activity.
4.Common attributes.A set of attributes can be defined for the potential classand these attributes apply to all instances of the class.5.Common operations.
A set of operations can be defined for the potential classand these operations apply to all instances of the class.6.Essential requirements.External entities that appear in the problem space andproduce or consume information essential to the operation of any solution for
the system will almost always be defined as classes in the requirements model.To be considered a legitimate class for inclusion in the requirements model, a po-
tential object should satisfy all (or almost all) of these characteristics. The decision
for inclusion of potential classes in the analysis model is somewhat subjective, and

later evaluation may cause an object to be discarded or reinstated. However, the first

step of class-based modeling is the definition of classes, and decisions (even sub-
jective ones) must be made. With this in mind, you should apply the selection char-

acteristics to the list of potential SafeHomeclasses:Potential ClassCharacteristic Number That Applieshomeownerrejected: 1, 2 fail even though 6 appliessensoraccepted: all applycontrol panelaccepted: all applyinstallationrejectedsystem (alias security function)accepted: all apply
number, type
rejected: 3 fails, attributes of sensormaster passwordrejected: 3 failstelephone numberrejected: 3 failssensor eventaccepted: all applyaudible alarm
accepted: 2, 3, 4, 5, 6 applymonitoring service
rejected: 1, 2 fail even though 6 appliesIt should be noted that (1) the preceding list is not all-inclusive, additional classes
would have to be added to complete the model; (2) some of the rejected potential
classes will become attributes for those classes that were accepted (e.g., numberandtypeare attributes of Sensor,
and master passwordand telephone numbermay becomeattributes of System); (3) different statements of the problem might cause different
Òaccept or rejectÓ decisions to be made (e.g., if each homeowner had an individual
password or was identified by voice print, the Homeowner
class would satisfy char-acteristics 1 and 2 and would have been accepted).uote:ÒClasses struggle,some classes
triumph, others are
eliminated.ÓMaoZedong
pre75977_ch06.qxd  11/27/08  3:34 PM  Page 170
6.5.2Specifying Attributes
Attributesdescribe a class that has been selected for inclusion in the requirementsmodel. In essence, it is the attributes that define the classÑthat clarify what is
meant by the class in the context of the problem space. For example, if we were to

build a system that tracks baseball statistics for professional baseball players, the
attributes of the class Player
would be quite different than the attributes of thesame class when it is used in the context of the professional baseball pension sys-
tem. In the former, attributes such as 
name, position, batting average, fielding percentage,years played,and games playedmight be relevant. For the latter, some of these attrib-
utes would be meaningful, but others would be replaced (or augmented) by attrib-
utes like average salary, credit toward full vesting, pension plan options chosen, mailing

address,and the like.To develop a meaningful set of attributes for an analysis class, you should study
each use case and select those ÒthingsÓ that reasonably ÒbelongÓ to the class. In ad-
dition, the following question should be answered for each class: ÒWhat data items
(composite and/or elementary) fully define this class in the context of the problem
at hand?ÓTo illustrate, we consider the 
Systemclass defined for SafeHome.A homeownercan configure the security function to reflect sensor information, alarm response
information, activation/deactivation information, identification information, and so
forth. We can represent these composite data items in the following manner:
identification information system ID verification phone number system statusalarm response information delay time telephone numberactivation/deactivation information master password number of allowable tries temporary password
Each of the data items to the right of the equal sign could be further defined to an
elementary level, but for our purposes, they constitute a reasonable list of attributes
for the Systemclass (shaded portion of Figure 6.9).Sensors are part of the overall 
SafeHomesystem, and yet they are not listed asdata items or as attributes in Figure 6.9. Sensorhas already been defined as a class,and multiple Sensorobjects will be associated with the Systemclass. In general,we avoid defining an item as an attribute if more than one of the items is to be as-
sociated with the class.6.5.3Defining Operations
Operations
define the behavior of an object. Although many different types of oper-ations exist, they can generally be divided into four broad categories: (1) operations
that manipulate data in some way (e.g., adding, deleting, reformatting, selecting), 
(2) operations that perform a computation, (3) operations that inquire about the stateCHAPTER 6REQUIREMENTS MODELING: SCENARIOS, INFORMATION, AND ANALYSIS CLASSES171Attributes are the setof data objects that
fully define the class
within the context of
the problem.When you define
operations for an
analysis class, focus on
problem-oriented
behavior rather than
behaviors required for
implementation.pre75977_ch06.qxd  11/27/08  3:34 PM  Page 171
172PART TWOMODELINGof an object, and (4) operations that monitor an object for the occurrence of a con-trolling event. These functions are accomplished by operating on attributes and/or
associations (Section 6.5.5). Therefore, an operation must have ÒknowledgeÓ of the

nature of the classÕ attributes and associations.As a first iteration at deriving a set of operations for an analysis class, you canagain study a processing narrative (or use case) and select those operations that rea-
sonably belong to the class. To accomplish this, the grammatical parse is again stud-

ied and verbs are isolated. Some of these verbs will be legitimate operations and can
be easily connected to a specific class. For example, from the 
SafeHomeprocessingnarrative presented earlier in this chapter, we see that Òsensor is 
assigneda numberand typeÓ or Òa master password is programmed
for arming and disarmingthesystem.Ó These phrases indicate a number of things:¥That an assign()operation is relevant for the Sensorclass.¥That a program()
operation will be applied to the Systemclass.¥That arm()and disarm()are operations that apply to Systemclass.Upon further investigation, it is likely that the operation 
program()
will be divided intoa number of more specific suboperations required to configure the system. For ex-
ample, 
program()
implies specifying phone numbers, configuring system character-istics (e.g., creating the sensor table, entering alarm characteristics), and entering

password(s). But for now, we specify 
program()
as a single operation.In addition to the grammatical parse, you can gain additional insight into other
operations by considering the communication that occurs between objects. Objects
communicate by passing messages to one another. Before continuing with the spec-

ification of operations, I explore this matter in a bit more detail.Systemprogram( )display( ) 
reset( ) 
query( ) 

arm( ) 

disarm( ) 
systemID
verificationPhoneNumber
systemStatus
delayTime

telephoneNumber
masterPassword
temporaryPassword

numberTries       
FIGURE6.9Class diagramfor the system
classpre75977_ch06.qxd  11/27/08  3:34 PM  Page 172
CHAPTER 6REQUIREMENTS MODELING: SCENARIOS, INFORMATION, AND ANALYSIS CLASSES173Class ModelsThe scene:EdÕs cubicle, as
requirements modeling begins.The players:Jamie, Vinod, and EdÑall members of
the SafeHomesoftware engineering team.The conversation:
[Ed has been working to extract classes from the use casetemplate for ACS-DCV (presented in an earlier sidebar in
this chapter) and is presenting the classes he has
extracted to his colleagues.]Ed:So when the homeowner wants to pick a camera, heor she has to pick it from a floor plan. IÕve defined aFloorPlanclass. HereÕs the diagram.
(They look at Figure 6.10.)Jamie:So FloorPlanis an object that is put togetherwith walls, doors, windows, and cameras. ThatÕs what
those labeled lines mean, right?Ed:Yeah, theyÕre called Òassociations.Ó One class is
associated with another according to the associations IÕveshown. [Associations are discussed in Section 6.5.5.]Vinod:
So the actual floor plan is made up of walls andcontains cameras and sensors that are placed withinthose walls. How does the floor plan know where to put
those objects?Ed:It doesnÕt, but the other classes do. See the attributes
under, say, 
WallSegment,
which is used to build awall. The wall segment has start and stop coordinates and
the draw()operation does the rest.Jamie:And the same goes for windows and doors.Looks like camera has a few extra attributes.Ed:Yeah, I need them to provide pan and zoom 
info.
Vinod:
I have a question. Why does the camera havean ID but the others donÕt? I notice you have an attribute
called nextWall.
How will WallSegment
know what thenext wall will be?Ed:Good question, but as they say, thatÕs a design
decision, so IÕm going to delay that until...

Jamie:Give me a break...IÕll bet youÕve already
figured it out.
Ed (smiling sheepishly):True, IÕm gonna use a list
structure which IÕll model when we get to design. If youget religious about separating analysis and design, the
level of detail I have right here could be suspect.Jamie:Looks pretty good to me, but I have a few morequestions.
(Jamie asks questions which result in minor modifications)
Vinod:
Do you have CRC cards for each of the objects?If so, we ought to role-play through them, just to makesure nothing has been omitted.Ed:IÕm not quite sure how to do them.Vinod:
ItÕs not hard and they really pay off. IÕll show
you.SAFEHOME6.5.4Class-Responsibility-Collaborator (CRC) Modeling
Class-responsibility-collaborator (CRC) modeling
[Wir90] provides a simple means
foridentifying and organizing the classes that are relevant to system or product
requirements. Ambler [Amb95] describes CRC modeling in the following way:A CRC model is really a collection of standard index cards that represent classes. Thecards are divided into three sections. Along the top of the card you write the name of the
class. In the body of the card you list the class responsibilities on the left and the collab-
orators on the right.In reality, the CRC model may make use of actual or virtual index cards. The intent is
to develop an organized representation of classes. Responsibilitiesare the attributesand operations that are relevant for the class. Stated simply, a responsibility is

Òanything the class knows or doesÓ [Amb95]. Collaborators
are those classes that areuote:ÒOne purpose ofCRC cards is to fail
early, to fail often,

and to fail
inexpensively. It is

a lot cheaper to
tear up a bunch of
cards than it would
be to reorganize a
large amount of
source code.ÓC.Horstmann
pre75977_ch06.qxd  11/27/08  3:34 PM  Page 173
174PART TWOMODELINGrequired to provide a class with the information needed to complete a responsibility.
In general, a collaboration
implies either a request for information or a request forsome action.A simple CRC index card for the FloorPlanclass is illustrated in Figure 6.11. Thelist of responsibilities shown on the CRC card is preliminary and subject to additions
or modification. The classes Wall
and Camera
are noted next to the responsibilitythat will require their collaboration.Classes.Basic guidelines for identifying classes and objects were presentedearlierin this chapter. The taxonomy of class types presented in Section 6.5.1 can be
extended by considering the following categories:¥Entity classes, also called modelor businessclasses, are extracted directlyfrom the statement of the problem (e.g., FloorPlanand Sensor). TheseFloorPlandetermineType( ) 
positionFloorplan( ) 
scale( ) 
change color( ) type 
name 
outsideDimensions CameradetermineType( )  
translateLocation( ) displayID( ) displayView( ) 
displayZoom( )  type ID location fieldView 
panAngle ZoomSetting WallSegment
type startCoordinates 

stopCoordinates nextWallSement 
determineType( ) 
draw( )  Windowtype startCoordinates 

stopCoordinates nextWindow 
determineType( ) 
draw( )  Is placed withinWall
type wallDimensions  determineType( ) 
computeDimensions ( )Doortype startCoordinates 

stopCoordinates nextDoordetermineType( ) 
draw( )  Is part of
Is used to buildIs used to buildIs used to buildFIGURE6.10Class diagramfor FloorPlan
(see sidebar
discussion)WebRef
An excellent discussionof these class types
can be found at
www.theumlcafe

.com/a0079.htm.pre75977_ch06.qxd  11/27/08  3:34 PM  Page 174
classes typically represent things that are to be stored in a database andpersist throughout the duration of the application (unless they are specifically
deleted).¥Boundary classesare used to create the interface (e.g., interactive screen orprinted reports) that the user sees and interacts with as the software is used.
Entity objects contain information that is important to users, but they do not
display themselves. Boundary classes are designed with the responsibility of
managing the way entity objects are represented to users. For example, a

boundary class called CameraWindow
would have the responsibility ofdisplaying surveillance camera output for the SafeHomesystem.¥Controller classesmanage a Òunit of workÓ [UML03] from start to finish. Thatis, controller classes can be designed to manage (1) the creation or update of
entity objects, (2) the instantiation of boundary objects as they obtain infor-
mation from entity objects, (3) complex communication between sets of
objects, (4) validation of data communicated between objects or between the
user and the application. In general, controller classes are not considered
until the design activity has begun.Responsibilities.Basic guidelines for identifying responsibilities (attributes andoperations) have been presented in Sections 6.5.2 and 6.5.3. Wirfs-Brock and her

colleagues [Wir90] suggest five guidelines for allocating responsibilities to classes:
1.System intelligence should be distributed across classes to best

address the needs of the problem.
Every application encompasses acertain degree of intelligence; that is, what the system knows and what it
cando. This intelligence can be distributed across classes in a number of
CHAPTER 6REQUIREMENTS MODELING: SCENARIOS, INFORMATION, AND ANALYSIS CLASSES175Class:Des
Res
Coll
aaborator:
Class:DeCoollaborator:
Class:DCCollaborator:
Class: FloorPlanDescriptionResponsibility:Collaborator:Incorporates walls, doors, and windowsShows position of video camerasDefines floor plan name/typeManages floor plan positioning
Scales floor plan for displayScales floor plan for displayWall
CameraFIGURE6.11A CRC modelindex card
uote:ÒObjects can beclassified
scientifically into
three major
categories: those
that donÕt work,
those that break
down, and those
that get lost.ÓRussellBaker
Whatguidelinescan be applied
forallocating

responsibilities
toclasses?
?pre75977_ch06.qxd  11/27/08  3:34 PM  Page 175
176PART TWOMODELINGdifferent ways. ÒDumbÓ classes (those that have few responsibilities) canbemodeled to act as servants to a few ÒsmartÓ classes (those having many

responsibilities). Although this approach makes the flow of control in a
system straightforward, it has a few disadvantages: it concentrates all intelli-
gence within a few classes, making changes more difficult, and it tends to
require more classes, hence more development effort.If system intelligence is more evenly distributed across the classes in anapplication, each object knows about and does only a few things (that are
generally well focused), the cohesiveness of the system is improved.
17 Thisenhances the maintainability of the software and reduces the impact of side
effects due to change.To determine whether system intelligence is properly distributed, the re-
sponsibilities noted on each CRC model index card should be evaluated to
determine if any class has an extraordinarily long list of responsibilities. This
indicates a concentration of intelligence.18 In addition, the responsibilities foreach class should exhibit the same level of abstraction. For example, among

the operations listed for an aggregate class called CheckingAccount
a re-viewer notes two responsibilities: balance-the-accountand check-off-cleared-
checks.
The first operation (responsibility) implies a complex mathematicaland logical procedure. The second is a simple clerical activity. Since these

two operations are not at the same level of abstraction, check-off-cleared-

checks
should be placed within the responsibilities of CheckEntry, 
a classthat is encompassed by the aggregate class CheckingAccount.
2.Each responsibility should be stated as generally as possible.
Thisguideline implies that general responsibilities (both attributes and operations)
should reside high in the class hierarchy (because they are generic, they will

apply to all subclasses).3.Information and the behavior related to it should reside within the

same class.This achieves the object-oriented principle called encapsulation.Data and the processes that manipulate the data should be packaged as a
cohesive unit.4.Information about one thing should be localized with a single class,

not distributed across multiple classes.
A single class should take ontheresponsibility for storing and manipulating a specific type of information.

This responsibility should not, in general, be shared across a number of
classes. If information is distributed, software becomes more difficult to
maintain and more challenging to test.17Cohesiveness is a design concept that is discussed in Chapter 8.
18In such cases, it may be necessary to spit the class into multiple classes or complete subsystems in
order to distribute intelligence more effectively.pre75977_ch06.qxd  11/27/08  3:34 PM  Page 176
5.Responsibilities should be shared among related classes, when
appropriate.
There are many cases in which a variety of related objectsmust all exhibit the same behavior at the same time. As an example, consider

a video game that must display the following classes: Player, PlayerBody,

PlayerArms, PlayerLegs, PlayerHead.
Each of these classes has its ownattributes (e.g., position, orientation, color, speed
) and all must be updated anddisplayed as the user manipulates a joystick. The responsibilities update()
anddisplay()must therefore be shared by each of the objects noted. Player
knows when something has changed and update()is required. It collaborateswith the other objects to achieve a new position or orientation, but each
object controls its own display.
Collaborations.
Classes fulfill their responsibilities in one of two ways: (1) A classcan use its own operations to manipulate its own attributes, thereby fulfilling a par-
ticular responsibility, or (2) a class can collaborate with other classes. Wirfs-Brock

and her colleagues [Wir90] define collaborations in the following way:
Collaborations represent requests from a client to a server in fulfillment of a clientresponsibility. A collaboration is the embodiment of the contract between the client and

the server....We 
say that an object collaborates with another object if, to fulfill aresponsibility, it needs to send the other object any messages. A single collaboration

flows in one directionÑrepresenting a request from the client to the server. From the

clientÕs point of view, each of its collaborations is associated with a particular responsi-

bility implemented by the server.
Collaborations are identified by determining whether a class can fulfill each respon-sibility itself. If it cannot, then it needs to interact with another class. Hence, a

collaboration.As an example, consider the 
SafeHomesecurity function. As part of the activa-tion procedure, the 
ControlPanel
object must determine whether any sensorsareopen. A responsibility named 
determine-sensor-status()
is defined. If sensors areopen, ControlPanel
must set a statusattribute to Ònot ready.Ó Sensor information
can be acquired from each Sensorobject. Therefore, the responsibility 
determine-sensor-status()
can be fulfilled only if ControlPanel
works in collaboration withSensor.
To help in the identification of collaborators, you can examine three different
generic relationships between classes [Wir90]: (1) the 
is-part-ofrelationship, (2) thehas-knowledge-ofrelationship, and (3) the depends-uponrelationship. Each of thethree generic relationships is considered briefly in the paragraphs that follow.
All classes that are part of an aggregate class are connected to the aggregate classvia an is-part-ofrelationship. Consider the classes defined for the video game notedearlier, the class 
PlayerBody
is-part-ofPlayer,
as are PlayerArms, PlayerLegs,
and PlayerHead.
In UML, these relationships are represented as the aggregationshown in Figure 6.12.CHAPTER 6REQUIREMENTS MODELING: SCENARIOS, INFORMATION, AND ANALYSIS CLASSES177pre75977_ch06.qxd  11/27/08  3:34 PM  Page 177
178PART TWOMODELINGWhen one class must acquire information from another class, the has-knowledge-ofrelationship is established. The determine-sensor-status()
responsibility noted ear-lier is an example of a has-knowledge-ofrelationship.The depends-uponrelationship implies that two classes have a dependency thatis not achieved by has-knowledge-ofor is-part-of.For example, 
PlayerHead
mustalways be connected to PlayerBody
(unless the video game is particularly violent),yet each object could exist without direct knowledge of the other. An attribute of the
PlayerHead
object called center-positionis determined from the center position ofPlayerBody.
This information is obtained via a third object, Player,
that acquires itfrom PlayerBody.
Hence, 
PlayerHead
depends-uponPlayerBody.
In all cases, the collaborator class name is recorded on the CRC model index cardnext to the responsibility that has spawned the collaboration. Therefore, the index

card contains a list of responsibilities and the corresponding collaborations that
enable the responsibilities to be fulfilled (Figure 6.11).When a complete CRC model has been developed, stakeholders can review themodel using the following approach [Amb95]:1.All participants in the review (of the CRC model) are given a subset of the
CRC model index cards. Cards that collaborate should be separated (i.e., no
reviewer should have two cards that collaborate).2.All use-case scenarios (and corresponding use-case diagrams) should be
organized into categories.3.The review leader reads the use case deliberately. As the review leader

comes to a named object, she passes a token to the person holding the corre-
sponding class index card. For example, a use case for 
SafeHomecontainsthe following narrative:The homeowner observes the SafeHomecontrol panel to determine if the system isready for input. If the system is not ready, the homeowner must physically close 
PlayerPlayerHeadPlayerBodyPlayerArmsPlayerLegs
FIGURE6.12A compositeaggregate

classpre75977_ch06.qxd  11/27/08  3:34 PM  Page 178
windows/doors so that the ready indicator is present. [A not-ready indicator impliesthat a sensor is open, i.e., that a door or window is open.]When the review leader comes to Òcontrol panel,Ó in the use case narrative,
the token is passed to the person holding the ControlPanel
index card. Thephrase Òimplies that a sensor is openÓ requires that the index card contains aresponsibility that will validate this implication (the responsibility determine-sensor-status()
accomplishes this). Next to the responsibility on the index cardis the collaborator Sensor.
The token is then passed to the Sensorobject.4.When the token is passed, the holder of the Sensorcard is asked to describethe responsibilities noted on the card. The group determines whether one (or
more) of the responsibilities satisfies the use-case requirement.5.If the responsibilities and collaborations noted on the index cards cannot
accommodate the use case, modifications are made to the cards. This may

include the definition of new classes (and corresponding CRC index cards) or
the specification of new or revised responsibilities or collaborations on
existing cards.This modus operandi continues until the use case is finished. When all use cases
have been reviewed, requirements modeling continues.CHAPTER 6REQUIREMENTS MODELING: SCENARIOS, INFORMATION, AND ANALYSIS CLASSES179CRC ModelsThe scene:EdÕs cubicle, as
requirements modeling begins.The players:Vinod and EdÑmembers of the
SafeHomesoftware engineering team.The conversation:[Vinod has decided to show Ed how to develop CRC cards
by showing him an example.]Vinod:
While youÕve been working on surveillance and
Jamie has been tied up with security, IÕve been working
on the home management function.Ed:WhatÕs the status of that? Marketing kept changing
its mind.Vinod:
HereÕs the first-cut use case for the whole
function . . .  weÕve refined it a bit, but it should give youan overall view...
Use case:SafeHomehome management function.Narrative:We want to use the home management
interface on a PC or an Internet connection to control
electronic devices that have wireless interface controllers. 
The system should allow me to turn specific lights on and

off, to control appliances that are connected to a wireless

interface, to set my heating and air conditioning system to

temperatures that I define. To do this, I want to select the

devices from a floor plan of the house. Each device must
be identified on the floor plan. As an optional feature, I
want to control all audiovisual devicesÑaudio, television,
DVD, digital recorders, and so forth.
With a single selection, I want to be able to set theentire house for various situations. One is home,anotheris away,
a third is overnight travel,
and a fourth is
extended travel.All of these situations will have settingsthat will be applied to all devices. In the overnight travel

and extended travelstates, the system should turn lights
on and off at random intervals (to make it look like

someone is home) and control the heating and air
conditioning system. I should be able to override these
setting via the Internet with appropriate password

protection...
Ed:The hardware guys have got all the wirelessinterfacing figured out?
SAFEHOMEpre75977_ch06.qxd  11/27/08  3:34 PM  Page 179
180PART TWOMODELING6.5.5Associations and Dependencies
In many instances, two analysis classes are related to one another in some fashion,much like two data objects may be related to one another (Section 6.4.3). In UML
these relationships are called associations.Referring back to Figure 6.10, theFloorPlanclass is defined by identifying a set of associations between FloorPlanand two other classes, Camera
and Wall.
The class Wall
is associated withthreeclasses that allow a wall to be constructed, 
WallSegment,Window,

andDoor.
In some cases, an association may be further defined by indicating multiplicity
. Re-ferring to Figure 6.10, a Wall
object is constructed from one or more WallSegment
objects. In addition, the Wall
object may contain 0 or more Window
objects and 0or more Doorobjects. These multiplicity constraints are illustrated in Figure 6.13,where Òone or moreÓ is represented using 1. .*, and Ò0 or moreÓ by 0 . .*. In UML, the
asterisk indicates an unlimited upper bound on the range.19Vinod (smiling):
TheyÕre working on it; say itÕs no
problem. Anyway, I extracted a bunch of classes for
home management and we can use one as an example.
LetÕs use the 
HomeManagementInterface
class.Ed:Okay...so the responsibilities are what
...the
attributes and operations for the class and the
collaborations are the classes that the responsibilities
point to.Vinod:
I thought you didnÕt understand CRC.
Ed:Maybe a little, but go ahead.Vinod:
So hereÕs my class definition for
HomeManagementInterface.

Attributes:
optionsPanelÑcontains info on buttons that enable user toselect functionality.
situationPanelÑcontains info on buttons that enable userto select situation.floorplanÑsame as surveillance object but this one
displays devices.deviceIconsÑinfo on icons representing lights,appliances, HVAC, etc.
devicePanelsÑsimulation of appliance or device controlpanel; allows control.Operations:displayControl(), selectControl(), displaySituation(), selectsituation(), accessFloorplan(), selectDeviceIcon(),
displayDevicePanel(), accessDevicePanel(),...Class:HomeManagementInterface
ResponsibilityCollaborator
displayControl()OptionsPanel(class)selectControl()OptionsPanel(class)displaySituation()SituationPanel(class)selectSituation()SituationPanel(class)accessFloorplan()FloorPlan(class) . . . . . . 
Ed:So when the operation accessFloorplan()is invoked,it collaborates with the FloorPlanobject just like the onewe developed for surveillance. Wait, I have a description
of it here. (They look at Figure 6.10.)Vinod:
Exactly. And if we wanted to review the entire
class model, we could start with this index card, then go
to the collaboratorÕs index card, and from there to one of

the collaboratorÕs collaborators, and so on.
Ed:Good way to find omissions or errors.Vinod:
Yep.
An association definesa relationship between
classes. Multiplicity
defines how many of
one class are related to
how many of another
class.19Other multiplicity relationsÑone to one, one to many, many to many, one to a specified range with
lower and upper limits, and othersÑmay be indicated as part of an association.pre75977_ch06.qxd  11/27/08  3:34 PM  Page 180
In many instances, a client-server relationship exists between two analysisclasses. In such cases, a client class depends on the server class in some way and adependency relationshipis established. Dependencies are defined by a stereotype. Astereotypeis an Òextensibility mechanismÓ [Arl02] within UML that allows you todefine a special modeling element whose semantics are custom defined. In UML
stereotypes are represented in double angle brackets (e.g., <<stereotype>>).
As an illustration of a simple dependency within the SafeHomesurveillance sys-tem, a Camera
object (in this case, the server class) provides a video image to a
DisplayWindow
object (in this case, the client class). The relationship between
these two objects is not a simple association, yet a dependency association does
exist. In a use case written for surveillance (not shown), you learn that a special pass-
word must be provided in order to view specific camera locations. One way to

achieve this is to have Camera
request a password and then grant permission to theDisplayWindow
to produce the video display. This can be represented as shown in
Figure 6.14where <<access>> implies that the use of the camera output is controlled

by a special password.CHAPTER 6REQUIREMENTS MODELING: SCENARIOS, INFORMATION, AND ANALYSIS CLASSES181WallSegment
WindowDoorWall
Is used to buildIs used to buildIs used to build1..*1110..*0..*FIGURE6.13MultiplicityCameraDisplayWindow{password}<<access>>FIGURE6.14DependenciesWhat is astereotype??pre75977_ch06.qxd  11/27/08  3:34 PM  Page 181
182PART TWOMODELING6.5.6Analysis Packages
An important part of analysis modeling is categorization. That is, various elementsof the analysis model (e.g., use cases, analysis classes) are categorized in a manner
that packages them as a groupingÑcalled an analysis package
Ñthat is given a rep-resentative name.To illustrate the use of analysis packages, consider the video game that I intro-
duced earlier. As the analysis model for the video game is developed, a large num-

ber of classes are derived. Some focus on the game environmentÑthe visual scenes

that the user sees as the game is played. Classes such as Tree, Landscape, Road,

Wall, Bridge, Building,
and VisualEffect
might fall within this category. Others
focus on the characters within the game, describing their physical features, actions,

and constraints. Classes such as Player
(described earlier), Protagonist, Antago-
nist,and SupportingRolesmight be defined. Still others describe the rules of thegameÑhow a player navigates through the environment. Classes such as

RulesOfMovement
and ConstraintsOnAction
are candidates here. Many othercategories might exist. These classes can be grouped in analysis packages as shown
in Figure 6.15.The plus sign preceding the analysis class name in each package indicates thatthe classes have public visibility and are therefore accessible from other packages.
Although they are not shown in the figure, other symbols can precede an element

within a package. A minus sign indicates that an element is hidden from all other
packages and a # symbol indicates that an element is accessible only to packages
contained within a given package.Environment
+Tree 
+Landscape 
+Road 
+Wall 

+Bridge 
+Building +VisualEffect 
+Scene Characters+Player +Protagonist 
+Antagonist +SupportingRole
RulesOfTheGame+RulesOfMovement +ConstraintsOnActionPackage nameFIGURE6.15PackagesA package is used toassemble a collection
of related classes.pre75977_ch06.qxd  11/27/08  3:34 PM  Page 182
6.6S
UMMARYTheobjectiveofrequirementsmodelingistocreateavarietyofrepresentationsthat
describewhatthecustomerrequires,establishabasisforthecreationofasoftware

design,anddefineasetofrequirementsthatcanbevalidatedoncethesoftwareis

built.Therequirementsmodelbridgesthegapbetweenasystem-levelrepresentation

thatdescribesoverallsystemandbusinessfunctionalityandasoftwaredesignthat

describesthesoftwareÕsapplicationarchitecture,userinterface,andcomponent-

levelstructure.
Scenario-based models depict software requirements from the userÕs point of
view. The use caseÑa narrative or template-driven description of an interaction

between an actor and the softwareÑis the primary modeling element. Derived
during requirements elicitation, the use case defines the keys steps for a specific
function or interaction. The degree of use-case formality and detail varies, but the
end result provides necessary input to all other analysis modeling activities. Sce-

narios can also be described using an activity diagramÑa flowchart-like graphical
representation that depicts the processing flow within a specific scenario. Swim-
lane diagrams illustrate how the processing flow is allocated to various actors or
classes.Data modeling is used to describe the information space that will be constructedor manipulated by the software. Data modeling begins by representing data
objectsÑcomposite information that must be understood by the software. The
attributes of each data object are identified and relationships between data objects
are described.Class-based modeling uses information derived from scenario-based and datamodeling elements to identify analysis classes. A grammatical parse may be used to
extract candidate classes, attributes, and operations from text-based narratives.
Criteria for the definition of a class are defined. A set of class-responsibility-
collaborator index cards can be used to define relationships between classes. In
addition, a variety of UML modeling notation can be applied to define hierarchies,
relationships, associations, aggregations, and dependencies among classes. Analy-
sis packages are used to categorize and group classes in a manner that makes them
more manageable for large systems.PROBLEMSAND
POINTSTO
PONDER6.1.Is it possible to begin coding immediately after an analysis model has been created?Explain your answer and then argue the counterpoint.6.2.An analysis rule of thumb is that the model Òshould focus on requirements that are visiblewithin the problem or business domain.Ó What types of requirements are notvisible in these do-mains? Provide a few examples.

6.3.What is the purpose of domain analysis? How is it related to the concept of requirementspatterns?CHAPTER 6REQUIREMENTS MODELING: SCENARIOS, INFORMATION, AND ANALYSIS CLASSES183pre75977_ch06.qxd  11/27/08  3:34 PM  Page 183
184PART TWOMODELING6.4.Is it possible to develop an effective analysis model without developing all four elementsshown in Figure 6.3? Explain.6.5.You have been asked to build one of the following systems:
a.a network-based course registration system for your university.
b.a Web-based order-processing system for a computer store.
c.a simple invoicing system for a small business.
d.an Internet-based cookbook that is built into an electric range or microwave.
Select the system that is of interest to you and develop an entity-relationship diagram that de-scribes data objects, relationships, and attributes.6.6.The department of public works for a large city has decided to develop a Web-based pot-
hole tracking and repair system (PHTRS). A description follows:Citizens can log onto a website and report the location and severity of potholes. As pot-holes are reported they are logged within a Òpublic works department repair systemÓ and
are assigned an identifying number, stored by street address, size (on a scale of 1 to 10),

location (middle, curb, etc.), district (determined from street address), and repair prior-

ity (determined from the size of the pothole). Work order data are associated with each

pothole and include pothole location and size, repair crew identifying number, number

of people on crew, equipment assigned, hours applied to repair, hole status (work in

progress, repaired, temporary repair, not repaired), amount of filler material used, and

cost of repair (computed from hours applied, number of people, material and equipment

used). Finally, a damage file is created to hold information about reported damage due

to the pothole and includes citizenÕs name, address, phone number, type of damage, and

dollar amount of damage. PHTRS is an online system; all queries are to be made inter-
actively.
a.Draw a UML use case diagram for the PHTRS system. YouÕll have to make a number of
assumptions about the manner in which a user interacts with this system.b.Develop a class model for the PHTRS system.
6.7.Write a template-based use case for the SafeHomehome management system describedinformally in the sidebar following Section 6.5.4.6.8.Develop a complete set of CRC model index cards on the product or system you chose aspart of Problem 6.5.
6.9.Conduct a review of the CRC index cards with your colleagues. How many additionalclasses, responsibilities, and collaborators were added as a consequence of the review?
6.10.What is an analysis package and how might it be used?FURTHER
READINGSAND
INFORMATION
SOURCESUse cases can serve as the foundation for all requirements modeling approaches. The subject isdiscussed at length by Rosenberg and Stephens (Use Case Driven Object Modeling with UML: The-
ory and Practice,
Apress, 2007), Denny (Succeeding with Use Cases: Working Smart to Deliver Qual-
ity,
Addison-Wesley, 2005), Alexander and Maiden (eds.) (
Scenarios, Stories, Use Cases: Throughthe Systems Development Life-Cycle,Wiley, 2004), Bittner and Spence (
Use Case Modeling,Addi-son-Wesley, 2002), Cockburn [Coc01b], and other references noted in both Chapters 5 and 6.
Data modeling presents a useful method for examining the information space. Books byHoberman [Hob06] and Simsion and Witt [Sim05] provide reasonably comprehensive treat-

ments. In addition, Allen and Terry (
Beginning Relational Data Modeling,2d ed., Apress, 2005),Allen (Data Modeling for Everyone,Wrox Press, 2002), Teorey and his colleagues (
DatabaseModeling and Design: Logical Design,4th ed., Morgan Kaufmann, 2005), and Carlis andMaguire(
Mastering Data Modeling,Addison-Wesley, 2000) present detailed tutorials for creating
pre75977_ch06.qxd  11/27/08  3:34 PM  Page 184
CHAPTER 6REQUIREMENTS MODELING: SCENARIOS, INFORMATION, AND ANALYSIS CLASSES185industry-quality data models. An interesting book by Hay (Data Modeling Patterns,
Dorset House,
1995) presents typical data model patterns that are encountered in many different businesses.UML modeling techniques that can be applied for both analysis and design are discussed byOÕDocherty (Object-Oriented Analysis and Design: Understanding System Development with UML2.0,Wiley, 2005), Arlow and Neustadt (
UML 2 and the Unified Process,2d ed., Addison-Wesley,
2005), Roques (UML in Practice,
Wiley, 2004), Dennis and his colleagues (
Systems Analysis andDesign with UML Version 2.0,
Wiley, 2004), Larman (
Applying UML and Patterns,
2d ed., Prentice-Hall, 2001), and Rosenberg and Scott (Use Case Driven Object Modeling with UML,Addison-Wesley, 1999).
A wide variety of information sources on requirements modeling are available on theInternet. An up-to-date list of World Wide Web references that are relevant to analysis

modeling can be found at the SEPA website: 
www.mhhe.com/engcs/compsci/pressman/
professional/olc/ser.htm
.pre75977_ch06.qxd  11/27/08  3:34 PM  Page 185
After my discussion of use cases, data modeling, and class-based modelsin Chapter 6, itÕs reasonable to ask, ÒArenÕt those requirements modeling

representations enough?ÓThe only reasonable answer is, ÒThat depends.Ó
For some types of software, the use case may be the only requirements mod-
eling representation that is required. For others, an object-oriented approach is
chosen and class-based models may be developed. But in other situations, com-
plex application requirements may demand an examination of how data objects
are transformed as they move through a system; how an application behaves as

a consequence of external events; whether existing domain knowledge can be
adapted to the current problem; or in the case of Web-based systems and appli-

cations, how content and functionality meld to provide an end user with the abil-

ity to successfully navigate a WebApp to achieve usage goals.
7.1R
EQUIREMENTSMODELINGSTRATEGIES
One view of requirements modeling, called structured analysis,considers data andthe processes that transform the data as separate entities. Data objects are mod-eled in a way that defines their attributes and relationships. Processes that
manipulate data objects are modeled in a manner that shows how they transform
data as data objects flow through the system. A second approach to analysis 186CHAPTER7REQUIREMENTSMODELING: FLOW,BEHAVIOR
, PATTERNS
, ANDWEBAPPSKEYCONCEPTSanalysis patterns . . . . . .200
behavioral model . . . . . . .195
configuration model . . . . . . .211
content model . .207

control flow model . . . . . . .191
data flow model . . . . . . .188
functional model . . . . . . .210
interaction model . . . . . . .209
navigation modeling . . . . .212
process specification . . .192
sequence diagrams . . . . .197
WebApps . . . . .205
Whatisit?
Therequirementsmodel
hasmanydifferentdimensions.In
thischapteryouÕlllearnaboutflow-
orientedmodels,behavioralmodels,andthespe-

cialrequirementsanalysisconsiderationsthat

comeintoplaywhenWebAppsaredeveloped.

Eachofthesemodelingrepresentationssupple-

mentstheusecases,datamodels,andclass-

basedmodelsdiscussedinChapter6.
Who does it?A software engineer (sometimescalled an ÒanalystÓ) builds the model using
requirements elicited from various stakeholders.QUICKLOOKWhy is it important?
Your insight into software
requirements grows in direct proportion to the

number of different requirements modeling

dimensions. Although you may not have the
time, the resources, or the inclination to develop
every representation suggested in this chapter

and Chapter 6, recognize that each different

modeling approach provides you with a differ-

ent way of looking at the problem. As a conse-
quence, you (and other stakeholders) will be
better able to assess whether youÕve properly
specified what must be accomplished.pre75977_ch07.qxd  11/27/08  3:36 PM  Page 186
modeled, called object-oriented analysis,focuses on the definition of classes and themanner in which they collaborate with one another to effect customer requirements.Although the analysis model that we propose in this book combines features ofboth approaches, software teams often choose one approach and exclude all repre-sentations from the other. The question is not which is best, but rather, what com-

bination of representations will provide stakeholders with the best model of software

requirements and the most effective bridge to software design.7.2F
LOW-ORIENTEDMODELINGAlthough data flow-oriented modeling is perceived as an outdated technique by
some software engineers, it continues to be one of the most widely used require-
ments analysis notations in use today.
1Although the data flow diagram
(DFD) andrelated diagrams and information are not a formal part of UML, they can be used to
complement UML diagrams and provide additional insight into system requirements

and flow.
The DFD takes an input-process-output view of a system. That is, data objectsflow into the software, are transformed by processing elements, and resultant data

objects flow out of the software. Data objects are represented by labeled arrows, and
transformations are represented by circles (also called bubbles). The DFD is pre-
sented in a hierarchical fashion. That is, the first data flow model (sometimes called
a level 0 DFD or context diagram
) represents the system as a whole. Subsequent data
flow diagrams refine the context diagram, providing increasing detail with each

subsequent level.CHAPTER 7REQUIREMENTS MODELING: FLOW, BEHAVIOR, PATTERNS, AND WEBAPPS187What are the steps?Flow-oriented modelingprovides an indication of how data objects aretransformed by processing functions. Behavioral

modeling depicts the states of the system and its
classes and the impact of events on these states.
Pattern-based modeling makes use of existing

domain knowledge to facilitate requirements
analysis. WebApp requirements models are

especially adapted for the representation of
content, interaction, function, and configuration-
related requirements.What is the work product?
A wide array of text-based and diagrammatic forms may be chosen

for the requirements model. Each of these repre-
sentations provides a view of one or more of the
modelel
ements.How do I ensure that IÕve done it right?Requirements modeling work products must be
reviewed for correctness, completeness, and
consistency. They must reflect the needs of all

stakeholders and establish a foundation from
which design can be conducted.1Data flow modeling is a core modeling activity in 
structured analysis.Some will suggest that
the DFD is old-school
and it has no place in
modern practice. ThatÕs

a view that excludes a
potentially useful mode
of representation at the
analysis level. If it can
help, use the DFD.pre75977_ch07.qxd  11/27/08  3:36 PM  Page 187
188PART TWOMODELING7.2.1Creating a Data Flow Model
The data flow diagram enables you to develop models of the information domain andfunctional domain. As the DFD is refined into greater levels of detail, you perform an
implicit functional decomposition of the system. At the same time, the DFD refine-

ment results in a corresponding refinement of data as it moves through the processes

that embody the application.A few simple guidelines can aid immeasurably during the derivation of a data flowdiagram: (1) the level 0 data flow diagram should depict the software/system as a
single bubble; (2) primary input and output should be carefully noted; (3) refinement
should begin by isolating candidate processes, data objects, and data stores to be
represented at the next level; (4) all arrows and bubbles should be labeled with
meaningful names; (5) information flow continuity
must be maintained from level tolevel,2 and (6) one bubble at a time should be refined. There is a natural tendency toovercomplicate the data flow diagram. This occurs when you attempt to show too

much detail too early or represent procedural aspects of the software in lieu of
information flow.
To illustrate the use of the DFD and related notation, we again consider the
SafeHomesecurity function. A level 0 DFD for the security function is shown inFigure7.1. The primary 
external entities(boxes) produce information for use by thesystem and consume information generated by the system. The labeled arrows rep-
resent data objects or data object hierarchies. For example, 
user commands and
dataencompasses all configuration commands, all activation/deactivation com-mands, all miscellaneous interactions, and all data that are entered to qualify or
expand a command.The level 0 DFD must now be expanded into a level 1 data flow model. But howdo we proceed? Following an approach suggested in Chapter 6, you should apply auote:ÒThe purpose ofdata flow diagrams
is to provide a
semantic bridge
between users
andsystems

developers.ÓKennethKozar
2That is, the data objects that flow into the system or into any transformation at one level must be the
same data objects (or their constituent parts) that flow into the transformation at a more refined level.Information flow
continuity must be
maintained as each
DFD level is refined.
This means that input
and output at one level
must be the same as
input and output at a
refined level.ControlpanelUser commandsand dataSensorsSensorstatusControlpaneldisplayTelephone
lineAlarm
SafeHomesoftwareDisplayinformation
Telephone
number tonesAlarm
typeFIGURE7.1Context-levelDFD for the
SafeHome
security
functionpre75977_ch07.qxd  11/27/08  3:36 PM  Page 188
CHAPTER 7REQUIREMENTS MODELING: FLOW, BEHAVIOR, PATTERNS, AND WEBAPPS189Ògrammatical parseÓ [Abb83] to the use case narrative that describes the context-level
bubble. That is, we isolate all nouns (and noun phrases) and verbs (and verb phrases)
in a SafeHomeprocessing narrative derived during the first requirements gatheringmeeting. Recalling the parsed processing narrative text presented in Section 6.5.1:The SafeHome security functionenablesthe homeownerto configurethe security systemwhen it is installed, monitorsall sensorsconnectedto the security system, and interacts
with the homeowner through the Internet, a PC,or a control panel.During installation, the SafeHomePC is used to program
and configurethe system.Each sensor is assigned a numberand type, a master passwordis programmed for armingand disarmingthe system, and telephone number(s)are inputfor dialingwhen a sensoreventoccurs.Whenasensoreventis
recognized,thesoftware
invokes
anaudible
alarmattachedto
thesystem.Afteradelay
timethatisspecifiedbythehomeownerduringsystemconfigura-
tionactivities,thesoftwaredialsatelephonenumberofamonitoring
service,provides
informationaboutthe
location,reportingthenatureoftheeventthathasbeendetected.The
telephonenumberwillbe
redialedevery20secondsuntiltelephone
connectionisobtained.The homeowner receivessecurity informationvia a control panel, the PC, or a browser,
collectively called an interface. The interface displaysprompting messagesand systemstatus informationon the control panel, the PC, or the browser window. Homeowner in-
teraction takes the following form . . .Referring to the grammatical parse, verbs are 
SafeHomeprocesses and can be rep-resented as bubbles in a subsequent DFD. Nouns are either external entities (boxes),

data or control objects (arrows), or data stores (double lines). From the discussion in
Chapter 6, recall that nouns and verbs can be associated with one another (e.g., each
sensor is assigned a number and type; therefore numberand typeare attributes of thedata object sensor). Therefore, by performing a grammatical parse on the process-

ing narrative for a bubble at any DFD level, you can generate much useful informa-
tion about how to proceed with the refinement to the next level. Using this
information, a level 1 DFD is shown in Figure 7.2. The context level process shown
in Figure 7.1has been expanded into six processes derived from an examination of

the grammatical parse. Similarly, the information flow between processes at level 1

has been derived from the parse. In addition, information flow continuity is main-
tained between levels 0 and 1.The processes represented at DFD level 1 can be further refined into lower levels.For example, the process 
monitor sensorscan be refined into a level 2 DFD as shownin Figure 7.3. Note once again that information flow continuity has been maintained
between levels.The refinement of DFDs continues until each bubble performs a simple function.That is, until the process represented by the bubble performs a function that would
be easily implemented as a program component. In Chapter 8, I discuss a concept,
called cohesion,that can be used to assess the processing focus of a given function.For now, we strive to refine DFDs until each bubble is Òsingle-minded.Ó
The grammatical parseis not foolproof, but it
can provide you with an
excellent jump start, if

youÕre struggling to

define data objects and
the transforms that

operate on them.Be certain that the
processing narrative

you intend to parse is
written at the same
level of abstraction
throughout.pre75977_ch07.qxd  11/27/08  3:36 PM  Page 189
190PART TWOMODELINGConfiguration information
ReadsensorsAssessagainstsetupConfigurationdataSensor ID,typeSensorstatusGeneratealarm
signalAlarm
typeAlarm
dataTelephone
numberDialphoneTelephone
number tonesFormat
fordisplaySensorinformation
Sensor IDtype,locationFIGURE7.3Level 2 DFDthat refines

themonitorsensorsprocess
Configuration information
ControlpanelSensorsControlpaneldisplayTelephone
lineAlarm
InteractwithuserConfiguresystemActivate/deactivatesystemProcesspasswordMonitorsensorsDisplaymessagesand statusUser commandsand dataPasswordStart
stopConfigurerequestConfigurationdataConfigurationdataConfigurationdataValid ID msg.
A/d msg.SensorstatusSensorinformation
Alarm type
Telephone
number tonesDisplayinformation
FIGURE7.2Level 1 DFD forSafeHome
security
functionpre75977_ch07.qxd  11/27/08  3:36 PM  Page 190
7.2.2Creating a Control Flow Model
For some types of applications, the data model and the data flow diagram are all thatis necessary to obtain meaningful insight into software requirements. As I have al-
ready noted, however, a large class of applications are ÒdrivenÓ by events rather than

data, produce control information rather than reports or displays, and process infor-
mation with heavy concern for time and performance. Such applications require the
use of control flow modelingin addition to data flow modeling.IhavealreadynotedthataneventorcontrolitemisimplementedasaBooleanvalue
(e.g.,trueorfalse,onoroff,1or0)oradiscretelistofconditions(e.g.,empty,jammed,

full).Toselectpotentialcandidateevents,thefollowingguidelinesaresuggested:
¥List all sensors that are ÒreadÓ by the software.¥List all interrupt conditions.¥List all ÒswitchesÓ that are actuated by an operator.
¥List all data conditions.¥Recalling the noun/verb parse that was applied to the processing narrative,

review all Òcontrol itemsÓ as possible control specification inputs/outputs.¥Describe the behavior of a system by identifying its states, identify how each
state is reached, and define the transitions between states.¥Focus on possible omissionsÑa very common error in specifying control; for
example, ask: ÒIs there any other way I can get to this state or exit from it?Ó
Among the many events and control items that are part of SafeHomesoftware aresensor event
(i.e., a sensor has been tripped), blink flag(a signal to blink thedisplay), and start/stop switch
(a signal to turn the system on or off).
7.2.3The Control Specification
A control specification(CSPEC) represents the behavior of the system (at the levelfrom which it has been referenced) in two different ways.3The CSPEC contains astate diagram that is a sequential specification of behavior. It can also contain a pro-

gram activation tableÑa combinatorial specification of behavior.
Figure 7.4depicts a preliminary state diagram
4for the level 1 control flow modelfor SafeHome.The diagram indicates how the system responds to events as it trav-erses the four states defined at this level. By reviewing the state diagram, you can
determine the behavior of the system and, more important, ascertain whether there
are ÒholesÓ in the specified behavior.
For example, the state diagram (Figure 7.4) indicates that the transitions from
theIdlestate can occur if the system is reset, activated, or powered off. If the systemis
CHAPTER 7REQUIREMENTS MODELING: FLOW, BEHAVIOR, PATTERNS, AND WEBAPPS191How do Iselectpotential events
for a control flow
diagram, state
diagram, or
CSPEC??3Additional behavioral modeling notation is presented in Section 7.3.
4The state diagram notation used here conforms to UML notation. A Òstate transition diagramÓ isavail-
able in structured analysis, but the UML format is superior in information content and representation.pre75977_ch07.qxd  11/27/08  3:36 PM  Page 191
192PART TWOMODELINGactivated (i.e., alarm system is turned on), a transition to the Monitoring-SystemStatusstate occurs, display messages are changed as shown, and the pro-cessmonitorAndControlSystemis invoked. Two transitions occur out of the
MonitoringSystemStatusstateÑ(1) when the system is deactivated, a transition oc-curs back to the Idlestate; (2) when a sensor is triggered into the ActingOnAlarmstate. All transitions and the content of all states are considered during the review.
A somewhat different mode of behavioral representation is the process activationtable. The PAT represents information contained in the state diagram in the context of
processes, not states. That is, the table indicates which processes (bubbles) in the flow
model will be invoked when an event occurs. The PAT can be used as a guide for a de-

signer who must build an executive that controls the processes represented at this
level. A PAT for the level 1 flow model of 
SafeHomesoftware is shown in Figure 7.5.The CSPEC describes the behavior of the system, but it gives us no informationabout the inner working of the processes that are activated as a result of this behavior.

The modeling notation that provides this information is discussed in Section 7.2.4.
7.2.4The Process Specification
Theprocessspecification
(PSPEC)isusedtodescribeallflowmodelprocessesthat
appearatthefinallevelofrefinement.Thecontentoftheprocessspecificationcan
ResettingEntry/set systemStatus "inactive"
Entry/set displayMsg1 "Starting system"

Entry/set displayMsg2 "Please wait"

Entry/set displayStatus slowBlinking

Do: run diagnosticsStart/stop switch
power "on"systemOKIdleEntry/set systemStatus "inactive"

Entry/set displayMsg1 "Ready"

Entry/set displayMsg2  ""

Entry/set displayStatus steady

KeyHit/handleKey failureDetected/
set displayMsg2 "contact Vendor"
MonitoringSystemStatusEntry/set systemStatus "monitoring"

Entry/set displayMsg1 "Armed"

Entry/set displayMsg2   ""

Entry/set displayStatus steady

Do: monitorAndControlSystem
KeyHit/handleKeyActingOnAlarmEntry/set systemStatus "monitorAndAlarm"

Entry/set displayMsg1 "ALARM"

Entry/set displayMsg2 triggeringSensor

Entry/set displayStatus fastBlinking

Do: monitorAndControlSystem
Do: soundAlarm

Do: notifyAlarmResponders

KeyHit/handleKey     ResetfalseAlarm
timeOutsensorTriggered/
startTimer
sensorTriggered/
restartTimer
ActivatedeactivatePasswordoff/powerOffdeactivatePasswordFIGURE7.4State diagram for SafeHomesecurity functionpre75977_ch07.qxd  11/27/08  3:36 PM  Page 192
CHAPTER 7REQUIREMENTS MODELING: FLOW, BEHAVIOR, PATTERNS, AND WEBAPPS193input eventsprocess activationmonitor and control system         0     1     0     0     1     1
activate/deactivate system         0     1     0     0     0     0

display messages and status       1     0     1     1     1     1

interact with user                       1     0     0     1     0     1
sensor event                             0     0     0     0     1     0

blink flag                                 0     0     1     1     0     0

start stop switch                        0     1     0     0     0     0

display action status complete     0     0     0     1     0     0
in-progress                               0     0     1     0     0     0

time out                                   0     0     0     0     0     1
outputalarm signal                             0     0     0     0     1     0
FIGURE7.5Process activa-
tion table for
SafeHome
security
functionData Flow ModelingThe scene:JamieÕs cubicle, after the
last requirements gathering meeting has concluded.The players:Jamie, Vinod, and EdÑall members of
the SafeHomesoftware engineering team.The conversation:
(Jamie has sketched out the models shown in Figures 7.1through 7.5and is showing them to Ed and Vinod.)
Jamie:I took a software engineering course in college,and they taught us this stuff. The Prof said itÕs a bit old-
fashioned, but you know what, it helps me to clarify
things.Ed:ThatÕs cool. But I donÕt see any classes or objects here.
Jamie:No . . . this is just a flow model with a littlebehavioral stuff thrown in.

Vinod:
So these DFDs represent an I-P-O view of thesoftware, right.
Ed:I-P-O?Vinod:
Input-process-output. The DFDs are actuallypretty intuitive . . . if you look at Ôem for a moment, theyshow how data objects flow through the system and get
transformed as they go.
Ed:Looks like we could convert every bubble into an
executable component . . . at least at the lowest level of
the DFD.Jamie:ThatÕs the cool part, you can. In fact, thereÕs a
way to translate the DFDs into an design architecture.
Ed:Really?Jamie:Yeah, but first weÕve got to develop a complete
requirements model and this isnÕt it.

Vinod:
Well, itÕs a first step, but weÕre going to have to
address class-based elements and also behavioral aspects,although the state diagram and PAT does some of that.
Ed:WeÕve got a lot work to do and not much time to do it.
(DougÑthe software engineering managerÑwalks into thecubical.)Doug:So the next few days will be spent developing therequirements model, huh?
Jamie (looking proud):
WeÕve already begun.
Doug:Good, weÕve got a lot of work to do and notmuch time to do it.
(Thethreesoftwareengineerslookatoneanotherandsmile.)
SAFEHOMEpre75977_ch07.qxd  11/27/08  3:36 PM  Page 193
194PART TWOMODELINGincludenarrativetext,aprogramdesignlanguage(PDL)description
5oftheprocess
algorithm,mathematicalequations,tables,orUMLactivitydiagrams.Byprovidinga
PSPECtoaccompanyeachbubbleintheflowmodel,youcancreateaÒmini-specÓthat

servesasaguidefordesignofthesoftwarecomponentthatwillimplementthebubble.
To illustrate the use of the PSPEC, consider the 
process password
transform repre-sented in the flow model for SafeHome(Figure 7.2). The PSPEC for this function mighttake the form:PSPEC:processpassword(atcontrolpanel).
Theprocesspassword
transformper-
formspasswordvalidationatthecontrolpanelforthe
SafeHomesecurityfunction.
Processpassword
receivesafour-digitpasswordfromthe
interactwithuser
function.Thepassword
isfirstcomparedtothemasterpasswordstoredwithinthesystem.Ifthemasterpassword
matches,<valididmessage=true>ispassedtothe
messageandstatusdisplay
function.If
themasterpassworddoesnotmatch,thefourdigitsarecomparedtoatableofsecondary

passwords(thesemaybeassignedtohouseguestsand/orworkerswhorequireentryto

thehomewhentheownerisnotpresent).Ifthepasswordmatchesanentrywithinthetable,

<valididmessage=true>ispassedtothe
messageandstatusdisplayfunction
.Ifthereisno
match,<valididmessage=false>ispassedtothemessageandstatusdisplayfunction.
If additional algorithmic detail is desired at this stage, a program design language
representation may also be included as part of the PSPEC. However, many believe

that the PDL version should be postponed until component design commences.5Program design language (PDL) mixes programming language syntax with narrative text to provide
procedural design detail. PDL is discussed briefly in Chapter 10.6Tools noted here do not represent an endorsement, but rather a sampling of tools in this category.
In most cases, tool names are trademarked by their respective developers.The PSPEC is a Òmini-specificationÓ for each
transform at the lowest

refined level of a DFD.Structured Analysis
Objective:Structured analysis tools allow asoftware engineer to create data models, flowmodels, and behavioral models in a manner that enablesconsistency and continuity checking and easy editing and
extension. Models created using these tools provide
thesoftware engineer with insight into the analysis

representation and help to eliminate errors before they
propagate into design, or worse, into implementation itself.Mechanics:Tools in this category use a Òdata
dictionaryÓ as the central database for the description
ofall data objects. Once entries in the dictionary are

defined, entity-relationship diagrams can be created
andobject hierarchies can be developed. Data flow

diagramming features allow easy creation of this graphical
model and also provide features for the creation of PSPECs
and CSPECs. Analysis tools also enable the software engineer to create behavioral models using the state
diagram as the operative notation.Representative Tools:
6MacA&D, WinA&D, developed by Excel software(www.excelsoftware.com
), provides a set ofsimple and inexpensive analysis and design tools forMacs and Windows machines.MetaCASE Workbench,
developed by MetaCase Consulting(www.metacase.com
), is a metatool used to definean analysis or design method (including structured
analysis) and its concepts, rules, notations, and
generators.System Architect,developed by Popkin Software(www.popkin.com
) provides a broad range of
analysis and design tools including tools for data
modeling and structured analysis.SOFTWARE
TOOLSpre75977_ch07.qxd  11/27/08  3:36 PM  Page 194
CHAPTER 7REQUIREMENTS MODELING: FLOW, BEHAVIOR, PATTERNS, AND WEBAPPS1957.3C
REATINGA
BEHAVIORAL
MODELThe modeling notation that I have discussed to this point represents static elementsof the requirements model. It is now time to make a transition to the dynamic be-
havior of the system or product. To accomplish this, you can represent the behavior

of the system as a function of specific events and time.The behavioral model
indicates how software will respond to external events orstimuli. To create the model, you should perform the following steps:
1.Evaluate all use cases to fully understand the sequence of interaction within
the system.2.Identify events that drive the interaction sequence and understand how these
events relate to specific objects.3.Create a sequence for each use case.4.Build a state diagram for the system.5.Review the behavioral model to verify accuracy and consistency.
Each of these steps is discussed in the sections that follow.
7.3.1Identifying Events with the Use Case
In Chapter 6 you learned that the use case represents a sequence of activities that in-
volves actors and the system. In general, an event occurs whenever the system and
an actor exchange information. In Section 7.2.3, I indicated that an event is nottheinformation that has been exchanged, but rather the fact that information has been
exchanged.A use case is examined for points of information exchange. To illustrate, we re-
consider the use case for a portion of the SafeHomesecurity function.The homeowner uses the keypad to key in a four-digit password. The password iscompared with the valid password stored in the system. If the password is incorrect, thecontrol panel will beeponce and reset itself for additional input. If the password iscorrect, the control panel awaits further action.
The underlined portions of the use case scenario indicate events. An actor should be
identified for each event; the information that is exchanged should be noted, and any
conditions or constraints should be listed.As an example of a typical event, consider the underlined use case phrase Òhome-owner uses the keypad to key in a four-digit password.Ó In the context of the
requirements model, the object, Homeowner,
7transmits an event to the objectControlPanel.
The event might be called password entered
. The informationHow do Imodel thesoftwareÕs

reaction to some
external event??7In this example, we assume that each user (homeowner) that interacts with 
SafeHomehas anidentifying password and is therefore a legitimate object.pre75977_ch07.qxd  11/27/08  3:36 PM  Page 195
196PART TWOMODELINGtransferred is the four digits that constitute the password, but this is not an essentialpart of the behavioral model. It is important to note that some events have an ex-
plicit impact on the flow of control of the use case, while others have no direct im-

pact on the flow of control. For example, the event 
password entered
does notexplicitly change the flow of control of the use case, but the results of the event

password compared
(derived from the interaction Òpassword is compared with thevalid password stored in the systemÓ) will have an explicit impact on the information
and control flow of the SafeHomesoftware.Once all events have been identified, they are allocated to the objects involved.
Objects can be responsible for generating events (e.g., Homeowner
generatesthepassword entered
event) or recognizing events that have occurred elsewhere(e.g., ControlPanel
recognizes the binary result of the password compared
event).7.3.2State Representations
In the context of behavioral modeling, two different characterizations of states must
be considered: (1) the state of each class as the system performs its function and
(2)the state of the system as observed from the outside as the system performs its

function.8The state of a class takes on both passive and active characteristics [Cha93]. Apassive stateis simply the current status of all of an objectÕs attributes. For example,
the passive state of the class Player
(in the video game application discussed inChapter 6) would include the current positionand orientationattributes of Player
aswell as other features of Player
that are relevant to the game (e.g., an attribute thatindicates magic wishes remaining). The active stateof an object indicates the current sta-tus of the object as it undergoes a continuing transformation or processing. The class
Player
might have the following active states: moving, at rest, injured, being cured;
trapped, lost,
and so forth. An event (sometimes called a trigger) must occur to forcean object to make a transition from one active state to another.
Two different behavioral representations are discussed in the paragraphs that
follow. The first indicates how an individual class changes state based on external

events and the second shows the behavior of the software as a function of time.State diagrams for analysis classes.
One component of a behavioral model isa UML state diagram9that represents active states for each class and the events (trig-gers) that cause changes between these active states. Figure 7.6illustrates a state di-
agram for the ControlPanel
object in the SafeHomesecurity function.Each arrow shown in Figure 7.6represents a transition from one active state of
an object to another. The labels shown for each arrow represent the event that
8The state diagrams presented in Chapter 6 and in Section 7.3.2 depict the state of the system. Our
discussion in this section will focus on the state of each class within the analysis model.9If you are unfamiliar with UML, a brief introduction to this important modeling notation is presented
in Appendix 1.The system has statesthat represent specific
externally observable

behavior; a class has
states that represent
its behavior as the
system performs its

functions.pre75977_ch07.qxd  11/27/08  3:36 PM  Page 196
triggers the transition. Although the active state model provides useful insight into
the Òlife historyÓ of an object, it is possible to specify additional information to pro-
vide more depth in understanding the behavior of an object. In addition to specify-
ing the event that causes the transition to occur, you can specify a guard and an

action [Cha93]. A guard
is a Boolean condition that must be satisfied in order for thetransition to occur. For example, the guard for the transition from the ÒreadingÓ state

to the ÒcomparingÓ state in Figure 7.6can be determined by examining the use case:
if (password input 4 digits) thencompareto stored password
In general, the guard for a transition usually depends upon the value of one or more
attributes of an object. In other words, the guard depends on the passive state of the
object.An actionoccurs concurrently with the state transition or as a consequence of itand generally involves one or more operations (responsibilities) of the object. For ex-

ample, the action connected to the 
password entered
event (Figure 7.6) is an opera-tion named validatePassword()
that accesses a password
object and performs adigit-by-digit comparison to validate the entered password.Sequence diagrams.
The second type of behavioral representation, called asequence diagram
in UML, indicates how events cause transitions from object toobject. Once events have been identified by examining a use case, the modeler
CHAPTER 7REQUIREMENTS MODELING: FLOW, BEHAVIOR, PATTERNS, AND WEBAPPS197ReadingLockedSelectingPasswordentered ComparingPassword = incorrect& numberOfTries < maxTries 
Password = correctActivation successfulKey hitDo: validatePasswordnumberOfTries > maxTries
Timer 
 lockedTime
Timer > lockedTime
FIGURE7.6State diagramfor the 
ControlPanel

classpre75977_ch07.qxd  11/27/08  3:36 PM  Page 197
198PART TWOMODELINGcreates a sequence diagramÑa representation of how events cause flow from oneobject to another as a function of time. In essence, the sequence diagram is a short-

hand version of the use case. It represents key classes and the events that cause
behavior to flow from class to class.Figure 7.7illustrates a partial sequence diagram for the 
SafeHomesecurity func-tion. Each of the arrows represents an event (derived from a use case) and indicates
how the event channels behavior between SafeHomeobjects. Time is measured ver-
tically (downward), and the narrow vertical rectangles represent time spent in pro-
cessing an activity. States may be shown along a vertical time line.
The first event, system ready, is derived from the external environment and chan-
nels behavior to the Homeowner
object. The homeowner enters a password. Arequest lookupevent is passed to System,which looks up the password in a simpledatabase and returns a result(foundor not found) to ControlPanel
(now in thecomparingstate). A valid password results in a password=correct
event to System,which activates Sensorswith a request activationevent. Ultimately, control is passed
back to the homeowner with the activation successfulevent.Once a complete sequence diagram has been developed, all of the events thatcause transitions between system objects can be collated into a set of input events
and output events (from an object). This information is useful in the creation of an
effective design for the system to be built.Unlike a state diagramthat represents
behavior without
noting the classes
involved, a sequence
diagram represents
behavior, by describing

how classes move
from state to state.Control panelSystemSystem readyReadingRequest lookupComparingResultPassword enteredPassword = correctRequest activationActivation successfulLockedSelectingTimer > lockedTime
AAActivation successfulHomeownerSensorsnumberOfTries > maxTries
FIGURE7.7Sequence diagram (partial) for the SafeHomesecurity functionpre75977_ch07.qxd  11/27/08  3:36 PM  Page 198
7.4P
ATTERNSFOR
REQUIREMENTSMODELINGSoftware patterns are a mechanism for capturing domain knowledge in a way thatallows it to be reapplied when a new problem is encountered. In some cases, the
domain knowledge is applied to a new problem within the same application domain.
In other cases, the domain knowledge captured by a pattern can be applied by anal-
ogy to a completely different application domain.The original author of an analysis pattern does not ÒcreateÓ the pattern, but,rather, 
discovers
it as requirements engineering work is being conducted. Once thepattern has been discovered, it is documented by describing Òexplicitly the general

problem to which the pattern is applicable, the prescribed solution, assumptions and

constraints of using the pattern in practice, and often some other information about

the pattern, such as the motivation and driving forces for using the pattern, discus-
sion of the patternÕs advantages and disadvantages, and references to some known

examples of using that pattern in practical applicationsÓ [Dev01].InChapter5,Iintroducedtheconceptofanalysispatternsandindicatedthatthese
patternsrepresentasolutionthatoftenincorporatesaclass,afunction,orabehavior

withintheapplicationdomain.Thepatterncanbereusedwhenperformingrequire-

mentsmodelingforanapplicationwithinadomain.
11Analysispatternsarestoredin
arepositorysothatmembersofthesoftwareteamcanusesearchfacilitiestofindand

reusethem.Onceanappropriatepatternisselected,itisintegratedintotherequire-

mentsmodelbyreferencetothepatternname.
CHAPTER 7REQUIREMENTS MODELING: FLOW, BEHAVIOR, PATTERNS, AND WEBAPPS199Objective:Analysis modeling tools providethe capability to develop scenario-basedmodels, class-based models, and behavioral models usingUMLnotation.
Mechanics:Tools in this category support the full range
of UML diagrams required to build an analysis model(these tools also support design modeling). In addition

todiagramming, tools in this category (1) perform

consistency and correctness checks for all UML diagrams,
(2) provide links for design and code generation,  (3) build
a database that enables the management and assessment
of large UML models required for complex systems.Representative Tools:
10The following tools support a full range of UML diagrams
required for analysis modeling:ArgoUMLis an open source tool available atargouml.tigris.org
.Enterprise Architect,developed by Sparx Systems
(www.sparxsystems.com.au
).PowerDesigner,
developed by Sybase(www.sybase.com
).Rational Rose,developed by IBM (Rational) (www01.ibm.com/software/rational/).System Architect,developed by Popkin Software(www.popkin.com
).UML Studio,developed by Pragsoft Corporation(www.pragsoft.com
).Visio,
developed by Microsoft (www.microsoft.com
).Visual UML,
developed by Visual Object Modelers
(www.visualuml.com
).SOFTWARE
TOOLS10Tools noted here do not represent an endorsement, but rather a sampling of tools in this category.
In most cases, tool names are trademarked by their respective developers.11An in-depth discussion of the use of patterns during software design is presented in Chapter 12.
Generalized Analysis Modeling in UMLpre75977_ch07.qxd  11/27/08  3:36 PM  Page 199
200PART TWOMODELING7.4.1Discovering Analysis Patterns
The requirements model is comprised of a wide variety of elements: scenario-based(use cases), data-oriented (the data model), class-based, flow-oriented, and behav-
ioral. Each of these elements examines the problem from a different perspective, and

each provides an opportunity to discover patterns that may occur throughout an

application domain, or by analogy, across different application domains.
The most basic element in the description of a requirements model is the use case.In the context of this discussion, a coherent set of use cases may serve as the basis
for discovering one or more analysis patterns. A 
semantic analysis pattern(SAP) Òis apattern that describes a small set of coherent use cases that together describe a basic
generic applicationÓ [Fer00].Consider the following preliminary use case for software required to control andmonitor a real-view camera and proximity sensor for an automobile:Use case:Monitor reverse motion
Description:When the vehicle is placed in reversegear, the control software enables a
video feed from a rear-placed video camera to the dashboard display. The control soft-
ware superimposes a variety of distance and orientation lines on the dashboard display
so that the vehicle operator can maintain orientation as the vehicle moves in reverse. The

control software also monitors a proximity sensor to determine whether an object is
inside 10 feet of the rear of the vehicle. It will automatically break the vehicle if the prox-
imity sensor indicates an object within xfeet of the rear of the vehicle, where 
xis deter-mined based on the speed of the vehicle.This use case implies a variety of functionality that would be refined and elaborated(into a coherent set of use cases) during requirements gathering and modeling.
Regardless of how much elaboration is accomplished, the use cases suggest a
simple, yet widely applicable SAPÑthe software-based monitoring and control of

sensors and actuators in a physical system. In this case, the ÒsensorsÓ provide infor-

mation about proximity and video information. The ÒactuatorÓ is the breaking sys-
tem of the vehicle (invoked if an object is very close to the vehicle). But in a more

general case, a widely applicable pattern is discovered.
Software in many different application domains is required to monitor sensorsand control physical actuators. It follows that an analysis pattern that describes
generic requirements for this capability could be used widely. The pattern, called

Actuator-Sensor
,would be applicable as part of the requirements model forSafeHomeand is discussed in Section 7.4.2, which follows.7.4.2A Requirements Pattern Example: Actuator-Sensor
12One of the requirements of the SafeHomesecurity function is the ability to monitorysecurity sensors (e.g., break-in sensors, fire, smoke or CO sensors, water sensors).
12This section has been adapted from [Kon02] with the permission of the authors.
pre75977_ch07.qxd  11/27/08  3:36 PM  Page 200
Internet-based extensions to SafeHomewill require the ability to control the move-
ment (e.g., pan, zoom) of a security camera within a residence. The implicationÑSafeHomesoftware must manage various sensors and ÒactuatorsÓ (e.g., cameracontrol mechanisms).Konrad and Cheng [Kon02] have suggested a requirements pattern named
Actuator-Sensor
that provides useful guidance for modeling this requirement
within SafeHomesoftware. An abbreviated version of the Actuator-Sensor
pattern,originally developed for automotive applications, follows.Pattern Name.Actuator-Sensor
Intent.Specify various kinds of sensors and actuators in an embedded system.Motivation.
Embedded systems usually have various kinds of sensors and actua-tors. These sensors and actuators are all either directly or indirectly connected to acontrol unit. Although many of the sensors and actuators look quite different, their
behavior is similar enough to structure them into a pattern. The pattern shows how
to specify the sensors and actuators for a system, including attributes and opera-
tions. The Actuator-Sensor
pattern uses a pullmechanism (explicit request for in-formation) for PassiveSensors
and a pushmechanism (broadcast of information)for the ActiveSensors.
Constraints
¥Each passive sensor must have some method to read sensor input and attrib-utes that represent the sensor value.¥Each active sensor must have capabilities to broadcast update messages
when its value changes.¥Each active sensor should send a life tick
, a status message issued within a
specified time frame, to detect malfunctions.
¥Each actuator must have some method to invoke the appropriate response

determined by the ComputingComponent.¥Each sensor and actuator should have a function implemented to check its
own operation state.¥Each sensor and actuator should be able to test the validity of the values
received or sent and set its operation state if the values are outside of the
specifications.Applicability.
Useful in any system in which multiple sensors and actuators arepresent.Structure.
A UML class diagram for the Actuator-Sensor
pattern is shown in Fig-ure7.8. 
Actuator, PassiveSensor,
and ActiveSensor
are abstract classes and de-noted in italics. There are four different types of sensors and actuators in this pattern.CHAPTER 7REQUIREMENTS MODELING: FLOW, BEHAVIOR, PATTERNS, AND WEBAPPS201pre75977_ch07.qxd  11/27/08  3:36 PM  Page 201
202PART TWOMODELINGThe Boolean,Integer,
and Realclasses represent the most common types of sen-sors and actuators. The complex classes are sensors or actuators that use values thatcannot be easily represented in terms of primitive data types, such as a radar device.
Nonetheless, these devices should still inherit the interface from the abstract classes
since they should have basic functionalities such as querying the operation states.Behavior.
Figure 7.9presents a UML sequence diagram for an example of the
Actuator-Sensor
pattern as it might be applied for the SafeHomefunction thatcontrols the positioning (e.g., pan, zoom) of a security camera. Here, the

ControlPanel
13queries a sensor (a passive position sensor) and an actuator (pancontrol) to check the operation state for diagnostic purposes before reading or set-
ting a value. The messages Set Physical Value
and Get Physical Value
are not messagesbetween objects. Instead, they describe the interaction between the physical devices
of the system and their software counterparts. In the lower part of the diagram,
below the horizontal line, the 
PositionSensor
reports that the operation state iszero. The ComputingComponent (represented as ControlPanel
)then sends the
error code for a position sensor failure to the FaultHandler
that will decide how thiserror affects the system and what actions are required. It gets the data from the
sensors and computes the required response for the actuators.Passive integer
sensorPassive sensor
Computing
component
Active sensor
Passive boolean
sensorPassive complex
sensorPassive real
sensorBooleanactuator
Integer
actuator
Complex
actuator
Realactuator
Actuator
Active boolean
sensorActive integer
sensorActive complex
sensorActive real
sensorFIGURE7.8UML sequence diagram for the Actuator-Sensor pattern.
Source:Adapted from [Kon02] with permission.13The original pattern uses the generic phrase 
ComputingComponent.pre75977_ch07.qxd  11/27/08  3:36 PM  Page 202
Participants.This section of the patterns description Òitemizes the classes/objects that are included in the requirements patternÓ [Kon02] and describes the
responsibilities of each class/object (Figure 7.8). An abbreviated list follows:¥PassiveSensor abstract: 
Defines an interface for passive sensors.¥PassiveBooleanSensor:
Defines passive Boolean sensors.¥PassiveIntegerSensor:
Defines passive integer sensors.¥PassiveRealSensor:
Defines passive real sensors.¥ActiveSensor abstract:
Defines an interface for active sensors.¥ActiveBooleanSensor:
Defines active Boolean sensors.¥ActiveIntegerSensor:
Defines active integer sensors.¥ActiveRealSensor:
Defines active real sensors.¥Actuator abstract:
Defines an interface for actuators.¥BooleanActuator:Defines Boolean actuators.¥IntegerActuator:Defines integer actuators.¥RealActuator:Defines real actuators.¥ComputingComponent:The central part of the controller; it gets the datafrom the sensors and computes the required response for the actuators.CHAPTER 7REQUIREMENTS MODELING: FLOW, BEHAVIOR, PATTERNS, AND WEBAPPS203FauntHandler(PositionSensor.
OpState = 1)PositionSensorControlPanel
Get operation statePanControlActuatorSenorInputDevicePositionSensorActuatorOutputDevicePanControlGet valueGet operation stateGet operation stateSet valueSet physical valueStore errorGet physical value(PositionSensor.
OpState = 0)FIGURE7.9UML Class diagram for the Actuator-Sensor pattern.
Source:Reprinted from [Kon02] with permission.pre75977_ch07.qxd  11/27/08  3:36 PM  Page 203
204PART TWOMODELING¥ActiveComplexSensor:
Complex active sensors have the basic functionalityof the abstract ActiveSensor
class, but additional, more elaborate, methods
and attributes need to be specified.¥PassiveComplexSensor:
Complex passive sensors have the basic function-ality of the abstract PassiveSensor
class, but additional, more elaborate,
methods and attributes need to be specified.¥ComplexActuator:Complex actuators also have the base functionality ofthe abstract Actuatorclass, but additional, more elaborate methods andattributes need to be specified.Collaborations.
This section describes how objects and classes interact with oneanother and how each carries out its responsibilities.¥When the ComputingComponentneeds to update the value of aPassiveSensor,
it queries the sensors, requesting the value by sending theappropriate message.¥ActiveSensors
are not queried. They initiate the transmission of sensorvalues to the computing unit, using the appropriate method to set the valueinthe 
ComputingComponent.They send a life tick at least once during aspecified time frame in order to update their timestamps with the system
clockÕs time.
¥When the ComputingComponentneeds to set the value of an actuator, it
sends the value to the actuator.
¥TheComputingComponentcanqueryandsettheoperationstateofthe
sensorsandactuatorsusingtheappropriatemethods.Ifanoperationstateis

foundtobezero,thentheerrorissenttothe
FaultHandler,
aclassthatcontains
methodsforhandlingerrormessages,suchasstartingamoreelaboraterecovery

mechanismorabackupdevice.Ifnorecoveryispossible,thenthesystemcan

onlyusethelastknownvalueforthesensororthedefaultvalue.
¥The ActiveSensors
offer methods to add or remove the addresses or
address ranges of the components that want to receive the messages in case
of a value change.Consequences1.Sensor and actuator classes have a common interface.2.Class attributes can only be accessed through messages, and the class
decides whether or not to accept the message. For example, if a value of an

actuator is set above a maximum value, then the actuator class may not

accept the message, or it might use a default maximum value.
3.The complexity of the system is potentially reduced because of the uniformity
of interfaces for actuators and sensors.pre75977_ch07.qxd  11/27/08  3:36 PM  Page 204
The requirements pattern description might also provide references to other related
requirements and design patterns.7.5R
EQUIREMENTSMODELINGFOR
WEBAPPS14Web developers are often skeptical when the idea of requirements analysis for

WebApps is suggested. ÒAfter all,Ó they argue, Òthe Web development process must

be agile, and analysis is time consuming. ItÕll slow us down just when we need to be

designing and building the WebApp.Ó
Requirements analysis does take time, but solving the wrong problem takes even
more time. The question for every WebApp developer is simpleÑare you sure you

understand the requirements of the problem? If the answer is an unequivocal Òyes,Ó
then it may be possible to skip requirements modeling, but if the answer is Òno,Ó then
requirements modeling should be performed.7.5.1How Much Analysis Is Enough?
The degree to which requirements modeling for WebApps is emphasized depends on

the following factors:¥Size and complexity of WebApp increment.
¥Number of stakeholders (analysis can help to identify conflicting requirements
coming from different sources).¥Size of the WebApp team.
¥Degree to which members of the WebApp team have worked together before

(analysis can help develop a common understanding of the project).¥Degree to which the organizationÕs success is directly dependent on the

success of the WebApp.
The converse of the preceding points is that as the project becomes smaller, the

number of stakeholders fewer, the development team more cohesive, and the appli-

cation less critical, it is reasonable to apply a more lightweight analysis approach.Although it is a good idea to analyze the problem beforebeginning design, it isnot true that allanalysis must precede alldesign. In fact, the design of a specific partof the WebApp only demands an analysis of those requirements that affect only that

part of the WebApp. As an example from 
SafeHome, you could validly designtheoverall website aesthetics (layouts, color schemes, etc.) without having

analyzed thefunctional requirements for e-commerce capabilities. You only need to

analyze that part of the problem that is relevant to the design work for the incre-
ment to be delivered.CHAPTER 7REQUIREMENTS MODELING: FLOW, BEHAVIOR, PATTERNS, AND WEBAPPS20514This section has been adapted from Pressman and Lowe [Pre08] with permission.
pre75977_ch07.qxd  11/27/08  3:36 PM  Page 205
206PART TWOMODELING7.5.2Requirements Modeling Input
An agile version of the generic software process discussed in Chapter 2 can be ap-plied when WebApps are engineered. The process incorporates a communication

activity that identifies stakeholders and user categories, the business context, de-
fined informational and applicative goals, general WebApp requirements, and usage

scenariosÑinformation that becomes input to requirements modeling. This infor-
mation is represented in the form of natural language descriptions, rough outlines,
sketches, and other informal representations.Analysis takes this information, structures it using a formally defined representa-tion scheme (where appropriate), and then produces more rigorous models as an
output. The requirements model provides a detailed indication of the true structure

of the problem and provides insight into the shape of the solution.
The SafeHomeACS-DCV
(camera surveillance) function was introduced in Chap-ter 6. When it was introduced, this function seemed relatively clear and was de-
scribed in some detail as part of a use case (Section 6.2.1). However, a reexamination

of the use case might uncover information that is missing, ambiguous, or unclear.
Some aspects of this missing information would naturally emerge during thedesign. Examples might include the specific layout of the function buttons, their aes-
thetic look and feel, the size of snapshot views, the placement of camera views and
the house floor plan, or even minutiae such as the maximum and minimum length
of passwords. Some of these aspects are design decisions (such as the layout of the
buttons) and others are requirements (such as the length of the passwords) that donÕt

fundamentally influence early design work.But some missing information might actually influence the overall design itself
and relate more to an actual understanding of the requirements. For example:Q1:What output video resolution is provided by 
SafeHomecameras?Q2:What occurs if an alarm condition is encountered while the camera is
being monitored?Q3:How does the system handle cameras that can be panned and zoomed?
Q4:What information should be provided along with the camera view? (For
example, location? time/date? last previous access?)
None of these questions were identified or considered in the initial development of
the use case, and yet, the answers could have a substantial effect on different aspects

of the design.Therefore, it is reasonable to conclude that although the communication activity
provides a good foundation for understanding, requirements analysis refines this

understanding by providing additional interpretation. As the problem structure is de-

lineated as part of the requirements model, questions invariably arise. It is these

questions that fill in the gapsÑor in some cases, actually help us to find the gaps in
the first place.pre75977_ch07.qxd  11/27/08  3:36 PM  Page 206
To summarize, the inputs to the requirements model will be the information col-
lected during the communication activityÑanything from an informal e-mail to a de-tailed project brief complete with comprehensive usage scenarios and product
specifications.7.5.3Requirements Modeling Output
Requirements analysis provides a disciplined mechanism for representing and eval-

uating WebApp content and function, the modes of interaction that users will en-

counter, and the environment and infrastructure in which the WebApp resides.
Each of these characteristics can be represented as a set of models that allow theWebApp requirements to be analyzed in a structured manner. While the specific

models depend largely upon the nature of the WebApp, there are five main classes

of models:¥Content modelÑidentifies the full spectrum of content to be provided by
the WebApp. Content includes text, graphics and images, video, and audio

data.¥Interaction model
Ñdescribes the manner in which users interact with theWebApp.
¥Functional modelÑdefines the operations that will be applied to WebApp
content and describes other processing functions that are independent of
content but necessary to the end user.
¥Navigation model
Ñdefines the overall navigation strategy for the WebApp.
¥Configuration model
Ñdescribes the environment and infrastructure in
which the WebApp resides.
You can develop each of these models using a representation scheme (often

calledaÒlanguageÓ) that allows its intent and structure to be communicated and

evaluated easily among members of the Web engineering team and other stake-

holders. As a consequence, a list of key issues (e.g., errors, omissions, inconsisten-

cies, suggestions for enhancement or modification, points of clarification) are
identified and acted upon.7.5.4Content Model for WebApps
The content model contains structural elements that provide an important view of

content requirements for a WebApp. These structural elements encompass content

objects and all analysis classesÑuser-visible entities that are created or manipulated
as a user interacts with the WebApp.
15Content can be developed prior to the implementation of the WebApp, while the
WebApp is being built, or long after the WebApp is operational. In every case, it is
CHAPTER 7REQUIREMENTS MODELING: FLOW, BEHAVIOR, PATTERNS, AND WEBAPPS20715Analysis classes were discussed in Chapter 6.
pre75977_ch07.qxd  11/27/08  3:36 PM  Page 207
208PART TWOMODELINGincorporated via navigational reference into the overall WebApp structure. A 
contentobjectmight be a textual description of a product, an article describing a news event,an action photograph taken at a sporting event, a userÕs response on a discussion

forum, an animated representation of a corporate logo, a short video of a speech, or
an audio overlay for a collection of presentation slides. The content objects might be

stored as separate files, embedded directly into Web pages, or obtained dynamically

from a database. In other words, a content object is any item of cohesive informa-
tion that is to be presented to an end user.
Content objects can be determined directly from use cases by examining thescenario description for direct and indirect references to content. For example, a

WebApp that supports 
SafeHomeis established at SafeHomeAssured.com.A usecase, 
Purchasing Select SafeHome Components,
describes the scenario required topurchase a SafeHomecomponent and contains the sentence:I will be able to get descriptive and pricing information for each product component.The content model must be capable of describing the content object Component.
In many instances, a simple list of content objects, coupled with a brief description
of each object, is sufficient to define the requirements for content that must be de-
signed and implemented. However, in some cases, the content model may benefit

from a richer analysis that graphically illustrates the relationships among content
objects and/or the hierarchy of content maintained by a WebApp.
For example, consider the 
data tree[Sri01] created for a SafeHomeAssured.comcomponent shown in Figure 7.10. The tree represents a hierarchy of information that
is used to describe a component. Simple or composite data items (one or more dataMarketing descriptionPhotographTech description
SchematicVideo
Wholesale pricePart number
Part name
Part type
ComponentDescriptionPriceRetail priceFIGURE7.10Data tree for
aSafeHome-Assured.comcomponentpre75977_ch07.qxd  11/27/08  3:36 PM  Page 208
values) are represented as unshaded rectangles. Content objects are represented asshaded rectangles. In the figure, 
descriptionis defined by five content objects (theshaded rectangles). In some cases, one or more of these objects would be further
refined as the data tree expands.A data tree can be created for any content that is composed of multiple contentobjects and data items. The data tree is developed in an effort to define hierarchical
relationships among content objects and to provide a means for reviewing content

so that omissions and inconsistencies are uncovered before design commences. In

addition, the data tree serves as the basis for content design.7.5.5Interaction Model for WebApps
The vast majority of WebApps enable a ÒconversationÓ between an end user and ap-

plication functionality, content, and behavior. This conversation can be described

using an interaction
model that can be composed of one or more of the followingelements: (1) use cases, (2) sequence diagrams, (3) state diagrams,16and/or (4) userinterface prototypes.In many instances, a set of use cases is sufficient to describe the interaction at ananalysis level (further refinement and detail will be introduced during design). How-
ever, when the sequence of interaction is complex and involves multiple analysis

classes or many tasks, it is sometimes worthwhile to depict it using a more rigorous
diagrammatic form.The layout of the user interface, the content it presents, the interaction mecha-
nisms it implements, and the overall aesthetic of the user-WebApp connections have

much to do with user satisfaction and the overall success of the WebApp. Although

it can be argued that the creation of a user interface prototype is a design activity, it

is a good idea to perform it during the creation of the analysis model. The sooner that
a physical representation of a user interface can be reviewed, the higher the likeli-
hood that end users will get what they want. The design of user interfaces is dis-
cussed in detail in Chapter 11.Because WebApp construction tools are plentiful, relatively inexpensive, and
functionally powerful, it is best to create the interface prototype using such tools.
The prototype should implement the major navigational links and represent the
overall screen layout in much the same way that it will be constructed. For exam-

ple, if five major system functions are to be provided to the end user, the prototype

should represent them as the user will see them upon first entering the WebApp.

Will graphical links be provided? Where will the navigation menu be displayed?

What other information will the user see? Questions like these should be answered
by the prototype.CHAPTER 7REQUIREMENTS MODELING: FLOW, BEHAVIOR, PATTERNS, AND WEBAPPS20916Sequence diagrams and state diagrams are modeled using UML notation. State diagrams are
described in Section 7.3.See Appendix 1 for additional detail.
pre75977_ch07.qxd  11/27/08  3:36 PM  Page 209
210PART TWOMODELING7.5.6Functional Model for WebApps
Many WebApps deliver a broad array of computational and manipulative functions
that can be associated directly with content (either using it or producing it) and that
are often a major goal of user-WebApp interaction. For this reason, functional re-

quirements must be analyzed, and when necessary, modeled.
The functional modeladdresses two processing elements of the WebApp, each
representing a different level of procedural abstraction: (1) user-observable func-
tionality that is delivered by the WebApp to end users, and (2) the operations con-

tained within analysis classes that implement behaviors associated with the class.User-observable functionality encompasses any processing functions that are ini-tiated directly by the user. For example, a financial WebApp might implement a va-

riety of financial functions (e.g., a college tuition savings calculator or a retirement
savings calculator). These functions may actually be implemented using operations
within analysis classes, but from the point of view of the end user, the function (more

correctly, the data provided by the function) is the visible outcome.
At a lower level of procedural abstraction, the requirements model describes theprocessing to be performed by analysis class operations. These operations manipu-
late class attributes and are involved as classes collaborate with one another to

accomplish some required behavior.
Regardless of the level of procedural abstraction, the UML activity diagram canbe used to represent processing details. At the analysis level, activity diagrams
should be used only where the functionality is relatively complex. Much of the com-
plexity of many WebApps occurs not in the functionality provided, but rather with

the nature of the information that can be accessed and the ways in which this can
be manipulated.An example of relatively complex functionality for SafeHomeAssured.comisaddressed by a use case entitled Get recommendations for sensor layout for my space.
The user has already developed a layout for the space to be monitored, and in this
use case, selects that layout and requests recommended locations for sensors within

the layout. SafeHomeAssured.comresponds with a graphical representation ofthe
layout with additional information on the recommended locations for sensors. The
interaction is quite simple, the content is somewhat more complex, but the underly-

ing functionality it very sophisticated. The system must undertake a relatively com-
plex analysis of the floor layout in order to determine the optimal set of sensors. It
must examine room dimensions, the location of doors and windows, and coordinate
these with sensor capabilities and specifications. No small task! A set of activity
diagrams can be used to describe processing for this use case.The second example is the use case Control cameras.
In this use case, the inter-
action is relatively simple, but there is the potential for complex functionality, given

that this ÒsimpleÓ operation requires complex communication with devices located
remotely and accessible across the Internet. A further possible complication relatespre75977_ch07.qxd  11/27/08  3:36 PM  Page 210
to negotiation of control when multiple authorized people attempt to monitorand/or control a single sensor at the same time.Figure 7.11depicts an activity diagram for the 
takeControlOfCamera()
operationthat is part of the Camera
analysis class used within the Control cameras
use case.It should be noted that two additional operations are invoked with the procedural

flow: requestCameraLock(),
which tries to lock the camera for this user, and
getCurrentCameraUser(),
which retrieves the name of the user who is currently con-trolling the camera. The construction details indicating how these operations are in-
voked and the interface details for each operation are not considered until WebApp

design commences.7.5.7Configuration Models for WebApps
In some cases, the configuration model is nothing more than a list of server-side
and client-side attributes. However, for more complex WebApps, a variety of con-

figuration complexities (e.g., distributing load among multiple servers, caching
architectures, remote databases, multiple servers serving various objects on the
same Web page) may have an impact on analysis and design. The UML 
deployment
diagram
can be used in situations in which complex configuration architecturesmust be considered.For SafeHomeAssured.comthe public content and functionality should bespecified to be accessible across all major Web clients (i.e., those with more than
CHAPTER 7REQUIREMENTS MODELING: FLOW, BEHAVIOR, PATTERNS, AND WEBAPPS211getCurrentCameraUser()Report Camera
in use and nameof current userLock availableLock unavailable
Camera not in useCamera in userequestCameraLock()Report Camera
now locked foruserReport Camera
unavailableFIGURE7.11Activitydiagram
forthe

takeControlOf-

Camera()
operationpre75977_ch07.qxd  11/27/08  3:36 PM  Page 211
212PART TWOMODELING1percent market share or greater
17). Conversely, it may be acceptable to restrict the
more complex control and monitoring functionality (which is only accessible toHomeowner
users) to a smaller set of clients. The configuration model forSafeHomeAssured.comwill also specify interoperability with existing productdatabases and monitoring applications.7.5.8Navigation Modeling
Navigation modeling considers how each user category will navigate from one
WebApp element (e.g., content object) to another. The mechanics of navigation are

defined as part of design. At this stage, you should focus on overall navigation

requirements. The following questions should be considered:¥Should certain elements be easier to reach (require fewer navigation steps)
than others? What is the priority for presentation?¥Should certain elements be emphasized to force users to navigate in their
direction?¥How should navigation errors be handled?¥Should navigation to related groups of elements be given priority over

navigation to a specific element?¥Should navigation be accomplished via links, via search-based access, or by
some other means?¥Should certain elements be presented to users based on the context of
previous navigation actions?¥Should a navigation log be maintained for users?¥Should a full navigation map or menu (as opposed to a single ÒbackÓ link or
directed pointer) be available at every point in a userÕs interaction?
¥Should navigation design be driven by the most commonly expected user
behaviors or by the perceived importance of the defined WebApp elements?
¥Can a user ÒstoreÓ his previous navigation through the WebApp to expedite

future usage?¥For which user category should optimal navigation be designed?¥How should links external to the WebApp be handled? Overlaying the

existing browser window? As a new browser window? As a separate frame?These and many other questions should be asked and answered as part of navigation
analysis.17Determining market share for browsers is notoriously problematic and varies depending on which
survey is used. Nevertheless, at the time of writing, Internet Explorer and Firefox are the onlybrowsers that were reported in excess of 30 percent, and Mozilla, Opera, and Safari the only other
ones consistently above 1 percent.pre75977_ch07.qxd  11/27/08  3:36 PM  Page 212
You and other stakeholders must also determine overall requirements for navi-
gation. For example, will a Òsite mapÓ be provided to give users an overview of the
entire WebApp structure? Can a user take a Òguided tourÓ that will highlight the most

important elements (content objects and functions) that are available? Will a user be

able to access content objects or functions based on defined attributes of those ele-
ments (e.g., a user might want to access all photographs of a specific building or all
functions that allow computation of weight)?7.6S
UMMARYFlow-oriented models focus on the flow of data objects as they are transformed by
processing functions. Derived from structured analysis, flow-oriented models use
the data flow diagram, a modeling notation that depicts how input is transformed
into output as data objects move through a system. Each software function that

transforms data is described by a process specification or narrative. In addition to
data flow, this modeling element also depicts control flowÑa representation that

illustrates how events affect the behavior of a system.Behavioral modeling depicts dynamic behavior. The behavioral model uses input
from scenario-based, flow-oriented, and class-based elements to represent the
states of analysis classes and the system as a whole. To accomplish this, states are

identified, the events that cause a class (or the system) to make a transition from one
state to another are defined, and the actions that occur as transition is accomplished
are also identified. State diagrams and sequence diagrams are the notation used for
behavioral modeling.Analysis patterns enable a software engineer to use existing domain knowledge tofacilitate the creation of a requirements model. An analysis pattern describes a spe-
cific software feature or function that can be described by a coherent set of usecases.

It specifies the intent of the pattern, the motivation for its use, constraints that limit

its use, its applicability in various problem domains, the overall structure of the pat-

tern, its behavior and collaborations, and other supplementary information.Requirements modeling for WebApps can use most, if not all, of the modeling el-
ements discussed in this book. However, these elements are applied within a set of

specialized models that address content, interaction, function, navigation, and the
client-server configuration in which the WebApp resides.
PROBLEMSAND
POINTSTO
PONDER7.1.What is the fundamental difference between the structured analysis and object-orientedstrategies for requirements analysis?7.2.In a data flow diagram, does an arrow represent a flow of control or something else?7.3.What is Òinformation flow continuityÓ and how is it applied as a data flow diagram isrefined?CHAPTER 7REQUIREMENTS MODELING: FLOW, BEHAVIOR, PATTERNS, AND WEBAPPS213pre75977_ch07.qxd  11/27/08  3:36 PM  Page 213
214PART TWOMODELING7.4.How is a grammatical parse used in the creation of a DFD?7.5.What is a control specification?7.6.Are a PSPEC and a use case the same thing? If not, explain the differences.7.7.There are two different types of ÒstatesÓ that behavioral models can represent. What arethey?7.8.How does a sequence diagram differ from a state diagram. How are they similar?7.9.Suggest three requirements patterns for a modern mobile phone and write a briefdescription of each. Could these patterns be used for other devices. Provide an example.

7.10.Select one of the patterns you developed in Problem 7.9 and develop a reasonably com-plete pattern description similar in content and style to the one presented in Section 7.4.2.
7.11.How much analysis modeling do you think would be required for SafeHomeAssured.com?Would each of the model types described in Section 7.5.3 be required?
7.12.What is the purpose of the interaction model for a WebApp?
7.13.It could be argued that a WebApp functional model should be delayed until design.
Present pros and cons for this argument.
7.14.What is the purpose of a configuration model?7.15.How does the navigation model differ from the interaction model?FURTHER
READINGSAND
INFORMATION
SOURCESDozens of books have been published on structured analysis. All cover the subject adequately,
but only a few do a truly excellent job. DeMarco and Plauger (
Structured Analysis and SystemSpecification,Pearson, 1985) is a classic that remains a good introduction to the basic notation.Books by Kendall and Kendall (
Systems Analysis and Design, 5th ed., Prentice-Hall, 2002), Hoffer
et al. (Modern Systems Analysis and Design,Addison-Wesley, 3d ed., 2001), Davis and Yen (
TheInformation System ConsultantÕs Handbook: Systems Analysis and Design,
CRC Press, 1998), andModell (A ProfessionalÕs Guide to Systems Analysis,
2d ed., McGraw-Hill, 1996) are worthwhile
references. YourdonÕs book (
Modern Structured Analysis, Yourdon-Press, 1989) on the subject

remains among the most comprehensive coverage published to date.
Behavioral modeling presents an important dynamic view of system behavior. Books by
Wagner and his colleagues (
Modeling Software with Finite State Machines: A Practical Approach,

Auerbach, 2006) and Boerger and Staerk (
Abstract State Machines,
Springer, 2003) present thor-
ough discussion of state diagrams and other behavioral representations.The majority of books written about software patterns focus on software design. However,
books by Evans (Domain-Driven Design,Addison-Wesley, 2003) and Fowler ([Fow03] and
[Fow97]) address analysis patterns specifically.
An in-depth treatment of analysis modeling for WebApps is presented by Pressman and
Lowe [Pre08]. Papers contained within an anthology edited by Murugesan and Desphande (Web
Engineering: Managing Diversity and Complexity of Web Application Development,
Springer, 2001)
treat various aspects of WebApp requirements. In addition, the annual 
Proceedings of the Inter-
national Conference on Web Engineering
regularly addresses requirements modeling issues.A wide variety of information sources on requirements modeling are available on theInternet. An up-to-date list of World Wide Web references that are relevant to analysis

modelingcan be found at the SEPA website: 
www.mhhe.com/engcs/compsci/pressman/ 
professional/olc/ser.htm
.pre75977_ch07.qxd  11/27/08  3:36 PM  Page 214
Software design encompasses the set of principles, concepts, and practicesthat lead to the development of a high-quality system or product. Design
principles establish an overriding philosophy that guides you in the design
work you must perform. Design concepts must be understood before the me-
chanics of design practice are applied, and design practice itself leads to the cre-
ation of various representations of the software that serve as a guide for the
construction activity that follows.Design is pivotal to successful software engineering. In the early 1990s MitchKapor, the creator of Lotus 1-2-3, presented a Òsoftware design manifestoÓ in

Dr.Dobbs Journal.
He said:What is design? ItÕs where you stand with a foot in two worldsÑthe world of technol-
ogy and the world of people and human purposesÑand you try to bring the two
together....215CHAPTER8DESIGNCONCEPTSWhat is it?Design is what almostevery engineer wants to do. It is the
place where creativity rulesÑwhere
stakeholder requirements, businessneeds, and technical considerations all come
together in the formulation of a product or sys-

tem. Design creates a representation or model
of the software, but unlike the requirements
model (that focuses on describing required
data, function, and behavior), the design model
provides detail about software architecture,
data structures, interfaces, and components that

are necessary to implement the system.
Who does it?Software engineers conduct each ofthe design tasks.Why is it important?
Design allows you to modelthe system or product that is to be built. This
model can be assessed for quality and
improved before code is generated, tests are
conducted, and end users become involved in
large numbers. Design is the place where soft-
ware quality is established.What are the steps?Design depicts the soft-warein a number of different ways. First, the
QUICKLOOKarchitecture of the system or product must be
represented. Then, the interfaces that connect

the software to end users, to other systems and
devices, and to its own constituent components
are modeled. Finally, the software components

that are used to construct the system are
designed. Each of these views represents a dif-
ferent design action, but all must conform to a

set of basic design concepts that guide software
design work.What is the work product?
A design model thatencompasses architectural, interface, component-

level, and deployment representations is the
primary work product that is produced during

software design.How do I ensure that IÕve done it right?Thedesign model is assessed by the software team
in an effort to determine whether it contains

errors, inconsistencies, or omissions; whether
better alternatives exist; and whether the

model can be implemented within the con-
straints, schedule, and cost that have been
established.KEYCONCEPTSabstraction . . . .223
architecture . . .223

aspects . . . . . .228

cohesion . . . . . .227

data design . . .234

design process .219

functionalindependence . .227
good design . . .219

information hiding . . . . . . .226
pre75977_ch08.qxd  11/27/08  3:38 PM  Page 215
The Roman architecture critic Vitruvius advanced the notion that well-designed build-
ings were those which exhibited firmness, commodity, and delight. The same might be
said of good software. Firmness:A program should not have any bugs that inhibit its func-tion. Commodity:A program should be suitable for the purposes for which it was in-tended. Delight:The experience of using the program should be a pleasurable one. Herewe have the beginnings of a theory of design for software.The goal of design is to produce a model or representation that exhibits firmness,commodity, and delight. To accomplish this, you must practice diversification and

then convergence. Belady [Bel81] states that Òdiversification is the acquisition of a

repertoire of alternatives, the raw material of design: components, component solu-

tions, and knowledge, all contained in catalogs, textbooks, and the mind.Ó Once this

diverse set of information is assembled, you must pick and choose elements from the
repertoire that meet the requirements defined by requirements engineering and the
analysis model (Chapters 5 through 7). As this occurs, alternatives are considered
and rejected and you converge on Òone particular configuration of components, and

thus the creation of the final productÓ [Bel81].Diversification and convergence combine intuition and judgment based on expe-
rience in building similar entities, a set of principles and/or heuristics that guide the
way in which the model evolves, a set of criteria that enables quality to be judged,
and a process of iteration that ultimately leads to a final design representation.Software design changes continually as new methods, better analysis, and broaderunderstanding evolve.1Even today, most software design methodologies lack the
depth, flexibility, and quantitative nature that are normally associated with more clas-

sical engineering design disciplines. However, methods for software design do exist,

criteria for design quality are available, and design notation can be applied. In this

chapter, I explore the fundamental concepts and principles that are applicable to all

software design, the elements of the design model, and the impact of patterns on
thedesign process. In Chapters 9 through 13 IÕll present a variety of software 

design methods as they are applied to architectural, interface, and component-

level design as well as pattern-based and Web-oriented design approaches.
8.1D
ESIGNWITHINTHE
CONTEXTOF
SOFTWARE
ENGINEERINGSoftware design sits at the technical kernel of software engineering and is applied
regardless of the software process model that is used. Beginning once software re-
quirements have been analyzed and modeled, software design is the last software
engineering action within the modeling activity and sets the stage for construction
(code generation and testing).216PART TWOMODELINGmodularity . . . .225
object-orienteddesign . . . . . . .230
patterns . . . . . .224

quality attributes . . . . .220
quality guidelines . . . . .219
refactoring . . . .229

separation ofconcerns . . . . . .225
software design . . . . . . .221
stepwise refinement . . . .228
1Those readers with further interest in the philosophy of software design might have interest in
Philippe KruchenÕs intriguing discussion of Òpost-modernÓ design [Kru05a].uote:ÒThemostcommon
miracleofsoftware

engineeringisthe

transitionfrom

analysistodesign

anddesigntocode.Ó
RichardDueÕ
pre75977_ch08.qxd  11/27/08  3:38 PM  Page 216
Each of the elements of the requirements model (Chapters 6 and 7) provides in-
formation that is necessary to create the four design models required for a completespecification of design. The flow of information during software design is illustrated
in Figure 8.1. The requirements model, manifested by scenario-based, class-based,
flow-oriented, and behavioral elements, feed the design task. Using design notation
and design methods discussed in later chapters, design produces a data/class de-
sign, an architectural design, an interface design, and a component design.The data/class design transforms class models (Chapter 6) into design class real-izations and the requisite data structures required to implement the software. The
objects and relationships defined in the CRC diagram and the detailed data content
depicted by class attributes and other notation provide the basis for the data design

action. Part of class design may occur in conjunction with the design of software
architecture. More detailed class design occurs as each software component is
designed.The architectural design defines the relationship between major structural ele-ments of the software, the architectural styles and design patterns that can be used

to achieve the requirements defined for the system, and the constraints that affect
the way in which architecture can be implemented [Sha96]. The architectural design
representationÑthe framework of a computer-based systemÑis derived from the
requirements model.CHAPTER 8DESIGN CONCEPTS217Software designshould always begin
with a consideration of
dataÑthe foundation
for all other elements
of the design. After the
foundation is laid, the
architecture must be
derived. Only then
should you perform

other design tasks.Analysis ModelUse cases - text Use-case diagrams 
Activity diagrams 
Swimlane diagramsData flow diagrams Control-flow diagrams 
Processing narrativesFlow-orientedelementsBehavioralelementsClass-basedelementsScenerio-basedelementsClass diagrams Analysis packages 
CRC models 
Collaboration diagrams  State diagrams Sequence diagramsData/Class DesignInterface Design
Architectural DesignComponent-
Level DesignDesign ModelFIGURE8.1Translating the requirements model into the design model
pre75977_ch08.qxd  11/27/08  3:38 PM  Page 217
The interface design describes how the software communicates with systems thatinteroperate with it, and with humans who use it. An interface implies a flow ofinformation (e.g., data and/or control) and a specific type of behavior. Therefore,

usage scenarios and behavioral models provide much of the information required

forinterface design.
The component-level design transforms structural elements of the software ar-chitecture into a procedural description of software components. Information ob-
tained from the class-based models, flow models, and behavioral models serve as
the basis for component design.During design you make decisions that will ultimately affect the success of soft-ware construction and, as important, the ease with which software can be main-
tained. But why is design so important?The importance of software design can be stated with a single wordÑquality.Design is the place where quality is fostered in software engineering. Design provides

you with representations of software that can be assessed for quality. Design is the

only way that you can accurately translate stakeholderÕs requirements into a finished

software product or system. Software design serves as the foundation for all the soft-
ware engineering and software support activities that follow. Without design, you risk

building an unstable systemÑone that will fail when small changes are made; one
that may be difficult to test; one whose quality cannot be assessed until late in the
software process, when time is short and many dollars have already been spent.218PART TWOMODELINGuote:ÒThere are twoways of
constructing a
software design.
One way is to
make it so simple
that there are
obviously no
deficiencies, and
the other way is to
make it so
complicated that
there are no
obvious
deficiencies. The
first method is far
more difficult.ÓC.A. R.Hoare
Design versus CodingThe scene:JamieÕs cubicle, as the
team prepares to translate requirements into design.The players:Jamie, Vinod, and EdÑall members of
the SafeHomesoftware engineering team.The conversation:
Jamie:You know, Doug [the team manager] is obsessed
with design. I gotta be honest, what I really love doing iscoding. Give me C++ or Java, and IÕm happy.
Ed:Nah...you like to design.
Jamie:YouÕre not listening; coding is where itÕs at.
Vinod:
I think what Ed means is you donÕt really like
coding; you like to design and express it in code. Code isthe language you use to represent the design.Jamie:And whatÕs wrong with that?
Vinod:
Level of abstraction.Jamie:Huh?Ed:A programming language is good for representingdetails like data structures and algorithms, but itÕs not so
good for representing architecture or component-to-
component collaboration...stuff like that.
Vinod:
And a screwed-up architecture can ruin even thebest code.
Jamie (thinking for a minute):So, youÕre sayingthat I canÕt represent architecture in code...thatÕs not true.

Vinod:
You can certainly imply architecture in code, but
in most programming languages, itÕs pretty difficult to get
a quick, big-picture read on architecture by examining
the code.Ed:And thatÕs what we want before we begin coding.
Jamie:Okay, maybe design and coding are different,
but I still like coding better.
SAFEHOMEpre75977_ch08.qxd  11/27/08  3:38 PM  Page 218
8.2T
HEDESIGNPROCESSSoftwaredesignisaniterativeprocessthroughwhichrequirementsaretranslated
intoaÒblueprintÓforconstructingthesoftware.Initially,theblueprintdepictsaholis-

ticviewofsoftware.Thatis,thedesignisrepresentedatahighlevelofabstractionÑ

alevelthatcanbedirectlytracedtothespecificsystemobjectiveandmoredetailed

data,functional,andbehavioralrequirements.Asdesigniterationsoccur,subse-

quentrefinementleadstodesignrepresentationsatmuchlowerlevelsofabstraction.

Thesecanstillbetracedtorequirements,buttheconnectionismoresubtle.
8.2.1Software Quality Guidelines and Attributes
Throughout the design process, the quality of the evolving design is assessed with a
series of technical reviews discussed in Chapter 15. McGlaughlin [McG91] suggests
three characteristics that serve as a guide for the evaluation of a good design:¥The design must implement all of the explicit requirements contained in the
requirements model, and it must accommodate all of the implicit require-
ments desired by stakeholders.¥The design must be a readable, understandable guide for those who generate

code and for those who test and subsequently support the software.¥Thedesignshouldprovideacompletepictureofthesoftware,addressingthe

data,functional,andbehavioraldomainsfromanimplementationperspective.
Each of these characteristics is actually a goal of the design process. But how is each
of these goals achieved?Quality Guidelines.In order to evaluate the quality of a design representation,you and other members of the software team must establish technical criteria forgood design. In Section 8.3, I discuss design concepts that also serve as software
quality criteria. For the time being, consider the following guidelines:1.A design should exhibit an architecture that (1) has been created using rec-
ognizable architectural styles or patterns, (2) is composed of components
that exhibit good design characteristics (these are discussed later in this
chapter), and (3) can be implemented in an evolutionary fashion,2therebyfacilitating implementation and testing.2.A design should be modular; that is, the software should be logically parti-
tioned into elements or subsystems.3.A design should contain distinct representations of data, architecture,

interfaces, and components.CHAPTER 8DESIGN CONCEPTS219uote:Ò...writing a
clever piece of code
that works is one
thing; designing
something that can
support a long-
lasting business is
quite another.Ó
C.Ferguson
What are thecharacteris-tics of a good
design??2For smaller systems, design can sometimes be developed linearly.
pre75977_ch08.qxd  11/27/08  3:38 PM  Page 219
4.A design should lead to data structures that are appropriate for the classes tobe implemented and are drawn from recognizable data patterns.
5.A design should lead to components that exhibit independent functional
characteristics.6.A design should lead to interfaces that reduce the complexity of connections
between components and with the external environment.
7.A design should be derived using a repeatable method that is driven by infor-
mation obtained during software requirements analysis.8.A design should be represented using a notation that effectively communi-
cates its meaning.These design guidelines are not achieved by chance. They are achieved through the
application of fundamental design principles, systematic methodology, and thorough

review.
220PART TWOMODELINGDesign is important because it allows a
software team to assess the quality3of thesoftware before it is implementedÑat a time when errors,omissions, or inconsistencies are easy and inexpensive to
correct. But how do we assess quality during design? The
software canÕt be tested, because there is no executable

software to test. What to do?Duringdesign,qualityisassessedbyconductingaseries
oftechnicalreviews(TRs).TRsarediscussedindetailin

Chapter15,
4butitÕsworthprovidingasummaryofthe
techniqueatthispoint.Atechnicalreviewisameeting

conductedbymembersofthesoftwareteam.Usuallytwo,

three,orfourpeopleparticipatedependingonthescopeof

thedesigninformationtobereviewed.Eachpersonplays
a role:the
reviewleader
plansthemeeting,setsanagenda,
andrunsthemeeting;the
recordertakesnotessothat
nothingismissed;the
produceristhepersonwhosework
product(e.g.,thedesignofasoftwarecomponent)isbeing

reviewed.Priortothemeeting,eachpersononthereview

teamisgivenacopyofthedesignworkproductandisasked

toreadit,lookingforerrors,omissions,orambiguity.When

themeetingcommences,theintentistonoteallproblems

withtheworkproductsothattheycanbecorrectedbefore

implementationbegins.TheTRtypicallylastsbetween90

minutesand2hours.AttheconclusionoftheTR,thereview

teamdetermineswhetherfurtheractionsarerequiredonthe

partoftheproducerbeforethedesignworkproductcanbe

approvedaspartofthefinaldesignmodel.
INFO3The quality factors discussed in Chapter 23 can assist the review team as it assesses quality.
4You might consider reviewing Chapter 15 at this time. Technical reviews are a critical part of the
design process and are an important mechanism for achieving design quality.Quality Attributes.Hewlett-Packard [Gra87] developed a set of software qualityattributes that has been given the acronym FURPSÑfunctionality, usability, reliabil-
ity, performance, and supportability. The FURPS quality attributes represent a target

for all software design:¥Functionalityis assessed by evaluating the feature set and capabilities of theprogram, the generality of the functions that are delivered, and the security of
the overall system.
uote:ÒQuality isnÕtsomething you lay
on top of subjects
and objects like
tinsel on a
Christmas tree.ÓRobertPirsig
Assessing Design QualityÑThe Technical Review
pre75977_ch08.qxd  11/27/08  3:38 PM  Page 220
¥Usabilityis assessed by considering human factors (Chapter 11), overall
aesthetics, consistency, and documentation.
¥Reliabilityis evaluated by measuring the frequency and severity of failure, the
accuracy of output results, the mean-time-to-failure (MTTF), the ability torecover from failure, and the predictability of the program.
¥Performanceis measured by considering processing speed, response time,
resource consumption, throughput, and efficiency.
¥Supportabilitycombines the ability to extend the program (extensibility),adaptability, serviceabilityÑthese three attributes represent a more common

term, maintainabilityÑand in addition, testability, compatibility, configura-

bility (the ability to organize and control elements of the software configura-
tion, Chapter 22), the ease with which a system can be installed, and the ease
with which problems can be localized.Not every software quality attribute is weighted equally as the software design is de-
veloped. One application may stress functionality with a special emphasis on secu-
rity. Another may demand performance with particular emphasis on processing

speed. A third might focus on reliability. Regardless of the weighting, it is important

to note that these quality attributes must be considered as design commences, not
after the design is complete and construction has begun.8.2.2The Evolution of Software Design
The evolution of software design is a continuing process that has now spanned al-
most six decades. Early design work concentrated on criteria for the development of
modular programs [Den73] and methods for refining software structures in a top-
down manner [Wir71]. Procedural aspects of design definition evolved into a philos-

ophy called structured programming
[Dah72], [Mil72]. Later work proposed methodsfor the translation of data flow [Ste74] or data structure (e.g., [Jac75], [War74]) into

a design definition. Newer design approaches (e.g., [Jac92], [Gam95]) proposed an

object-oriented approach to design derivation. More recent emphasis in software de-
sign has been on software architecture [Kru06] and the design patterns that can be
used to implement software architectures and lower levels of design abstractions
(e.g., [Hol06] [Sha05]). Growing emphasis on aspect-oriented methods (e.g., [Cla05],
[Jac04]), model-driven development [Sch06], and test-driven development [Ast04]
emphasize techniques for achieving more effective modularity and architectural
structure in the designs that are created.A number of design methods, growing out of the work just noted, are being ap-plied throughout the industry. Like the analysis methods presented in Chapters 6 and

7, each software design method introduces unique heuristics and notation, as well
as a somewhat parochial view of what characterizes design quality. Yet, all of these

methods have a number of common characteristics: (1) a mechanism for the trans-
lation of the requirements model into a design representation, (2) a notation forCHAPTER 8DESIGN CONCEPTS221Software designerstend to focus on the
problem to be solved.
Just donÕt forget that
the FURPS attributes
are always part of the

problem. They must be
considered.uote:ÒA designer knowsthat he has
achieved perfection
not when there is
nothing left to add,
but when there is
nothing left to take
away.Ó
Antoinede
St-ExpureyWhatcharacter-istics are common
to all design
methods??pre75977_ch08.qxd  11/27/08  3:38 PM  Page 221
representing functional components and their interfaces, (3) heuristics for refine-ment and partitioning, and (4) guidelines for quality assessment.Regardless of the design method that is used, you should apply a set of basic con-cepts to data, architectural, interface, and component-level design. These concepts

are considered in the sections that follow.
222PART TWOMODELINGGeneric Task Set for Design
1.Examine the information domain
model, and design appropriate datastructures for data objects and their attributes.2.Using the analysis model, select an architectural style
that is appropriate for the software.3.Partition the analysis model into design subsystems
and allocate these subsystems within the architecture:Be certain that each subsystem is functionally
cohesive.Design subsystem interfaces.
Allocate analysis classes or functions to eachsubsystem.4.Create a set of design classes or components:
Translateanalysisclassdescriptionintoadesign
class.Check each design class against design criteria;consider inheritance issues.Define methods and messages associated with eachdesign class.Evaluate and select design patterns for a design
class or a subsystem.Review design classes and revise as required.5.Design any interface required with external systems
or devices.6.Design the user interface:
Review results of task analysis.
Specify action sequence based on user scenarios.
Create behavioral model of the interface.

Define interface objects, control mechanisms.

Review the interface design and revise as required.
7.Conduct component-level design.
Specify all algorithms at a relatively low level ofabstraction.Refine the interface of each component.

Define component-level data structures.
Review each component and correct all errorsuncovered.8.Develop a deployment model.
TASKSET8.3D
ESIGNCONCEPTSA set of fundamental software design concepts has evolved over the history of soft-
ware engineering. Although the degree of interest in each concept has varied over

the years, each has stood the test of time. Each provides the software designer with

a foundation from which more sophisticated design methods can be applied. Each
helps you answer the following questions:¥What criteria can be used to partition software into individual components?¥How is function or data structure detail separated from a conceptual repre-
sentation of the software?¥What uniform criteria define the technical quality of a software design?M. A. Jackson [Jac75] once said: ÒThe beginning of wisdom for a [software engi-neer] is to recognize the difference between getting a program to work, and getting
it right.Ó Fundamental software design concepts provide the necessary framework

for Ògetting it right.Ópre75977_ch08.qxd  11/27/08  3:38 PM  Page 222
In the sections that follow, I present a brief overview of important software design
concepts that span both traditional and object-oriented software development.8.3.1Abstraction
When you consider a modular solution to any problem, many levels of abstractioncan be posed. At the highest level of abstraction, a solution is stated in broad terms
using the language of the problem environment. At lower levels of abstraction, a

more detailed description of the solution is provided. Problem-oriented terminology

is coupled with implementation-oriented terminology in an effort to state a solution.
Finally, at the lowest level of abstraction, the solution is stated in a manner that can

be directly implemented.As different levels of abstraction are developed, you work to create both proce-dural and data abstractions. A procedural abstraction
refers to a sequence of instruc-tions that have a specific and limited function. The name of a procedural abstraction
implies these functions, but specific details are suppressed. An example of a proce-
dural abstraction would be the word openfor a door. 
Openimplies a long sequenceof procedural steps (e.g., walk to the door, reach out and grasp knob, turn knob and

pull door, step away from moving door, etc.).
5A data abstraction
is a named collection of data that describes a data object. Inthecontext of the procedural abstraction 
open,we can define a data abstractioncalled door.
Like any data object, the data abstraction for doorwould encompassaset of attributes that describe the door (e.g., door type, swing direction, opening

mechanism, weight, dimensions). It follows that the procedural abstraction open
would make use of information contained in the attributes of the data abstraction
door.
8.3.2Architecture
Software architecture
alludes to Òthe overall structure of the software and the ways
inwhich that structure provides conceptual integrity for a systemÓ [Sha95a]. In its

simplest form, architecture is the structure or organization of program components
(modules), the manner in which these components interact, and the structure of data
that are used by the components. In a broader sense, however, components can be

generalized to represent major system elements and their interactions.One goal of software design is to derive an architectural rendering of a system.This rendering serves as a framework from which more detailed design activities are
conducted. A set of architectural patterns enables a software engineer to solve
common design problems.CHAPTER 8DESIGN CONCEPTS223uote:ÒAbstraction is oneof the fundamental
ways that we as
humans cope with
complexity.Ó
GradyBooch
5It should be noted, however, that one set of operations can be replaced with another, as long as the
function implied by the procedural abstraction remains the same. Therefore, the steps required toimplement openwould change dramatically if the door were automatic and attached to a sensor.As a designer, work
hard to derive both
procedural and data
abstractions that serve

the problem at hand.
Ifthey can serve an

entire domain of
problems, thatÕs even

better.
WebRef
An in-depth discussionof software architecture
can be found at
www.sei.cmu.edu/

ata/ata_init.html.pre75977_ch08.qxd  11/27/08  3:38 PM  Page 223
Shaw and Garlan [Sha95a] describe a set of properties that should be specified as
part of an architectural design:Structural properties.
This aspect of the architectural design representation definesthe components of a system (e.g., modules, objects, filters) and the manner in whichthose components are packaged and interact with one another. For example, objects are

packaged to encapsulate both data and the processing that manipulates the data and in-
teract via the invocation of methods.
Extra-functional properties.
The architectural design description should addresshow the design architecture achieves requirements for performance, capacity, reliability,

security, adaptability, and other system characteristics.
Families of related systems.
The architectural design should draw upon repeatable
patterns that are commonly encountered in the design of families of similar systems. In
essence, the design should have the ability to reuse architectural building blocks.
Given the specification of these properties, the architectural design can be repre-sented using one or more of a number of different models [Gar95]. Structural models
represent architecture as an organized collection of program components.
Framework models
increase the level of design abstraction by attempting to identifyrepeatable architectural design frameworks that are encountered in similar types of
applications. Dynamic modelsaddress the behavioral aspects of the program archi-tecture, indicating how the structure or system configuration may change as a func-

tion of external events. Process modelsfocus on the design of the business ortechnical process that the system must accommodate. Finally, 
functional modelscanbe used to represent the functional hierarchy of a system.A number of different architectural description languages
(ADLs) have been devel-oped to represent these models [Sha95b]. Although many different ADLs have been
proposed, the majority provide mechanisms for describing system components and

the manner in which they are connected to one another.
You should note that there is some debate about the role of architecture in design.
Some researchers argue that the derivation of software architecture should be sep-
arated from design and occurs between requirements engineering actions and more
conventional design actions. Others believe that the derivation of architecture is an

integral part of the design process. The manner in which software architecture is
characterized and its role in design are discussed in Chapter 9.8.3.3Patterns
Brad Appleton defines a design patternin the following manner: ÒA pattern is anamed nugget of insight which conveys the essence of a proven solution to a recur-

ring problem within a certain context amidst competing concernsÓ [App00]. Stated
in another way, a design pattern describes a design structure that solves a particular

design problem within a specific context and amid ÒforcesÓ that may have an impact
on the manner in which the pattern is applied and used.224PART TWOMODELINGuote:ÒA softwarearchitecture is the
development work
product that gives
the highest return
on investment with
respect to quality,

schedule, and
cost.ÓLenBasset al.
DonÕt just let architec-ture happen. If you do,
youÕll spend the rest of
the project trying to

force fit the design.
Design architecture
explicitly.
uote:ÒEach patterndescribes a
problem which
occurs over and
over again in our
environment, and
then describes the
core of the solution
to that problem, in
such a way that
you can use this
solution a million
times over, without

ever doing it the
same way twice.ÓChristopherAlexanderpre75977_ch08.qxd  11/27/08  3:38 PM  Page 224
The intent of each design pattern is to provide a description that enables a
designer to determine (1) whether the pattern is applicable to the current work,(2)whether the pattern can be reused (hence, saving design time), and (3) whether

the pattern can serve as a guide for developing a similar, but functionally or struc-

turally different pattern. Design patterns are discussed in detail in Chapter 12.8.3.4Separation of Concerns
Separation of concerns
is a design concept [Dij82] that suggests that any complexproblem can be more easily handled if it is subdivided into pieces that can each be
solved and/or optimized independently. A 
concernis a feature or behavior that isspecified as part of the requirements model for the software. By separating concerns
into smaller, and therefore more manageable pieces, a problem takes less effort and

time to solve.For two problems, p1and p2, if the perceived complexity of p1is greater than theperceived complexity of p2, it follows that the effort required to solve p1is greaterthan the effort required to solve p2. As a general case, this result is intuitively obvi-
ous. It does take more time to solve a difficult problem.It also follows that the perceived complexity of two problems when they are com-bined is often greater than the sum of the perceived complexity when each is taken
separately. This leads to a divide-and-conquer strategyÑitÕs easier to solve a com-

plex problem when you break it into manageable pieces. This has important impli-
cations with regard to software modularity.Separation of concerns is manifested in other related design concepts: modular-ity, aspects, functional independence, and refinement. Each will be discussed in the

subsections that follow.
8.3.5Modularity
Modularity is the most common manifestation of separation of concerns. Software
is divided into separately named and addressable components, sometimes called
modules,that are integrated to satisfy problem requirements.IthasbeenstatedthatÒmodularityisthesingleattributeofsoftwarethatallowsa
programtobeintellectuallymanageableÓ[Mye78].Monolithicsoftware(i.e.,alarge

programcomposedofasinglemodule)cannotbeeasilygraspedbyasoftwareengi-

neer.Thenumberofcontrolpaths,spanofreference,numberofvariables,andover-

allcomplexitywouldmakeunderstandingclosetoimpossible.Inalmostall

instances,youshouldbreakthedesignintomanymodules,hopingtomakeunder-

standingeasierand,asaconsequence,reducethecostrequiredtobuildthesoftware.
Recalling my discussion of separation of concerns, it is possible to conclude thatif you subdivide software indefinitely the effort required to develop it will become
negligibly small! Unfortunately, other forces come into play, causing this conclusion

to be (sadly) invalid. Referring to Figure 8.2, the effort (cost) to develop an individual

software module does decrease as the total number of modules increases. Given theCHAPTER 8DESIGN CONCEPTS225The argument for sepa-ration of concerns can

be taken too far. If

you divide a problem
into an inordinate
number of very

smallproblems,

solving each will be
easy, but putting the

solution togetherÑ
integrationÑ
may be very difficult.
pre75977_ch08.qxd  11/27/08  3:38 PM  Page 225
same set of requirements, more modules means smaller individual size. However, as
the number of modules grows, the effort (cost) associated with integrating the mod-
ules also grows. These characteristics lead to a total cost or effort curve shown in the
figure. There is a number, 
M,of modules that would result in minimum developmentcost, but we do not have the necessary sophistication to predict Mwith assurance.The curves shown in Figure 8.2do provide useful qualitative guidance when mod-
ularity is considered. You should modularize, but care should be taken to stay in the

vicinity of M.Undermodularity or overmodularity should be avoided. But how do you
know the vicinity of M? How modular should you make software? The answers to
these questions require an understanding of other design concepts considered later
in this chapter.
You modularize a design (and the resulting program) so that development can be
more easily planned; software increments can be defined and delivered; changes can
be more easily accommodated; testing and debugging can be conducted more effi-
ciently, and long-term maintenance can be conducted without serious side effects.
8.3.6Information Hiding
The concept of modularity leads you to a fundamental question: ÒHow do I decom-
pose a software solution to obtain the best set of modules?Ó The principle of infor-
mation hiding [Par72] suggests that modules be Òcharacterized by design decisions
that (each) hides from all others.Ó In other words, modules should be specified and
designed so that information (algorithms and data) contained within a module is in-
accessible to other modules that have no need for such information.Hidingimpliesthateffectivemodularitycanbeachievedbydefiningasetofinde-
pendentmodulesthatcommunicatewithoneanotheronlythatinformationneces-

sarytoachievesoftwarefunction.Abstractionhelpstodefinetheprocedural(or

informational)entitiesthatmakeupthesoftware.Hidingdefinesandenforcesaccess

constraintstobothproceduraldetailwithinamoduleandanylocaldatastructure

usedbythemodule[Ros75].
226PART TWOMODELINGMRegion of minimumcostNumber of modulesCost or effort
Cost/moduleCost to integrateTotal software cos
tFIGURE8.2Modularityand software

costWhat is theright numberof modules for a
given system??The intent of information
hiding is to hide the
details of data structures

and procedural processing
behind a module inter-
face. Knowledge of the
details need not be
known by users of the
module.pre75977_ch08.qxd  11/27/08  3:38 PM  Page 226
The use of information hiding as a design criterion for modular systems provides
the greatest benefits when modifications are required during testing and later dur-ing software maintenance. Because most data and procedural detail are hidden from
other parts of the software, inadvertent errors introduced during modification are

less likely to propagate to other locations within the software.8.3.7Functional Independence
The concept of functional independence is a direct outgrowth of separation of con-
cerns, modularity, and the concepts of abstraction and information hiding. In land-

mark papers on software design, Wirth [Wir71] and Parnas [Par72] allude to

refinement techniques that enhance module independence. Later work by Stevens,
Myers, and Constantine [Ste74] solidified the concept.Functional independence is achieved by developing modules with Òsingle-mindedÓ function and an ÒaversionÓ to excessive interaction with other modules.
Stated another way, you should design software so that each module addresses a

specific subset of requirements and has a simple interface when viewed from other
parts of the program structure. It is fair to ask why independence is important.Software with effective modularity, that is, independent modules, is easier to de-
velop because function can be compartmentalized and interfaces are simplified
(consider the ramifications when development is conducted by a team). Independent
modules are easier to maintain (and test) because secondary effects caused by de-
sign or code modification are limited, error propagation is reduced, and reusable
modules are possible. To summarize, functional independence is a key to good de-

sign, and design is the key to software quality.
Independence is assessed using two qualitative criteria: cohesion and coupling.Cohesionis an indication of the relative functional strength of a module. Couplingisan indication of the relative interdependence among modules.Cohesion is a natural extension of the information-hiding concept described inSection 8.3.6. A cohesive module performs a single task, requiring little interaction
with other components in other parts of a program. Stated simply, a cohesive mod-

ule should (ideally) do just one thing. Although you should always strive for high co-
hesion (i.e., single-mindedness), it is often necessary and advisable to have a
software component perform multiple functions. However, ÒschizophrenicÓ compo-

nents (modules that perform many unrelated functions) are to be avoided if a good
design is to be achieved.Coupling is an indication of interconnection among modules in a software struc-ture. Coupling depends on the interface complexity between modules, the point at
which entry or reference is made to a module, and what data pass across the inter-

face. In software design, you should strive for the lowest possible coupling. Simple
connectivity among modules results in software that is easier to understand and less
prone to a Òripple effectÓ [Ste74], caused when errors occur at one location and prop-
agate throughout a system.CHAPTER 8DESIGN CONCEPTS227Why shouldyou strivetocreate

independent
modules??Cohesion is aqualitative indication
of the degree to which
a module focuses on
just one thing.Coupling is aqualitative indication of
the degree to which a
module is connected to
other modules and to
the outside world.pre75977_ch08.qxd  11/27/08  3:38 PM  Page 227
8.3.8Refinement
Stepwise refinement is a top-down design strategy originally proposed by NiklausWirth [Wir71]. A program is developed by successively refining levels of procedural

detail. A hierarchy is developed by decomposing a macroscopic statement of func-
tion (a procedural abstraction) in a stepwise fashion until programming language
statements are reached.Refinement is actually a process of elaboration.
You begin with a statement of
function (or description of information) that is defined at a high level of abstraction.
That is, the statement describes function or information conceptually but provides

no information about the internal workings of the function or the internal structure
of the information. You then elaborate on the original statement, providing more and

more detail as each successive refinement (elaboration) occurs.Abstraction and refinement are complementary concepts. Abstraction enablesyou to specify procedure and data internally but suppress the need for ÒoutsidersÓ to
have knowledge of low-level details. Refinement helps you to reveal low-level de-
tails as design progresses. Both concepts allow you to create a complete design
model as the design evolves.8.3.9Aspects
As requirements analysis occurs, a set of ÒconcernsÓ is uncovered. These concerns

Òinclude requirements, use cases, features, data structures, quality-of-service issues,
variants, intellectual property boundaries, collaborations, patterns and contractsÓ
[AOS07]. Ideally, a requirements model can be organized in a way that allows you to

isolate each concern (requirement) so that it can be considered independently. In

practice, however, some of these concerns span the entire system and cannot be

easily compartmentalized.As design begins, requirements are refined into a modular design representation.Consider two requirements, Aand B.Requirement A crosscutsrequirement BÒif asoftware decomposition [refinement] has been chosen in which Bcannot be satis-fied without taking Ainto accountÓ [Ros04].For example, consider two requirements for the 
SafeHomeAssured.comWebApp.
Requirement Ais described via the ACS-DCV
use case discussed in Chapter6. A
design refinement would focus on those modules that would enable a registered user
to access video from cameras placed throughout a space. Requirement Bis a genericsecurity requirement that states that a registered user must be validated prior to using

SafeHomeAssured.com.This requirement is applicable for all functions that areavailable to registered SafeHomeusers. As design refinement occurs, A*is a designrepresentation for requirement Aand B*is a design representation for requirement B.Therefore, 
A*and B*are representations of concerns, and B* crosscuts A*.An aspectis a representation of a crosscutting concern. Therefore, the design rep-
resentation, B*, of the requirement a registered user must be validated prior to using
SafeHomeAssured.com,is an aspect of the SafeHomeWebApp. It is important to
228PART TWOMODELINGThere is a tendency tomove immediately to
full detail, skipping
refinement steps. This
leads to errors and

omissions and makes
the design much more
difficult to review.

Perform stepwise

refinement.uote:ÒItÕs hard to read
through a book on
the principles of
magic without
glancing at the
cover periodically
to make sure it
isnÕt a book on
software design.ÓBruceTognazzini
A crosscutting concern
is some characteristicof the system that
applies across many
different requirements.pre75977_ch08.qxd  11/27/08  3:38 PM  Page 228
identify aspects so that the design can properly accommodate them as refinementand modularization occur. In an ideal context, an aspect is implemented as a sepa-

rate module (component) rather than as software fragments that are ÒscatteredÓ or
ÒtangledÓ throughout many components [Ban06]. To accomplish this, the design ar-

chitecture should support a mechanism for defining an aspectÑa module that en-
ables the concern to be implemented across all other concerns that it crosscuts.8.3.10Refactoring
An important design activity suggested for many agile methods (Chapter 3),
refactoringis a reorganization technique that simplifies the design (or code) of acomponent without changing its function or behavior. Fowler [Fow00] defines refac-

toring in the following manner: ÒRefactoring is the process of changing a software
system in such a way that it does not alter the external behavior of the code [design]
yet improves its internal structure.Ó
Whensoftwareisrefactored,theexistingdesignisexaminedforredundancy,un-
useddesignelements,inefficientorunnecessaryalgorithms,poorlyconstructedor

inappropriatedatastructures,oranyotherdesignfailurethatcanbecorrectedtoyield

abetterdesign.Forexample,afirstdesigniterationmightyieldacomponentthat

exhibitslowcohesion(i.e.,itperformsthreefunctionsthathaveonlylimitedrelation-

shiptooneanother).Aftercarefulconsideration,youmaydecidethatthecomponent

shouldberefactoredintothreeseparatecomponents,eachexhibitinghighcohesion.
CHAPTER 8DESIGN CONCEPTS229WebRef
Excellent resources forrefactoring can be
found at www
.refactoring.com.WebRef
A variety of refactoringpatterns can be foundat

http://c2.com/cgi/

wiki?Refactoring
Patterns.Design ConceptsThe scene:VinodÕs cubicle, as
design modeling begins.The players:Vinod, Jamie, and EdÑmembers of the
SafeHomesoftware engineering team. Also, Shakira, anew member of the team.
The conversation:
[All four team members have just returned from a morning
seminar entitiled ÒApplying Basic Design Concepts,Ó
offered by a local computer science professor.]
Vinod:
Did you get anything out of the seminar?Ed:Knew most of the stuff, but itÕs not a bad idea to hear
it again, I suppose.
Jamie:When I was an undergrad CS major, I never
really understood why information hiding was as
important as they say it is.
Vinod:
Because . . . bottom line . . . itÕs a technique for
reducing error propagation in a program. Actually,
functional independence also accomplishes the same thing.Shakira:I wasnÕt a CS grad, so a lot of the stuff the
instructor mentioned is new to me. I can generate
goodcode and fast. I donÕt see why this stuff is so

important.
Jamie:IÕve seen your work, Shak, and you know what,you do a lot of this stuff naturally
...thatÕs why your
designs and code work.
Shakira (smiling):Well, I always do try to partition
the code, keep it focused on one thing, keep interfaces
simple and constrained, reuse code whenever I can...

that sort of thing.
Ed:Modularity, functional independence, hiding, 
patterns
...see.
Jamie:Istillremembertheveryfirstprogramming
courseItook
...theytaughtustorefinethecode
iteratively.

Vinod:
Same thing can be applied to design, you know.
Vinod:
The only concepts I hadnÕt heard of before were
ÒaspectsÓ and Òrefactoring.ÓSAFEHOMEpre75977_ch08.qxd  11/27/08  3:38 PM  Page 229
Theresultwillbesoftwarethatiseasiertointegrate,easiertotest,andeasierto
maintain.8.3.11Object-Oriented Design Concepts
The object-oriented (OO) paradigm is widely used in modern software engineering.
Appendix 2 has been provided for those readers who may be unfamiliar with OO

design concepts such as classes and objects, inheritance, messages, and polymor-

phism, among others.8.3.12Design Classes
The requirements model defines a set of analysis classes (Chapter 6). Each describes
some element of the problem domain, focusing on aspects of the problem that are
user visible. The level of abstraction of an analysis class is relatively high.As the design model evolves, you will define a set of design classesthat refine theanalysis classes by providing design detail that will enable the classes to be imple-

mented, and implement a software infrastructure that supports the business solu-
tion. Five different types of design classes, each representing a different layer of the
design architecture, can be developed [Amb01]:
¥User interface classesdefine all abstractions that are necessary for human-computer interaction (HCI). In many cases, HCI occurs within the context of 
a metaphor(e.g., a checkbook, an order form, a fax machine), and the designclasses for the interface may be visual representations of the elements of the
metaphor.
¥Business domain classesare often refinements of the analysis classes definedearlier. The classes identify the attributes and services (methods) that are

required to implement some element of the business domain.¥Process classesimplement lower-level business abstractions required to fullymanage the business domain classes.¥Persistent classesrepresent data stores (e.g., a database) that will persistbeyond the execution of the software.¥System classesimplement software management and control functions thatenable the system to operate and communicate within its computing envi-

ronment and with the outside world.230PART TWOMODELINGShakira:ThatÕs used in Extreme Programming, I think
she said.Ed:Yep.ItÕsnotawholelotdifferentthanrefinement,only
youdoitafterthedesignorcodeiscompleted.Kindofan
optimizationpassthroughthesoftware,ifyouaskme.
Jamie:LetÕs get back to 
SafeHomedesign. I think weshould put these concepts on our review checklist as we
develop the design model for SafeHome.Vinod:
I agree. But as important, letÕs all commit to think
about them as we develop the design.What typesof classesdoes the designer
create??pre75977_ch08.qxd  11/27/08  3:38 PM  Page 230
As the architecture forms, the level of abstraction is reduced as each analysis classis transformed into a design representation. That is, analysis classes represent data
objects (and associated services that are applied to them) using the jargon of the
business domain. Design classes present significantly more technical detail as a
guide for implementation.Arlow and Neustadt [Arl02] suggest that each design class be reviewed to ensurethat it is Òwell-formed.Ó They define four characteristics of a well-formed design
class:Complete and sufficient.A design class should be the complete encapsu-lation of all attributes and methods that can reasonably be expected (based
on a knowledgeable interpretation of the class name) to exist for the class.
For example, the class 
Scenedefined for video-editing software is completeonly if it contains all attributes and methods that can reasonably be associ-
ated with the creation of a video scene. Sufficiency ensures that the design
class contains only those methods that are sufficient to achieve the intent of
the class, no more and no less.Primitiveness.
Methods associated with a design class should be focusedon accomplishing one service for the class. Once the service has been imple-mented with a method, the class should not provide another way to accom-

plish the same thing. For example, the class 
VideoClip
for video-editingsoftware might have attributes start-pointandend-pointto indicate the startand end points of the clip (note that the raw video loaded into the system

may be longer than the clip that is used). The methods, setStartPoint()andsetEndPoint(),provide the only means for establishing start and end points
forthe clip.
Highcohesion.
Acohesivedesignclasshasasmall,focusedsetofresponsi-
bilitiesandsingle-mindedlyappliesattributesandmethodstoimplement
thoseresponsibilities.Forexample,theclass
VideoClip
mightcontainasetof
methodsforeditingthevideoclip.Aslongaseachmethod focusessolelyon

attributesassociatedwiththevideoclip,cohesionismaintained.
Low coupling.
Within the design model, it is necessary for design classes to
collaborate with one another. However, collaboration should be kept to an
acceptable minimum. If a design model is highly coupled (all design classes
collaborate with all other design classes), the system is difficult to implement,
to test, and to maintain over time. In general, design classes within a subsys-

tem should have only limited knowledge of other classes. This restriction,
called the Law of Demeter[Lie03], suggests that a method should only sendmessages to methods in neighboring classes.6CHAPTER 8DESIGN CONCEPTS231What is aÒwell-formedÓ design
class??6A less formal way of stating the Law of Demeter is ÒEach unit should only talk to its friends; DonÕt
talk to strangers.Ópre75977_ch08.qxd  11/27/08  3:38 PM  Page 231
232PART TWOMODELINGThe scene:EdÕs cubicle, as design
modeling begins.The players:Vinod and EdÑmembers of the
SafeHomesoftware engineering team.The conversation:
[Ed is working on the FloorPlanclass (see sidebar dis-cussion in Section 6.5.3 and Figure 6.10) and has refinedit for the design model.]Ed:So you remember the FloorPlanclass, right? ItÕs
used as part of the surveillance and home management
functions.Vinod (nodding):
Yeah, I seem to recall that we used
it as part of our CRC discussions for home management.

Ed:Wedid.Anyway,IÕmrefiningitfordesign.Wantto
showhowweÕllactuallyimplementthe
FloorPlanclass.Myideaistoimplementitasasetoflinkedlists[a
specificdatastructure]So
...Ihadto
refinetheanalysis
classFloorPlan(Figure6.10)andactually,sortof
simplifyit.
Vinod:
The analysis class showed only things in theproblem domain, well, actually on the computer screen,
that were visible to the end user, right?
Ed:Yep, but for the 
FloorPlandesign class, IÕve gottoadd some things that are implementation specific. I
needed to show that FloorPlanis an aggregation ofsegmentsÑhence the SegmentclassÑand that theSegmentclass is composed of lists for wall segments,windows, doors, and so on. The class Cameracollaborates with FloorPlan,and obviously, there can
be many cameras in the floor plan.Vinod:
Phew, letÕs see a picture of this new 
FloorPlandesign class.
[Ed shows Vinod the drawing shown in Figure 8.3.]

Vinod:
Okay, I see what youÕre trying to do. This allows
you to modify the floor plan easily because new items canbe added to or deleted from the listÑthe aggregationÑ
without any problems.
Ed (nodding):Yeah, I think itÕll work.
Vinod:
So do I.SAFEHOMEFloorPlanaddCamera( ) addWall( ) 

addWindow( ) 

deleteSegment( ) 
draw( )  type 
outsideDimensions  WallSegment
SegmentstartCoordinate 

endCoordinate getType( ) 
draw( )WindowCameratype id 
fieldView 

panAngle
zoomSetting  1*1*FIGURE8.3Design class
for FloorPlan
and composite
aggregation

for the class
(see sidebar
discussion)Refining an Analysis Class into a Design Class
pre75977_ch08.qxd  11/27/08  3:38 PM  Page 232
8.4T
HEDESIGNMODELThedesignmodelcanbeviewedintwodifferentdimensionsasillustratedin
Figure8.4.The
processdimension
indicatestheevolutionofthedesignmodelasde-
signtasksareexecutedaspartofthesoftwareprocess.The
abstractiondimension
representsthelevelofdetailaseachelementoftheanalysismodelistransformed

intoadesignequivalentandthenrefinediteratively.ReferringtoFigure 8.4,the

dashedlineindicatestheboundarybetweentheanalysisanddesignmodels.Insome

cases,acleardistinctionbetweentheanalysisanddesignmodelsispossible.Inother

cases,theanalysismodelslowlyblendsintothedesignandacleardistinctionisless

obvious.The elements of the design model use many of the same UML diagrams7thatwere used in the analysis model. The difference is that these diagrams are refined
and elaborated as part of design; more implementation-specific detail is provided,

and architectural structure and style, components that reside within the architec-

ture, and interfaces between the components and with the outside world are all

emphasized.CHAPTER 8DESIGN CONCEPTS233Process dimension
Abstraction dimensionArchitecture elementsInterface 
elementsComponent-level elementsDeployment-level elementsLowHighClass diagrams Analysis packages 
CRC models 
Collaboration 
   diagrams 
Data flow diagrams 
Control-flow diagrams 
Processing narrativesUse cases - text 
Use-case diagrams 
Activity diagrams 
Swimlane diagrams 
Collaboration 
   diagrams
State diagrams
Sequence diagramsDesign class 
   realizations
Subsystems 
Collaboration 
   diagrams Refinements to:Deployment diagramsClass diagrams
Analysis packages
CRC models
Collaboration diagrams
Data flow diagrams
Control-flow diagrams
Processing narratives
State diagrams
Sequence diagramsComponent diagrams
Design classes 
Activity diagrams 
Sequence diagrams Refinements to:Component diagrams
Design classes 
Activity diagrams 
Sequence diagrams Design class realizations 
Subsystems 
Collaboration diagrams 
Component diagrams 
Design classes 
Activity diagrams 
Sequence diagramsAnalysis modelDesign modelRequirements:  Constraints  Interoperability
  Targets and

      configurationTechnical interface

 design  
Navigation design 
GUI design     Design class 
      realizations 
   Subsystems 
   Collaboration 
      diagrams FIGURE8.4Dimensions of the design modelThe design model hasfour major elements:
data, architecture,
components, and 
interface.
7Appendix 1 provides a tutorial on basic UML concepts and notation.
pre75977_ch08.qxd  11/27/08  3:38 PM  Page 233
Youshouldnote,however,thatmodelelementsindicatedalongthehorizontalaxis
arenotalwaysdevelopedinasequentialfashion.Inmostcasespreliminaryarchitec-
turaldesignsetsthestageandisfollowedbyinterfacedesignandcomponent-level

design,whichoftenoccurinparallel.Thedeploymentmodelisusuallydelayeduntil

thedesignhasbeenfullydeveloped.
You can apply design patterns (Chapter 12) at any point during design. These pat-
terns enable you to apply design knowledge to domain-specific problems that have
been encountered and solved by others.8.4.1Data Design Elements
Like other software engineering activities, data design (sometimes referred to as data
architecting
) creates a model of data and/or information that is represented at a high
level of abstraction (the customer/userÕs view of data). This data model is then re-

fined into progressively more implementation-specific representations that can be
processed by the computer-based system. In many software applications, the archi-
tecture of the data will have a profound influence on the architecture of the software
that must process it.The structure of data has always been an important part of software design. Atthe program component level, the design of data structures and the associated
algorithms required to manipulate them is essential to the creation of high-quality
applications. At the application level, the translation of a data model (derived as part
of requirements engineering) into a database is pivotal to achieving the business
objectives of a system. At the business level, the collection of information stored in
disparate databases and reorganized into a Òdata warehouseÓ enables data mining
or knowledge discovery that can have an impact on the success of the business itself.

In every case, data design plays an important role. Data design is discussed in more

detail in Chapter 9.8.4.2Architectural Design Elements
The architectural design
for software is the equivalent to the floor plan of a house. Thefloor plan depicts the overall layout of the rooms; their size, shape, and relationship

to one another; and the doors and windows that allow movement into and out of the

rooms. The floor plan gives us an overall view of the house. Architectural design el-

ements give us an overall view of the software.
The architectural model [Sha96] is derived from three sources: (1) informationabout the application domain for the software to be built; (2) specific requirements
model elements such as data flow diagrams or analysis classes, their relationships
and collaborations for the problem at hand; and (3) the availability of architectural
styles (Chapter 9) and patterns (Chapter 12).The architectural design element is usually depicted as a set of interconnectedsubsystems, often derived from analysis packages within the requirements model.
Each subsystem may have itÕs own architecture (e.g., a graphical user interface might
234PART TWOMODELINGuote:ÒQuestions aboutwhether design
isnecessary or

affordable are
quite beside the
point: design is
inevitable. The
alternative to 
good design is bad
design, not no
design at all.ÓDouglasMartin
At the architectural(application) level,
data design focuses on
files or databases; at
the component level,
data design considers
the data structures that

are required to
implement local data
objects.uote:ÒYou can use an

eraser on the
drafting table or a
sledge hammer on
the construction
site.ÓFrankLloyd
Wright
pre75977_ch08.qxd  11/27/08  3:38 PM  Page 234
be structured according to a preexisting architectural style for user interfaces). Tech-
niques for deriving specific elements of the architectural model are presented in
Chapter 9.8.4.3Interface Design Elements
The interface design for software is analogous to a set of detailed drawings (and

specifications) for the doors, windows, and external utilities of a house. These
drawings depict the size and shape of doors and windows, the manner in which they

operate, the way in which utility connections (e.g., water, electrical, gas, telephone)

come into the house and are distributed among the rooms depicted in the floor plan.
They tell us where the doorbell is located, whether an intercom is to be used to an-
nounce a visitorÕs presence, and how a security system is to be installed. In essence,

the detailed drawings (and specifications) for the doors, windows, and external util-

ities tell us how things and information flow into and out of the house and within the
rooms that are part of the floor plan. The interface design elements for software de-
pict information flows into and out of the system and how it is communicated among
the components defined as part of the architecture.There are three important elements of interface design: (1) the user interface (UI);(2) external interfaces to other systems, devices, networks, or other producers or
consumers of information; and (3) internal interfaces between various design com-
ponents. These interface design elements allow the software to communicate exter-
nally and enable internal communication and collaboration among the components
that populate the software architecture.UI design (increasingly called usability design) is a major software engineering ac-tion and is considered in detail in Chapter 11. Usability design incorporates aesthetic
elements (e.g., layout, color, graphics, interaction mechanisms), ergonomic ele-

ments (e.g., information layout and placement, metaphors, UI navigation), and tech-
nical elements (e.g., UI patterns, reusable components). In general, the UI is a unique
subsystem within the overall application architecture.
The design of external interfaces requires definitive information about the entityto which information is sent or received. In every case, this information should be

collected during requirements engineering (Chapter 5) and verified once the inter-
face design commences.8The design of external interfaces should incorporate errorchecking and (when necessary) appropriate security features.The design of internal interfaces is closely aligned with component-level design(Chapter 10). Design realizations of analysis classes represent all operations and the
messaging schemes required to enable communication and collaboration between
operations in various classes. Each message must be designed to accommodate
therequisite information transfer and the specific functional requirements of the
CHAPTER 8DESIGN CONCEPTS235uote:ÒThe public is morefamiliar with bad
design than good
design. It is, in
effect, conditioned
to prefer bad
design, because
that is what it lives
with. The new
becomes
threatening, the
old reassuring.ÓPaulRand
There are three parts
to the interface design

element: the user
interface, interfaces to

system external to the

application, and inter-
faces to components
within the application.uote:ÒEverynowand

thengoaway,have

alittlerelaxation,

forwhenyoucome

backtoyourwork

yourjudgmentwill

besurer.Gosome

distanceaway

becausethenthe

workappears

smallerandmore

ofitcanbetakenin

ataglanceanda

lackofharmony

andproportionis

morereadilyseen.Ó
LeonardoDaVinci8Interface characteristics can change with time. Therefore, a designer should ensure that the spec-
ification for the interface is accurate and complete.pre75977_ch08.qxd  11/27/08  3:38 PM  Page 235
operation that has been requested. If the classic input-process-output approach todesign is chosen, the interface of each software component is designed based on data
flow representations and the functionality described in a processing narrative.In some cases, an interface is modeled in much the same way as a class. In UML,an interface is defined in the following manner [OMG03a]: ÒAn interface is a speci-
fier for the externally-visible [public] operations of a class, component, or other clas-
sifier (including subsystems) without specification of internal structure.Ó Stated more
simply, an interface is a set of operations that describes some part of the behavior of

a class and provides access to these operations.
For example, the 
SafeHomesecurity function makes use of a control panel that al-lows a homeowner to control certain aspects of the security function. In an advanced
version of the system, control panel functions may be implemented via a wireless
PDA or mobile phone.
The ControlPanel
class (Figure 8.5) provides the behavior associated with a key-
pad, and therefore, it must implement the operations 
readKeyStroke ()
and decodeKey ().If these operations are to be provided to other classes (in this case, 
WirelessPDA

andMobilePhone), it is useful to define an interface as shown in the figure. Theinterface, named 
KeyPad, is shown as an <<interface>> stereotype or as a small,
labeled circle connected to the class with a line. The interface is defined with no
attributes and the set of operations that are necessary to achieve the behavior of
akeypad.
The dashed line with an open triangle at its end (Figure 8.5) indicates that theControlPanel
class provides 
KeyPadoperations as part of its behavior. In UML, this
236PART TWOMODELINGControlPanel
LCDdisplay LEDindicators 
keyPadCharacteristics 
speaker 
wirelessInterface 
readKeyStroke( ) decodeKey( ) 
displayStatus( ) 
lightLEDs( ) 
sendControlMsg( )KeyPadreadKeystroke( ) 
decodeKey( ) <<Interface>>
WirelessPDAMobilePhoneKeyPadFIGURE8.5Interface
representation

for Control-

PanelWebRef
Extremely valuableinformation on UI

design can be found at
www.useit.com
.uote:ÒA commonmistake that
people make when
trying to design

something
completely
foolproof was to
underestimate the
ingenuity of
complete fools.ÓDouglasAdams
pre75977_ch08.qxd  11/27/08  3:39 PM  Page 236
is characterized as a realization.That is, part of the behavior of ControlPanel
willbe implemented by realizing KeyPadoperations. These operations will be provided
to other classes that access the interface.8.4.4Component-Level Design Elements
The component-level design for software is the equivalent to a set of detailed draw-
ings (and specifications) for each room in a house. These drawings depict wiring and

plumbing within each room, the location of electrical receptacles and wall switches,
faucets, sinks, showers, tubs, drains, cabinets, and closets. They also describe the
flooring to be used, the moldings to be applied, and every other detail associated
with a room. The component-level design for software fully describes the internal
detail of each software component. To accomplish this, the component-level design

defines data structures for all local data objects and algorithmic detail for all pro-
cessing that occurs within a component and an interface that allows access to all
component operations (behaviors).Within the context of object-oriented software engineering, a component is rep-
resented in UML diagrammatic form as shown in Figure 8.6. In this figure, a compo-

nent named SensorManagement(part of the SafeHomesecurity function) isrepresented. A dashed arrow connects the component to a class named Sensorthatis assigned to it. The SensorManagementcomponent performs all functions asso-ciated with SafeHomesensors including monitoring and configuring them. Furtherdiscussion of component diagrams is presented in Chapter 10.The design details of a component can be modeled at many different levels ofabstraction. A UML activity diagram can be used to represent processing logic.
Detailed procedural flow for a component can be represented using either
pseudocode (a programming language-like representation described in Chapter 10)
or some other diagrammatic form (e.g., flowchart or box diagram). Algorithmic
structure follows the rules established for structured programming (i.e., a set of con-
strained procedural constructs). Data structures, selected based on the nature of the
data objects to be processed, are usually modeled using pseudocode or the pro-
gramming language to be used for implementation.8.4.5Deployment-Level Design Elements
Deployment-level design elements indicate how software functionality and subsys-
tems will be allocated within the physical computing environment that will support
CHAPTER 8DESIGN CONCEPTS237uote:ÒThe details arenot the details.
They make the
design.ÓCharlesEames
SensorManagementSensorFIGURE8.6A UMLcomponent
diagrampre75977_ch08.qxd  11/27/08  3:39 PM  Page 237
the software. For example, the elements of the 
SafeHomeproduct are configuredtooperate within three primary computing environmentsÑa home-based PC, the
SafeHomecontrol panel, and a server housed at CPI Corp. (providing Internet-based
access to the system).During design, a UML deployment diagram is developed and then refined asshown in Figure 8.7. In the figure, three computing environments are shown (in

actuality, there would be more including sensors, cameras, and others). The sub-

systems (functionality) housed within each computing element are indicated. For
example, the personal computer houses subsystems that implement security, sur-

veillance, home management, and communications features. In addition, an exter-

nal access subsystem has been designed to manage all attempts to access the
SafeHomesystem from anexternal source. Each subsystem would be elaborated to
indicate the components that it implements.The diagram shown in Figure 8.7is in 
descriptor form.This means that the de-ployment diagram shows the computing environment but does not explicitly indicate

configuration details. For example, the Òpersonal computerÓ is not further identified.

It could be a Mac or a Windows-based PC, a Sun workstation, or a Linux-box. These

details are provided when the deployment diagram is revisited in 
instance formduring the latter stages of design or as construction begins. Each instance of the
deployment (a specific, named hardware configuration) is identified.
238PART TWOMODELINGCPI server
Control panel
Personal computerSecurityHomeManagementSurveillance
CommunicationSecurityHomeownerAccessExternalAccess
FIGURE8.7A UMLdeployment
diagramDeployment diagramsbegin in descriptorform, where the

deployment environ-
ment is described in
general terms. Later,

instance form is used

and elements of the
configuration are
explicitly described.pre75977_ch08.qxd  11/27/08  3:39 PM  Page 238
8.5S
UMMARYSoftware design commences as the first iteration of requirements engineeringcomes to a conclusion. The intent of software design is to apply a set of principles,
concepts, and practices that lead to the development of a high-quality system or
product. The goal of design is to create a model of software that will implement all
customer requirements correctly and bring delight to those who use it. Software de-
signers must sift through many design alternatives and converge on a solution that

best suits the needs of project stakeholders.The design process moves from a Òbig pictureÓ view of software to a more narrow
view that defines the detail required to implement a system. The process begins by
focusing on architecture. Subsystems are defined; communication mechanisms
among subsystems are established; components are identified, and a detailed de-
scription of each component is developed. In addition, external, internal, and user
interfaces are designed.Design concepts have evolved over the first 60 years of software engineering
work. They describe attributes of computer software that should be present regard-
less of the software engineering process that is chosen, the design methods that are
applied, or the programming languages that are used. In essence, design concepts

emphasize the need for abstraction as a mechanism for creating reusable software
components; the importance of architecture as a way to better understand the over-

all structure of a system; the benefits of pattern-based engineering as a technique for
designing software with proven capabilities; the value of separation of concerns and

effective modularity as a way to make software more understandable, more testable,

and more maintainable; the consequences of information hiding as a mechanism
forreducing the propagation of side effects when errors do occur; the impact of

functional independence as a criterion for building effective modules; the use of
refinement as a design mechanism; a consideration of aspects that crosscut system
requirements; the application of refactoring for optimizing the design that is derived;
and the importance of object-oriented classes and the characteristics that are related
to them.The design model encompasses four different elements. As each of these ele-ments is developed, a more complete view of the design evolves. The architectural
element uses information derived from the application domain, the requirements
model, and available catalogs for patterns and styles to derive a complete structural
representation of the software, its subsystems, and components. Interface design el-

ements model external and internal interfaces and the user interface. Component-
level elements define each of the modules (components) that populate the
architecture. Finally, deployment-level design elements allocate the architecture, its

components, and the interfaces to the physical configuration that will house the
software.CHAPTER 8DESIGN CONCEPTS239pre75977_ch08.qxd  11/27/08  3:39 PM  Page 239
PROBLEMSAND
POINTSTO
PONDER8.1.Do you design software when you ÒwriteÓ a program? What makes software design differ-ent from coding?8.2.If a software design is not a program (and it isnÕt), then what is it?
8.3.How do we assess the quality of a software design?8.4.Examine the task set presented for design. Where is quality assessed within the task set?How is this accomplished? How are the quality attributes discussed in Section 8.2.1 achieved?
8.5.Provide examples of three data abstractions and the procedural abstractions that can be
used to manipulate them.
8.6.Describe software architecture in your own words.8.7.Suggest a design pattern that you encounter in a category of everyday things (e.g.,consumer electronics, automobiles, appliances). Briefly describe the pattern.
8.8.Describe separation of concerns in your own words. Is there a case when a divide-and-conquer strategy may not be appropriate? How might such a case affect the argument formodularity?8.9.When should a modular design be implemented as monolithic software? How can this beaccomplished? Is performance the only justification for implementation of monolithic software?
8.10.Discuss the relationship between the concept of information hiding as an attribute ofeffective modularity and the concept of module independence.
8.11.How are the concepts of coupling and software portability related? Provide examples to
support your discussion.
8.12.ApplyaÒstepwiserefinementapproachÓtodevelopthreedifferentlevelsofprocedural
abstractionsforoneormoreofthefollowingprograms:(a)Developacheckwriterthat,givena
numericdollaramount,willprinttheamountinwordsnormallyrequiredonacheck.(b)Itera-

tivelysolvefortherootsofatranscendentalequation.(c)Developasimpletaskscheduling

algorithmforanoperatingsystem.
8.13.Consider the software required to implement a full navigation capability (using GPS) in amobile, handheld communication device. Describe two or three crosscutting concerns that
would be present. Discuss how you would represent one of these concerns as an aspect.8.14.Does ÒrefactoringÓ mean that you modify the entire design iteratively? If not, what doesit mean?
8.15.Briefly describe each of the four elements of the design model.FURTHER
READINGSAND
INFORMATION
SOURCESDonald Norman has written two books (The Design of Everyday Things,Doubleday, 1990, and 
ThePsychology of Everyday Things,
Harpercollins, 1988) that have become classics in the designliterature and ÒmustÓ reading for anyone who designs anything that humans use. Adams(Conceptual Blockbusting,
3d ed., Addison-Wesley, 1986) has written a book that is essential
reading for designers who want to broaden their way of thinking. Finally, a classic text by Polya

(How to Solve It,2d ed., Princeton University Press, 1988) provides a generic problem-solving
process that can help software designers when they are faced with complex problems.Following in the same tradition, Winograd et al. (
Bringing Design to Software,Addison-Wesley, 1996) discusses software designs that work, those that donÕt, and why. A fascinating

book edited by Wixon and Ramsey (
Field Methods Casebook for Software Design,Wiley, 1996)
240PART TWOMODELINGpre75977_ch08.qxd  11/27/08  3:39 PM  Page 240
suggests field research methods (much like those used by anthropologists) to understand howend users do the work they do and then design software that meets their needs. Beyer and
Holtzblatt (Contextual Design: A Customer-Centered Approach to Systems Designs,
AcademicPress, 1997) offer another view of software design that integrates the customer/user into every
aspect of the software design process. Bain (Emergent Design,Addison-Wesley, 2008) couples
patterns, refactoring, and test-driven development into an effective design approach.Comprehensive treatment of design in the context of software engineering is presentedbyFox (
Introduction to Software Engineering Design,Addison-Wesley, 2006) and Zhu (
SoftwareDesign Methodology,
Butterworth-Heinemann, 2005). McConnell (Code Complete,2d ed., Mi-crosoft Press, 2004) presents an excellent discussion of the practical aspects of designing high-
quality computer software. Robertson (Simple Program Design,
3d ed., Boyd and FraserPublishing, 1999) presents an introductory discussion of software design that is useful for those
beginning their study of the subject. Budgen (Software Design,2d ed., Addison-Wesley, 2004) in-
troduces a variety of popular design methods, comparing and contrasting each. Fowler and his
colleagues (Refactoring: Improving the Design of Existing Code,
Addison-Wesley, 1999) discusses
techniques for the incremental optimization of software designs. Rosenberg and Stevens (Use
Case Driven Object Modeling with UML,Apress, 2007) discuss the development of object-orienteddesigns using use cases as a foundation.An excellent historical survey of software design is contained in an anthology edited by Free-man and Wasserman (
Software Design Techniques,
4th ed., IEEE, 1983). This tutorial reprintsmany of the classic papers that have formed the basis for current trends in software design.
Measures of design quality, presented from both the technical and management perspectives,

are considered by Card and Glass (Measuring Software Design Quality,
Prentice-Hall, 1990).A wide variety of information sources on software design are available on the Internet. Anup-to-date list of World Wide Web references that are relevant to software design and design

engineering can be found at the SEPA website: 
www.mhhe.com/engcs/compsci/

pressman/professional/olc/ser.htm
.CHAPTER 8DESIGN CONCEPTS241pre75977_ch08.qxd  11/27/08  3:39 PM  Page 241
Design has been described as a multistep process in which representationsof data and program structure, interface characteristics, and procedural

detail are synthesized from information requirements. This description isextended by Freeman [Fre80]:[D]esign is an activity concerned with making major decisions, often of a structuralnature. It shares with programming a concern for abstracting information represen-
tation and processing sequences, but the level of detail is quite different at the
extremes. Design builds coherent, well-planned representations of programs that
concentrate on the interrelationships of parts at the higher level and the logical oper-
ations involved at the lower levels.
As I noted in Chapter 8, design is information driven. Software design methodsare derived from consideration of each of the three domains of the analysis model.
The data, functional, and behavioral domains serve as a guide for the creation of
the software design.Methods required to create Òcoherent, well-planned representationsÓ of thedata and architectural layers of the design model are presented in this chapter.

The objective is to provide a systematic approach for the derivation of the

architectural designÑthe preliminary blueprint from which software is
constructed.242CHAPTER9ARCHITECTURALDESIGNKEYCONCEPTSarchetypes . . . . .257
architecturaldescription 
language . . . . . .264
architecture . . . .243
alternatives . . .261

components . . .258

complexity . . . .263

data centered . .250

data flow . . . . .251

design . . . . . . .255

genres . . . . . . .247

layered . . . . . .253
objectoriented . .252
patterns . . . . . .253

refinement . . . .258

styles . . . . . . .249

template . . . . .247
ATAM . . . . . . . . .262

factoring . . . . . .268

instantiation . . . .260

mapping . . . . . . .265
What is it?Architectural designrepresents the structure of data andprogram components that are re-
quired to build a computer-basedsystem. It considers the architectural style that the
system will take, the structure and properties of

the components that constitute the system, and
the interrelationships that occur among all ar-
chitectural components of a system.Who does it?Although a software engineer candesign both data and architecture, the job is of-
ten allocated to specialists when large, complex
systems are to be built. A database or dataQUICKLOOKwarehouse designer creates the data architec-
ture for a system. The Òsystem architectÓ selects
an appropriate architectural style from the re-
quirements derived during software require-
ments analysis.Why is it important?
You wouldnÕt attempt to build
a house without a blueprint, would you? You also

wouldnÕt begin drawing blueprints by sketching

the plumbing layout for the house. YouÕd need to

look at the big pictureÑthe house itselfÑbefore
you worry about details. ThatÕs what architectural

design doesÑit provides you with the big picture
and ensures that youÕve got it right.pre75977_ch09.qxd  11/27/08  3:42 PM  Page 242
9.1S
OFTWARE
ARCHITECTUREIn their landmark book on the subject, Shaw and Garlan [Sha96] discuss software
architecture in the following manner:Ever since the first program was divided into modules, software systems have had archi-tectures, and programmers have been responsible for the interactions among the mod-
ules and the global properties of the assemblage. Historically, architectures have been

implicitÑaccidents of implementation, or legacy systems of the past. Good software
developers have often adopted one or several architectural patterns as strategies for
system organization, but they use these patterns informally and have no means to make
them explicit in the resulting system.Today, effective software architecture and its explicit representation and design have
become dominant themes in software engineering.9.1.1What Is Architecture?
When you consider the architecture of a building, many different attributes come to
mind. At the most simplistic level, you think about the overall shape of the physical

structure. But in reality, architecture is much more. It is the manner in which the var-

ious components of the building are integrated to form a cohesive whole. It is the
way in which the building fits into its environment and meshes with other buildings

in its vicinity. It is the degree to which the building meets its stated purpose and sat-

isfies the needs of its owner. It is the aesthetic feel of the structureÑthe visual im-

pact of the buildingÑand the way textures, colors, and materials are combined to
create the external facade and the internal Òliving environment.Ó It is small detailsÑ

the design of lighting fixtures, the type of flooring, the placement of wall hangings,
the list is almost endless. And finally, it is art.
But architecture is also something else. It is Òthousands of decisions, both big andsmallÓ [Tyr05]. Some of these decisions are made early in design and can have a

profound impact on all other design actions. Others are delayed until later, thereby
CHAPTER 9ARCHITECTURAL DESIGN243What are the steps?Architectural design beginswith data design and then proceeds to the deri-vation of one or more representations of the ar-
chitectural structure of the system. Alternative

architectural styles or patterns are analyzed to

derive the structure that is best suited to customer
requirements and quality attributes. Once an al-
ternative has been selected, the architecture is

elaborated using an architectural design
method.What is the work product?
An architecturemodel encompassing data architecture and pro-
gram structure is created during architectural
design. In addition, component properties and

relationships (interactions) are described.How do I ensure that IÕve done it right?Ateach stage, software design work products are
reviewed for clarity, correctness, completeness,

and consistency with requirements and with one
another.
uote:ÒThe architecture
of a system is a
comprehensive
framework that
describes its form
and structureÑits
components and
how they fit
together.Ó
JerroldGrochow
pre75977_ch09.qxd  11/27/08  3:42 PM  Page 243
eliminating overly restrictive constraints that would lead to a poor implementation
of the architectural style.But what about software architecture? Bass, Clements, and Kazman [Bas03]define this elusive term in the following way:The software architecture of a program or computing system is the structure or structuresof the system, which comprise software components, the externally visible properties of
those components, and the relationships among them.The architecture is not the operational software. Rather, it is a representation that
enables you to (1) analyze the effectiveness of the design in meeting its stated re-
quirements, (2) consider architectural alternatives at a stage when making design
changes is still relatively easy, and (3) reduce the risks associated with the construc-

tion of the software.ThisdefinitionemphasizestheroleofÒsoftwarecomponentsÓinanyarchitectural
representation.Inthecontextofarchitecturaldesign,asoftwarecomponentcanbe

somethingassimpleasaprogrammoduleoranobject-orientedclass,butitcanalso

beextendedtoincludedatabasesandÒmiddlewareÓthatenabletheconfigurationof

anetworkofclientsandservers.Thepropertiesofcomponentsarethosecharacter-

isticsthatarenecessaryforanunderstandingofhowthecomponentsinteractwith

othercomponents.Atthearchitecturallevel,internalproperties(e.g.,detailsofanal-

gorithm)arenotspecified.Therelationshipsbetweencomponentscanbeassimple

asaprocedurecallfromonemoduletoanotherorascomplexasadatabaseaccess

protocol.Some members of the software engineering community (e.g., [Kaz03]) make adistinction between the actions associated with the derivation of a software archi-
tecture (what I call Òarchitectural designÓ) and the actions that are applied to derive
the software design. As one reviewer of this edition noted:There is a distinct difference between the terms architecture and design. A designis aninstance of an architecture
similar to an object being an instance of a class. For example,
consider the client-server architecture. I can design a network-centric software system inmany different ways from this architecture using either the Java platform (Java EE) or
Microsoft platform (.NET framework). So, there is one architecture, but many designs can

be created based on that architecture. Therefore, you cannot mix ÒarchitectureÓ and

ÒdesignÓ with each other.
AlthoughIagreethatasoftwaredesignisaninstanceofaspecificsoftware
architecture,theelementsandstructuresthataredefinedaspartofanarchitec-

turearetherootofeverydesign that evolves from them.Designbeginswitha

considerationofarchitecture.
Inthisbookthedesignofsoftwarearchitectureconsiderstwolevelsofthedesign
pyramid(Figure8.1)Ñdatadesignandarchitecturaldesign.Inthecontextofthepre-

cedingdiscussion,datadesignenablesyoutorepresentthedatacomponentofthe

architectureinconventionalsystemsandclassdefinitions(encompassingattributes
244PART TWOMODELINGSoftware architecturemust model the
structure of a system

and the manner in
which data and
procedural components
collaborate with one
another.
uote:ÒMarry your

architecture in
haste, repent at
your leisure.ÓBarryBoehm
WebRef
Useful pointers tomany software
architecture sites can
be obtained at 
www2.umassd
.edu/SECenter/
SAResources.html.pre75977_ch09.qxd  11/27/08  3:42 PM  Page 244
andoperations)inobject-orientedsystems.Architecturaldesignfocusesonthe
representationofthestructureofsoftwarecomponents,theirproperties,andinter-

actions.9.1.2Why Is Architecture Important?
In a book dedicated to software architecture, Bass and his colleagues [Bas03] iden-

tify three key reasons that software architecture is important:¥Representations of software architecture are an enabler for communication
between all parties (stakeholders) interested in the development of a
computer-based system.¥The architecture highlights early design decisions that will have a profound
impact on all software engineering work that follows and, as important, on
the ultimate success of the system as an operational entity.
¥Architecture Òconstitutes a relatively small, intellectually graspable model of
how the system is structured and how its components work togetherÓ [Bas03].The architectural design model and the architectural patterns contained within it
aretransferable. That is, architecture genres, styles, and patterns (Sections 9.2

through 9.4) can be applied to the design of other systems and represent a set of
abstractions that enable software engineers to describe architecture in predictable
ways.9.1.3Architectural Descriptions
Each of us has a mental image of what the word architecture
means. In reality, how-
ever, it means different things to different people. The implication is that different

stakeholders will see an architecture from different viewpoints that are driven by dif-
ferent sets of concerns. This implies that an architectural description is actually a set
of work products that reflect different views of the system.For example, the architect of a major office building must work with a variety of
different stakeholders. The primary concern of the owner of the building (one stake-
holder) is to ensure that it is aesthetically pleasing and that it provides sufficient of-

fice space and infrastructure to ensure its profitability. Therefore, the architect must

develop a description using views of the building that address the ownerÕs concerns.

The viewpoints used are a three-dimensional drawings of the building (to illustrate

the aesthetic view) and a set of two-dimensional floor plans to address this stake-
holderÕs concern for office space and infrastructure.
But the office building has many other stakeholders, including the structuralsteelfabricator who will provide steel for the building skeleton. The structural steel

fabricator needs detailed architectural information about the structural steel that will
support the building, including types of I-beams, their dimensions, connectivity,

materials, and many other details. These concerns are addressed by different work
products that represent different views of the architecture. Specialized drawings
CHAPTER 9ARCHITECTURAL DESIGN245uote:ÒArchitecture is fartoo important to
leave in the hands
of a single person,
no matter how
bright they are.ÓScottAmbler
The architectural modelprovides a Gestalt view
of the system,
allowing the software
engineer to examine it
as a whole.Your effort should

focus on architectural
representations that
will guide all other
aspects of design.
Spend the time to
carefully review the
architecture. A mistake
here will have a long-
term negative impact.
pre75977_ch09.qxd  11/27/08  3:42 PM  Page 245
(another viewpoint) of the structural steel skeleton of the building focus on only oneof many of the fabricatorÕs concerns.
An architectural description of a software-based system must exhibit character-istics that are analogous to those noted for the office building. Tyree and Akerman

[Tyr05] note this when they write: ÒDevelopers want clear, decisive guidance on how

to proceed with design. Customers want a clear understanding on the environmen-

tal changes that must occur and assurances that the architecture will meet their busi-
ness needs. Other architects want a clear, salient understanding of the architectureÕs

key aspects.Ó Each of these ÒwantsÓ is reflected in a different view represented using
a different viewpoint.The IEEE Computer Society has proposed IEEE-Std-1471-2000, RecommendedPractice for Architectural Description of Software-Intensive Systems,
[IEE00], with thefollowing objectives: (1) to establish a conceptual framework and vocabulary for use
during the design of software architecture, (2) to provide detailed guidelines for rep-

resenting an architectural description, and (3) to encourage sound architectural
design practices.The IEEE standard defines an architectural description
(AD) as Òa collection of prod-ucts to document an architecture.Ó The description itself is represented using multiple
views, where each viewis Òa representation of a whole system from the perpective ofa related set of [stakeholder] concerns.Ó A viewis created according to rules and con-ventions defined in a viewpointÑÒa specification of the conventions for constructing

and using a viewÓ [IEE00]. A number of different work products that are used to de-
velop different views of the software architecture are discussed later in this chapter.
9.1.4Architectural Decisions
Each view developed as part of an architectural description addresses a specific
stakeholder concern. To develop each view (and the architectural description as a

whole) the system architect considers a variety of alternatives and ultimately decides
on the specific architectural features that best meet the concern. Therefore, archi-

tectural decisions themselves can be considered to be one view of the architecture.
The reasons that decisions were made provide insight into the structure of a system

and its conformance to stakeholder concerns.Asasystemarchitect,youcanusethetemplatesuggestedinthesidebartodocu-
menteachmajordecision.Bydoingthis,youprovidearationaleforyourworkand

establishanhistoricalrecordthatcanbeusefulwhendesignmodificationsmust

bemade.
246PART TWOMODELING9.2A
RCHITECTURALGENRESAlthough the underlying principles of architectural design apply to all types of archi-
tecture, the architectural 
genrewill often dictate the specific architectural approach tothe structure that must be built. In the context of architectural design, genreimplies apre75977_ch09.qxd  11/27/08  3:42 PM  Page 246
CHAPTER 9ARCHITECTURAL DESIGN247Architecture Decision Description Template
Each major architectural decision can bedocumented for later review by stakeholders whowant to understand the architecture description that hasbeen proposed. The template presented in this sidebar is
an adapted and abbreviated version of a template
proposed by Tyree and Ackerman [Tyr05].
Design issue:Describe the architectural designissues that are to be addressed.Resolution:State the approach youÕve chosen
to address the design issue.Category:
Specify the design category that

the issue and resolution address
(e.g., data design, content
structure, component structure,
integration, presentation).Assumptions:Indicate any assumptions that
helped shape the decision.Constraints:Specify any environmental
constraints that helped shape the
decision (e.g., technology
standards, available patterns,

project-related issues).Alternatives:Briefly describe the architectural
design alternatives that were

considered and why they were
rejected.Argument:
State why you chose the
resolution over other alternatives.
Implications:Indicate the design consequences
of making the decision. How will
the resolution affect other

architectural design issues? Will
the resolution constrain the design
in any way?Related decisions:What other documented decisions
are related to this decision?Related concerns:What other requirements are
related to this decision?Work products:
Indicate where this decision will
be reflected in the architecture
description.Notes:Reference any team notes or other
documentation that was used to
make the decision.INFOA number of differentarchitectural styles
may be applicable to a
specific genre (also
called an application
domain).specific category within the overall software domain. Within each category, you en-
counter a number of subcategories. For example, within the genre of 
buildings, you
would encounter the following general styles: houses, condos, apartment buildings,
office buildings, industrial building, warehouses, and so on. Within each general style,

more specific styles might apply (Section 9.3). Each style would have a structure that
can be described using a set of predictable patterns.In his evolving Handbook of Software Architecture
[Boo08], Grady Booch suggeststhe following architectural genres for software-based systems:¥Artificial intelligenceÑSystems that simulate or augment human cognition,locomotion, or other organic processes.¥Commercial and nonprofit
ÑSystems that are fundamental to theoperation of a business enterprise.¥CommunicationsÑSystems that provide the infrastructure for transferring
and managing data, for connecting users of that data, or for presenting data
at the edge of an infrastructure.¥Content authoringÑSystems that are used to create or manipulate textual
or multimedia artifacts.pre75977_ch09.qxd  11/27/08  3:42 PM  Page 247
248PART TWOMODELING¥Devices
ÑSystems that interact with the physical world to provide some
point service for an individual.¥Entertainment and sportsÑSystems that manage public events or that
provide a large group entertainment experience.
¥FinancialÑSystems that provide the infrastructure for transferring and

managing money and other securities.¥GamesÑSystems that provide an entertainment experience for individuals

or groups.¥Government
ÑSystems that support the conduct and operations of a local,
state, federal, global, or other political entity.
¥IndustrialÑSystems that simulate or control physical processes.¥LegalÑSystems that support the legal industry.
¥MedicalÑSystemsthatdiagnoseorhealorthatcontributetomedical

research.¥MilitaryÑSystems for consultation, communications, command, control,
and intelligence (C4I) as well as offensive and defensive weapons.¥Operating systems
ÑSystems that sit just above hardware to provide basic

software services.¥Platforms
ÑSystems that sit just above operating systems to provide

advanced services.¥ScientificÑSystems that are used for scientific research and applications.¥Tools
ÑSystems that are used to develop other systems.¥Transportation
ÑSystems that control water, ground, air, or space vehicles.
¥UtilitiesÑSystemsthatinteractwithothersoftwaretoprovidesomepoint

service.From the standpoint of architectural design, each genre represents a unique chal-
lenge. As an example, consider the software architecture for a game system. Game

systems, sometimes called immersive interactive applications,
require the computa-tion of intensive algorithms, sophisticated computer graphics, streaming multimedia
data sources, real-time interactivity via conventional and unconventional inputs,

and a variety of other specialized concerns.Alexandre Francois [Fra03] suggests a software architecture for Immersipresence1that can be applied for a gaming environment. He describes the architecture in the

following manner:SAI (Software Architecture for Immersipresence) is a new software architecture modelfordesigning, analyzing and implementing applications performing distributed,
uote:ÒProgrammingwithout an overall
architecture or
design in mind is
like exploring a
cave with only a
flashlight: You

donÕt know where
youÕve been, you
donÕt know where
youÕre going, and
you donÕt know
quite where you
are.ÓDannyThorpe
1Francois uses the term 
immersipresencefor immersive, interactive applications.pre75977_ch09.qxd  11/27/08  3:42 PM  Page 248
asynchronous parallel processing of generic data streams. The goal of SAI is to provide a
universal framework for the distributed implementation of algorithms and their easy
integration into complex systems.... The underlying extensible data model and hybrid

(shared repository and message-passing) distributed asynchronous parallel processing
model allow natural and efficient manipulation of generic data streams, using existing
libraries or native code alike. The modularity of the style facilitates distributed code de-
velopment, testing, and reuse, as well as fast system design and integration, maintenance

and evolution.A detailed discussion of SAI is beyond the scope of this book. However, it is impor-
tant to recognize that the gaming system genre can be addressed with an architec-
tural style (Section 9.3) that has been specifically designed to address gaming system
concerns. If you have further interest, see [Fra03].9.3A
RCHITECTURALSTYLESWhen a builder uses the phrase Òcenter hall colonialÓ to describe a house, most peo-

ple familiar with houses in the United States will be able to conjure a general image
of what the house will look like and what the floor plan is likely to be. The builder
has used an architectural style
as a descriptive mechanism to differentiate the housefrom other styles (e.g., A-frame, raised ranch, Cape Cod). But more important, the

architectural style is also a template for construction. Further details of the house
must be defined, its final dimensions must be specified, customized features may
beadded, building materials are to be determined, but the styleÑa Òcenter hall

colonialÓÑguides the builder in his work.The software that is built for computer-based systems also exhibits one of manyarchitectural styles. Each style describes a system category that encompasses (1) a
set of components (e.g., a database, computational modules) that perform a function

required by a system; (2) a set of connectors that enable Òcommunication, coordina-
tion and cooperationÓ among components; (3) constraints that define how compo-
nents can be integrated to form the system; and (4) semantic models that enable a
designer to understand the overall properties of a system by analyzing the known

properties of its constituent parts [Bas03].An architectural style is a transformation that is imposed on the design of an en-tire system. The intent is to establish a structure for all components of the system.
In the case where an existing architecture is to be reengineered (Chapter 29), the
imposition of an architectural style will result in fundamental changes to the struc-
ture of the software including a reassignment of the functionality of components
[Bos00].An architectural pattern, like an architectural style, imposes a transformation on
the design of an architecture. However, a pattern differs from a style in a number of

fundamental ways: (1) the scope of a pattern is less broad, focusing on one aspect
ofthe architecture rather than the architecture in its entirety; (2) a pattern imposes a
CHAPTER 9ARCHITECTURAL DESIGN249uote:ÒThere is at theback of every

artistÕs mind, a

pattern or type of
architecture.ÓG.K.Chesterton
What is anarchitecturalstyle??WebRef
Attribute-basedarchitectural styles
(ABAS) can be used as
building blocks for
software architectures.
Information can be

obtained at 
www.sei.cmu

.edu/architecture/
abas.html.pre75977_ch09.qxd  11/27/08  3:42 PM  Page 249
rule on the architecture, describing how the software will handle some aspect of its
functionality at the infrastructure level (e.g., concurrency) [Bos00]; (3) architectural
patterns (Section 9.4) tend to address specific behavioral issues within the context of
the architecture (e.g., how real-time applications handle synchronization or inter-
rupts). Patterns can be used in conjunction with an architectural style to shape the
overall structure of a system. In Section 9.3.1, I consider commonly used architec-

tural styles and patterns for software.250PART TWOMODELINGCanonical Architectural Structures
In essence, software architecture represents astructure in which some collection of entities (oftencalled components) is connected by a set of definedrelationships (often called connectors). Both components
and connectors are associated with a set of properties
thatallow the designer to differentiate the types of components

and connectors that can be used. But what kinds of
structures (components, connectors, and properties) can be

used to describe an architecture? Bass and Kazman
[Bas03] suggest five canonical or foundation architectural
structures:Functional structure.Components represent functionor processing entities. Connectors represent interfaces that
provide the ability to ÒuseÓ or Òpass data toÓ a component.
Properties describe the nature of the components and the

organization of the interfaces.
Implementation structure.ÒComponents can bepackages, classes, objects, procedures, functions,methods, etc., all of which are vehicles for packaging
functionality at various levels of abstractionÓ [Bas03].
Connectors include the ability to pass data and control,
share data, ÒuseÓ, and Òis-an-instance-of.Ó Properties
focus on quality characteristics (e.g., maintainability,

reusability) that result when the structure is implemented.Concurrency structure.Components represent Òunitsof concurrencyÓ that are organized as parallel tasks orthreads. ÒRelations [connectors] include synchronizes-with,
is-higher-priority-than, sends-data-to, canÕt-run-without, and

canÕt-run-with. Properties relevant to this structure include

priority, preemptability, and execution timeÓ [Bas03].
Physical structure.This structure is similar to thedeployment model developed as part of design. The
components are the physical hardware on which software
resides. Connectors are the interfaces between hardware

components, and properties address capacity, bandwidth,

performance, and other attributes.
Developmental structure.This structure defines thecomponents, work products, and other information sources
that are required as software engineering proceeds.
Connectors represent the relationships among work prod-
ucts, and properties identify the characteristics of each item.
Each of these structures presents a different view of
software architecture, exposing information that is useful to

the software team as modeling and construction proceed.INFO9.3.1A Brief Taxonomy of Architectural Styles
Although millions of computer-based systems have been created over the past
60years, the vast majority can be categorized into one of a relatively small number

of architectural styles:Data-centered architectures.
A data store (e.g., a file or database) resides atthe center of this architecture and is accessed frequently by other components thatupdate, add, delete, or otherwise modify data within the store. Figure 9.1illus-

trates a typical data-centered style. Client software accesses a central repository.

In some cases the data repository is passive. That is, client software accesses the
data independent of any changes to the data or the actions of other client soft-
ware. A variation on this approach transforms the repository into a ÒblackboardÓuote:ÒThe use ofpatterns and styles
of design is
pervasive in

engineering
disciplines.ÓMaryShawand
DavidGarlan
pre75977_ch09.qxd  11/27/08  3:42 PM  Page 250
CHAPTER 9ARCHITECTURAL DESIGN251ClientsoftwareClientsoftwareClientsoftwareClientsoftwareClientsoftwareClientsoftwareClientsoftwareClientsoftwareData store(repository or
blackboard)FIGURE9.1Data-centered
architecture
that sends notifications to client software when data of interest to the clientchanges.Data-centeredarchitecturespromote
integrability
[Bas03].Thatis,existing
componentscanbechangedandnewclientcomponentsaddedtothearchitecture

withoutconcernaboutotherclients(becausetheclientcomponentsoperate

independently).Inaddition,datacanbepassedamongclientsusingtheblack-

boardmechanism(i.e.,theblackboardcomponentservestocoordinatethetrans-

ferofinformationbetweenclients).Clientcomponentsindependentlyexecute

processes.Data-flow architectures.
This architecture is applied when input data are to betransformed through a series of computational or manipulative components intooutput data. A pipe-and-filter pattern (Figure 9.2) has a set of components, called
filters, connected by pipesthat transmit data from one component to the next. Eachfilter works independently of those components upstream and downstream, is de-
signed to expect data input of a certain form, and produces data output (to the next
filter) of a specified form. However, the filter does not require knowledge of the

workings of its neighboring filters.If the data flow degenerates into a single line of transforms, it is termed batch se-quential. This structure accepts a batch of data and then applies a series of sequen-
tial components (filters) to transform it.Call and return architectures.
This architectural style enables you to achieve aprogram structure that is relatively easy to modify and scale. A number of substyles[Bas03] exist within this category:¥Main program/subprogram architectures.
This classic program structuredecomposes function into a control hierarchy where a ÒmainÓ programpre75977_ch09.qxd  11/27/08  3:42 PM  Page 251
252PART TWOMODELINGinvokes a number of program components that in turn may invoke still other
components. Figure 9.3illustrates an architecture of this type.
¥Remote procedure call architectures.
The components of a mainprogram/subprogram architecture are distributed across multiple computers
on a network.Object-oriented architectures.
The components of a system encapsulate dataand the operations that must be applied to manipulate the data. Communication and
coordination between components are accomplished via message passing.Main programController subprogramController subprogramController subprogramApplication subprogramApplication subprogramApplication subprogramApplication subprogramApplication subprogramApplication subprogramApplication subprogramFIGURE9.3Main program/subprogram architecture
FilterPipesFilterFilterFilterFilterFilterFilterFilterPipes and filtersFilterFilterFIGURE9.2Data-flowarchitecture
pre75977_ch09.qxd  11/27/08  3:42 PM  Page 252
CHAPTER 9ARCHITECTURAL DESIGN253Layered architectures.
The basic structure of a layered architecture is illustratedin Figure 9.4. A number of different layers are defined, each accomplishing opera-tions that progressively become closer to the machine instruction set. At the outer
layer, components service user interface operations. At the inner layer, components

perform operating system interfacing. Intermediate layers provide utility services

and application software functions.Thesearchitecturalstylesareonlyasmallsubsetofthoseavailable.
2Oncerequirementsengineeringuncoversthecharacteristicsandconstraintsofthesys-

temtobebuilt,thearchitecturalstyleand/orcombinationofpatternsthatbest

fitsthosecharacteristicsandconstraintscanbechosen.Inmanycases,more

thanonepatternmightbeappropriateandalternativearchitecturalstylescanbe

designedandevaluated.Forexample,alayeredstyle(appropriateformostsys-

tems)canbecombinedwithadata-centeredarchitectureinmanydatabase

applications.9.3.2Architectural Patterns
As the requirements model is developed, youÕll notice that the software must address
a number of broad problems that span the entire application. For example, the

requirements model for virtually every e-commerce application is faced with the
following problem: How do we offer a broad array of goods to a broad array of

customers and allow those customers to purchase our goods online?
Core layerComponentsUser interface layer
Application layerUtility layerFIGURE9.4Layered
architecture
2See [Bus07], [Gor06], [Roz05], [Bas03], [Bos00], or [Hof00] for a detailed discussion of architectural
styles and patterns.uote:ÒMaybe itÕs in the
basement. Let me
go upstairs and
check.ÓM.C.Escher
pre75977_ch09.qxd  11/27/08  3:42 PM  Page 253
254PART TWOMODELINGThe scene:JamieÕs cubicle, as design
modeling begins.The players:Jamie and EdÑmembers of theSafeHomesoftware engineering team.The conversation:
Ed (frowning):
WeÕve been modeling the security
function using UML . . . you know classes, relationships,that sort of stuff. So I guess the object-oriented

architecture3is the right way to go.Jamie:But . . .?Ed:But . . . I have trouble visualizing what an object-oriented architecture is. I get the call and return

architecture, sort of a conventional process hierarchy, but

OO . . . I donÕt know, it seems sort of amorphous.
Jamie (smiling):Amorphous, huh?Ed:Yeah . . . what I mean is I canÕt visualize a real
structure, just design classes floating in space.Jamie:Well,thatÕsnottrue.Thereareclasshierarchies
. . .thinkofthehierarchy(aggregation)wedidforthe
FloorPlanobject [Figure 8.3]. An OO architecture is acombination of that structure and the interconnectionsÑ
you know, collaborationsÑbetween the classes. We can

show it by fully describing the attributes and operations,
the messaging that goes on, and the structure of the
classes.Ed:IÕm going to spend an hour mapping out a call andreturn architecture; then IÕll go back and consider an OO
architecture.Jamie:DougÕll have no problem with that. He said thatwe should consider architectural alternatives. By the
way,thereÕs absolutely no reason why both of these

architectures couldnÕt be used in combination with one

another.
Ed:Good. IÕm on it.SAFEHOME3It can be argued that the 
SafeHomearchitecture should be considered at a higher level than thearchitecture noted. SafeHomehas a variety of subsystemsÑhome monitoring functionality, thecompanyÕs monitoring site, and the subsystem running on the ownerÕs PC. Within subsystems,concurrent processes (e.g., those monitoring sensors) and event handling are prevalent. Some
architectural decisions at this level are made during product engineering, but architectural design
within software engineering may very well have to consider these issues.Choosing an Architectural Style
The requirements model also defines a context in which this question must beanswered. For example, an e-commerce business that sells golf equipment to
consumers will operate in a different context than an e-commerce business that sells
high-priced industrial equipment to medium and large corporations. In addition, a
set of limitations and constraints may affect the way in which you address the prob-
lem to be solved.Architectural patterns address an application-specific problem within a specificcontext and under a set of limitations and constraints. The pattern proposes an
architectural solution that can serve as the basis for architectural design.Earlier in this chapter, I noted that most applications fit within a specific domain
or genre and that one or more architectural styles may be appropriate for that genre.
For example, the overall architectural style for an application might be call-and-

return or object-oriented. But within that style, you will encounter a set of common

problems that might best be addressed with specific architectural patterns. Some
ofthese problems and a more complete discussion of architectural patterns are

presented in Chapter 12.pre75977_ch09.qxd  11/27/08  3:42 PM  Page 254
CHAPTER 9ARCHITECTURAL DESIGN2559.3.3Organization and Refinement
Because the design process often leaves you with a number of architectural alterna-tives, it is important to establish a set of design criteria that can be used to assess an
architectural design that is derived. The following questions [Bas03] provide insight

into an architectural style:Control.
How is control managed within the architecture? Does a distinctcontrol hierarchy exist, and if so, what is the role of components within this
control hierarchy? How do components transfer control within the system?
How is control shared among components? What is the control topology
(i.e.,the geometric form that the control takes)? Is control synchronized or

docomponents operate asynchronously?
Data.Howaredatacommunicatedbetweencomponents?Istheflowofdata
continuous,oraredataobjectspassedtothesystemsporadically?Whatisthe
modeofdatatransfer(i.e.,aredatapassedfromonecomponenttoanother

oraredataavailablegloballytobesharedamongsystemcomponents)?Do

datacomponents(e.g.,ablackboardorrepository)exist,andifso,whatis

theirrole?Howdofunctionalcomponentsinteractwithdatacomponents?

Aredatacomponentspassiveoractive(i.e.,doesthedatacomponent

activelyinteractwithothercomponentsinthesystem)?Howdodataand

controlinteractwithinthesystem?
These questions provide the designer with an early assessment of design quality and

lay the foundation for more detailed analysis of the architecture.9.4A
RCHITECTURALDESIGNAsarchitecturaldesignbegins,thesoftwaretobedevelopedmustbeputinto

contextÑthatis,thedesignshoulddefinetheexternalentities(othersystems,de-

vices,people)thatthesoftwareinteractswithandthenatureoftheinteraction.This

informationcangenerallybeacquiredfromtherequirementsmodelandallother

informationgatheredduringrequirementsengineering.Oncecontextismodeled

andallexternalsoftwareinterfaceshavebeendescribed,youcanidentifyasetof

architecturalarchetypes.An
archetype
isanabstraction(similartoaclass)thatrep-
resentsoneelementofsystembehavior.Thesetofarchetypesprovidesacollection

ofabstractionsthatmustbemodeledarchitecturallyifthesystemistobecon-

structed,butthearchetypesthemselvesdonotprovideenoughimplementationde-

tail.Therefore,thedesignerspecifiesthestructureofthesystembydefiningand

refiningsoftwarecomponentsthatimplementeacharchetype.Thisprocesscontin-

uesiterativelyuntilacompletearchitecturalstructurehasbeenderived.Inthe

sectionsthatfollowweexamineeachofthesearchitecturaldesigntasksinabit

moredetail.
How do Iassess anarchitectural style
that has been
derived??uote:ÒA doctor can bury

his mistakes, but
an architect can
only advise his
client to plant
vines.ÓFrankLloyd
Wright
pre75977_ch09.qxd  11/27/08  3:42 PM  Page 255
9.4.1Representing the System in Context
At the architectural design level, a software architect uses an architectural context di-
agram
(ACD) to model the manner in which software interacts with entities external
to its boundaries. The generic structure of the architectural context diagram is illus-
trated in Figure 9.5.Referring to the figure, systems that interoperate with the 
target system(thesystem for which an architectural design is to be developed) are represented as¥Superordinate systems
Ñthose systems that use the target system as part of
some higher-level processing scheme.¥Subordinate systems
Ñthose systems that are used by the target system and
provide data or processing that are necessary to complete target system

functionality.
¥Peer-levelsystems
Ñthosesystemsthatinteractonapeer-to-peerbasis(i.e.,
informationiseitherproducedorconsumedbythepeersandthetarget

system.¥ActorsÑentities (people, devices) that interact with the target system by

producing or consuming information that is necessary for requisite processing.Each of these external entities communicates with the target system through an in-
terface (the small shaded rectangles).To illustrate the use of the ACD, consider the home security function of the
SafeHomeproduct. The overall 
SafeHomeproduct controller and the Internet-basedsystem are both superordinate to the security function and are shown above the
256PART TWOMODELINGSuperordinate systemsSubordinate systemsDepends onUses Uses Used byPeersActorsTarget system
FIGURE9.5Architectural
context
diagram
Source:Adapted from[Bos00].Architectural contextrepresents how the
software interacts with
entities external to its

boundaries.How do
systemsinteroperate with
one another??pre75977_ch09.qxd  11/27/08  3:42 PM  Page 256
function in Figure 9.6. The surveillance function is a peer systemand uses (is used by)the home security function in later versions of the product. The homeowner and con-trol panels are actors that are both producers and consumers of information
used/produced by the security software. Finally, sensors are used by the security

software and are shown as subordinate to it.As part of the architectural design, the details of each interface shown in Fig-ure9.6would have to be specified. All data that flow into and out of the target sys-

tem must be identified at this stage.9.4.2Defining Archetypes
An archetype
is a class or pattern that represents a core abstraction that is critical tothe design of an architecture for the target system. In general, a relatively small set
of archetypes is required to design even relatively complex systems. The target sys-
tem architecture is composed of these archetypes, which represent stable elements
of the architecture but may be instantiated many different ways based on the
behavior of the system.In many cases, archetypes can be derived by examining the analysis classes de-fined as part of the requirements model. Continuing the discussion of the SafeHome
home security function, you might define the following archetypes:¥Node.Represents a cohesive collection of input and output elements ofthehome security function. For example a node might be comprised of

(1)various sensors and (2) a variety of alarm (output) indicators.
¥Detector.
An abstraction that encompasses all sensing equipment that feedsinformation into the target system.CHAPTER 9ARCHITECTURAL DESIGN257Archetypes are theabstract building blocks
of an architectural
design.Target system: 
security functionUses Uses PeersHomeownerSafeHomeproductInternet-based
systemSurveillance
functionSensorsControl panelSensors UsesFIGURE9.6Architectural
context
diagram for
the SafeHome
security
functionpre75977_ch09.qxd  11/27/08  3:42 PM  Page 257
¥Indicator.
An abstraction that represents all mechanisms (e.g., alarm siren,flashing lights, bell) for indicating that an alarm condition is occurring.¥Controller.
An abstraction that depicts the mechanism that allows thearming or disarming of a node. If controllers reside on a network, they havethe ability to communicate with one another.
Each of these archetypes is depicted using UML notation as shown in Figure 9.7.
Recall that the archetypes form the basis for the architecture but are abstractions that
must be further refined as architectural design proceeds. For example, 
Detector
might be refined into a class hierarchy of sensors.9.4.3Refining the Architecture into Components
Asthesoftwarearchitectureisrefinedintocomponents,thestructureofthesystem

beginstoemerge.Buthowarethesecomponentschosen?Inordertoanswerthis

question,youbeginwiththeclassesthatweredescribedaspartoftherequire-

mentsmodel.
4Theseanalysisclassesrepresententitieswithintheapplication
(business)domainthatmustbeaddressedwithinthesoftwarearchitecture.Hence,

theapplicationdomainisonesourceforthederivationandrefinementofcompo-

nents.Anothersourceistheinfrastructuredomain.Thearchitecturemustaccom-

modatemanyinfrastructurecomponentsthatenableapplicationcomponents

buthavenobusinessconnectiontotheapplicationdomain.Forexample,mem-

orymanagementcomponents,communicationcomponents,databasecompo-

nents,andtaskmanagementcomponentsareoftenintegratedintothesoftware

architecture.258PART TWOMODELINGController
NodeCommunicates withDetectorIndicatorFIGURE9.7UML relation-
ships for
SafeHome
security
function
archetypes

Source:Adapted from[Bos00].4If a conventional (non-object-oriented) approach is chosen, components are derived from the data
flow model. I discuss this approach briefly in Section 9.6.uote:ÒThe structure of asoftware system
provides the
ecology in which
code is born,
matures, and dies.
A well-designed
habitat allows for
the successful
evolution of all the
components
needed in a
software system.ÓR.Pattis
pre75977_ch09.qxd  11/27/08  3:42 PM  Page 258
The interfaces depicted in the architecture context diagram (Section 9.4.1) implyone or more specialized components that process the data that flows across theinterface. In some cases (e.g., a graphical user interface), a complete subsystem
architecture with many components must be designed.Continuing the SafeHomehome security function example, you might define the
set of top-level components that address the following functionality:¥External communication management
Ñcoordinates communication of the
security function with external entities such as other Internet-based systems
and external alarm notification.¥Control panel processingÑmanages all control panel functionality.
¥Detector managementÑcoordinates access to all detectors attached to the
system.¥Alarm processingÑverifies and acts on all alarm conditions.Each of these top-level components would have to be elaborated iteratively and then
positioned within the overall 
SafeHomearchitecture. Design classes (with appro-priate attributes and operations) would be defined for each. It is important to note,

however, that the design details of all attributes and operations would not be speci-

fied until component-level design (Chapter 10).The overall architectural structure (represented as a UML component diagram) is
illustrated in Figure 9.8. Transactions are acquired by 
external communication man-
agementas they move in from components that process the 
SafeHomeGUI and theCHAPTER 9ARCHITECTURAL DESIGN259SafeHome executiveExternal 
communicationmanagement GUI Internet
interface
Function selectionSecuritySurveillance
HomemanagementControl panel processingDetectormanagementAlarm
processing-FIGURE9.8Overall architectural structure for 
SafeHomewith top-level componentspre75977_ch09.qxd  11/27/08  3:42 PM  Page 259
Internet interface. This information is managed by a SafeHomeexecutive compo-nent that selects the appropriate product function (in this case security). The controlpanel processingcomponent interacts with the homeowner to arm/disarm the se-curity function. The detector managementcomponent polls sensors to detect analarm condition, and the alarm processingcomponent produces output when analarm is detected.9.4.4Describing Instantiations of the System
The architectural design that has been modeled to this point is still relatively highlevel. The context of the system has been represented, archetypes that indicate the
important abstractions within the problem domain have been defined, the overall

structure of the system is apparent, and the major software components have
been identified. However, further refinement (recall that all design is iterative) is

still necessary.
To accomplish this, an actual instantiation of the architecture is developed. By this
I mean that the architecture is applied to a specific problem with the intent of demon-
strating that the structure and components are appropriate.Figure 9.9illustrates an instantiation of the 
SafeHomearchitecture for the securitysystem. Components shown in Figure 9.8are elaborated to show additional detail.

For example, the 
detector managementcomponent interacts with a scheduler
infra-structure component that implements polling of each sensorobject used by the se-curity system. Similar elaboration is performed for each of the components
represented in Figure 9.8.260PART TWOMODELINGArchitectural Design
Objective:Architectural design tools modelthe overall software structure by representingcomponent interface, dependencies and relationships, and
interactions.Mechanics:Tool mechanics vary. In most cases, 
architectural design capability is part of the functionality
provided by automated tools for analysis and design
modeling.Representative Tools:
5Adalon,developed by Synthis Corp. (www.synthis.
com), is a specialized design tool for the design andconstruction of specific Web-based component
architectures.ObjectiF,
developed by microTOOL GmbH(www.microtool.de/objectiF/en/
), is a UML-based design tool that leads to architectures 
(e.g., Coldfusion, J2EE, Fusebox) amenable to
component-based software engineering 
(Chapter 29).Rational Rose,developed by Rational (www-306.ibm.com/software/rational/), is a UML-based design tool that supports all 

aspects of architectural design.SOFTWARE
TOOLS5Tools noted here do not represent an endorsement, but rather a sampling of tools in this category.
In most cases, tool names are trademarked by their respective developers.pre75977_ch09.qxd  11/27/08  3:42 PM  Page 260
CHAPTER 9ARCHITECTURAL DESIGN261External
communicationmanagementGUI Internet
interface
SecurityControlpanel processingDetectormanagementAlarm
processingKeypadprocessingCP displayfunctionsSchedulerPhonecommunicationAlarm
SafeHomeexecutiveSensorFIGURE9.9An instantiation of the security function with component elaboration9.5A
SSESSINGALTERNATIVE
ARCHITECTURALDESIGNSIn their book on the evaluation of software architectures, Clements and hiscolleagues [Cle03] state:To put it bluntly, an architecture is a bet, a wager on the success of a system. WouldnÕt it
be nice to know in advance if youÕve placed your bet on a winner, as opposed to waiting

until the system is mostly completed before knowing whether it will meet its requirements
or not? If youÕre buying a system or paying for its development, wouldnÕt you like to have

some assurance that itÕs started off down the right path? If youÕre the architect yourself,

wouldnÕt you like to have a good way to validate your intuitions and experience, so that

you can sleep at night knowing that the trust placed in your design is well founded?Indeed, answers to these questions would have value. Design results in a number ofarchitectural alternatives that are each assessed to determine which is the most
appropriate for the problem to be solved. In the sections that follow, I present two

different approaches for the assessment of alternative architectural designs. The first
method uses an iterative method to assess design trade-offs. The second approach
applies a pseudo-quantitative technique for assessing design quality.
pre75977_ch09.qxd  11/27/08  3:42 PM  Page 261
262PART TWOMODELINGWebRef
In-depth information 
on ATAM can be

obtained at: 
www.sei.cmu.edu/

activities/
architecture/
ata_method.html.9.5.1An Architecture Trade-Off Analysis Method
The Software Engineering Institute (SEI) has developed an architecture trade-off analy-
sis method(ATAM) [Kaz98] that establishes an iterative evaluation process for software
architectures. The design analysis activities that follow are performed iteratively:1.Collect scenarios.A set of use cases (Chapters 5 and 6) is developed torepresent the system from the userÕs point of view.
2.Elicit requirements, constraints, and environment description.
This informationis determined as part of requirements engineering and is used to be certain
that all stakeholder concerns have been addressed.3.Describe the architectural styles/patterns that have been chosen to address the

scenarios and requirements.The architectural style(s) should be describedusing one of the following architectural views:¥Module viewfor analysis of work assignments with components and thedegree to which information hiding has been achieved.¥Process viewfor analysis of system performance.¥Data flow viewfor analysis of the degree to which the architecture meetsfunctional requirements.4.Evaluate quality attributes by considering each attribute in isolation.
The num-ber of quality attributes chosen for analysis is a function of the time available
for review and the degree to which quality attributes are relevant to the sys-
tem at hand. Quality attributes for architectural design assessment include
reliability, performance, security, maintainability, flexibility, testability, porta-

bility, reusability, and interoperability.
5.Identify the sensitivity of quality attributes to various architectural attributes for a

specific architectural style.
This can be accomplished by making small changes inthe architecture and determining how sensitive a quality attribute, say perform-

ance, is to the change. Any attributes that are significantly affected by variation

in the architecture are termed sensitivity points.6.Critique candidate architectures (developed in step 3) using the sensitivity analy-

sis conducted in step 5.The SEI describes this approach in the followingmanner [Kaz98]:Once the architectural sensitivity points have been determined, finding trade-offpoints is simply the identification of architectural elements to which multiple attrib-
utes are sensitive. For example, the performance of a client-server architecture might

be highly sensitive to the number of servers (performance increases, within some
range, by increasing the number of servers)....The number of servers, then, is a

trade-off point with respect to this architecture.These six steps represent the first ATAM iteration. Based on the results of steps 5 and
6, some architecture alternatives may be eliminated, one or more of the remainingpre75977_ch09.qxd  11/27/08  3:42 PM  Page 262
architectures may be modified and represented in more detail, and then the ATAM
steps are reapplied.6CHAPTER 9ARCHITECTURAL DESIGN263Architecture Assessment
The scene:Doug MillerÕs office as
architectural design modeling proceeds.The players:Vinod, Jamie, and EdÑmembers of the
SafeHomesoftware engineering team and Doug Miller,
manager of the software engineering group.
The conversation:
Doug:I know you guys are deriving a couple ofdifferent architectures for the 
SafeHomeproduct, andthatÕs a good thing. I guess my question is, how are we
going to choose the one thatÕs best?
Ed:IÕm working on a call and return style and then
either Jamie or I are going to derive an OO architecture.
Doug:Okay, and how do we choose?
Jamie:ItookaCScourseindesigninmysenioryear,and
Irememberthatthereareanumberofwaystodoit.

Vinod:
There are, but theyÕre a bit academic. Look, Ithink we can do our assessment and choose the right oneusing use cases and scenarios.Doug:IsnÕt that the same thing?
Vinod:
Not when youÕre talking about architecturalassessment. We already have a complete set of use cases.
So we apply each to both architectures and see how the system reacts, how components and connectors work in
the use case context.Ed:ThatÕs a good idea. Makes sure we didnÕt leave
anything out.
Vinod:
True, but it also tells us whether the architectural
design is convoluted, whether the system has to twist itselfinto a pretzel to get the job done.Jamie:ScenariosarenÕtjustanothernameforusecases.
Vinod:
No, in this case a scenario implies somethingdifferent.

Doug:YouÕre talking about a quality scenario or a
change scenario, right?
Vinod:
Yes. What we do is go back to the stakeholders
and ask them how SafeHomeis likely to change over thenext, say, three years. You know, new versions, features,
that sort of thing. We build a set of change scenarios.

We also develop a set of quality scenarios that define

the attributes weÕd like to see in the software
architecture.Jamie:And we apply them to the alternatives.
Vinod:
Exactly. The style that handles the use cases and
scenarios best is the one we choose.SAFEHOME9.5.2Architectural Complexity
A useful technique for assessing the overall complexity of a proposed architecture is
to consider dependencies between components within the architecture. These de-
pendencies are driven by information/control flow within the system. Zhao [Zha98]
suggests three types of dependencies:Sharing dependenciesrepresent dependence relationships among consumers who use thesame resource or producers who produce for the same consumers. For example, for two
components uand v, if uand vrefer to the same global data, then there exists a shareddependence relationship between uand v.Flow dependenciesrepresent dependence relationships between producers and con-sumers of resources. For example, for two components 
uand v,if umust complete before6The 
Software Architecture Analysis Method(SAAM) is an alternative to ATAM and is well-worthexamining by those readers interested in architectural analysis. A paper on SAAM can be down-loaded from www.sei.cmu.edu/publications/articles/saam-metho-propert-sas.html.pre75977_ch09.qxd  11/27/08  3:42 PM  Page 263
264PART TWOMODELINGcontrol flows into v(prerequisite), or if ucommunicates with vby parameters, then thereexists a flow dependence relationship between uand v.Constrained dependencies
represent constraints on the relative flow of control amonga set of activities. For example, for two components 
uand v, uand vcannot execute atthe same time (mutual exclusion), then there exists a constrained dependence relation-ship between uand v.The sharing and flow dependencies noted by Zhao are similar to the concept of cou-pling discussed in Chapter 8. Coupling is an important design concept that is appli-
cable at the architectural level and at the component level. Simple metrics for
evaluating coupling are discussed in Chapter 23.9.5.3Architectural Description Languages
The architect of a house has a set of standardized tools and notation that allow the
design to be represented in an unambiguous, understandable fashion. Although the
software architect can draw on UML notation, other diagrammatic forms, and a few

related tools, there is a need for a more formal approach to the specification of an
architectural design.Architectural description language
(ADL) provides a semantics and syntax for describ-
ing a software architecture. Hofmann and his colleagues [Hof01] suggest that an ADL
should provide the designer with the ability to decompose architectural components,

compose individual components into larger architectural blocks, and represent inter-
faces (connection mechanisms) between components. Once descriptive, language-

based techniques for architectural design have been established, it is more likely that
effective assessment methods for architectures will be established as the design evolves.The following summary of a number of important
ADLs was prepared by Rickard Land [Lan02]and is reprinted with the authorÕs permission. It should be

noted that the first five ADLs listed have been developed for
research purposes and are not commercial products.Rapide(http://poset.stanford.edu/rapide/)builds on the notion of partial ordered sets, and thus
introduces quite new (but seemingly powerful)

programming constructs.UniCon(www.cs.cmu.edu/~UniCon
)is Òan
architectural description language intended to aid
designers in defining software architectures in terms of

abstractions that they find useful.ÓAesop(www.cs.cmu.edu/~able/aesop/
)addressestheproblemofstylereuse.WithAesop,itis

possibletodefinestylesandusethemwhenconstructing

anactualsystem.
Wright
(www.cs.cmu.edu/~able/wright/
)is a
formal language including the following elements:

componentswith ports
, connectorswith roles, and glueto attach roles to ports. Architectural styles can be

formalized in the language with predicates, thus

allowing for static checks to determine the consistency

and completeness of an architecture.Acme(www.cs.cmu.edu/~acme/
) can be seen asa second-generation ADL, in that its intention is to
identify a kind of least common denominator for
ADLs.UML(www.uml.org/
)includes many of the artifacts
needed for architectural descriptionsÑprocesses,
nodes, views, etc. For informal descriptions, UML is

well suited just because it is a widely understood
standard. It, however, lacks the full strength needed for

an adequate architectural description.SOFTWARE
TOOLSArchitectural Description Languages
pre75977_ch09.qxd  11/27/08  3:42 PM  Page 264
CHAPTER 9ARCHITECTURAL DESIGN2659.6A
RCHITECTURALMAPPINGUSINGDATA
FLOWThe architectural styles discussed in Section 9.3.1 represent radically different archi-tectures. So it should come as no surprise that a comprehensive mapping that
accomplishes the transition from the requirements model to a variety of architectural
styles does not exist. In fact, there is no practical mapping for some architectural
styles, and the designer must approach the translation of requirements to design for
these styles in using the techniques discussed in Section 9.4.To illustrate one approach to architectural mapping, consider the call and return
architectureÑan extremely common structure for many types of systems. The call
and return architecture can reside within other more sophisticated architectures
discussed earlier in this chapter. For example, the architecture of one or more

components of a client-server architecture might be call and return.A mapping technique, called 
structured design[You79], is often characterized as a
data flow-oriented design method because it provides a convenient transition from a

data flow diagram (Chapter 7) to software architecture.7The transition from informa-tion flow (represented as a DFD) to program structure is accomplished as part of a six-
step process: (1) the type of information flow is established, (2) flow boundaries are
indicated, (3) the DFD is mapped into the program structure, (4) control hierarchy is

defined, (5) the resultant structure is refined using design measures and heuristics, and
(6) the architectural description is refined and elaborated.Asabriefexampleofdataflowmapping,Ipresentastep-by-stepÒtransformÓ
mappingforasmallpartofthe
SafeHomesecurityfunction.
8Inordertoperformthe
mapping,thetypeofinformationflowmustbedetermined.Onetypeofinformation

flowiscalled
transformflow
andexhibitsalinearquality.Dataflowsintothesystem
alongan
incomingflowpath
whereitistransformedfromanexternalworld
representationintointernalizedform.Onceithasbeeninternalized,itisprocessed

ata
transformcenter.
Finally,itflowsoutofthesystemalongan
outgoingflowpath
thattransformsthedataintoexternalworldform.
99.6.1 Transform Mapping
Transform mapping is a set of design steps that allows a DFD with transform flow

characteristics to be mapped into a specific architectural style. To illustrate this

approach, we again consider the SafeHomesecurity function.10One element of theanalysis model is a set of data flow diagrams that describe information flow within7It should be noted that other elements of the requirements model are also used during the mapping
method.8A more detailed discussion of structured design is presented within the website that accompanies
this book.9Anotherimportanttypeofinformationflow,
transactionflow,
isnotconsideredinthisexample,butis
addressedinthestructureddesignexamplepresentedwithinthewebsitethataccompaniesthisbook.
10We consider only the portion of the 
SafeHomesecurity function that uses the control panel. Otherfeatures discussed throughout this book are not considered here.pre75977_ch09.qxd  11/27/08  3:42 PM  Page 265
266PART TWOMODELINGthe security function. To map these data flow diagrams into a software architecture,
you would initiate the following design steps:Step 1. Review the fundamental system model.
The fundamental system modelor context diagram depicts the security function as a single transformation, repre-senting the external producers and consumers of data that flow into and out of the
function. Figure 9.10depicts a level 0 context model, and Figure 9.11shows refined

data flow for the security function.ControlpanelUser commandsand dataSensorsSensorstatusControlpaneldisplayTelephone
lineAlarm
SafeHomesoftwareDisplayinformation
Telephone
number tonesAlarm
typeFIGURE9.10Context-levelDFD for the
SafeHome
security
functiontelephonelineConfiguration information
ControlpanelSensorsControlpaneldisplayTelephone
lineAlarm
InteractwithuserConfiguresystemActivate/deactivatesystemProcesspasswordMonitorsensorsDisplaymessagesand statusUser commandsand dataPasswordStart
stopConfigurerequestConfigurationdataConfigurationdataConfigurationdataValid ID msg.
A/D msg.SensorstatusSensorinformation
Alarm type
Telephone
number tonesDisplayinformation
FIGURE9.11Level 1 DFD forthe SafeHome
security
functionpre75977_ch09.qxd  11/27/08  3:42 PM  Page 266
Step 2. Review and refine data flow diagrams for the software.
Informationobtained from the requirements model is refined to produce greater detail. Forexample, the level 2 DFD for 
monitor sensors(Figure 9.12) is examined, and a level 3data flow diagram is derived as shown in Figure 9.13. At level 3, each transform inCHAPTER 9ARCHITECTURAL DESIGN267IftheDFDisrefined
furtheratthistime,strive

toderivebubblesthat

exhibithighcohesion.
Configuration information
ReadsensorsAssessagainstsetupConfigurationdataSensor ID,typeSensorstatusGeneratealarm
signalAlarm
typeAlarm
dataTelephone
numberDialphoneTelephone
number tonesFormat
fordisplaySensorinformation
Sensor IDtype,locationFIGURE9.12Level 2 DFDthat refines the

monitor
sensors
transform
Generatepulses tolineTelephone
number tonesSet upconnectionto phonenetSelectphonenumberEstablishalarm
conditionsAcquireresponseinfoReadsensorsGeneratealarm
signalFormat
displayGeneratedisplayConfiguration information
Configuration dataSensorstatusSensorID, settingAlarm
condition code,sensor ID, timinginformation
List ofnumbersTelephone
numberTone
readytelephonenumberAlarm
dataSensorID type,locationFormated
ID, type,locationAlarm
typeSensorinformation
FIGURE9.13Level 3 DFD for monitor sensorswith flow boundariespre75977_ch09.qxd  11/27/08  3:42 PM  Page 267
the data flow diagram exhibits relatively high cohesion (Chapter 8). That is, theprocess implied by a transform performs a single, distinct function that can be

implemented as a component in the SafeHomesoftware. Therefore, the DFD in
Figure 9.13contains sufficient detail for a Òfirst cutÓ at the design of architecture for

the monitor sensorssubsystem, and we proceed without further refinement.Step 3. Determine whether the DFD has transform or transaction flow
11characteristics.
Evaluating the DFD (Figure 9.13), we see data entering the soft-ware along one incoming path and exiting along three outgoing paths. Therefore, an

overall transform characteristic will be assumed for information flow.
Step 4. Isolate the transform center by specifying incoming and outgoing
flow boundaries.
Incoming data flows along a path in which information isconverted from external to internal form; outgoing flow converts internalized data

to external form. Incoming and outgoing flow boundaries are open to interpretation.
That is, different designers may select slightly different points in the flow as bound-
ary locations. In fact, alternative design solutions can be derived by varying the
placement of flow boundaries. Although care should be taken when boundaries are
selected, a variance of one bubble along a flow path will generally have little impact
on the final program structure.Flow boundaries for the example are illustrated as shaded curves running verti-cally through the flow in Figure 9.13. The transforms (bubbles) that constitute the
transform center lie within the two shaded boundaries that run from top to bottom
in the figure. An argument can be made to readjust a boundary (e.g., an incoming
flow boundary separating read sensorsand acquire response infocould be proposed).The emphasis in this design step should be on selecting reasonable boundaries,
rather than lengthy iteration on placement of divisions.Step 5. Perform Òfirst-level factoring.Ó
The program architecture derived usingthis mapping results in a top-down distribution of control. Factoringleads to aprogram structure in which top-level components perform decision making and low-level components perform most input, computation, and output work. Middle-level
components perform some control and do moderate amounts of work.When transform flow is encountered, a DFD is mapped to a specific structure(acall and return architecture) that provides control for incoming, transform, and

outgoing information processing. This first-level factoring for the monitor sensors
subsystem is illustrated in Figure 9.14. A main controller (called monitor sensorsexecutive) resides at the top of the program structure and coordinates the following
subordinate control functions:¥An incoming information processing controller, called 
sensor input controller,

coordinates receipt of all incoming data.268PART TWOMODELINGYou will often
encounter both other
types of data flow
within the same flow-
oriented model. The
flows are partitioned,

and program structure

is derived using the
appropriate mapping.Vary the location of

flow boundaries in an
effort to explore alter-

native program struc-

tures. This takes very

little time and provides
important insight.
11In transaction flow, a single data item, called a 
transaction,causes the data flow to branch alongone of a number of flow paths defined by the nature of the transaction.pre75977_ch09.qxd  11/27/08  3:42 PM  Page 268
CHAPTER 9ARCHITECTURAL DESIGN269¥A transform flow controller, called 
alarm conditions controller,
supervises alloperations on data in internalized form (e.g., a module that invokes various
data transformation procedures).¥An outgoing information processing controller, called 
alarm output controller,

coordinates production of output information.Although a three-pronged structure is implied by Figure 9.14, complex flows inlarge systems may dictate two or more control modules for each of the generic
control functions described previously. The number of modules at the first level

should be limited to the minimum that can accomplish control functions and still
maintain good functional independence characteristics.Step 6. Perform Òsecond-level factoring.Ó
Second-level factoring is accom-plished by mapping individual transforms (bubbles) of a DFD into appropriatemodules within the architecture. Beginning at the transform center boundary and
moving outward along incoming and then outgoing paths, transforms are mapped

into subordinate levels of the software structure. The general approach to second-
level factoring is illustrated in Figure 9.15.AlthoughFigure9.15illustratesaone-to-onemappingbetweenDFDtransforms
andsoftwaremodules,differentmappingsfrequentlyoccur.Twooreventhreebub-

blescanbecombinedandrepresentedasonecomponent,orasinglebubblemay

beexpandedtotwoormorecomponents.Practicalconsiderationsandmeasures
MonitorsensorsexecutiveAlarm
conditionscontrollerAlarm
outputcontrollerSensorinputcontrollerFIGURE9.14First-levelfactoring for
monitor
sensorsDonÕt becomedogmatic at this stage.
It may be necessary to

establish two or more
controllers for input
processing or computa-
tion, based on the
complexity of the
system to be built. If
common sense dictates
this approach, do it!Eliminateredundant
controlmodules.Thatis,

ifacontrolmoduledoes

nothingexceptcontrol

oneothermodule,its

controlfunctionshould

beimplodedtoahigher-

levelmodule.
pre75977_ch09.qxd  11/27/08  3:42 PM  Page 269
ofdesignqualitydictatetheoutcomeofsecond-levelfactoring.Reviewandrefine-
mentmayleadtochangesinthisstructure,butitcanserveasaÒfirst-iterationÓ

design.Second-levelfactoringforincomingflowfollowsinthesamemanner.Factoring
isagainaccomplishedbymovingoutwardfromthetransformcenterboundaryon

theincomingflowside.Thetransformcenterof
monitorsensors
subsystemsoft-
wareismappedsomewhatdifferently.Eachofthedataconversionorcalculation

transformsofthetransformportionoftheDFDismappedintoamodulesubordi-

natetothetransformcontroller.Acompletedfirst-iterationarchitectureisshown

inFigure9.16.
The components mapped in the preceding manner and shown in Figure 9.16represent an initial design of software architecture. Although components are
named in a manner that implies function, a brief processing narrative (adapted from
the process specification developed for a data transformation created during
requirements modeling) should be written for each. The narrative describes the270PART TWOMODELINGMonitorsensorsexecutiveAlarm
conditionscontrollerAlarm
outputcontrollerSensorinputcontrollerGeneratealarm
signalFormat
displayGeneratedisplaySet upconnectionto phonenetGeneratepulses tolineTransform
flow boundary
Generatealarm
signalSet upconnectionto phone netFormat
displayGeneratepulses to lineGeneratedisplayFIGURE9.15Second-levelfactoring for
monitor
sensorsKeepÒworkerÓmodules
lowintheprogram

structure.Thiswilllead

toanarchitecturethatis

easiertomaintain.
pre75977_ch09.qxd  11/27/08  3:42 PM  Page 270
CHAPTER 9ARCHITECTURAL DESIGN271component interface, internal data structures, a functional narrative, and a brief
discussion of restrictions and special features (e.g., file input-output, hardware-
dependent characteristics, special timing requirements).Step7.Refinethefirst-iterationarchitectureusingdesignheuristicsfor
improvedsoftwarequality.
Afirst-iterationarchitecturecanalwaysberefinedby
applyingconceptsoffunctionalindependence(Chapter8).Componentsareexploded

orimplodedtoproducesensiblefactoring,separationofconcerns,goodcohesion,

minimalcoupling,andmostimportant,astructurethatcanbeimplementedwithout

difficulty,testedwithoutconfusion,andmaintainedwithoutgrief.
Refinements are dictated by the analysis and assessment methods describedbriefly in Section 9.5, as well as practical considerations and common sense. There
are times, for example, when the controller for incoming data flow is totally unnec-

essary, when some input processing is required in a component that is subordi-

nateto the transform controller, when high coupling due to global data cannot be

avoided, or when optimal structural characteristics cannot be achieved. Software
requirements coupled with human judgment is the final arbiter.
The objective of the preceding seven steps is to develop an architectural repre-sentation of software. That is, once structure is defined, we can evaluate and refine
software architecture by viewing it as a whole. Modifications made at this time
require little additional work, yet can have a profound impact on software quality.
You should pause for a moment and consider the difference between the design
approach described and the process of Òwriting programs.Ó If code is the only repre-
sentation of software, you and your colleagues will have great difficulty evaluating

or refining at a global or holistic level and will, in fact, have difficulty Òseeing the
forest for the trees.ÓAlarm
outputcontrollerGeneratealarm
signalSet upconnectionto phone netFormat
displayGeneratepulses to lineGeneratedisplayAlarm
conditionscontrollerSelectphonenumberEstablishalarm
conditionsMonitorsensorsexecutiveSensorinputcontrollerAcquireresponseinfoReadsensorsFIGURE9.16First-iterationstructure for

monitor
sensorsuote:ÒMake it as simpleas possible. But no
simpler.Ó
AlbertEinstein
pre75977_ch09.qxd  11/27/08  3:42 PM  Page 271
272PART TWOMODELINGThe scene:JamieÕs cubicle, as
design modeling begins.The players:Jamie and EdÑmembers of theSafeHomesoftware engineering team.The conversation:
[Ed has just completed a first-cut design of the monitorsensors subsystem. He stops in to ask Jamie her 
opinion.]Ed:So hereÕs the architecture that I derived.
[Ed shows Jamie Figure 9.16, which she studies for a fewmoments.]Jamie:ThatÕs cool, but I think we can do a few things to
make it simpler...and better.

Ed:Such as?Jamie:Well, why did you use the 
sensor input controllercomponent?
Ed:Because you need a controller for the mapping.Jamie:Not really. The controller doesnÕt do much, since
weÕre managing a single flow path for incoming data.We can eliminate the controller with no ill effects.
Ed:I can live with that. IÕll make the change and...
Jamie (smiling):Hold up! We can also implode the
components establish alarm conditions
and select phonenumber. The transform controller you show isnÕt really
necessary, and the small decrease in cohesion is tolerable.
Ed:Simplification, huh?Jamie:Yep. And while weÕre making refinements, it
would be a good idea to implode the components format
displayand generate display. Display formatting for the
control panel is simple. We can define a new module
called produce display.
Ed (sketching):So this is what you think we should do?Ó[Shows Jamie Figure 9.17.]
Jamie:ItÕs a good start.
SAFEHOMEAlarm
outputcontrollerGeneratealarm
signalSet upconnectionto phone netProducedisplayGeneratepulses to lineEstablishalarm
conditionsMonitorsensorsexecutiveAcquireresponseinfoReadsensorsFIGURE9.17Refinedprogram

structure for

monitor
sensorsRefining a First-Cut Architecture
9.6.2Refining the Architectural Design
Any discussion of design refinement should be prefaced with the following com-ment: ÒRemember that an Ôoptimal designÕ that doesnÕt work has questionable

merit.Ó You should be concerned with developing a representation of software that

will meet all functional and performance requirements and merit acceptance based
on design measures and heuristics.Whathappensafter the
architecture has
been created??pre75977_ch09.qxd  11/27/08  3:42 PM  Page 272
CHAPTER 9ARCHITECTURAL DESIGN273Refinement of software architecture during early stages of design is to be en-couraged. As I discussed earlier in this chapter, alternative architectural styles may
be derived, refined, and evaluated for the ÒbestÓ approach. This approach to opti-
mization is one of the true benefits derived by developing a representation of soft-
ware architecture.It is important to note that structural simplicity often reflects both elegance andefficiency. Design refinement should strive for the smallest number of components

that is consistent with effective modularity and the least complex data structure that
adequately serves information requirements.9.7S
UMMARYSoftware architecture provides a holistic view of the system to be built. It depicts the

structure and organization of software components, their properties, and the con-
nections between them. Software components include program modules and the
various data representations that are manipulated by the program. Therefore, data

design is an integral part of the derivation of the software architecture. Architecture
highlights early design decisions and provides a mechanism for considering the ben-

efits of alternative system structures.A number of different architectural styles and patterns are available to the soft-ware engineer and may be applied within a given architectural genre. Each style de-
scribes a system category that encompasses a set of components that perform a
function required by a system; a set of connectors that enable communication, co-
ordination, and cooperation among components; constraints that define how com-
ponents can be integrated to form the system; and semantic models that enable a
designer to understand the overall properties of a system.
In a general sense, architectural design is accomplished using four distinct steps.
First, the system must be represented in context. That is, the designer should define
the external entities that the software interacts with and the nature of the interac-
tion. Once context has been specified, the designer should identify a set of top-level
abstractions, called archetypes, that represent pivotal elements of the systemÕs be-

havior or function. After abstractions have been defined, the design begins to move

closer to the implementation domain. Components are identified and represented
within the context of an architecture that supports them. Finally, specific instantia-

tions of the architecture are developed to ÒproveÓ the design in a real-world context.
As a simple example of architectural design, the mapping method presented inthis chapter uses data flow characteristics to derive a commonly used architectural
style. A data flow diagram is mapped into program structure using a transform map-
ping approach. Transform mapping is applied to an information flow that exhibits

distinct boundaries between incoming and outgoing data. The DFD is mapped into a
structure that allocates control to input, processing, and output along three sepa-
rately factored module hierarchies. Once an architecture has been derived, it is elab-
orated and then analyzed using quality criteria.pre75977_ch09.qxd  11/27/08  3:42 PM  Page 273
PROBLEMSAND
POINTSTO
PONDER9.1.Using the architecture of a house or building as a metaphor, draw comparisons with
software architecture. How are the disciplines of classical architecture and the software archi-tecture similar? How do they differ?9.2.Present two or three examples of applications for each of the architectural styles noted inSection 9.3.1.
9.3.Some of the architectural styles noted in Section 9.3.1 are hierarchical in nature and oth-ers are not. Make a list of each type. How would the architectural styles that are not hierarchi-cal be implemented?9.4.The terms architectural style, architectural pattern,
and framework
(not discussed in thisbook) are often encountered in discussions of software architecture. Do some research anddescribe how each of these terms differs from its counterparts.9.5.Select an application with which you are familiar. Answer each of the questions posed for
control and data in Section 9.3.3.
9.6.Research the ATAM (using [Kaz98]) and present a detailed discussion of the six steps
presented in Section 9.5.1.
9.7.If you havenÕt done so, complete Problem 6.6. Use the design methods described in this
chapter to develop a software architecture for the PHTRS.
9.8.Using a data flow diagram and a processing narrative, describe a computer-based system
that has distinct transform flow characteristics. Define flow boundaries and map the DFD into asoftware architecture using the technique described in Section 9.6.1.FURTHER
READINGSAND
INFORMATION
SOURCESThe literature on software architecture has exploded over the past decade. Books by Gorton

(Essential Software Architecture,
Springer, 2006), Reekie and McAdam (
A Software Architecture
Primer,
Angophora Press, 2006), Albin (The Art of Software Architecture,
Wiley, 2003), and Bass
and his colleagues (Software Architecture in Practice,
2ded., Addison-Wesley, 2002) present
worthwhile introductions to an intellectually challenging topic area.Buschman and his colleagues (Pattern-Oriented Software Architecture,
Wiley, 2007) and
Kuchana (
Software Architecture Design Patterns in Java,
Auerbach, 2004) discuss pattern-oriented
aspects of architectural design. Rozanski and Woods (
Software Systems Architecture,
Addison-Wesley, 2005), Fowler (
Patterns of Enterprise Application Architecture,
Addison-Wesley, 2003),
Clements and his colleagues (Documenting Software Architecture: View and Beyond,
Addison-Wesley, 2002), Bosch [Bos00], and Hofmeister and his colleagues [Hof00] provide in-depth treat-

ments of software architecture.Hennesey and Patterson (Computer Architecture,
4th ed., Morgan-Kaufmann, 2007) take adistinctly quantitative view of software architectural design issues. Clements and his colleagues
(Evaluating Software Architectures,
Addison-Wesley, 2002) consider the issues associated with
the assessment of architectural alternatives and the selection of the best architecture for a given
problem domain.Implementation-specific books on architecture address architectural design within a specificdevelopment environment or technology. Marks and Bell (
Service-Oriented Architecture,
Wiley,
2006) discuss a design approach that links business and computational resources with the re-
quirements defined by customers. Stahl and his colleagues (Model-Driven Software Development,
Wiley, 2006) discuss architecture within the context of domain-specific modeling approaches.

Radaideh and Al-ameed (Architecture of Reliable Web Applications Software,
GI Global, 2007) con-sider architectures that are appropriate for WebApps. Clements and Northrop (
Software Product
Lines: Practices and Patterns,
Addison-Wesley, 2001) address the design of architectures that
274PART TWOMODELINGpre75977_ch09.qxd  12/3/08  1:58 PM  Page 274
CHAPTER 9ARCHITECTURAL DESIGN275support software product lines. Shanley (Protected Mode Software Architecture,
Addison-Wesley,
1996) provides architectural design guidance for anyone designing PC-based real-time operating
systems, multitask operating systems, or device drivers.Current software architecture research is documented yearly in the Proceedings of the Inter-national Workshop on Software Architecture,
sponsored by the ACM and other computing organ-
izations, and the Proceedings of the International Conference on Software Engineering.A wide variety of information sources on architectural design are available on the Internet.An up-to-date list of World Wide Web references that are relevant to architectural design can be

found at the SEPA website: 
www.mhhe.com/engcs/compsci/pressman/professional/

olc/ser.htm
.pre75977_ch09.qxd  12/3/08  1:58 PM  Page 275
Component-level design occurs after the first iteration of architecturaldesign has been completed. At this stage, the overall data and program

structure of the software has been established. The intent is to translatethe design model into operational software. But the level of abstraction of the
existing design model is relatively high, and the abstraction level of the opera-
tional program is low. The translation can be challenging, opening the door to the

introduction of subtle errors that are difficult to find and correct in later stages of
the software process. In a famous lecture, Edsgar Dijkstra, a major contributor to

our understanding of software design, stated [Dij72]:Software seems to be different from many other products, where as a rule higher qual-ity implies a higher price. Those who want really reliable software will discover that

they must find a means of avoiding the majority of bugs to start with, and as a result,276CHAPTER10COMPONENT-LEVELDESIGNKEYCONCEPTScohesion . . . . . . .286
componentsclassifying . . . .307

adaptation . . . .305

composition . . .305
object-oriented . . . . . .277
qualification . . .304

traditional . . . .298

WebApp . . . . . .296
component-baseddevelopment . . . .303
content design . . .297
coupling . . . . . . .288
What is it?A complete set of soft-ware components is defined duringarchitectural design. But the internal

data structures and processingdetails of each component are not represented
at a level of abstraction that is close to code.
Component-level design defines the data struc-
tures, algorithms, interface characteristics, and

communication mechanisms allocated to each
software component.Who does it?A software engineer performs 
component-level design.Why is it important?
You have to be able to de-
termine whether the software will work before

you build it. The component-level design repre-
sents the software in a way that allows you to re-
view the details of the design for correctness and
consistency with other design representations
(i.e., the data, architectural, and interface de-

signs). It provides a means for assessing whether
data structures, interfaces, and algorithms will

work.What are the steps?Design representationsofdata, architecture, and interfaces form the
QUICKLOOKfoundation for component-level design. The
class definition or processing narrative for each
component is translated into a detailed design
that makes use of diagrammatic or text-based
forms that specify internal data structures, local

interface detail, and processing logic. Design

notation encompasses UML diagrams and sup-
plementary forms. Procedural design is specified

using a set of structured programming con-
structs. It is often possible to acquire existing
reusable software components rather than build-
ing new ones.What is the work product?
The design for eachcomponent, represented in graphical, tabular,

or text-based notation, is the primary work

product produced during component-level
design.How do I ensure that IÕve done it right?A designreview is conducted. The design is examined to
determine whether data structures, interfaces, pro-

cessing sequences, and logical conditions are cor-
rect and will produce the appropriate data or
control transformation allocated to the component

during earlier design steps.pre75977_ch10.qxd  11/27/08  3:46 PM  Page 276
CHAPTER 10COMPONENT-LEVEL DESIGN277designguidelines . . . . . .285
domainengineering . . . .303

tabular design 
notation . . . . . . .300
the programming process will become cheaper . . . effective programmers . . . should notwaste their time debuggingÑthey should not introduce bugs to start with.Although these words were spoken many years ago, they remain true today. As you
translate the design model into source code, you should follow a set of design

principles that not only perform the translation but also do not Òintroduce bugs to
start with.ÓIt is possible to represent the component-level design using a programming lan-guage. In essence, the program is created using the architectural design model as a

guide. An alternative approach is to represent the component-level design using
some intermediate (e.g., graphical, tabular, or text-based) representation that can be

translated easily into source code. Regardless of the mechanism that is used to
represent the component-level design, the data structures, interfaces, and algo-
rithms defined should conform to a variety of well-established design guidelines that
help you to avoid errors as the procedural design evolves. In this chapter, I examine

these design guidelines and the methods available for achieving them.uote:ÒThe details arenot the details.
They make the
design.ÓCharlesEames
10.1W
HAT
ISACOMPONENT?A componentis a modular building block for computer software. More formally, the
OMG Unified Modeling Language Specification[OMG03a] defines a component as Ò...a modular, deployable, and replaceable part of a system that encapsulates
implementation and exposes a set of interfaces.ÓAs we discussed in Chapter 9, components populate the software architectureand, as a consequence, play a role in achieving the objectives and requirements of

the system to be built. Because components reside within the software architec-
ture, they must communicate and collaborate with other components and with

entities (e.g., other systems, devices, people) that exist outside the boundaries of
the software.The true meaning of the term componentwill differ depending on the point of viewof the software engineer who uses it. In the sections that follow, I examine three im-

portant views of what a component is and how it is used as design modeling proceeds.10.1.1An Object-Oriented View
In the context of object-oriented software engineering, a component contains a set
of collaborating classes.1Each class within a component has been fully elaboratedto include all attributes and operations that are relevant to its implementation. As
part of the design elaboration, all interfaces that enable the classes to communicate
and collaborate with other design classes must also be defined. To accomplish this,

you begin with the requirements model and elaborate analysis classes (for compo-
nents that relate to the problem domain) and infrastructure classes (for components
that provide support services for the problem domain).
From an object-oriented viewpoint, a
component is a set of
collaborating classes.1In some cases, a component may contain a single class.
pre75977_ch10.qxd  11/27/08  3:46 PM  Page 277
278PART TWOMODELINGPrintJobcomputeJobinitiateJobnumberOfPagesnumberOfSides
paperType

   paperWeight

   paperSize
   paperColor
magnification
colorRequirements
productionFeatures
   collationOptions
   bindingOptions
   coverStock
   bleed
   priority
totalJobCost
WOnumber PrintJobcomputePageCost( ) 
computePaperCost( ) 
computeProdCost( ) 
computeTotalJobCost( ) 

buildWorkOrder( ) 

checkPriority( ) 
passJobto Production( ) Elaborated design class<<interface>> 

computeJobcomputePageCost( ) 
computePaperCost( ) 
computeProdCost( ) 
computeTotalJobCost( )
<<interface>> 

initiateJobbuildWorkOrder( ) 

checkPriority( ) 
passJobto Production( )Design
componentnumberOfPages 
numberOfSides 
paperType 

magnification 
productionFeaturesPrintJobcomputeJobCost( ) 
passJobtoPrinter( ) Analysis classFIGURE10.1Elaboration ofa design
componentTo illustrate this process of design elaboration, consider software to be built for a
sophisticated print shop. The overall intent of the software is to collect the cus-
tomerÕs requirements at the front counter, cost a print job, and then pass the job on

to an automated production facility. During requirements engineering, an analysis

class called PrintJobwas derived. The attributes and operations defined duringanalysis are noted at the top of Figure 10.1. During architectural design, PrintJobisdefined as a component within the software architecture and is represented using
the shorthand UML notation2shown in the middle right of the figure. Note thatPrintJobhas two interfaces, computeJob,
which provides job costing capability, and
initiateJob,
which passes the job along to the production facility. These are repre-
sented using the ÒlollipopÓ symbols shown to the left of the component box.2Readers who are unfamiliar with UML notation should refer to Appendix 1.
pre75977_ch10.qxd  11/27/08  3:46 PM  Page 278
Component-level design begins at this point. The details of the component PrintJobmust be elaborated to provide sufficient information to guide implementation. The orig-
inal analysis class is elaborated to flesh out all attributes and operations required to im-
plement the class as the component PrintJob.Referring to the lower right portion ofFigure 10.1, the elaborated design class PrintJobcontains more detailed attributeinformation as well as an expanded description of operations required to implement
the component. The interfaces computeJob
and initiateJob
imply communication andcollaboration with other components (not shown here). For example, the operation

computePageCost()
(part of the computeJob
interface) might collaborate with aPricingTable
component that contains job pricing information. The checkPriority()
operation (part of the initiateJob
interface) might collaborate with a JobQueuecompo-nent to determine the types and priorities of jobs currently awaiting production.
This elaboration activity is applied to every component defined as part of thearchitectural design. Once it is completed, further elaboration is applied to each
attribute, operation, and interface. The data structures appropriate for each attribute

must be specified. In addition, the algorithmic detail required to implement the pro-
cessing logic associated with each operation is designed. This procedural design
activity is discussed later in this chapter. Finally, the mechanisms required to imple-

ment the interface are designed. For object-oriented software, this may encompass

the description of all messaging that is required to effect communication between
objects within the system.10.1.2The Traditional View
In the context of traditional software engineering, a component is a functional element
of a program that incorporates processing logic, the internal data structures that are re-

quired to implement the processing logic, and an interface that enables the component

to be invoked and data to be passed to it. A traditional component, also called a 
module,resides within the software architecture and serves one of three important roles: (1) a
control componentthat coordinates the invocation of all other problem domain com-
ponents, (2) a problem domain componentthat implements a complete or partial func-tion that is required by the customer, or (3) an 
infrastructure component
that isresponsible for functions that support the processing required in the problem domain.Like object-oriented components, traditional software components are derivedfrom the analysis model. In this case, however, the data flow-oriented element of the

analysis model serves as the basis for the derivation. Each transform (bubble) repre-
sented at the lowest levels of the data flow diagram is mapped (Section 9.6) into a
module hierarchy. Control components (modules) reside near the top of the hierar-

chy (program architecture), and problem domain components tend to reside toward
the bottom of the hierarchy. To achieve effective modularity, design concepts like

functional independence (Chapter 8) are applied as components are elaborated.To illustrate this process of design elaboration for traditional components, again
consider software to be built for a sophisticated print shop. A set of data flow diagramsCHAPTER 10COMPONENT-LEVEL DESIGN279Recall that analysismodeling and design
modeling are both
iterative actions. Elabo-
rating the original
analysis class may
require additional
analysis steps, which
are then followed with
design modeling steps
to represent the
elaborated design class
(the details of the
component).uote:ÒA complex systemthat works is
invariably found to
have evolved from
a simple system
that worked.ÓJohnGall
pre75977_ch10.qxd  11/27/08  3:46 PM  Page 279
280PART TWOMODELINGAs the design for eachsoftware component is
elaborated, the focus
shifts to the design of
specific data structures

and procedural design
to manipulate the data
structures. However,

donÕt forget the
architecture that must
house the components
or the global data
structures that

mayserve many

components.would be derived during requirements modeling. Assume that these are mapped intoan architecture shown in Figure 10.2. Each box represents a software component.
Note that the shaded boxes are equivalent in function to the operations defined for the
PrintJobclass discussed in Section 10.1.1. In this case, however, each operation is
represented as a separate module that is invoked as shown in the figure. Other mod-

ules are used to control processing and are therefore control components.During component-level design, each module in Figure 10.2is elaborated. The
module interface is defined explicitly. That is, each data or control object that flows

across the interface is represented. The data structures that are used internal to the
module are defined. The algorithm that allows the module to accomplish its intended
function is designed using the stepwise refinement approach discussed in Chapter 8.
The behavior of the module is sometimes represented using a state diagram.To illustrate this process, consider the module 
ComputePageCost.
The intent of thismodule is to compute the printing cost per page based on specifications provided by

the customer. Data required to perform this function are: 
number of pages in the docu-
ment, total number of documents to be produced, one- or two-side printing, color requirements,
and size requirements.These data are passed to ComputePageCost
via the moduleÕs in-
terface. ComputePageCost
uses these data to determine a page cost that is based onthe size and complexity of the jobÑa function of all data passed to the module via
the interface. Page cost is inversely proportional to the size of the job and directly

proportional to the complexity of the job.
Readprint jobdataJobmanagementsystemSelectjobmgmtfunctionDevelopjob costBuildwork orderSend jobtoproductionComputepage costComputepaper costComputeprod costCheckpriorityPass job toproductionFIGURE10.2Structure chart
for a tradi-
tional systempre75977_ch10.qxd  11/27/08  3:46 PM  Page 280
Figure 10.3represents the component-level design using a modified UML
notation. The ComputePageCost
module accesses data by invoking the module
getJobData,
which allows all relevant data to be passed to the component, and adatabase interface, 
accessCostsDB,which enables the module to access a databasethat contains all printing costs. As design continues, the ComputePageCost
module iselaborated to provide algorithm detail and interface detail (Figure 10.3). Algorithm
detail can be represented using the pseudocode text shown in the figure or with
aUML activity diagram. The interfaces are represented as a collection of input and

output data objects or items. Design elaboration continues until sufficient detail is
provided to guide construction of the component.
10.1.3A Process-Related View
The object-oriented and traditional views of component-level design presented in
Sections 10.1.1 and 10.1.2 assume that the component is being designed from
scratch. That is, you have to create a new component based on specifications
derived from the requirements model. There is, of course, another approach.
CHAPTER 10COMPONENT-LEVEL DESIGN281ComputePageCostDesign componentaccessCostsDBgetJobDataElaborated modulePageCostin: numberPages in: numberDocs 
in: sides= 1, 2 
in: color=1, 2, 3, 4 
in: page size = A, B, C, D 
out: page cost 
in:  job size 
in:  color=1, 2, 3, 4 
in:  pageSize = A, B, C, D 
out:  BPC 
out:  SF  job size (JS) =
    numberPages * numberDocs;
 lookup base page cost (BPC) -->
    accessCostsDB (JS, color);
 lookup size factor (SF) -->
    accessCostDB (JS, color, size)

 job complexity factor (JCF) = 
   1 + [(sides-1)*sideCost + SF]
 pagecost = BPC * JCF  getJobData (numberPages, numberDocs,
 sides, color, pageSize, pageCost) 

accessCostsDB(jobSize, color, pageSize, 

BPC, SF) 
computePageCost( )FIGURE10.3Component-level design for ComputePageCostpre75977_ch10.qxd  11/27/08  3:46 PM  Page 281
282PART TWOMODELINGOverthepasttwodecades,thesoftwareengineeringcommunityhasemphasizedthe
needtobuildsystemsthatmakeuseofexistingsoftwarecomponentsordesignpatterns.
Inessence,acatalogofprovendesignorcode-levelcomponentsismadeavailableto

youasdesignworkproceeds.Asthesoftwarearchitectureisdeveloped,youchoose

componentsordesignpatternsfromthecatalogandusethemtopopulatethearchitec-

ture.Becausethesecomponentshavebeencreatedwithreusabilityinmind,acomplete

descriptionoftheirinterface,thefunction(s)theyperform,andthecommunicationand

collaborationtheyrequireareallavailabletoyou.Idiscusssomeoftheimportant

aspectsofcomponent-basedsoftwareengineering(CBSE)laterinSection10.6.
Component-Based Standards and Frameworks
One of the key elements that lead to thesuccess or failure of CBSE is the availabilityofcomponent-based standards, sometimes called
middleware. Middlewareis a collection of infrastructurecomponents that enable problem domain components to
communicate with one another across a network or
within a complex system. Software engineers who want
to use component-based development as their software
process can choose from among the following
standards:OMG CORBAÑwww.corba.org/

Microsoft COM
Ñwww.microsoft.com/com/
tech/complus.aspMicrosoft .NET
Ñhttp://msdn2.microsoft.com/
en-us/netframework/default.aspxSun JavaBeansÑhttp://java.sun.com/
products/ejb/
The websites noted present a wide array of tutorials, white
papers, tools, and general resources on these important

middleware standards.INFO10.2D
ESIGNINGCLASS-BASEDCOMPONENTSAs I have already noted, component-level design draws on information developed
as part of the requirements model (Chapters 6 and 7) and represented as part of
thearchitectural model (Chapter 9). When an object-oriented software engineering

approach is chosen, component-level design focuses on the elaboration of problem
domain specific classes and the definition and refinement of infrastructure classes
contained in the requirements model. The detailed description of the attributes,
operations, and interfaces used by these classes is the design detail required as a
precursor to the construction activity.
10.2.1Basic Design Principles
Four basic design principles are applicable to component-level design and have been
widely adopted when object-oriented software engineering is applied. The underlying
motivation for the application of these principles is to create designs that are more
amenable to change and to reduce the propagation of side effects when changes do
occur. You can use these principles as a guide as each software component is developed.
The Open-Closed Principle (OCP).ÒA module [component] should be open for extension but closed for modificationÓ[Mar00]. This statement seems to be apre75977_ch10.qxd  11/27/08  3:46 PM  Page 282
CHAPTER 10COMPONENT-LEVEL DESIGN283contradiction, but it represents one of the most important characteristics of a goodcomponent-level design. Stated simply, you should specify the component in a way

that allows it to be extended (within the functional domain that it addresses) with-
out the need to make internal (code or logic-level) modifications to the component
itself. To accomplish this, you create abstractions that serve as a buffer between the

functionality that is likely to be extended and the design class itself.For example, assume that the 
SafeHomesecurity function makes use of a Detectorclass that must check the status of each type of security sensor. It is likely that as time

passes, the number and types of security sensors will grow. If internal processing logic

is implemented as a sequence of if-then-else constructs, each addressing a different
sensor type, the addition of a new sensor type will require additional internal pro-

cessing logic (still another if-then-else). This is a violation of OCP.
One way to accomplish OCP for the Detectorclass is illustrated in Figure 10.4.The sensorinterface presents a consistent view of sensors to the detector compo-nent. If a new type of sensor is added no change is required for the Detectorclass(component). The OCP is preserved.Detector<<interface>>
Sensorread( ) enable( ) 
disable( ) 
test( )Window/ 
doorSensorSmokeSensorMotionDetectorHeatSensorCO2SensorFIGURE10.4Following theOCPThe OCP in ActionThe scene:VinodÕs cubicle.
The players:Vinod and ShakiraÑmembers of the
SafeHomesoftware engineering team.The conversation:Vinod:
I just got a call from Doug [the team manager].He says marketing wants to add a new sensor.

Shakira (smirking):Not again, jeez!Vinod:
Yeah . . . and youÕre not going to believe what
these guys have come up with.
Shakira:Amaze me.Vinod (laughing):
They call it a doggie angst sensor.
Shakira:Say what?Vinod:
ItÕs for people who leave their pets home in
apartments or condos or houses that are close to one
SAFEHOMEpre75977_ch10.qxd  11/27/08  3:46 PM  Page 283
284PART TWOMODELINGThe Liskov Substitution Principle (LSP).
ÒSubclasses should be substitutable fortheir base classesÓ[Mar00]. This design principle, originally proposed by Barbara Liskov
[Lis88], suggests that a component that uses a base class should continue to functionproperly if a class derived from the base class is passed to the component instead. LSP
demands that any class derived from a base class must honor any implied contract be-
tween the base class and the components that use it. In the context of this discussion,
a ÒcontractÓ is a preconditionthat must be true before the component uses a base classand a postconditionthat should be true after the component uses a base class. Whenyou create derived classes, be sure they conform to the pre- and postconditions.Dependency Inversion Principle (DIP).
ÒDepend on abstractions. Do not depend
on concretionsÓ[Mar00]. As we have seen in the discussion of the OCP, abstractions
are the place where a design can be extended without great complication. The morea component depends on other concrete components (rather than on abstractions
such as an interface), the more difficult it will be to extend.The Interface Segregation Principle (ISP).
ÒMany client-specific interfaces
arebetter than one general purpose interfaceÓ
[Mar00]. There are many instances inwhich multiple client components use the operations provided by a server class. ISP
suggests that you should create a specialized interface to serve each major category
of clients. Only those operations that are relevant to a particular category of clients
should be specified in the interface for that client. If multiple clients require the same
operations, it should be specified in each of the specialized interfaces.As an example, consider the 
FloorPlanclass that is used for the SafeHomesecu-rity and surveillance functions (Chapter 6). For the security functions, FloorPlanisused only during configuration activities and uses the operations placeDevice(),
showDevice(), groupDevice(),and removeDevice()
to place, show, group, and remove
sensors from the floor plan. The SafeHomesurveillance function uses the fourIf you dispense withdesign and hack out
code, just remember
that code is the
ultimate Òconcretion.Ó
YouÕre violating DIP.
another. The dog starts to bark. The neighbor gets angry
and complains. With this sensor, if the dog barks for

more than, say, a minute, the sensor sets a special alarm

mode that calls the owner on his or her cell phone.Shakira:YouÕre kidding me, right?
Vinod:
Nope. Doug wants to know how much time itÕs
going to take to add it to the security function.
Shakira (thinking a moment):Not much . . . look.[She shows Vinod Figure 10.4] WeÕve isolated the actual
sensor classes behind the sensorinterface. As long as
we have specs for the doggie sensor, adding it should be

a piece of cake. Only thing IÕll have to do is create an
appropriate component . . . uh, class, for it. No change
to the Detectorcomponent at all.Vinod:
So IÕll tell Doug itÕs no big deal.
Shakira:Knowing Doug, heÕll keep us focused and notdeliver the doggie thing until the next release.Vinod:
ThatÕs not a bad thing, but you can implement
now if he wants you to?
Shakira:Yeah, the way we designed the interface lets
me do it with no hassle.
Vinod (thinking a moment):
Have you ever heardof the open-closed principle?
Shakira (shrugging):Never heard of it.Vinod (smiling):
Not a problem.pre75977_ch10.qxd  11/27/08  3:46 PM  Page 284
operations noted for security, but also requires special operations to manage
cameras: showFOV()
and showDeviceID().Hence, the ISP suggests that client compo-
nents from the two SafeHomefunctions have specialized interfaces defined forthem.The interface for security would encompass only the operations 
placeDevice(),
showDevice(), groupDevice(),and removeDevice().
The interface for surveillancewouldincorporate the operations 
placeDevice(), showDevice(), groupDevice(),andremoveDevice(),
along with showFOV()
and showDeviceID().Although component-level design principles provide useful guidance, compo-
nents themselves do not exist in a vacuum. In many cases, individual components
or classes are organized into subsystems or packages. It is reasonable to ask how
this packaging activity should occur. Exactly how should components be organized

as the design proceeds? Martin [Mar00] suggests additional packaging principles
that are applicable to component-level design:The Release Reuse Equivalency Principle (REP).
ÒThe granule of reuse is the
granule of releaseÓ
[Mar00]. When classes or components are designed for reuse, there
is an implicit contract that is established between the developer of the reusable entityand the people who will use it. The developer commits to establish a release control
system that supports and maintains older versions of the entity while the users slowly
upgrade to the most current version. Rather than addressing each class individually,

it is often advisable to group reusable classes into packages that can be managed and
controlled as newer versions evolve.The Common Closure Principle (CCP).
ÒClasses that change together belong
together.Ó
[Mar00]. Classes should be packaged cohesively. That is, when classes are
packaged as part of a design, they should address the same functional or behavioralarea. When some characteristic of that area must change, it is likely that only those

classes within the package will require modification. This leads to more effective
change control and release management.The Common Reuse Principle (CRP).ÒClasses that arenÕt reused together should
not be grouped togetherÓ[Mar00]. When one or more classes within a packagechanges, the release number of the package changes. All other classes or packagesthat rely onthe package that has been changed must now update to the most recent

release of the package and be tested to ensure that the new release operates without
incident. If classes are not grouped cohesively, it is possible that a class with no rela-

tionship to other classes within a package is changed. This will precipitate unneces-
sary integration and testing. For this reason, only classes that are reused together
should be included within a package.10.2.2Component-Level Design Guidelines
In addition to the principles discussed in Section 10.2.1, a set of pragmatic design
guidelines can be applied as component-level design proceeds. These guidelines
apply to components, their interfaces, and the dependencies and inheritanceCHAPTER 10COMPONENT-LEVEL DESIGN285Designing componentsfor reuse requires more
than good technical
design. It also requires
effective configuration
control mechanisms
(Chapter 22).pre75977_ch10.qxd  11/27/08  3:46 PM  Page 285
286PART TWOMODELINGcharacteristics that have an impact on the resultant design. Ambler [Amb02b] sug-gests the following guidelines:Components.Naming conventions should be established for components that are
specified as part of the architectural model and then refined and elaborated as partof the component-level model. Architectural component names should be drawn

from the problem domain and should have meaning to all stakeholders who view the
architectural model. For example, the class name 
FloorPlanis meaningful to every-one reading it regardless of technical background. On the other hand, infrastructure
components or elaborated component-level classes should be named to reflect
implementation-specific meaning. If a linked list is to be managed as part of the
FloorPlanimplementation, the operation manageList()is appropriate, even if a non-
technical person might misinterpret it.3You can choose to use stereotypes to help identify the nature of components at
the detailed design level. For example, 
<<infrastructure>>
might be used to identify aninfrastructure component, <<database>>could be used to identify a database thatservices one or more design classes or the entire system; <<table>>can be used toidentify a table within a database.Interfaces.
Interfaces provide important information about communication and
collaboration (as well as helping us to achieve the OCP). However, unfettered repre-
sentation of interfaces tends to complicate component diagrams. Ambler [Amb02c]
recommends that (1) lollipop representation of an interface should be used in lieu of
the more formal UML box and dashed arrow approach, when diagrams grow complex;
(2) for consistency, interfaces should flow from the left-hand side of the component

box; (3) only those interfaces that are relevant to the component under consideration
should be shown, even if other interfaces are available. These recommendations are
intended to simplify the visual nature of UML component diagrams.Dependencies and Inheritance.For improved readability, it is a good idea
tomodel dependencies from left to right and inheritance from bottom (derived
classes) to top (base classes). In addition, component interdependencies should
berepresented via interfaces, rather than by representation of a component-to-

component dependency. Following the philosophy of the OCP, this will help to

make the system more maintainable.10.2.3Cohesion
In Chapter 8, I described cohesion as the Òsingle-mindednessÓ of a component.
Within the context of component-level design for object-oriented systems, 
cohesionWhat shouldwe considerwhen we name
components??3It is unlikely that someone from marketing or the customer organization (a nontechnical type)
would examine detailed design information.pre75977_ch10.qxd  11/27/08  3:46 PM  Page 286
implies that a component or class encapsulates only attributes and operations thatare closely related to one another and to the class or component itself. Lethbridge
and Lagani”re [Let01] define a number of different types of cohesion (listed in order
of the level of the cohesion4):Functional.Exhibited primarily by operations, this level of cohesion occurswhen a component performs a targeted computation and then returns a
result.Layer.
Exhibited by packages, components, and classes, this type of cohe-sion occurs when a higher layer accesses the services of a lower layer,
butlower layers do not access higher layers. Consider, for example, the

SafeHomesecurity function requirement to make an outgoing phone call if analarm is sensed. It might be possible to define a set of layered packages as
shown in Figure 10.5. The shaded packages contain infrastructure compo-
nents. Access is from the control panel package downward.Communicational.All operations that access the same data are definedwithin one class. In general, such classes focus solely on the data in ques-tion, accessing and storing it.Classes and components that exhibit functional, layer, and communicational

cohesion are relatively easy to implement, test, and maintain. You should strive to

achieve these levels of cohesion whenever possible. It is important to note, however,

that pragmatic design and implementation issues sometimes force you to opt for
lower levels of cohesion.CHAPTER 10COMPONENT-LEVEL DESIGN2874In general, the higher the level of cohesion, the easier the component is to implement, test, and
maintain.)DetectorControl panelPhoneModemT-com
FIGURE10.5Layer cohesionAlthough an under-standing of the various
levels of cohesion is
instructive, it is more

important to be aware

of the general concept
as you design
components. Keep
cohesion as high as is
possible.pre75977_ch10.qxd  11/27/08  3:46 PM  Page 287
288PART TWOMODELINGCohesion in ActionThe scene:JamieÕs cubicle.
The players:Jamie and EdÑmembers of theSafeHomesoftware engineering team who are workingon the surveillance function.
The conversation:
Ed:I have a first-cut design of the cameracomponent.Jamie:Wanna do a quick review?
Ed:I guess . . . but really, IÕd like your input on
something.
(Jamie gestures for him to continue.)
Ed:We originally defined five operations for 
camera.Look . . .determineType()
tells me the type of camera.translateLocation()allows me to move the cameraaround the floor plan.
displayID()gets the camera ID and displays it near thecamera icon.
displayView()
shows me the field of view of the cameragraphically.

displayZoom()shows me the magnification of the cam-era graphically.
Ed:IÕve designed each separately, and theyÕre pretty
simple operations. So I thought it might be a good idea tocombine all of the display operations into just one thatÕs

called displayCamera()ÑitÕll show the ID, the view, and

the zoom. Whaddaya think?Jamie (grimacing):Not sure thatÕs such a good 
idea.Ed (frowning):
Why, all of these little ops can cause
headaches.
Jamie:The problem with combining them is we losecohesion, you know, the 
displayCamera()op wonÕt be
single-minded.
Ed (mildly exasperated):So what? The whole thingwill be less than 100 source lines, max. ItÕll be easier toimplement, I think.Jamie:And what if marketing decides to change theway that we represent the view field?
Ed:I just jump into the displayCamera()op and make themod.
Jamie:What about side effects?
Ed:Whaddaya mean?Jamie:Well, say you make the change but
inadvertently create a problem with the ID display.

Ed:I wouldnÕt be that sloppy.
Jamie:Maybe not, but what if some support person 
two years from now has to make the mod. He might notunderstand the op as well as you do, and, who knows, he
might be sloppy.
Ed:So youÕre against it?Jamie:YouÕre the designer . . . itÕs your decision . . . just
be sure you understand the consequences of lowcohesion.Ed (thinking a moment):Maybe weÕll go withseparate display ops.
Jamie:Good decision.SAFEHOME10.2.4Coupling
In earlier discussions of analysis and design, I noted that communication andcollaboration are essential elements of any object-oriented system. There is, however,

a darker side to this important (and necessary) characteristic. As the amount of com-
munication and collaboration increases (i.e., as the degree of ÒconnectednessÓ between
classes increases), the complexity of the system also increases. And as complexity
increases, the difficulty of implementing, testing, and maintaining software grows.Couplingis a qualitative measure of the degree to which classes are connected toone another. As classes (and components) become more interdependent, coupling

increases. An important objective in component-level design is to keep coupling as
low as is possible.pre75977_ch10.qxd  11/27/08  3:47 PM  Page 288
Class coupling can manifest itself in a variety of ways. Lethbridge and Lagani”re[Let01] define the following coupling categories:Content coupling.Occurs when one component Òsurreptitiously modifiesdata that is internal to another componentÓ [Let01]. This violates informationhidingÑa basic design concept.Common coupling.Occurs when a number of components all make use ofa global variable. Although this is sometimes necessary (e.g., for establishingdefault values that are applicable throughout an application), common cou-
pling can lead to uncontrolled error propagation and unforeseen side effects
when changes are made.Control coupling.
Occurs when operation A()invokes operation 
B()andpasses a control flag to B.The control flag then ÒdirectsÓ logical flow withinB.The problem with this form of coupling is that an unrelated change in Bcan result in the necessity to change the meaning of the control flag that Apasses. If this is overlooked, an error will result.

Stamp coupling.Occurs when ClassBis declared as a type for an argu-ment of an operation of ClassA. Because ClassBis now a part of the defini-tion of ClassA, modifying the system becomes more complex.
Data coupling.Occurs when operations pass long strings of data argu-ments. The ÒbandwidthÓ of communication between classes and componentsgrows and the complexity of the interface increases. Testing and mainte-

nance are more difficult.Routine call coupling.Occurs when one operation invokes another. This
level of coupling is common and is often quite necessary. However, it does
increase the connectedness of a system.Type use coupling.
Occurs when component Auses a data type defined incomponent B(e.g., this occurs whenever Òa class declares an instance vari-able or a local variable as having another class for its typeÓ [Let01]). If the typedefinition changes, every component that uses the definition must also
change.Inclusion or import coupling.Occurs when component Aimports or in-cludes a package or the content of component B.External coupling.Occurs when a component communicates or collabo-rates with infrastructure components (e.g., operating system functions,database capability, telecommunication functions). Although this type of cou-

pling is necessary, it should be limited to a small number of components or

classes within a system.Software must communicate internally and externally. Therefore, coupling is a fact

of life. However, the designer should work to reduce coupling whenever possible and

understand the ramifications of high coupling when it cannot be avoided.CHAPTER 10COMPONENT-LEVEL DESIGN289As the design for eachsoftware component is
elaborated, the focus
shifts to the design of
specific data structures

and procedural design
to manipulate the data
structures. However,

donÕt forget the
architecture that must
house the components
or the global data
structures that

mayserve many

components.pre75977_ch10.qxd  11/27/08  3:47 PM  Page 289
290PART TWOMODELINGIf youÕre working in anon-OO environment,
the first three steps
focus on refinement of
data objects and
processing functions
(transforms) identified

as part of the require-

ments model.Coupling in ActionThe scene:ShakiraÕs cubicle.
The players:Vinod and ShakiraÑmembers of the
SafeHomesoftware team who are working on the securityfunction.The conversation:
Shakira:I had what I thought was a great idea . . .then I thought about it a little, and it seemed like a not sogreat idea. I finally rejected it, but I just thought IÕd run it
by you.Vinod:
Sure. WhatÕs the idea?
Shakira:Well, each of the sensors recognizes an alarm
condition of some kind, right?Vinod (smiling):
ThatÕs why we call them sensors,
Shakira.
Shakira (exasperated):Sarcasm, Vinod, youÕve got
to work on your interpersonal skills.
Vinod:
You were saying?
Shakira:Okay, anyway, I figured . . . why not create an
operation within each sensor object called makeCall()thatwould collaborate directly with the OutgoingCallcomponent, well, with an interface to the 
OutgoingCallcomponent.Vinod (pensive):
You mean rather than having
thatcollaboration occur out of a component like
ControlPanel
or something?Shakira:Yeah . . . but then I said to myself, that
meansthat every sensor object will be connected to the

OutgoingCallcomponent, and that means that itsindirectly coupled to the outside world and . . . well, I just
thought it made things complicated.Vinod:
I agree. In this case, itÕs a better idea to let the
sensor interface pass info to the 
ControlPanel
and letitinitiate the outgoing call. Besides, different sensors
might result in different phone numbers. You donÕt

wantthe senor to store that information because if it

changes . . .Shakira:It just didnÕt feel right.
Vinod:
Design heuristics for coupling tell us itÕs not right.
Shakira:Whatever . . .SAFEHOME10.3C
ONDUCTINGCOMPONENT-LEVELDESIGNEarlier in this chapter I noted that component-level design is elaborative in nature.You must transform information from requirements and architectural models into

adesign representation that provides sufficient detail to guide the construction

(coding and testing) activity. The following steps represent a typical task set for

component-level design, when it is applied for an object-oriented system.Step 1. Identify all design classes that correspond to the problem domain.
Using the requirements and architectural model, each analysis class and architec-
tural component is elaborated as described in Section 10.1.1.Step 2. Identify all design classes that correspond to the infrastructure
domain.These classes are not described in the requirements model and are oftenmissing from the architecture model, but they must be described at this point. As we
have noted earlier, classes and components in this category include GUI components

(often available as reusable components), operating system components, and object
and data management components.Step 3. Elaborate all design classes that are not acquired as reusable
components.Elaboration requires that all interfaces, attributes, and operationsuote:ÒIf I had moretime, I would have
written a shorter
letter.Ó
BlaisePascal
pre75977_ch10.qxd  11/27/08  3:47 PM  Page 290
necessary to implement the class be described in detail. Design heuristics (e.g., com-ponent cohesion and coupling) must be considered as this task is conducted.Step 3a. Specify message details when classes or components collaborate.
The requirements model makes use of a collaboration diagram to show how analy-
sis classes collaborate with one another. As component-level design proceeds, it is

sometimes useful to show the details of these collaborations by specifying the struc-
ture of messages that are passed between objects within a system. Although this de-
sign activity is optional, it can be used as a precursor to the specification of interfaces
that show how components within the system communicate and collaborate.Figure 10.6illustrates a simple collaboration diagram for the printing system dis-
cussed earlier. Three objects, 
ProductionJob, WorkOrder,
and JobQueue,collab-orate to prepare a print job for submission to the production stream. Messages are
passed between objects as illustrated by the arrows in the figure. During require-
ments modeling the messages are specified as shown in the figure. However, as de-

sign proceeds, each message is elaborated by expanding its syntax in the following
manner [Ben02]:[guard condition] sequence expression (return value) :message name (argument list)where a [guard condition]is written in Object Constraint Language (OCL)5and speci-fies any set of conditions that must be met before the message can be sent; sequence
expressionis an integer value (or other ordering indicator, e.g., 3.1.2) that indicates
the sequential order in which a message is sent; (return value)is the name of theinformation that is returned by the operation invoked by the message; 
message name
identifies the operation that is to be invoked, and 
(argument list)is the list of attributesthat are passed to the operation.CHAPTER 10COMPONENT-LEVEL DESIGN291:ProductionJob:WorkOrder
:JobQueue1: buildJob(WOnumber)2: submitJob
(WOnumber)FIGURE10.6Collaborationdiagram with
messaging5OCL is discussed briefly in Appendix 1.
pre75977_ch10.qxd  11/27/08  3:47 PM  Page 291
292PART TWOMODELINGPrintJobcomputeJobinitiateJobProductionJobbuildJobsubmitJobWorkOrder
appropriate attributesbuildWorkOrder ( )
getJobDescriptionJobQueueappropriate attributescheckPriority ( )<<interface>>
 initiateJobpassJobToProduction( )
FIGURE10.7Refactoring interfaces and class definitions for PrintJob
Step 3b. Identify appropriate interfaces for each component.
Within the
context of component-level design, a UML interface is Òa group of externally visible(i.e., public) operations. The interface contains no internal structure, it has no attrib-

utes, no associations . . .Ó [Ben02]. Stated more formally, an interface is the equiva-

lent of an abstract class that provides a controlled connection between design

classes. The elaboration of interfaces is illustrated in Figure 10.1. In essence, opera-

tions defined for the design class are categorized into one or more abstract classes.
Every operation within the abstract class (the interface) should be cohesive; that is,
it should exhibit processing that focuses on one limited function or subfunction.Referring to Figure 10.1, it can be argued that the interface initiateJob
does notexhibit sufficient cohesion. In actuality, it performs three different subfunctionsÑ

building a work order, checking job priority, and passing a job to production. The

interface design should be refactored. One approach might be to reexamine the de-
sign classes and define a new class WorkOrder
that would take care of all activitiesassociated with the assembly of a work order. The operation 
buildWorkOrder()
be-comes a part of that class. Similarly, we might define a class 
JobQueuethat wouldincorporate the operation checkPriority()
. A class ProductionJob
would encompassall information associated with a production job to be passed to the production
facility. The interface 
initiateJob
would then take the form shown in Figure 10.7.Theinterface 
initiateJob
is now cohesive, focusing on one function. The interfaces
associated with ProductionJob, WorkOrder,
and JobQueueare similarly single-minded.Step 3c. Elaborate attributes and define data types and data structures
required to implement them.
In general, data structures and types used to defineattributes are defined within the context of the programming language that is to bepre75977_ch10.qxd  11/27/08  3:47 PM  Page 292
used for implementation. UML defines an attributeÕs data type using the following
syntax:name : type-expression initial-value {property string}where nameis the attribute name, 
type expressionis the data type, 
initial valueis the valuethat the attribute takes when an object is created, and property-stringdefines a prop-erty or characteristic of the attribute.During the first component-level design iteration, attributes are normally de-scribed by name. Referring once again to Figure 10.1, the attribute list for PrintJob
lists only the names of the attributes. However, as design elaboration proceeds, each

attribute is defined using the UML attribute format noted. For example, 
paperType-
weightis defined in the following manner:paperType-weight: string 
ÒAÓ { contains 1 of 4 values - A, B, C, or D}
which defines paperType-weight
as a string variable initialized to the value A that cantake on one of four values from the set {A,B,C, D}.
If an attribute appears repeatedly across a number of design classes, and it has arelatively complex structure, it is best to create a separate class to accommodate the

attribute.Step 3d. Describe processing flow within each operation in detail.
This maybe accomplished using a programming language-based pseudocode or with a UMLactivity diagram. Each software component is elaborated through a number of iter-
ations that apply the stepwise refinement concept (Chapter 8).The first iteration defines each operation as part of the design class. In every case,
the operation should be characterized in a way that ensures high cohesion; that is,
theoperation should perform a single targeted function or subfunction. The next

iteration does little more than expand the operation name. For example, the operation

computePaperCost()
noted in Figure 10.1can be expanded in the following manner:
computePaperCost (weight, size, color): numeric
This indicates that computePaperCost()
requires the attributes weight, size,and colorasinput and returns a value that is numeric (actually a dollar value) as output.Ifthealgorithmrequiredtoimplement
computePaperCost()
issimpleand
widelyunderstood,nofurtherdesignelaborationmaybenecessary.Thesoftware

engineerwhodoesthecodingwillprovidethedetailnecessarytoimplementthe

operation.However,ifthealgorithmismorecomplexorarcane,furtherdesign

elaborationisrequiredatthisstage.Figure10.8depictsaUMLactivitydiagramfor

computePaperCost().
Whenactivitydiagramsareusedforcomponent-leveldesign
specification,theyaregenerallyrepresentedatalevelofabstractionthatissome-

whathigherthansourcecode.AnalternativeapproachÑtheuseofpseudocodefor

designspecificationÑisdiscussedinSection10.5.3.
CHAPTER 10COMPONENT-LEVEL DESIGN293Use stepwiseelaboration as you
refine the component
design. Always ask, 
ÒIs there a way this
can be simplified and
yet still accomplish the
same result?Ópre75977_ch10.qxd  11/27/08  3:47 PM  Page 293
294PART TWOMODELINGStep 4. Describe persistent data sources (databases and files) and identify
the classes required to manage them.
Databases and files normally transcendthe design description of an individual component. In most cases, these persistent
data stores are initially specified as part of architectural design. However, as design

elaboration proceeds, it is often useful to provide additional detail about the struc-

ture and organization of these persistent data sources.Step 5. Develop and elaborate behavioral representations for a class or
component.UML state diagrams were used as part of the requirements model torepresent the externally observable behavior of the system and the more localized
behavior of individual analysis classes. During component-level design, it is some-
times necessary to model the behavior of a design class.The dynamic behavior of an object (an instantiation of a design class as theprogram executes) is affected by events that are external to it and the current stateValidate attributes
inputaccessPaperDB(weight)returns baseCostperPage
Size = BpaperCostperPage =paperCostperPage*1.2Size = CpaperCostperPage = 
paperCostperPage*1.4Size = DpaperCostperPage = 
paperCostperPage*1.6Color is custompaperCostperPage =   
paperCostperPage*1.14Color is standardpaperCostperPage =
    baseCostperPageReturns 
(paperCostperPage)FIGURE10.8UML activitydiagram for
compute-
PaperCost()pre75977_ch10.qxd  11/27/08  3:47 PM  Page 294
(mode of behavior) of the object. To understand the dynamic behavior of an object,
you should examine all use cases that are relevant to the design class throughout its
life. These use cases provide information that helps you to delineate the events that

affect the object and the states in which the object resides as time passes and events
occur. The transitions between states (driven by events) are represented using a UML

statechart [Ben02] as illustrated in Figure 10.9.The transition from one state (represented by a rectangle with rounded corners)to another occurs as a consequence of an event that takes the form:Event-name (parameter-list) [guard-condition] / action expressionwhere event-nameidentifies the event, parameter-listincorporates data that areassociated with the event, guard-conditionis written in Object Constraint Language(OCL) and specifies a condition that must be met before the event can occur, and

action expressiondefines an action that occurs as the transition takes place.Referring to Figure 10.9, each state may define entry/and exit/actions that occur astransition into the state occurs and as transition out of the state occurs, respectively. In

most cases, these actions correspond to operations that are relevant to the class that is
being modeled. The do/indicator provides a mechanism for indicating activities that
CHAPTER 10COMPONENT-LEVEL DESIGN295buildingJobDataentry/readJobData( )
exit/displayJobData( ) 
do/checkConsistency( ) 
include/dataInputentry/computeJob 

exit/save totalJobCost  formingJob
entry/buildJob 

exit/save WOnumber 
do/ computingJobCostsubmittingJobentry/submitJob 

exit/initiateJob 
do/place on JobQueue Behavior within the 
state buildingJobDatadataInputCompleted [all data 
items consistent]/displayUserOptions dataInputIncomplete 
deliveryDateAccepted [customer is authorized]/ 

printJobEstimate jobCostAccepted [customer is authorized]/ 
getElectronicSignature jobSubmitted [all authorizations acquired]/
printWorkOrder 
FIGURE10.9Statechartfragment for
PrintJob classpre75977_ch10.qxd  11/27/08  3:47 PM  Page 295
296PART TWOMODELINGoccur while in the state, and the 
include/indicator provides a means for elaborating the
behavior by embedding more statechart detail within the definition of a state.It is important to note that the behavioral model often contains information thatis not immediately obvious in other design models. For example, careful examina-
tion of the statechart in Figure 10.9indicates that the dynamic behavior of the

PrintJobclass is contingent upon two customer approvals as costs and schedule
data for the print job are derived. Without approvals (the guard condition ensures

that the customer is authorized to approve) the print job cannot be submitted

because there is no way to reach the submittingJob
state.Step 6. Elaborate deployment diagrams to provide additional implementa-

tion detail.Deployment diagrams (Chapter 8) are used as part of architecturaldesign and are represented in descriptor form. In this form, major system functions
(often represented as subsystems) are represented within the context of the com-
puting environment that will house them.
During component-level design, deployment diagrams can be elaborated to rep-resent the location of key packages of components. However, components generally

are not represented individually within a component diagram. The reason for this is
to avoid diagrammatic complexity. In some cases, deployment diagrams are elabo-

rated into instance form at this time. This means that the specific hardware and
operating system environment(s) that will be used is (are) specified and the location

of component packages within this environment is indicated.
Step 7. Refactor every component-level design representation and always
consider alternatives.
Throughout this book, I have emphasized that designisaniterative process. The first component-level model you create will not be as

complete, consistent, or accurate as the 
nth iteration you apply to the model. It is
essential to refactor as design work is conducted.In addition, you should not suffer from tunnel vision. There are always alterna-tive design solutions, and the best designers consider all (or most) of them before
settling on the final design model. Develop alternatives and consider each care-
fully, using the design principles and concepts presented in Chapter 8 and in this

chapter.
10.4C
OMPONENT-LEVELDESIGNFOR
WEBAPPSThe boundary between content and function is often blurred when Web-based

systems and applications (WebApps) are considered. Therefore, it is reasonable to

ask: What is a WebApp component?
In the context of this chapter, a WebApp component is (1) a well-defined cohesive
function that manipulates content or provides computational or data processing for

an end user or (2) a cohesive package of content and functionality that provides the
pre75977_ch10.qxd  11/27/08  3:47 PM  Page 296
end user with some required capability. Therefore, component-level design for
WebApps often incorporates elements of content design and functional design.
10.4.1Content Design at the Component Level
Content design at the component level focuses on content objects and the 
mannerinwhich they may be packaged for presentation to a WebApp end user.

Asan example, consider a Web-based video surveillance capability within

SafeHomeAssured.com.Among many capabilities, the user can select and control

any of the cameras represented as part of a floor plan, require video-capture thumb-
nail images from all the cameras, and display streaming video from any one camera.
In addition, the user can control pan and zoom for a camera using appropriate
control icons.A number of potential content components can be defined for the video surveil-lance capability: (1) the content objects that represent the space layout (the floor
plan) with additional icons representing the location of sensors and video cameras,
(2) the collection of thumbnail video captures (each a separate data object), and
(3)the streaming video window for a specific camera. Each of these components can

be separately named and manipulated as a package.Consider a floor plan that depicts four cameras placed strategically throughout ahouse. Upon user request, a video frame is captured from each camera and is iden-
tified as a dynamically generated content object, VideoCapture
N,where Nidenti-fies cameras 1 to 4. A content component, named Thumbnail-Images,combinesall four VideoCapture
Ncontent objects and displays them on the video surveillancepage.The formality of content design at the component level should be tuned to thecharacteristics of the WebApp to be built. In many cases, content objects need not

be organized as components and can be manipulated individually. However, as the

size and complexity (of the WebApp, content objects, and their interrelationships)

grows, it may be necessary to organize content in a way that allows easier reference
and design manipulation.6In addition, if content is highly dynamic (e.g., the contentfor an online auction site), it becomes important to establish a clear structural model
that incorporates content components.10.4.2Functional Design at the Component Level
Modern Web applications deliver increasingly sophisticated processing functions

that (1) perform localized processing to generate content and navigation capability
in a dynamic fashion, (2) provide computation or data processing capability that is

appropriate for the WebAppÕs business domain, (3) provide sophisticated database

query and access, or (4) establish data interfaces with external corporate systems. To
CHAPTER 10COMPONENT-LEVEL DESIGN2976Content components can also be reused in other WebApps.
pre75977_ch10.qxd  11/27/08  3:47 PM  Page 297
298PART TWOMODELINGachieve these (and many other) capabilities, you will design and construct WebApp
functional components that are similar in form to software components for
conventional software.
WebApp functionality is delivered as a series of components developed in paral-
lel with the information architecture to ensure that they are consistent. In essence
you begin by considering both the requirements model and the initial information
architecture and then examining how functionality affects the userÕs interaction with

the application, the information that is presented, and the user tasks that are
conducted.During architectural design, WebApp content and functionality are combined to
create a functional architecture. A functional architecture
is a representation of thefunctional domain of the WebApp and describes the key functional components in

the WebApp and how these components interact with each other.
Forexample,thepanandzoomfunctionsforthe
SafeHomeAssured.comvideosurveillancecapabilityareimplementedaspartofa
CameraControl
component.Alternatively,panandzoomcanbeimplementedastheoperations,
pan()andzoom(),whicharepartofa
Camera
class.Ineithercase,thefunctionalityimpliedbypanand
zoommustbeimplementedasmoduleswithin
SafeHomeAssured.com.10.5D
ESIGNINGTRADITIONALCOMPONENTSThefoundationsofcomponent-leveldesignfortraditionalsoftwarecomponents
7wereformedintheearly1960sandweresolidifiedwiththeworkofEdsgerDijkstra

andhiscolleagues([Boh66],[Dij65],[Dij76b]).Inthelate1960s,Dijkstraandothers

proposedtheuseofasetofconstrainedlogicalconstructsfromwhichanyprogram

couldbeformed.TheconstructsemphasizedÒmaintenanceoffunctionaldomain.Ó

Thatis,eachconstructhadapredictablelogicalstructureandwasenteredatthe

topandexitedatthebottom,enablingareadertofollowproceduralflowmore

easily.
The constructs are sequence, condition, and repetition. 
Sequenceimplementsprocessing steps that are essential in the specification of any algorithm. Condition
provides the facility for selected processing based on some logical occurrence, and

repetitionallows for looping. These three constructs are fundamental to structuredprogramming
Ñan important component-level design technique.The structured constructs were proposed to limit the procedural design ofsoftware to a small number of predictable logical structures. Complexity metrics
(Chapter 23) indicate that the use of the structured constructs reduces program com-
plexity and thereby enhances readability, testability, and maintainability. The use of
7A traditional software component implements an element of processing that addresses a function
or subfunction in the problem domain or some capability in the infrastructure domain. Often calledmodules, procedures, or subroutines, traditional components do not encapsulate data in the same
way that object-oriented components do.Structured
programming is a
design technique that
constrains logic flow
tothree constructs:

sequence, condition,
and repetition.pre75977_ch10.qxd  11/27/08  3:47 PM  Page 298
a limited number of logical constructs also contributes to a human understandingprocess that psychologists call chunking.
To understand this process, consider the
way in which you are reading this page. You do not read individual letters but rather

recognize patterns or chunks of letters that form words or phrases. The structured
constructs are logical chunks that allow a reader to recognize procedural elements
of a module, rather than reading the design or code line by line. Understanding is

enhanced when readily recognizable logical patterns are encountered.Any program, regardless of application area or technical complexity, can be
designed and implemented using only the three structured constructs. It should be
noted, however, that dogmatic use of only these constructs can sometimes cause

practical difficulties. Section 10.5.1 considers this issue in further detail.10.5.1Graphical Design Notation
ÓA picture is worth a thousand words,Ó but itÕs rather important to know which

picture and which 1000 words. There is no question that graphical tools, such as the
UML activity diagram or the flowchart, provide useful pictorial patterns that readily

depict procedural detail. However, if graphical tools are misused, the wrong picture

may lead to the wrong software.Theactivitydiagramallowsyoutorepresentsequence,condition,andrepetitionÑ
allelementsofstructuredprogrammingÑandisadescendentofanearlierpicto-

rialdesignrepresentation(stillusedwidely)calleda
flowchart.
Aflowchart,like
anactivitydiagram,isquitesimplepictorially.Aboxisusedtoindicateaprocess-

ingstep.Adiamondrepresentsalogicalcondition,andarrowsshowtheflow

ofcontrol.Figure10.10illustratesthreestructuredconstructs.The
sequenceisCHAPTER 10COMPONENT-LEVEL DESIGN299FirsttaskNext
taskSequenceSelectionConditionTFIf-then-elseRepetitionElse-partThen-partCaseconditionCase  partTTTFTTFFFFDo   whileRepeat  untilFIGURE10.10Flowchartconstructspre75977_ch10.qxd  11/27/08  3:47 PM  Page 299
300PART TWOMODELINGHow do Ibuild adecision table??representedastwoprocessingboxesconnectedbyaline(arrow)ofcontrol.
Condition,alsocalled
if-then-else,isdepictedasadecisiondiamondthat,iftrue,
causesthen-partprocessingtooccur,andiffalse,invokes
else-partprocessing.Repetitionisrepresentedusingtwoslightlydifferentforms.The
dowhile
testsacon-
ditionandexecutesalooptaskrepetitivelyaslongastheconditionholdstrue.A

repeatuntil
executesthelooptaskfirstandthentestsaconditionandrepeatsthe
taskuntiltheconditionfails.The
selection(orselect-case)constructshowninthefig-
ureisactuallyanextensionofthe
if-then-else.Aparameteristestedbysuccessive
decisionsuntilatrueconditionoccursanda
casepart
processingpathisexecuted.
In general, the dogmatic use of only the structured constructs can introduce inef-ficiency when an escape from a set of nested loops or nested conditions is required.
More important, additional complication of all logical tests along the path of escape
can cloud software control flow, increase the possibility of error, and have a nega-

tive impact on readability and maintainability. What can you do?
YouÕre left with two options: (1) The procedural representation is redesigned so
that the Òescape branchÓ is not required at a nested location in the flow of control or
(2) the structured constructs are violated in a controlled manner; that is, a con-
strained branch out of the nested flow is designed. Option 1 is obviously the ideal
approach, but option 2 can be accommodated without violating the spirit of struc-
tured programming.10.5.2Tabular Design Notation
In many software applications, a module may be required to evaluate a complex
combination of conditions and select appropriate actions based on these conditions.
Decision tables[Hur83] provide a notation that translates actions and conditions
(described in a processing narrative or a use case) into a tabular form. The table is
difficult to misinterpret and may even be used as a machine-readable input to a
table-driven algorithm.Decision table organization is illustrated in Figure 10.11. Referring to the figure,
the table is divided into four sections. The upper left-hand quadrant contains a list
of all conditions. The lower left-hand quadrant contains a list of all actions that are
possible based on combinations of conditions. The right-hand quadrants form a
matrix that indicates condition combinations and the corresponding actions that
will occur for a specific combination. Therefore, each column of the matrix may be

interpreted as a processing rule.The following steps are applied to develop a deci-sion table:1.Listallactionsthatcanbeassociatedwithaspecificprocedure(orcomponent).
2.List all conditions (or decisions made) during execution of the procedure.3.Associate specific sets of conditions with specific actions, eliminating impos-
sible combinations of conditions; alternatively, develop every possible per-

mutation of conditions.4.Define rules by indicating what actions occur for a set of conditions.Use a decision tablewhen a complex set of
conditions and actions
are encountered within
a component.pre75977_ch10.qxd  11/27/08  3:47 PM  Page 300
To illustrate the use of a decision table, consider the following excerpt from an
informal use case that has just been proposed for the print shop system:Three types of customers are defined: a regular customer, a silver customer, and a gold
customer (these types are assigned by the amount of business the customer does with the
print shop over a 12 month period). A regular customer receives normal print rates and

delivery. A silver customer gets an 8 percent discount on all quotes and is placed ahead

of all regular customers in the job queue. A gold customer gets a 15 percent reduction in
quoted prices and is placed ahead of both regular and silver customers in the job queue.
A special discount of xpercent in addition to other discounts can be applied to anycustomerÕs quote at the discretion of management.
Figure 10.11illustrates a decision table representation of the preceding informal use
case. Each of the six rules indicates one of six viable conditions. As a general rule, the

decision table can be used effectively to supplement other procedural design notation.10.5.3Program Design Language
Program design language
(PDL), also called structured Englishor pseudocode,incorpo-rates the logical structure of a programming language with the free-form expressive
ability of a natural language (e.g., English). Narrative text (e.g., English) is embedded
within a programming language-like syntax. Automated tools (e.g., [Cai03]) can be

used to enhance the application of PDL.A basic PDL syntax should include constructs for component definition, interfacedescription, data declaration, block structuring, condition constructs, repetition con-
structs, and input-output (I/O) constructs. It should be noted that PDL can be
extended to include keywords for multitasking and/or concurrent processing, inter-
rupt handling, interprocess synchronization, and many other features. The applica-
tion design for which PDL is to be used should dictate the final form for the design
language. The format and semantics for some of these PDL constructs are presented
in the example that follows.CHAPTER 10COMPONENT-LEVEL DESIGN301ConditionsRegular customer Silver customer  
Gold customer 
Special discountActionsNo discount 
Apply 8 percent discount  Apply 15 percent discount  Apply additional x percentdiscountTFTTTTTF1356
4FTTT2RulesFIGURE10.11Decision tablenomenclature
pre75977_ch10.qxd  11/27/08  3:47 PM  Page 301
302PART TWOMODELINGTo illustrate the use of PDL, consider a procedural design for the 
SafeHomesecu-rity function discussed in earlier chapters. The system monitors alarms for fire,
smoke, burglar, water, and temperature (e.g., the heating system fails while the

homeowner is away during winter) and produces an alarm bell and calls a monitor-

ing service, generating a voice-synthesized message.
Recall that PDL is nota programming language. You can adapt as required with-
out worry about syntax errors. However, the design for the monitoring software

would have to be reviewed (do you see any problems?) and further refined before
code could be written. The following PDL8provides an elaboration of the procedural
design for an early version of an alarm management component.componentalarmManagement;
The intent of this component is to manage control panel switches and input from sensors by
type and to act on any alarm condition that is encountered.set default values for systemStatus (returned value), all data items
initialize all system ports and reset all hardware
check controlPanelSwitches (cps)
ifcps = ÒtestÓ then invokealarm set toÒonÓ

ifcps = ÒalarmOffÓ then invokealarm set toÒoffÓ

ifcps = ÒnewBoundingValueÓ then invokekeyboardInput

ifcps = ÒburglarAlarmOffÓ invokedeactivateAlarm;

¥
¥
¥
default for cps = noneresetall signalValues and switches

do forall sensors
invoke checkSensor procedure returning signalValue

if signalValue > bound [alarmType]
then phoneMessage = message [alarmType]
set alarmBell to ÒonÓ for alarmTimeSeconds
set system status = ÒalarmConditionÓ
parbegininvokealarm procedure withÒonÓ, alarmTimeSeconds;

invokephone procedureset to alarmType, phoneNumber
endparelseskip
endifenddoforendalarmManagement
8The level of detail represented by the PDL is defined locally. Some people prefer a more natural
language-oriented description, while others prefer something that is close to code.pre75977_ch10.qxd  11/27/08  3:47 PM  Page 302
Note that the designer for the alarmManagementcomponent has used the con-struct parbegin É parendthat specifies a parallel block. All tasks specified within theparbeginblock are executed in parallel. In this case, implementation details are not
considered.10.6C
OMPONENT-BASEDDEVELOPMENTIn the software engineering context, reuse is an idea both old and new. Programmers
have reused ideas, abstractions, and processes since the earliest days of computing,
but the early approach to reuse was ad hoc. Today, complex, high-quality computer-

based systems must be built in very short time periods and demand a more organ-
ized approach to reuse.Component-based software engineering(CBSE) is a process that emphasizes thedesign and construction of computer-based systems using reusable software
Òcomponents.Ó Clements [Cle95] describes CBSE in the following way:[CBSE] embodies the Òbuy, donÕt buildÓ philosophy espoused by Fred Brooks and others.
In the same way that early subroutines liberated the programmer from thinking about
details, [CBSE] shifts the emphasis from programming software to composing software
systems. Implementation has given way to integration as the focus.But a number of questions arise. Is it possible to construct complex systems byassembling them from a catalog of reusable software components? Can this beaccomplished in a cost- and time-effective manner? Can appropriate incentives be
established to encourage software engineers to reuse rather than reinvent? Is

management willing to incur the added expense associated with creating reusable
software components? Can the library of components necessary to accomplish reuse
be created in a way that makes it accessible to those who need it? Can components
that do exist be found by those who need them?Increasingly, the answer to each of these questions is Òyes.Ó In the rest of this
section, I examine some of the issues that must be considered to make CBSE
successful within a software engineering organization.10.6.1Domain Engineering
The intent of domain engineeringis to identify, construct, catalog, and disseminate a
set of software components that have applicability to existing and future software in
a particular application domain.9The overall goal is to establish mechanisms that
enable software engineers to share these componentsÑto reuse themÑduring work
on new and existing systems. Domain engineering includes three major activitiesÑ
analysis, construction, and dissemination.CHAPTER 10COMPONENT-LEVEL DESIGN303uote:ÒDomainengineeringis

aboutfinding

commonalities
amongsystemsto

identify
componentsthat

canbeappliedto

manysystems...Ó
PaulClements
9In Chapter 9 we referred to architectural genres that identify specific application domains.
pre75977_ch10.qxd  11/27/08  3:47 PM  Page 303
304PART TWOMODELINGThe overall approach to 
domain analysisis often characterized within the contextof object-oriented software engineering. The steps in the process are defined as:1.Define the domain to be investigated.
2.Categorize the items extracted from the domain.3.Collect a representative sample of applications in the domain.4.Analyze each application in the sample and define analysis classes.5.Develop a requirements model for the classes.It is important to note that domain analysis is applicable to any software engineer-ing paradigm and may be applied for conventional as well as object-oriented

development.10.6.2Component Qualification, Adaptation, and Composition
Domain engineering provides the library of reusable components that are required

for component-based software engineering. Some of these reusable components are
developed in-house, others can be extracted from existing applications, and still

others may be acquired from third parties.Unfortunately, the existence of reusable components does not guarantee that
these components can be integrated easily or effectively into the architecture chosen
for a new application. It is for this reason that a sequence of component-based
development actions is applied when a component is proposed for use.ComponentQualification.
Componentqualificationensuresthatacandidate
componentwillperformthefunctionrequired,willproperlyÒfitÓintothearchitectural
style(Chapter9)specifiedforthesystem,andwillexhibitthequalitycharacteristics

(e.g.,performance,reliability,usability)thatarerequiredfortheapplication.
An interface description provides useful information about the operation and use of
a software component, but it does not provide all of the information required to deter-

mine if a proposed component can, in fact, be reused effectively in a new application.
Among the many factors considered during component qualification are [Bro96]:¥Application programming interface (API).¥Development and integration tools required by the component.¥Run-time requirements, including resource usage (e.g., memory or storage),
timing or speed, and network protocol.¥Service requirements, including operating system interfaces and support
from other components.¥Security features, including access controls and authentication protocol.¥Embedded design assumptions, including the use of specific numerical or
nonnumerical algorithms.¥Exception handling.The analysis processwe discuss in this
section focuses on
reusable components.
However, the analysis

of complete COTS
systems (e.g., 
e-commerce Apps,
sales force automation
Apps) can also be a
part of domain

analysis.What factors areconsidered during
component
qualification??pre75977_ch10.qxd  11/27/08  3:47 PM  Page 304
Each of these factors is relatively easy to assess when reusable components thathave been developed in-house are proposed. If good software engineering practices
were applied during the development of a component, answers to the questions
implied by the list can be developed. However, it is much more difficult to determine

the internal workings of commercial off-the-shelf (COTS) or third-party components
because the only available information may be the interface specification itself.Component Adaptation.In an ideal setting, domain engineering creates a libraryof components that can be easily integrated into an application architecture. Theimplication of Òeasy integrationÓ is that (1) consistent methods of resource manage-
ment have been implemented for all components in the library, (2) common activi-

ties such as data management exist for all components, and (3) interfaces within the
architecture and with the external environment have been implemented in a consis-

tent manner.
In reality, even after a component has been qualified for use within an application
architecture, conflicts may occur in one or more of the areas just noted. To avoid

these conflicts, an adaptation technique called component wrapping
[Bro96] is some-times used. When a software team has full access to the internal design and code for
a component (often not the case unless open-source COTS components are used),
white-box wrapping
is applied. Like its counterpart in software testing (Chapter 18),white-box wrapping examines the internal processing details of the component and
makes code-level modifications to remove any conflict. 
Gray-box wrapping
is appliedwhen the component library provides a component extension language or API that

enables conflicts to be removed or masked. 
Black-box wrapping
requires the intro-duction of pre- and postprocessing at the component interface to remove or mask

conflicts. You must determine whether the effort required to adequately wrap a com-

ponent is justified or whether a custom component (designed to eliminate the
conflicts encountered) should be engineered instead.Component Composition.The component composition task assembles quali-fied, adapted, and engineered components to populate the architecture establishedfor an application. To accomplish this, an infrastructure must be established to bind

the components into an operational system. The infrastructure (usually a library of
specialized components) provides a model for the coordination of components and

specific services that enable components to coordinate with one another and
perform common tasks.Because the potential impact of reuse and CBSE on the software industry isenormous, a number of major companies and industry consortia have proposed
standards for component software.10CHAPTER 10COMPONENT-LEVEL DESIGN305Inadditiontoassessing
whetherthecostof

adaptationforreuseis

justified,youshould

alsoassesswhether

achievingrequired

functionalityand

performancecanbe

donecosteffectively.
10Greg Olsen [Ols06] provides an excellent discussion of past and present industry efforts to make
CBSE a reality.pre75977_ch10.qxd  11/27/08  3:47 PM  Page 305
306PART TWOMODELINGOMG/CORBA.
The Object Management Group has published a commonobject request broker architecture
(OMG/CORBA). An object request broker(ORB) provides a variety of services that enable reusable components
(objects) to communicate with other components, regardless of their location
within a system.Microsoft COM and .NET.
Microsoft has developed a component objectmodel(COM) that provides a specification for using components produced by
various vendors within a single application running under the Windows op-
erating system. From the point of view of the application, Òthe focus is not on
how [COM objects are] implemented, only on the fact that the object has an
interface that it registers with the system, and that it uses the component
system to communicate with other COM objectsÓ [Har98a]. The Microsoft
.NET framework encompasses COM and provides a reusable class library that

covers a wide array of application domains.
Sun JavaBeans Components.
The JavaBeans component system is aportable, platform-independent CBSE infrastructure developed using the Java
programming language. The JavaBeans component system encompasses a
set of tools, called the Bean Development Kit(BDK), that allows developers to(1) analyze how existing Beans (components) work, (2) customize their
behavior and appearance, (3) establish mechanisms for coordination and

communication, (4) develop custom Beans for use in a specific application,
and (5) test and evaluate Bean behavior.
None of these standards dominate the industry. Although many developers

havestandardized on one, it is likely that large software organizations may

choose to use a standard based on the application categories and platforms that
are chosen.10.6.3Analysis and Design for Reuse
Although the CBSE process encourages the use of existing software components,
there are times when new software components must be developed and integrated
with existing COTS and in-house components. Because these new components
become members of the in-house library of reusable components, they should be
engineered for reuse.Design concepts such as abstraction, hiding, functional independence, refine-
ment, and structured programming, along with object-oriented methods, testing,
software quality assurance (SQA), and correctness verification methods (Chapter 21),
all contribute to the creation of software components that are reusable. In this sub-
section, I consider the reuse-specific issues that are complementary to solid software
engineering practices.The requirements model is analyzed to determine those elements that point toexisting reusable components. Elements of the requirements model are compared toWebRef
The latest information
on JavaBeans can 
be obtained at
java.sun.com/
products/
javabeans/docs/.WebRef
The latest information
on COM and .NET can
be obtained at 
www.microsoft

.com/COMandmsdn2.microsoft
.com/en-us/
netframework
default.aspx.WebRef
The latest information
on CORBA can be
obtained at
www.omg.org
.pre75977_ch10.qxd  11/27/08  3:47 PM  Page 306
descriptions of reusable components in a process that is sometimes referred to asÒspecification matchingÓ [Bel95]. If specification matching points to an existing com-
ponent that fits the needs of the current application, you can extract the component
from a reuse library (repository) and use it in the design of a new system. If compo-
nents cannot be found (i.e., there is no match), a new component is created. It is at
this pointÑwhen you begin to create a new componentÑthat design for reuse(DFR)should be considered.As we have already noted, DFR requires that you apply solid software design con-cepts and principles (Chapter 8). But the characteristics of the application domain
must also be considered. Binder [Bin93] suggests a number of key issues11that forma basis for design for reuse:Standard data.
The application domain should be investigated and standard
global data structures (e.g., file structures or a complete database) should be
identified. All design components can then be characterized to make use of
these standard data structures.Standard interface protocols.
Three levels of interface protocol should beestablished: the nature of intramodular interfaces, the design of externaltechnical (nonhuman) interfaces, and the human-computer interface.Program templates.
An architectural style (Chapter 9) is chosen and canserve as a template for the architectural design of a new software.Once standard data, interfaces, and program templates have been established, youhave a framework in which to create the design. New components that conform to
this framework have a higher probability for subsequent reuse.10.6.4Classifying and Retrieving Components
Consider a large university library. Hundreds of thousands of books, periodicals, and

other information resources are available for use. But to access these resources,
acategorization scheme must be developed. To navigate this large volume of

information, librarians have defined a classification scheme that includes a Library
of Congress classification code, keywords, author names, and other index entries. All

enable the user to find the needed resource quickly and easily.
Now, consider a large component repository. Tens of thousands of reusable soft-
ware components reside in it. But how do you find the one that you need? To answer

this question, another question arises: How do we describe software components in
unambiguous, classifiable terms? These are difficult questions, and no definitive
answer has yet been developed. In this section I explore current directions that will
enable future software engineers to navigate reuse libraries.CHAPTER 10COMPONENT-LEVEL DESIGN307DFR can be quitedifficult when compo-
nents must be inter-
faced or integrated
with legacy systems or
with multiple systems
whose architecture and
interfacing protocols

are inconsistent.11In general, DFR preparations should be undertaken as part of domain engineering.
pre75977_ch10.qxd  11/27/08  3:47 PM  Page 307
308PART TWOMODELINGA reusable software component can be described in many ways, but an idealdescription encompasses what Tracz [Tra95] has called the 
3C modelÑconcept,content, and context. The conceptof a software component is Òa description of whatthe component doesÓ [Whi95]. The interface to the component is fully described and
the semanticsÑrepresented within the context of pre- and postconditionsÑis iden-
tified. The concept should communicate the intent of the component. The contentofa component describes how the concept is realized. In essence, the content is infor-

mation that is hidden from casual users and need be known only to those who intend
to modify or test the component. The contextplaces a reusable software componentwithin its domain of applicability. That is, by specifying conceptual, operational, and

implementation features, the context enables a software engineer to find the appro-
priate component to meet application requirements.To be of use in a pragmatic setting, concept, content, and context must be trans-
lated into a concrete specification scheme. Dozens of papers and articles have been
written about classification schemes for reusable software components (e.g., see
[Cec06] for an overview of current trends).
Classification enables you to find and retrieve candidate reusable components,but a reuse environment must exist to integrate these components effectively. A

reuse environment exhibits the following characteristics:
¥A component database capable of storing software components and the clas-
sification information necessary to retrieve them.¥A library management system that provides access to the database.
¥A software component retrieval system (e.g., an object request broker) that
enables a client application to retrieve components and services from the
library server.
¥CBSE tools that support the integration of reused components into a new
design or implementation.Each of these functions interact with or is embodied within the confines of a reuse
library.
The reuse library
is one element of a larger software repository (Chapter 22) andprovides facilities for the storage of software components and a wide variety of

reusable work products (e.g., specifications, designs, patterns, frameworks, code
fragments, test cases, user guides). The library encompasses a database and the
tools that are necessary to query the database and retrieve components from it. The
component classification scheme serves as the basis for library queries.Queries are often characterized using the context element of the 3C model de-scribed earlier in this section. If an initial query results in a voluminous list of candi-
date components, the query is refined to narrow the list. Concept and content
information are then extracted (after candidate components are found) to assist you
in selecting the proper component.What arethekey
characteristics of
a component
reuse
environment??WebRef
A comprehensivecollection of resources
on CBSE can be found
at www.cbd-hq

.com/.pre75977_ch10.qxd  11/27/08  3:47 PM  Page 308
CHAPTER 10COMPONENT-LEVEL DESIGN309CBSEObjective:To aid in modeling, design,
review, and integration of software components
as part of a larger system.
Mechanics:Tools mechanics vary. In general, CBSE tools
assist in one or more of the following capabilities:specification and modeling of the software architecture,
browsing and selection of available software components;
integration of components.Representative Tools
12ComponentSource(www.componentsource.com
)provides a wide array of COTS software components(and tools) supported within many different

component standards.Component Manager,
developed by Flashline(www.flashline.com
), Òis an application that
enables, promotes, and measures software component
reuse.ÓSelect Component Factory,
developed by Select BusinessSolutions (www.selectbs.com
), Òis an integratedset of products for software design, design review,

service/component management, requirements

management and code generation.ÓSoftware Through Pictures-ACD,distributed by Aonix(www.aonix.com
), enables comprehensive
modeling using UML for the OMG model driven
architectureÑan open, vendor-neutral approach
forCBSE.
SOFTWARE
TOOLS12Tools noted here do not represent an endorsement, but rather a sampling of tools in this category.
In most cases, tool names are trademarked by their respective developers.10.7S
UMMARYThe component-level design process encompasses a sequence of activities thatslowly reduces the level of abstraction with which software is represented.
Component-level design ultimately depicts the software at a level of abstraction that
is close to code.Three different views of component-level design may be taken, depending onthenature of the software to be developed. The object-oriented view focuses on the

elaboration of design classes that come from both the problem and infrastructure
domain. The traditional view refines three different types of components or modules:
control modules, problem domain modules, and infrastructure modules. In both
cases, basic design principles and concepts that lead to high-quality software are ap-
plied. When considered from a process viewpoint, component-level design draws on

reusable software components and design patterns that are pivotal elements of
component-based software engineering.A number of important principles and concepts guide the designer as classes areelaborated. Ideas encompassed in the Open-Closed Principle and the Dependency
Inversion Principle and concepts such as coupling and cohesion guide the software

engineer in building testable, implementable, and maintainable software compo-

nents. To conduct component-level design in this context, classes are elaborated by

specifying messaging details, identifying appropriate interfaces, elaborating attrib-
utes and defining data structures to implement them, describing processing flowpre75977_ch10.qxd  11/27/08  3:47 PM  Page 309
310PART TWOMODELINGwithin each operation, and representing behavior at a class or component level. Inevery case, design iteration (refactoring) is an essential activity.
Traditional component-level design requires the representation of data struc-
tures, interfaces, and algorithms for a program module in sufficient detail to guide
inthe generation of programming language source code. To accomplish this, the

designer uses one of a number of design notations that represent component-level
detail in either graphical, tabular, or text-based formats.
Component-level design for WebApps considers both content and functionality as
it is delivered by a Web-based system. Content design at the component level focuses

on content objects and the manner in which they may be packaged for presentation
to a WebApp end user. Functional design for WebApps focuses on processing func-

tions that manipulate content, perform computations, query and access a database,

and establish interfaces with other systems. All component-level design principles
and guidelines apply.
Structured programming is a procedural design philosophy that constrains thenumber and type of logical constructs used to represent algorithmic detail. The in-
tent of structured programming is to assist the designer in defining algorithms that
are less complex and therefore easier to read, test, and maintain.Component-based software engineering identifies, constructs, catalogs, and dis-seminates a set of software components in a particular application domain. These
components are then qualified, adapted, and integrated for use in a new system.
Reusable components should be designed within an environment that establishes

standard data structures, interface protocols, and program architectures for each
application domain.PROBLEMSAND
POINTSTO
PONDER10.1.The term componentis sometimes a difficult one to define. First provide a generic defini-
tion, and then provide more explicit definitions for object-oriented and traditional software.
Finally, pick three programming languages with which you are familiar and illustrate how each

defines a component.10.2.Why are control components necessary in traditional software and generally not requiredin object-oriented software?
10.3.Describe the OCP in your own words. Why is it important to create abstractions that serveas an interface between components?
10.4.Describe the DIP in your own words. What might happen if a designer depends too heav-ily on concretions?
10.5.Select three components that you have developed recently and assess the types of cohesionthat each exhibits. If you had to define the primary benefit of high cohesion, what would it be?
10.6.Select three components that you have developed recently and assess the types of cou-pling that each exhibits. If you had to define the primary benefit of low coupling, what wouldit be?10.7.Is it reasonable to say that problem domain components should never exhibit externalcoupling? If you agree, what types of component would exhibit external coupling?
pre75977_ch10.qxd  11/27/08  3:47 PM  Page 310
10.8.Develop (1) an elaborated design class, (2) interface descriptions, (3) an activity diagramfor one of the operations within the class, and (4) a detailed statechart diagram for one of theSafeHomeclasses that we have discussed in earlier chapters.10.9.Are stepwise refinement and refactoring the same thing? If not, how do they differ?10.10.What is a WebApp component?
10.11.Select a small portion of an existing program (approximately 50 to 75 source lines).Isolate the structured programming constructs by drawing boxes around them in the source

code. Does the program excerpt have constructs that violate the structured programming
philosophy? If so, redesign the code to make it conform to structured programming constructs.
If not, what do you notice about the boxes that youÕve drawn?
10.12.All modern programming languages implement the structured programming con-structs. Provide examples from three programming languages.

10.13.Select a small coded component and represent it using (1) an activity diagram, (2) aflowchart, (3) a decision table, and (4) PDL.

10.14.Why is ÒchunkingÓ important during the component-level design review process?FURTHER
READINGSAND
INFORMATION
SOURCESMany books on component-based development and component reuse have been publishedinrecent years. Apperly and his colleagues (
Service- and Component-Based Development,Addison-Wesley, 2003), Heineman and Councill (
Component Based Software Engineering,Addison-Wesley, 2001), Brown (
Large Scale Component-Based Development,Prentice-Hall,2000), Allen (Realizing e-Business with Components,Addison-Wesley, 2000), Herzum and Sims
(Business Component Factory,
Wiley, 1999), Allen, Frost, and Yourdon (
Component-Based Devel-opment for Enterprise Systems: Applying the Select Perspective,Cambridge University Press, 1998)cover all important aspects of the CBSE process. Cheesman and Daniels (
UML Components,
Addison-Wesley, 2000) discuss CBSE with a UML emphasis.
Gao and his colleagues (Testing and Quality Assurance for Component-Based Software,
ArtechHouse, 2006) and Gross (
Component-Based Software Testing with UML,
Springer, 2005) discuss
testing and SQA issues for component-based systems.Dozens of books describing the industryÕs component-based standards have been published
in recent years. These address the inner workings of the standards themselves but also consider
many important CBSE topics.The work of Linger, Mills, and Witt (
Structured ProgrammingÑTheory and Practice,
Addison-Wesley, 1979) remains a definitive treatment of the subject. The text contains a good PDL as well

as detailed discussions of the ramifications of structured programming. Other books that focus
on procedural design issues for traditional systems include those by Robertson (Simple Program

Design,3d ed., Course Technology, 2000), Farrell (
A Guide to Programming Logic and Design,
Course Technology, 1999), Bentley (
Programming Pearls,
2d ed., Addison-Wesley, 1999), and
Dahl (Structured Programming,
Academic Press, 1997).Relatively few recent books have been dedicated solely to component-level design. In gen-eral, programming language books address procedural design in some detail but always in the
context of the language that is introduced by the book. Hundreds of titles are available.A wide variety of information sources on component-level design are available on theInternet. An up-to-date list of World Wide Web references that are relevant to component-level

design can be found at the SEPA website: 
www.mhhe.com/engcs/compsci/pressman/
professional/olc/ser.htm
.CHAPTER 10COMPONENT-LEVEL DESIGN311pre75977_ch10.qxd  11/27/08  3:47 PM  Page 311
We live in a world of high-technology products, and virtually all ofthemÑconsumer electronics, industrial equipment, corporate systems,
military systems, personal computer software, and WebAppsÑrequire
human interaction. If a product is to be successful, it must exhibit good
usabilityÑa qualitative measure of the ease and efficiency with which a human can employ
the functions and features offered by the high-technology product.Whether an interface has been designed for a digital music player or theweapons control system for a fighter aircraft, usability matters. If interface mech-
anisms have been well designed, the user glides through the interaction using a
smooth rhythm that allows work to be accomplished effortlessly. But if the inter-

face is poorly conceived, the user moves in fits and starts, and the end result is

frustration and poor work efficiency.
For the first three decades of the computing era, usability was not a dominantconcern among those who built software. In his classic book on design, Donald
Norman [Nor88] argued that it was time for a change in attitude:To make technology that fits human beings, it is necessary to study human beings. But
now we tend to study only the technology. As a result, people are required to conform

to technology. It is time to reverse this trend, time to make technology that conforms

to people.312CHAPTER11USERINTERFACE
DESIGNKEYCONCEPTSaccessibility . . .334
commandlabeling . . . . . .333
control . . . . . . .313

designevaluation . . . . .342
error handling . .333

golden rules . . .313

help facilities . .332

interfaceanalysis . . . . .320

consistent . . .316

design . . . . . .328

models . . . . . .317
internationali-zation . . . . . . .334
memory load . .314
What is it?User interface design
creates an effective communication
medium between a human and a
computer. Following a set of interface
design principles, design identifies interface ob-

jects and actions and then creates a screen layout
that forms the basis for a user interface prototype.
Who does it?A software engineer designs theuser interface by applying an iterative process

that draws on predefined design principles.Why is it important?
If software is difficult to use,
if it forces you into mistakes, or if it frustrates
your efforts to accomplish your goals, you wonÕt

like it, regardless of the computational power it
exhibits, the content it delivers, or the functional-
ity it offers. The interface has to be right because

it molds a userÕs perception of the software.
What are the steps?User interface design begins
with the identification of user, task, and environ-
QUICKLOOKmental requirements. Once user tasks have beenidentified, user scenarios are created and ana-
lyzed to define a set of interface objects and

actions. These form the basis for the creation of

screen layout that depicts graphical design and
placement of icons, definition of descriptive
screen text, specification and titling for windows,
and specification of major and minor menu
items. Tools are used to prototype and ultimately

implement the design model, and the result is
evaluated for quality.
What is the work product?
User scenarios arecreated and screen layouts are generated. An
interface prototype is developed and modified in

an iterative fashion.How do I ensure that IÕve done it right?An in-terface prototype is Òtest drivenÓ by the users,

and feedback from the test drive is used for the
next iterative modification of the prototype.pre75977_ch11.qxd  11/27/08  3:55 PM  Page 312
CHAPTER 11USER INTERFACE DESIGN313As technologists studied human interaction, two dominant issues arose. First, a setof golden rules(discussed in Section 11.1) were identified. These applied to all hu-man interaction with technology products. Second, a set of interaction mechanisms

were defined to enable software designers to build systems that properly imple-
mented the golden rules. These interaction mechanisms, collectively called the
graphical user interface 
(GUI), have eliminated some of the most egregious problems
associated with human interfaces. But even in a ÒWindows world,Ó we all have

encountered user interfaces that are difficult to learn, difficult to use, confusing,

counterintuitive, unforgiving, and in many cases, totally frustrating. Yet, someone

spent time and energy building each of these interfaces, and it is not likely that the
builder created these problems purposely.
11.1T
HEGOLDENRULESIn his book on interface design, Theo Mandel [Man97] coins three golden rules:1.Place the user in control.2.Reduce the userÕs memory load.
3.Make the interface consistent.These golden rules actually form the basis for a set of user interface design princi-
ples that guide this important aspect of software design.11.1.1Place the User in Control
During a requirements-gathering session for a major new information system, a key
user was asked about the attributes of the window-oriented graphical interface.ÒWhat I really would like,Ó said the user solemnly, Òis a system that reads my mind.
It knows what I want to do before I need to do it and makes it very easy for me to get
it done. ThatÕs all, just that.Ó
My first reaction was to shake my head and smile, but I paused for a moment.
There was absolutely nothing wrong with the userÕs request. She wanted a system

that reacted to her needs and helped her get things done. She wanted to control the
computer, not have the computer control her.
Most interface constraints and restrictions that are imposed by a designer areintended to simplify the mode of interaction. But for whom?As a designer, you may be tempted to introduce constraints and limitations to
simplify the implementation of the interface. The result may be an interface that is
easy to build, but frustrating to use. Mandel [Man97] defines a number of design
principles that allow the user to maintain control:Define interaction modes in a way that does not force a user into unneces-
sary or undesired actions.
An interaction mode is the current state of the inter-face. For example, if 
spell check
is selected in a word-processor menu, the softwareprinciples andguidelines . . . . .336
process . . . . . .319

response time . .332

task analysis . .322

taskelaboration . . . .324
usability . . . . . .317

user analysis . .321

WebApp interface
design . . . . . . .335
uote:ÒItÕs better to
design the user
experience than
rectify it.ÓJonMeads
pre75977_ch11.qxd  11/27/08  3:55 PM  Page 313
314PART TWOMODELINGmoves to a spell-checking mode. There is no reason to force the user to remain in
spell-checking mode if the user desires to make a small text edit along the way. The

user should be able to enter and exit the mode with little or no effort.Provide for flexible interaction.
Because different users have different interac-tion preferences, choices should be provided. For example, software might allow a
user to interact via keyboard commands, mouse movement, a digitizer pen, a mul-

titouch screen, or voice recognition commands. But every action is not amenable to
every interaction mechanism. Consider, for example, the difficulty of using keyboard

command (or voice input) to draw a complex shape.
Allow user interaction to be interruptible and undoable.
Even when involved
in a sequence of actions, the user should be able to interrupt the sequence to dosomething else (without losing the work that had been done). The user should also
be able to ÒundoÓ any action.Streamline interaction as skill levels advance and allow the interaction to
be customized.Users often find that they perform the same sequence of interac-tions repeatedly. It is worthwhile to design a ÒmacroÓ mechanism that enables an

advanced user to customize the interface to facilitate interaction.Hide technical internals from the casual user.
The user interface should move
the user into the virtual world of the application. The user should not be aware of the
operating system, file management functions, or other arcane computing technol-
ogy. In essence, the interface should never require that the user interact at a level

that is ÒinsideÓ the machine (e.g., a user should never be required to type operating
system commands from within application software).Design for direct interaction with objects that appear on the screen.
Theuser feels a sense of control when able to manipulate the objects that are necessaryto perform a task in a manner similar to what would occur if the object were a phys-
ical thing. For example, an application interface that allows a user to ÒstretchÓ an

object (scale it in size) is an implementation of direct manipulation.11.1.2Reduce the UserÕs Memory Load
The more a user has to remember, the more error-prone the interaction with the

system will be. It is for this reason that a well-designed user interface does not tax
the userÕs memory. Whenever possible, the system should ÒrememberÓ pertinent in-

formation and assist the user with an interaction scenario that assists recall. Man-
del [Man97] defines design principles that enable an interface to reduce the userÕs

memory load:Reduce demand on short-term memory.
When users are involved in complex
tasks, the demand on short-term memory can be significant. The interface should bedesigned to reduce the requirement to remember past actions, inputs, and results.uote:ÒI have alwayswished that my
computer would be
as easy to use as
my telephone. My
wish has come
true. I no longer
know how to use
my telephone.ÓBjarneStronstrup
(originator of
C)pre75977_ch11.qxd  11/27/08  3:55 PM  Page 314
CHAPTER 11USER INTERFACE DESIGN315This can be accomplished by providing visual cues that enable a user to recognize
past actions, rather than having to recall them.Establish meaningful defaults.
The initial set of defaults should make sense forthe average user, but a user should be able to specify individual preferences. How-
ever, a ÒresetÓ option should be available, enabling the redefinition of original default

values.Define shortcuts that are intuitive.
When mnemonics are used to accomplisha system function (e.g., alt-P to invoke the print function), the mnemonic should be
tied to the action in a way that is easy to remember (e.g., first letter of the task to be
invoked).
The visual layout of the interface should be based on a real-world
metaphor.
For example, a bill payment system should use a checkbook and check
register metaphor to guide the user through the bill paying process. This enables the
user to rely on well-understood visual cues, rather than memorizing an arcane
interaction sequence.Disclose information in a progressive fashion.
The interface should be or-ganized hierarchically. That is, information about a task, an object, or some be-
havior should be presented first at a high level of abstraction. More detail should
be presented after the user indicates interest with a mouse pick. An example, com-

mon to many word-processing applications, is the underlining function. The func-
tion itself is one of a number of functions under a text stylemenu. However, every
underlining capability is not listed. The user must pick underlining; then all un-
derlining options (e.g., single underline, double underline, dashed underline) are

presented.Violating a UI Golden Rule
The scene:VinodÕs cubicle, as user
interface design begins.
The players:Vinod and Jamie, members of the
SafeHomesoftware engineering team.The conversation:
Jamie:IÕve been thinking about the surveillance function
interface.

Vinod (smiling):
Thinking is good.Jamie:I think maybe we can simplify matters some.Vinod:
Meaning?Jamie:Well, what if we eliminate the floor plan entirely.
ItÕs flashy, but itÕs going to take serious development effort.
Instead we just ask the user to specify the camera he
wants to see and then display the video in a video
window.
Vinod:
How does the homeowner remember how manycameras are set up and where they are?
Jamie (mildly irritated):HeÕs the homeowner; he
should know.

Vinod:
But what if he doesnÕt?
Jamie:He should.SAFEHOMEpre75977_ch11.qxd  11/27/08  3:55 PM  Page 315
316PART TWOMODELING11.1.3Make the Interface Consistent
The interface should present and acquire information in a consistent fashion. Thisimplies that (1) all visual information is organized according to design rules that are
maintained throughout all screen displays, (2) input mechanisms are constrained
toa limited set that is used consistently throughout the application, and (3) mecha-

nisms for navigating from task to task are consistently defined and implemented.
Mandel [Man97] defines a set of design principles that help make the interface
consistent:Allow the user to put the current task into a meaningful context.
Many in-terfaces implement complex layers of interactions with dozens of screen images. Itis important to provide indicators (e.g., window titles, graphical icons, consistent

color coding) that enable the user to know the context of the work at hand. In
addition, the user should be able to determine where he has come from and what
alternatives exist for a transition to a new task.Maintain consistency across a family of applications.
A set of applications (orproducts) should all implement the same design rules so that consistency is main-tained for all interaction.If past interactive models have created user expectations, do not make
changes unless there is a compelling reason to do so.
Once a particular in-teractive sequence has become a de facto standard (e.g., the use of alt-S to save a
file), the user expects this in every application he encounters. A change (e.g., using
alt-S to invoke scaling) will cause confusion.
The interface design principles discussed in this and the preceding sectionsprovide you with basic guidance. In the sections that follow, youÕll learn about the

interface design process itself.Vinod:
ThatÕs not the point . . . what if he forgets?
Jamie:Uh, we could provide a list of operationalcameras and their locations.Vinod:
ThatÕs possible, but why should he have to ask
for a list?
Jamie:Okay, we provide the list whether he asks 
or not.
Vinod:
Better. At least he doesnÕt have to remember stuff
that we can give him.
Jamie (thinking for a moment):But you like thefloor plan, donÕt you?
Vinod:
Uh huh.Jamie:Which one will marketing like, do you think?Vinod:
YouÕre kidding, right?
Jamie:No.Vinod:
Duh . . . the one with the flash . . . they lovesexy product features . . . theyÕre not interested in whichis easier to build.Jamie (sighing):Okay, maybe IÕll prototype both.
Vinod:
Good idea . . . then we let the customer decide.uote:ÒThings that lookdifferent should act
different. Things
that look the same
should act the
same.ÓLarryMarine
pre75977_ch11.qxd  11/27/08  3:55 PM  Page 316
CHAPTER 11USER INTERFACE DESIGN31711.2U
SERINTERFACE
ANALYSISAND
DESIGNThe overall process for analyzing and designing a user interface begins with the
creation of different models of system function (as perceived from the outside). You

begin by delineating the human- and computer-oriented tasks that are required to
achieve system function and then considering the design issues that apply to all
interface designs. Tools are used to prototype and ultimately implement the design

model, and the result is evaluated by end users for quality.
11.2.1Interface Analysis and Design Models
Four different models come into play when a user interface is to be analyzed and de-
signed. A human engineer (or the software engineer) establishes a user model,thesoftware engineer creates a design model,the end user develops a mental image thatis often called the userÕs 
mental modelor the system perception,
and the implementersUsabilityIn an insightful paper on usability, Larry
Constantine [Con95] asks a question that hassignificant bearing on the subject: ÒWhat do users want,anyway?Ó He answers this way:Whatusersreallywantaregoodtools.Allsoftware

systems,fromoperatingsystemsandlanguagesto

dataentryanddecisionsupportapplications,are

justtools.Enduserswantfromthetoolswe

engineerforthemmuchthesameasweexpectfrom

thetoolsweuse.Theywantsystemsthatareeasyto

learnandthathelpthemdotheirwork.Theywant

softwarethatdoesnÕtslowthemdown,thatdoesnÕt

trickorconfusethem,thatdoesnÕtmakeiteasierto

makemistakesorhardertofinishthejob.
Constantine argues that usability is not derived from
aesthetics, state-of-the-art interaction mechanisms, or 

built-in interface intelligence. Rather, it occurs when the

architecture of the interface fits the needs of the people

who will be using it.A formal definition of usability is somewhat illusive.
Donahue and his colleagues [Don99] define it in the
following manner: ÒUsability is a measure of how well
acomputer system ... facilitates learning; helps learners

remember what theyÕve learned; reduces the likelihood

oferrors; enables them to be efficient, and makes them

satisfied with the system.ÓThe only way to determine whether ÒusabilityÓ exists
within a system you are building is to conduct usabilityassessment or testing. Watch users interact with the system

and answer the following questions [Con95]:¥Isthesystemusablewithoutcontinualhelporinstruction?
¥Do the rules of interaction help a knowledgeable userto work efficiently?
¥Do interaction mechanisms become more flexible asusers become more knowledgeable?¥Has the system been tuned to the physical and socialenvironment in which it will be used?¥Is the user aware of the state of the system? Does theuser know where she is at all times?¥Is the interface structured in a logical and consistent
manner?¥Are interaction mechanisms, icons, and proceduresconsistent across the interface?
¥Does the interaction anticipate errors and help the usercorrect them?¥Is the interface tolerant of errors that are made?
¥Is the interaction simple?If each of these questions is answered Òyes,Ó it is likely that
usability has been achieved.Among the many measurable benefits derived from ausable system are [Don99]: increased sales and customer
satisfaction, competitive advantage, better reviews in the
media, better word of mouth, reduced support costs,

improved end-user productivity, reduced training costs,

reduced documentation costs, reduced likelihood of
litigation from unhappy customers.INFOWebRef
An excellent source ofUI design information

can be found at 
www.useit.com
.pre75977_ch11.qxd  11/27/08  3:55 PM  Page 317
318PART TWOMODELINGof the system create an implementation model. Unfortunately, each of these models
may differ significantly. Your role, as an interface designer, is to reconcile these dif-
ferences and derive a consistent representation of the interface.The user model establishes the profile of end users of the system. In his introduc-tory column on Òuser-centric design,Ó Jeff Patton [Pat07] notes:The truth is, designers and developersÑmyself includedÑoften think about users. How-ever, in the absence of a strong mental model of specific users, we self-substitute. Self-

substitution isnÕt user centricÑitÕs self-centric.
To build an effective user interface, Òall design should begin with an understanding
of the intended users, including profiles of their age, gender, physical abilities, edu-

cation, cultural or ethnic background, motivation, goals and personalityÓ [Shn04]. In
addition, users can be categorized as:Novices.
No syntactic knowledge1 of the system and little semantic knowledge2of the application or computer usage in general.Knowledgeable, intermittent users.Reasonable semantic knowledge of the appli-cation but relatively low recall of syntactic information necessary to use theinterface.Knowledgeable, frequent users.Good semantic and syntactic knowledge that of-ten leads to the Òpower-user syndromeÓ; that is, individuals who look for short-cuts and abbreviated modes of interaction.The userÕs 
mental model(system perception) is the image of the system that endusers carry in their heads. For example, if the user of a particular word processor
were asked to describe its operation, the system perception would guide the re-
sponse. The accuracy of the description will depend upon the userÕs profile (e.g.,

novices would provide a sketchy response at best) and overall familiarity with soft-

ware in the application domain. A user who understands word processors fully but
has worked with the specific word processor only once might actually be able to pro-
vide a more complete description of its function than the novice who has spent

weeks trying to learn the system.The implementation modelcombines the outward manifestation of the computer-based system (the look and feel of the interface), coupled with all supporting infor-
mation (books, manuals, videotapes, help files) that describes interface syntax and
semantics. When the implementation model and the userÕs mental model are coin-

cident, users generally feel comfortable with the software and use it effectively. To

accomplish this ÒmeldingÓ of the models, the design model must have beenuote:ÒIf thereÕs a ÕtrickÕ
to it, the UI is
broken.ÓDouglasAndersonEven a novice userwants shortcuts; even

knowledgeable,
frequent users
sometimes need
guidance. Give them
what they need.1In this context, 
syntactic knowledgerefers to the mechanics of interaction that are required to usethe interface effectively.2Sema
ntic knowledgerefers to the underlying sense of the applicationÑan understanding of thefunctions that are performed, the meaning of input and output, and the goals and objectives of thesystem.The userÕs mental
model shapes how the
user perceives the
interface and whether

the UI meets the userÕs

needs.pre75977_ch11.qxd  11/27/08  3:55 PM  Page 318
CHAPTER 11USER INTERFACE DESIGN319developed to accommodate the information contained in the user model, and theimplementation model must accurately reflect syntactic and semantic information
about the interface.The models described in this section are Òabstractions of what the user is doingor thinks he is doing or what somebody else thinks he ought to be doing when he
uses an interactive systemÓ [Mon84]. In essence, these models enable the interface

designer to satisfy a key element of the most important principle of user interface
design: ÒKnow the user, know the tasks.Ó
11.2.2The Process
The analysis and design process for user interfaces is iterative and can be repre-
sented using a spiral model similar to the one discussed in Chapter 2. Referring to
Figure 11.1, the user interface analysis and design process begins at the interior of
the spiral and encompasses four distinct framework activities [Man97]: (1) interface
analysis and modeling, (2) interface design, (3) interface construction, and (4) inter-
face validation. The spiral shown in Figure 11.1implies that each of these tasks will

occur more than once, with each pass around the spiral representing additional

elaboration of requirements and the resultant design. In most cases, the construc-
tion activity involves prototypingÑthe only practical way to validate what has been

designed.Interface analysisfocuses on the profile of the users who will interact with thesystem. Skill level, business understanding, and general receptiveness to the new
system are recorded; and different user categories are defined. For each user cate-
gory, requirements are elicited. In essence, you work to understand the system

perception (Section 11.2.1) for each class of users.Once general requirements have been defined, a more detailed task analysisisconducted. Those tasks that the user performs to accomplish the goals of the systemuote:ÒÉ pay attentionto what users do,
not what they say.Ó
JakobNielsen
Interface design
Interface construction
Interface analysis and modeling
Interface validation
FIGURE11.1The userinterface

design process
uote:ÒItÕs better to
design the user
experience than
rectify it.ÓJonMeads
pre75977_ch11.qxd  11/27/08  3:55 PM  Page 319
320PART TWOMODELINGare identified, described, and elaborated (over a number of iterative passes through
the spiral). Task analysis is discussed in more detail in Section 11.3. Finally, analysis

of the user environment focuses on the physical work environment. Among the

questions to be asked are¥Where will the interface be located physically?¥Will the user be sitting, standing, or performing other tasks unrelated to the

interface?¥Does the interface hardware accommodate space, light, or noise constraints?
¥Are there special human factors considerations driven by environmental

factors?The information gathered as part of the analysis action is used to create an analysis
model for the interface. Using this model as a basis, the design action commences.The goal of interface designis to define a set of interface objects and actions (andtheir screen representations) that enable a user to perform all defined tasks in a
manner that meets every usability goal defined for the system. Interface design is
discussed in more detail in Section 11.4.Interface constructionnormally begins with the creation of a prototype that en-ables usage scenarios to be evaluated. As the iterative design process continues, a
user interface tool kit (Section 11.5) may be used to complete the construction of the
interface.Interface validationfocuses on (1) the ability of the interface to implement everyuser task correctly, to accommodate all task variations, and to achieve all general

user requirements; (2) the degree to which the interface is easy to use and easy
tolearn, and (3) the usersÕ acceptance of the interface as a useful tool in their

work.As I have already noted, the activities described in this section occur iteratively.
Therefore, there is no need to attempt to specify every detail (for the analysis or de-

sign model) on the first pass. Subsequent passes through the process elaborate task
detail, design information, and the operational features of the interface.11.3I
NTERFACE
ANALYSIS
3A key tenet of all software engineering process models is this: understand the prob-
lem before you attempt to design a solution.In the case of user interface design, un-derstanding the problem means understanding (1) the people (end users) who will
interact with the system through the interface, (2) the tasks that end users must
What do weneed toknow about the
environment as
we begin UI
design??3It is reasonable to argue that this section should be placed in Chapter 5, 6, or 7, since requirements
analysis issues are discussed there. It has been positioned here because interface analysis and de-sign are intimately connected to one another, and the boundary between the two is often fuzzy.pre75977_ch11.qxd  11/27/08  3:55 PM  Page 320
CHAPTER 11USER INTERFACE DESIGN321perform to do their work, (3) the content that is presented as part of the interface,
and (4) the environment in which these tasks will be conducted. In the sections that

follow, I examine each of these elements of interface analysis with the intent of

establishing a solid foundation for the design tasks that follow.
11.3.1User Analysis
The phrase Òuser interfaceÓ is probably all the justification needed to spend some
time understanding the user before worrying about technical matters. Earlier I noted
that each user has a mental image of the software that may be different from the
mental image developed by other users. In addition, the userÕs mental image may be

vastly different from the software engineerÕs design model. The only way that you

can get the mental image and the design model to converge is to work to understand

the users themselves as well as how these people will use the system. Information
from a broad array of sources can be used to accomplish this:User Interviews.The most direct approach, members of the software teammeet with end users to better understand their needs, motivations, work cul-
ture, and a myriad of other issues. This can be accomplished in one-on-one

meetings or through focus groups.Sales input.Sales people meet with users on a regular basis and can gatherinformation that will help the software team to categorize users and betterunderstand their requirements.Marketing input.
Market analysis can be invaluable in the definition of
market segments and an understanding of how each segment might use thesoftware in subtly different ways.Support input.Support staff talks with users on a daily basis. They are themost likely source of information on what works and what doesnÕt, what
users like and what they dislike, what features generate questions and what

features are easy to use.The following set of questions (adapted from [Hac98]) will help you to better
understand the users of a system:¥Are users trained professionals, technicians, clerical, or manufacturing
workers?¥What level of formal education does the average user have?¥Are the users capable of learning from written materials or have they
expressed a desire for classroom training?¥Are users expert typists or keyboard phobic?¥What is the age range of the user community?¥Will the users be represented predominately by one gender?
¥How are users compensated for the work they perform?How do welearn whatthe user wants
from the UI??Above all, spend time
talking to actual users,
but be careful. One
strong opinion doesnÕt
necessarily mean that
the majority of users
will agree.How do we learn
about the
demographics and
characteristics of end
users?pre75977_ch11.qxd  11/27/08  3:55 PM  Page 321
322PART TWOMODELING¥Do users work normal office hours or do they work until the job is done?¥Is the software to be an integral part of the work users do or will it be usedonly occasionally?¥What is the primary spoken language among users?¥What are the consequences if a user makes a mistake using the system?¥Are users experts in the subject matter that is addressed by the system?¥Do users want to know about the technology that sits behind the interface?Once these questions are answered, youÕll know who the end users are, what is likely

to motivate and please them, how they can be grouped into different user classes or
profiles, what their mental models of the system are, and how the user interface must

be characterized to meet their needs.11.3.2Task Analysis and Modeling
The goal of task analysis is to answer the following questions:¥What work will the user perform in specific circumstances?¥What tasks and subtasks will be performed as the user does the work?¥What specific problem domain objects will the user manipulate as work is
performed?¥What is the sequence of work tasksÑthe workflow?¥What is the hierarchy of tasks?To answer these questions, you must draw upon techniques that I have discussed

earlier in this book, but in this instance, these techniques are applied to the user

interface.Use cases.In earlier chapters you learned that the use case describes the mannerin which an actor (in the context of user interface design, an actor is always a person)interacts with a system. When used as part of task analysis, the use case is devel-
oped to show how an end user performs some specific work-related task. In most
instances, the use case is written in an informal style (a simple paragraph) in the
first-person. For example, assume that a small software company wants to build

acomputer-aided design system explicitly for interior designers. To get a better

understanding of how they do their work, actual interior designers are asked to
describe a specific design function. When asked: ÒHow do you decide where to put
furniture in a room?Ó an interior designer writes the following informal use case:I begin by sketching the floor plan of the room, the dimensions and the location of win-dows and doors. IÕm very concerned about light as it enters the room, about the view out
of the windows (if itÕs beautiful, I want to draw attention to it), about the running length

of an unobstructed wall, about the flow of movement through the room. I then look at the

list of furniture my customer and I have chosenÑtables, chairs, sofa, cabinets, the list ofThe userÕs goal is to
accomplish one or
more tasks via the UI.
To accomplish this, 

the UI must provide
mechanisms that allow
the user to achieve 
her goal.pre75977_ch11.qxd  11/27/08  3:55 PM  Page 322
CHAPTER 11USER INTERFACE DESIGN323accentsÑlamps, rugs, paintings, sculpture, plants, smaller pieces, and my notes on any
desires my customer has for placement. I then draw each item from my lists using a tem-

plate that is scaled to the floor plan. I label each item I draw and use pencil because I al-

ways move things. I consider a number of alternative placements and decide on the one

I like best. Then, I draw a rendering (a 3-D picture) of the room to give my customer a feel

for what itÕll look like.This use case provides a basic description of one important work task for the
computer-aided design system. From it, you can extract tasks, objects, and the
overall flow of the interaction. In addition, other features of the system that would

please the interior designer might also be conceived. For example, a digital photo

could be taken looking out each window in a room. When the room is rendered, the
actual outside view could be represented through each window.
Use Cases for UI DesignThe scene:VinodÕs cubicle, as user
interface design continues.
The players:Vinod and Jamie, members of the
SafeHomesoftware engineering team.The conversation:
Jamie:I pinned down our marketing contact and hadher write a use case for the surveillance interface.

Vinod:
From whose point of view?Jamie:The homeowner, who else is there?
Vinod:
ThereÕs also the system administrator role, even
if itÕs the homeowner playing the role, itÕs a different point
of view. The ÒadministratorÓ sets the system up, configures

stuff, lays out the floor plan, places the cameras . . .
Jamie:All I had her do was play the role of thehomeowner when he wants to see video.
Vinod:
ThatÕs okay. ItÕs one of the major behaviors of the
surveillance function interface. But weÕre going to have to
examine the system administration behavior as well.Jamie (irritated):YouÕre right.
[Jamie leaves to find the marketing person. She returns a
few hours later.]
Jamie:I was lucky, I found her and we worked through
the administrator use case together. Basically, weÕre going
to define ÒadministrationÓ as one function thatÕs applicable

to all other SafeHomefunctions. HereÕs what we came 
up with.[Jamie shows the informal use case to Vinod.]
Informal use case:I want to be able to set or editthe system layout at any time. When I set up the system,
Iselect an administration function. It asks me whether 

I want to do a new setup or whether I want to edit 
an existing setup. If I select a new setup, the system
displays a drawing screen that will enable me to draw
the floor plan onto a grid. There will be icons for walls,
windows, and doors so that drawing is easy. I just

stretch the icons to their appropriate lengths. The system
will display the lengths in feet or meters (I can select 
the measurement system). I can select from a library

ofsensors and cameras and place them on the floor

plan. I get to label each, or the system will do automatic
labeling. I can establish settings for sensors and cameras
from appropriate menus. If I select edit, I can move
sensors or cameras, add new ones or delete existing
ones, edit the floor plan, and edit the settings for
cameras and sensors. In every case, I expect the system

to do consistency checking and to help me avoid
mistakes.Vinod (after reading the scenario):
Okay, there
are probably some useful design patterns [Chapter 12] or
reusable components for GUIs for drawing programs. IÕll
betcha 50 bucks we can implement some or most of the
administrator interface using them.
Jamie:Agreed. IÕll check it out.SAFEHOMEpre75977_ch11.qxd  11/27/08  3:55 PM  Page 323
324PART TWOMODELINGTask elaboration.
In Chapter 8, I discussed stepwise elaboration (also called func-tional decomposition or stepwise refinement) as a mechanism for refining the pro-cessing tasks that are required for software to accomplish some desired function.
Task analysis for interface design uses an elaborative approach to assist in under-

standing the human activities the user interface must accommodate.Task analysis can be applied in two ways. As I have already noted, an interactive,
computer-based system is often used to replace a manual or semimanual activity. To

understand the tasks that must be performed to accomplish the goal of the activity, you

must understand the tasks that people currently perform (when using a manual ap-
proach) and then map these into a similar (but not necessarily identical) set of tasks that
are implemented in the context of the user interface. Alternatively, you can study an

existing specification for a computer-based solution and derive a set of user tasks that
will accommodate the user model, the design model, and the system perception.Regardless of the overall approach to task analysis, you must first define and clas-
sify tasks. I have already noted that one approach is stepwise elaboration. For
example, letÕs reconsider the computer-aided design system for interior designers dis-

cussed earlier. By observing an interior designer at work, you notice that interior

design comprises a number of major activities: furniture layout (note the use case dis-
cussed earlier), fabric and material selection, wall and window coverings selection,

presentation (to the customer), costing, and shopping. Each of these major tasks can
be elaborated into subtasks. For example, using information contained in the use case,

furniture layout can be refined into the following tasks: (1) draw a floor plan based on

room dimensions, (2) place windows and doors at appropriate locations, (3a) use fur-
niture templates to draw scaled furniture outlines on the floor plan, (3b) use accents

templates to draw scaled accents on the floor plan, (4) move furniture outlines and

accent outlines to get the best placement, (5) label all furniture and accent outlines,
(6)draw dimensions to show location, and (7) draw a perspective-rendering view for

the customer. A similar approach could be used for each of the other major tasks.
Subtasks 1 to 7 can each be refined further. Subtasks 1 to 6 will be performed by
manipulating information and performing actions within the user interface. On the
other hand, subtask 7 can be performed automatically in software and will result in
little direct user interaction.4The design model of the interface should accommodateeach of these tasks in a way that is consistent with the user model (the profile of a
ÒtypicalÓ interior designer) and system perception (what the interior designer expects
from an automated system).Object elaboration.
Rather than focusing on the tasks that a user must perform,you can examine the use case and other information obtained from the user andextract the physical objects that are used by the interior designer. These objects can
Task elaboration is
quite useful, but it can
also be dangerous.
Just because you have
elaborated a task, do
not assume that there
isnÕt another way to
do it, and that the
other way will be
triedwhen the UI is

implemented.4However, this may not be the case. The interior designer might want to specify the perspective to be
drawn, the scaling, the use of color, and other information. The use case related to drawing per-spective renderings would provide the information you need to address this task.pre75977_ch11.qxd  11/27/08  3:55 PM  Page 324
CHAPTER 11USER INTERFACE DESIGN325be categorized into classes. Attributes of each class are defined, and an evaluationof the actions applied to each object provide a list of operations. For example, the

furniture template might translate into a class called Furniture
with attributes thatmight include size, shape, location,and others. The interior designer would selecttheobject from the Furniture
class, move
it to a position on the floor plan (another ob-ject in this context), draw
the furniture outline, and so forth. The tasks 
select, move,
and draw
are operations. The user interface analysis model would not provide a lit-
eral implementation for each of these operations. However, as the design is elabo-

rated, the details of each operation are defined.Workflow analysis.
When a number of different users, each playing differentroles, makes use of a user interface, it is sometimes necessary to go beyond task
analysis and object elaboration and apply workflow analysis.This technique allowsyou to understand how a work process is completed when several people (and roles)
are involved. Consider a company that intends to fully automate the process of pre-

scribing and delivering prescription drugs. The entire process5will revolve around aWeb-based application that is accessible by physicians (or their assistants), pharma-

cists, and patients. Workflow can be represented effectively with a UML swimlane

diagram (a variation on the activity diagram).We consider only a small part of the work process: the situation that occurs when
a patient asks for a refill. Figure 11.2presents a swimlane diagram that indicates the

tasks and decisions for each of the three roles noted earlier. This information may

have been elicited via interview or from use cases written by each actor. Regardless,

the flow of events (shown in the figure) enables you to recognize a number of key
interface characteristics:1.Each user implements different tasks via the interface; therefore, the look and

feel of the interface designed for the patient will be different than the one
defined for pharmacists or physicians.2.The interface design for pharmacists and physicians must accommodate
access to and display of information from secondary information sources
(e.g., access to inventory for the pharmacist and access to information about

alternative medications for the physician).3.Many of the activities noted in the swimlane diagram can be further elabo-
rated using task analysis and/or object elaboration (e.g., Fills prescriptioncould imply a mail-order delivery, a visit to a pharmacy, or a visit to a special

drug distribution center).Hierarchical representation.
A process of elaboration occurs as you begin toanalyze the interface. Once workflow has been established, a task hierarchy can be
defined for each user type. The hierarchy is derived by a stepwise elaboration ofAlthough objectelaboration is useful,
itshould not be used 

as a stand-alone
approach. The userÕs

voice mustbe consid-ered during task
analysis.5This example has been adapted from [Hac98].
uote:ÒIt is far better to adapt the
technology to the
user than to force
the user to adapt
to the technology.Ó
LarryMarine
pre75977_ch11.qxd  11/27/08  3:55 PM  Page 325
326PART TWOMODELINGPatientPharmacistPhysicianRequests that a prescription be refilledNo refills remainingChecks patientrecordsDetermines status of 
prescriptionRefills remainingRefill not allowedApproves refill Evaluates alternative
medicationNoneReceives request tocontact physicianAlternative

availableChecks inventory for
refill or alternative
Out of stockReceives out of stocknotificationReceives time/dateto pick upIn stockPicks upprescriptionFillsprescriptionFIGURE11.2Swimlane diagram for prescription refill function
pre75977_ch11.qxd  11/27/08  3:56 PM  Page 326
CHAPTER 11USER INTERFACE DESIGN327eachtask identified for the user. For example, consider the following user task and
subtask hierarchy.
User task:Requests that a prescription be refilled
¥Provide identifying information.
¥Specify name.¥Specify userid.¥Specify PIN and password.
¥Specify prescription number.
¥Specify date refill is required.To complete the task, three subtasks are defined. One of these subtasks, 
provide iden-

tifying information,is further elaborated in three additional sub-subtasks.11.3.3Analysis of Display Content
The user tasks identified in Section 11.3.2 lead to the presentation of a variety of
different types of content. For modern applications, display content can range from
character-based reports (e.g., a spreadsheet), graphical displays (e.g., a histogram,
a3-D model, a picture of a person), or specialized information (e.g., audio or video

files). The analysis modeling techniques discussed in Chapters 6 and 7 identify the
output data objects that are produced by an application. These data objects may be
(1) generated by components (unrelated to the interface) in other parts of an
application, (2) acquired from data stored in a database that is accessible from the
application, or (3) transmitted from systems external to the application in question.During this interface analysis step, the format and aesthetics of the content (as itis displayed by the interface) are considered. Among the questions that are asked
and answered are:¥Are different types of data assigned to consistent geographic locations on
thescreen (e.g., photos always appear in the upper right-hand corner)?
¥Can the user customize the screen location for content?¥Is proper on-screen identification assigned to all content?¥If a large report is to be presented, how should it be partitioned for ease of
understanding?¥Will mechanisms be available for moving directly to summary information for

large collections of data?¥Will graphical output be scaled to fit within the bounds of the display device

that is used?¥How will color be used to enhance understanding?¥How will error messages and warnings be presented to the user?The answers to these (and other) questions will help you to establish requirements
for content presentation.How do wedeterminethe format and
aesthetics of
content displayed
as part of the UI??pre75977_ch11.qxd  11/27/08  3:56 PM  Page 327
328PART TWOMODELING11.3.4Analysis of the Work Environment
Hackos and Redish [Hac98] discuss the importance of work environment analysis
when they state:People do not perform their work in isolation. They are influenced by the activity aroundthem, the physical characteristics of the workplace, the type of equipment they are using,

and the work relationships they have with other people. If the products you design do not
fit into the environment, they may be difficult or frustrating to use.
In some applications the user interface for a computer-based system is placed in aÒuser-friendly locationÓ (e.g., proper lighting, good display height, easy keyboard
access), but in others (e.g., a factory floor or an airplane cockpit), lighting may be
suboptimal, noise may be a factor, a keyboard or mouse may not be an option, dis-

play placement may be less than ideal. The interface designer may be constrained by
factors that mitigate against ease of use.In addition to physical environmental factors, the workplace culture also comes
into play. Will system interaction be measured in some manner (e.g., time per trans-

action or accuracy of a transaction)? Will two or more people have to share infor-

mation before an input can be provided? How will support be provided to users of

the system? These and many related questions should be answered before the inter-
face design commences.11.4I
NTERFACE
DESIGNSTEPSOnce interface analysis has been completed, all tasks (or objects and actions)
required by the end user have been identified in detail and the interface design
activity commences. Interface design, like all software engineering design, is an it-
erative process. Each user interface design step occurs a number of times, elaborat-
ing and refining information developed in the preceding step.Although many different user interface design models (e.g., [Nor86], [Nie00]) havebeen proposed, all suggest some combination of the following steps:1.Using information developed during interface analysis (Section 11.3), define
interface objects and actions (operations).2.Define events (user actions) that will cause the state of the user interface to
change. Model this behavior.
3.Depict each interface state as it will actually look to the end user.
4.Indicate how the user interprets the state of the system from information pro-
vided through the interface.In some cases, you can begin with sketches of each interface state (i.e., what the
user interface looks like under various circumstances) and then work backward to
define objects, actions, and other important design information. Regardless of the
sequence of design tasks, you should (1) always follow the golden rules discusseduote:ÒInteractive design[is] a seamless
blend of graphic
arts, technology,

and psychology.Ó
BradWieners
pre75977_ch11.qxd  11/27/08  3:56 PM  Page 328
CHAPTER 11USER INTERFACE DESIGN329in Section 11.1, (2) model how the interface will be implemented, and (3) considerthe environment (e.g., display technology, operating system, development tools)

that will be used.11.4.1Applying Interface Design Steps
The definition of interface objects and the actions that are applied to them is an
important step in interface design. To accomplish this, user scenarios are parsed

in much the same way as described in Chapter 6. That is, a use case is written.
Nouns (objects) and verbs (actions) are isolated to create a list of objects and
actions.Once the objects and actions have been defined and elaborated iteratively, they
are categorized by type. Target, source, and application objects are identified. A

source object
(e.g., a report icon) is dragged and dropped onto a target object(e.g., aprinter icon). The implication of this action is to create a hard-copy report. An
application objectrepresents application-specific data that are not directly manipu-lated as part of screen interaction. For example, a mailing list is used to store names

for a mailing. The list itself might be sorted, merged, or purged (menu-based ac-
tions), but it is not dragged and dropped via user interaction.Whenyouaresatisfiedthatallimportantobjectsandactionshavebeende-
fined(foronedesigniteration),screenlayoutisperformed.Likeotherinterface

designactivities,screenlayoutisaninteractiveprocessinwhichgraphicalde-

signandplacementoficons,definitionofdescriptivescreentext,specification

andtitlingforwindows,anddefinitionofmajorandminormenuitemsarecon-

ducted.Ifareal-worldmetaphorisappropriatefortheapplication,itisspecified

atthistime,andthelayoutisorganizedinamannerthatcomplementsthe

metaphor.
To provide a brief illustration of the design steps noted previously, consider a user
scenario for the SafeHomesystem (discussed in earlier chapters). A preliminary usecase (written by the homeowner) for the interface follows:Preliminary use case:
I want to gain access to my SafeHomesystem from any remotelocation via the Internet. Using browser software operating on my notebook computer(while IÕm at work or traveling), I can determine the status of the alarm system, arm or
disarm the system, reconfigure security zones, and view different rooms within the house
via preinstalled video cameras.To access 
SafeHomefrom a remote location, I provide an identifier and a password.
These define levels of access (e.g., all users may not be able to reconfigure the system) and
provide security. Once validated, I can check the status of the system and change the sta-

tus by arming or disarming SafeHome.I can reconfigure the system by displaying a floorplan of the house, viewing each of the security sensors, displaying each currently config-

ured zone, and modifying zones as required. I can view the interior of the house via strate-

gically placed video cameras. I can pan and zoom each camera to provide different views

of the interior.
pre75977_ch11.qxd  11/27/08  3:56 PM  Page 329
330PART TWOMODELINGBased on this use case, the following homeowner tasks, objects, and data items are
identified:¥accessesthe SafeHomesystem¥entersan IDand password
to allow remote access¥checks
system status¥armsor disarms SafeHomesystem¥displaysfloor planand sensor locations¥displayszoneson floor plan¥changes
zoneson floor plan¥displaysvideo camera locations
on floor plan¥selectsvideo camera
for viewing¥viewsvideo images(four frames per second)¥pansor zoomsthe video camera
Objects (boldface) and actions (italics) are extracted from this list of homeowner
tasks. The majority of objects noted are application objects. However, 
video
camera location
(a source object) is dragged and dropped onto video camera
(atarget object) to create a 
video image(a window with video display).A preliminary sketch of the screen layout for video monitoring is created (Fig-ure11.3).
6To invoke the video image, a video camera location icon, 
C,located in the
floor plan displayed in the monitoring window is selected. In this case a camera lo-
cation in the living room (LR) is then dragged and dropped onto the video camera
icon in the upper left-hand portion of the screen. The video image window appears,
displaying streaming video from the camera located in the LR. The zoom and pan
control slides are used to control the magnification and direction of the video image.
To select a view from another camera, the user simply drags and drops a different

camera location icon into the camera icon in the upper left-hand corner of the
screen.The layout sketch shown would have to be supplemented with an expansion ofeach menu item within the menu bar, indicating what actions are available for the

video monitoring mode (state). A complete set of sketches for each homeowner task
noted in the user scenario would be created during the interface design.11.4.2User Interface Design Patterns
Graphical user interfaces have become so common that a wide variety of user inter-
face design patterns has emerged. As I noted earlier in this book, a design pattern isAlthough automatedtools can be useful in
developing layout
prototypes, sometimes
a pencil and paper are
all that are needed.6Note that this differs somewhat from the implementation of these features in earlier chapters. This
might be considered a first draft design and represents one alternative that might be considered.pre75977_ch11.qxd  11/27/08  3:56 PM  Page 330
CHAPTER 11USER INTERFACE DESIGN331an abstraction that prescribes a design solution to a specific, well-bounded design
problem.As an example of a commonly encountered interface design problem, consider asituation in which a user must enter one or more calendar dates, sometimes months
in advance. There are many possible solutions to this simple problem, and a num-
ber of different patterns that might be proposed. Laakso [Laa00] suggests a pattern
called CalendarStripthat produces a continuous, scrollable calendar in which thecurrent date is highlighted and future dates may be selected by picking them from
the calendar. The calendar metaphor is well known to every user and provides an

effective mechanism for placing a future date in context.A vast array of interface design patterns has been proposed over the past
decade. A more detailed discussion of user interface design patterns is presented
in Chapter 12. In addition, Erickson [Eri08] provides pointers to many Web-based

collections.11.4.3Design Issues
Asthedesignofauserinterfaceevolves,fourcommondesignissuesalmostalways

surface:systemresponsetime,userhelpfacilities,errorinformationhandling,and
Access   Configure  System Status   View   Monitoring
Monitoring
First FloorSSSSSSSSMMVideo ImageŠLRLRDRKITCCCSafeHomeConnectStatusVideo Camera
InOutRLSMCdoor/window sensormotion detector (beam shown)video camera locationFIGURE11.3Preliminary
screen layout
WebRef
A wide variety of UIdesign patterns has

been proposed. For
pointers to a variety of
patterns sites, visit 

www.hcipatterns

.org.pre75977_ch11.qxd  11/27/08  3:56 PM  Page 331
332PART TWOMODELINGcommandlabeling.Unfortunately,manydesignersdonotaddresstheseissuesuntil
relativelylateinthedesignprocess(sometimesthefirstinklingofaproblemdoesnÕt

occuruntilanoperationalprototypeisavailable).Unnecessaryiteration,project

delays,andend-userfrustrationoftenresult.Itisfarbettertoestablisheachasa

designissuetobeconsideredatthebeginningofsoftwaredesign,whenchangesare

easy and costs are low.
Response time.System response time is the primary complaint for many interac-tive applications. In general, system response time is measured from the point atwhich the user performs some control action (e.g., hits the return key or clicks a
mouse) until the software responds with desired output or action.System response time has two important characteristics: length and variability.
If system response is too long, user frustration and stress are inevitable. Variability
refers to the deviation from average response time, and in many ways, it is the

most important response time characteristic. Low variability enables the user to
establish an interaction rhythm, even if response time is relatively long. For ex-
ample, a 1-second response to a command will often be preferable to a response

that varies from 0.1 to 2.5 seconds. When variability is significant, the user is al-
ways off balance, always wondering whether something ÒdifferentÓ has occurred

behind the scenes.Help facilities.
Almost every user of an interactive, computer-based system re-
quires help now and then. In some cases, a simple question addressed to a knowl-edgeable colleague can do the trick. In others, detailed research in a multivolume set
of Òuser manualsÓ may be the only option. In most cases, however, modern software

provides online help facilities that enable a user to get a question answered or

resolve a problem without leaving the interface.A number of design issues [Rub88] must be addressed when a help facility is con-sidered:¥Will help be available for all system functions and at all times during system

interaction? Options include help for only a subset of all functions and
actions or help for all functions.¥How will the user request help? Options include a help menu, a special
function key, or a HELP command.
¥How will help be represented? Options include a separate window, a

reference to a printed document (less than ideal), or a one- or two-line
suggestion produced in a fixed screen location.¥How will the user return to normal interaction? Options include a
returnbutton displayed on the screen, a function key, or control 

sequence.uote:ÒA commonmistake that
people make when
trying to design

something
completely
foolproof is to
underestimate the
ingenuity of
complete fools.ÓDouglasAdams
pre75977_ch11.qxd  11/27/08  3:56 PM  Page 332
CHAPTER 11USER INTERFACE DESIGN333¥How will help information be structured? Options include a ÒflatÓ structure inwhich all information is accessed through a keyword, a layered hierarchy of
information that provides increasing detail as the user proceeds into the

structure, or the use of hypertext.
Error handling.
Error messages and warnings are Òbad newsÓ delivered to usersof interactive systems when something has gone awry. At their worst, error

messages and warnings impart useless or misleading information and serve only to
increase user frustration. There are few computer users who have not encountered
an error of the form: ÒApplication XXX has been forced to quit because an error of type

1023 has been encountered.ÓSomewhere, an explanation for error 1023 must exist;
otherwise, why would the designers have added the identification? Yet, the error

message provides no real indication of what went wrong or where to look to get

additional information. An error message presented in this manner does nothing to
assuage user anxiety or to help correct the problem.In general, every error message or warning produced by an interactive systemshould have the following characteristics:¥The message should describe the problem in jargon that the user can
understand.¥The message should provide constructive advice for recovering from the

error.
¥The message should indicate any negative consequences of the error (e.g.,
potentially corrupted data files) so that the user can check to ensure that they
have not occurred (or correct them if they have).¥The message should be accompanied by an audible or visual cue. That is, a
beep might be generated to accompany the display of the message, or the

message might flash momentarily or be displayed in a color that is easily
recognizable as the Òerror color.Ó
¥The message should be Ònonjudgmental.Ó That is, the wording should never
place blame on the user.
Because no one really likes bad news, few users will like an error message no mat-
ter how well designed. But an effective error message philosophy can do much to
improve the quality of an interactive system and will significantly reduce user frus-

tration when problems do occur.
Menu and command labeling.The typed command was once the most com-mon mode of interaction between user and system software and was commonlyused for applications of every type. Today, the use of window-oriented, point-and-

pick interfaces has reduced reliance on typed commands, but some power-users
continue to prefer a command-oriented mode of interaction. A number of designWhatcharacter-istics should a
ÒgoodÕÓ error
message have??uote:ÒThe interface from
hellÑÕto correct
this error and
continue, enter any
11-digit prime
number ÉÕÓAuthor unknownpre75977_ch11.qxd  11/27/08  3:56 PM  Page 333
334PART TWOMODELINGissues arise when typed commands or menu labels are provided as a mode of
interaction:¥Will every menu option have a corresponding command?
¥What form will commands take? Options include a control sequence (e.g.,
alt-P), function keys, or a typed word.¥How difficult will it be to learn and remember the commands? What can be
done if a command is forgotten?¥Can commands be customized or abbreviated by the user?¥Are menu labels self-explanatory within the context of the interface?¥Are submenus consistent with the function implied by a master menu item?As I noted earlier in this chapter, conventions for command usage should be es-

tablished across all applications. It is confusing and often error-prone for a user
to type alt-D when a graphics object is to be duplicated in one application and 
alt-D when a graphics object is to be deleted in another. The potential for error is

obvious.Application accessibility.
As computing applications become ubiquitous, soft-ware engineers must ensure that interface design encompasses mechanisms thatenable easy access for those with special needs. Accessibilityfor users (and softwareengineers) who may be physically challenged is an imperative for ethical, legal, and
business reasons. A variety of accessibility guidelines (e.g., [W3C03])Ñmany de-
signed for Web applications but often applicable to all types of softwareÑprovide de-

tailed suggestions for designing interfaces that achieve varying levels of accessibility.

Others (e.g., [App08], [Mic08]) provide specific guidelines for Òassistive technologyÓ

that addresses the needs of those with visual, hearing, mobility, speech, and learn-

ing impairments.Internationalization.Software engineers and their managers invariably underes-
timate the effort and skills required to create user interfaces that accommodate theneeds of different locales and languages. Too often, interfaces are designed for one

locale and language and then jury-rigged to work in other countries. The challenge
for interface designers is to create ÒglobalizedÓ software. That is, user interfaces
should be designed to accommodate a generic core of functionality that can be de-
livered to all who use the software. Localizationfeatures enable the interface to becustomized for a specific market.A variety of internationalization guidelines (e.g., [IBM03]) are available to soft-ware engineers. These guidelines address broad design issues (e.g., screen layouts
may differ in various markets) and discrete implementation issues (e.g., different
alphabets may create specialized labeling and spacing requirements). The Unicode
standard [Uni03] has been developed to address the daunting challenge of manag-
ing dozens of natural languages with hundreds of characters and symbols.WebRef
Guidelines fordeveloping accessible
software can be
foundat 

www3.ibm.com/
able/guidelines/
software/
accesssoftware
.html.pre75977_ch11.qxd  11/27/08  3:56 PM  Page 334
CHAPTER 11USER INTERFACE DESIGN335User Interface Development
Objective:These tools enable a softwareengineer to create a sophisticated GUI withrelatively little custom software development. The toolsprovide access to reusable components and make the
creation of an interface a matter of selecting from

predefined capabilities that are assembled using the tool.Mechanics:Modern user interfaces are constructed
using a set of reusable components that are coupled withsome custom components developed to provide
specialized features. Most user interface development tools

enable a software engineer to create an interface using

Òdrag and dropÓ capability. That is, the developer selects

from many predefined capabilities (e.g., forms builders,

interaction mechanisms, command processing capability)
and places these capabilities within the content of the
interface to be created.
Representative Tools:
7LegaSuite GUI, developed by Seagull Software(www.seagullsoftware.com
), enabled thecreation of browser-based GUIs and provide facilities
for reengineering antiquated interfaces.
MotifCommonDesktopEnvironment,
developedbyThe
OpenGroup(
www.osf.org/tech/desktop/cde/
),is an integrated graphical user interface for open

systems desktop computing. It delivers a single,
standard graphical interface for the management of

data and files (the graphical desktop) and
applications.Altia Design 8.0,developed by Altia (www.altia.com
),is a tool for creating GUIs on a variety of different

platforms (e.g., automotive, handheld, industrial).
SOFTWARE
TOOLS7Tools noted here do not represent an endorsement, but rather a sampling of tools in this category.
8Each of us has bookmarked a Web page, only to revisit it later and have no indication of the web-
site or the context for the page (as well as no way to move to another location within the site).11.5W
EBAPPINTERFACE
DESIGNEvery user interfaceÑwhether it is designed for a WebApp, a traditional software
application, a consumer product, or an industrial deviceÑshould exhibit the usabil-
ity characteristics that were discussed earlier in this chapter. Dix [Dix99] argues that

you should design a WebApp interface so that it answers three primary questions for

the end user:WhereamI?
Theinterfaceshould(1)provideanindicationoftheWebAppthathas
beenaccessed
8and(2)informtheuserofherlocationinthecontenthierarchy.
What can I do now?The interface should always help the user understand hiscurrent optionsÑwhat functions are available, what links are live, what content

is relevant?Where have I been, where am I going?The interface must facilitate navigation.Hence, it must provide a ÒmapÓ (implemented in a way that is easy to under-
stand) of where the user has been and what paths may be taken to move else-

where within the WebApp.
An effective WebApp interface must provide answers for each of these questions as

the end user navigates through content and functionality.
If it is likely that usersmay enter your
WebApp at various

locations and levels in
the content hierarchy,

be sure to design every

page with navigation
features that will lead
the user to other points
of interest.pre75977_ch11.qxd  11/27/08  3:56 PM  Page 335
336PART TWOMODELING11.5.1Interface Design Principles and Guidelines
The user interface of a WebApp is its Òfirst impression.Ó Regardless of the value of its
content, the sophistication of its processing capabilities and services, and the over-

all benefit of the WebApp itself, a poorly designed interface will disappoint the

potential user and may, in fact, cause the user to go elsewhere. Because of the sheer

volume of competing WebApps in virtually every subject area, the interface must

ÒgrabÓ a potential user immediately.
Bruce Tognozzi [Tog01] defines a set of fundamental characteristics that all
interfaces should exhibit and in doing so, establishes a philosophy that should be
followed by every WebApp interface designer:
Effective interfaces are visually apparent and forgiving, instilling in their users a sense ofcontrol. Users quickly see the breadth of their options, grasp how to achieve their goals,
and do their work.Effective interfaces do not concern the user with the inner workings of the system.Work is carefully and continuously saved, with full option for the user to undo any activ-

ity at any time.Effective applications and services perform a maximum of work, while requiring aminimum of information from users.In order to design WebApp interfaces that exhibit these characteristics, Tognozzi
[Tog01] identifies a set of overriding design principles:
9Anticipation.A WebApp should be designed so that it anticipates the userÕs next
move.
For example, consider a customer support WebApp developed by a manufac-
turer of computer printers. A user has requested a content object that presents
information about a printer driver for a newly released operating system. The
designer of the WebApp should anticipate that the user might request a download

of the driver and should provide navigation facilities that allow this to happen

without requiring the user to search for this capability.
Communication.The interface should communicate the status of any activity initi-
ated by the user.
Communication can be obvious (e.g., a text message) or subtle (e.g.,an image of a sheet of paper moving through a printer to indicate that printing is
under way). The interface should also communicate user status (e.g., the userÕs iden-

tification) and her location within the WebApp content hierarchy.
Consistency.
The use of navigation controls, menus, icons, and aesthetics (e.g., color,
shape, layout) should be consistent throughout the WebApp.
For example, if underlined
blue text implies a navigation link, content should never incorporate blue underlinedtext that does not imply a link. In addition, an object, say a yellow triangle, used to
A good WebApp
interface is

understandable and
forgiving, providing the
user with a sense of
control.Is there a set
of basic prin-ciples that can be
applied as you
design a GUI??9TognozziÕs original principles have been adapted and extended for use this book. See [Tog01] for
further discussion of these principles.uote:ÒIf a site is
perfectly usable
but it lacks an
elegant and
appropriate design
style, it will fail.ÓCurtCloninger
pre75977_ch11.qxd  11/27/08  3:56 PM  Page 336
CHAPTER 11USER INTERFACE DESIGN337indicate a caution message before the user invokes a particular function or action,
should not be used for other purposes elsewhere in the WebApp. Finally, every

feature of the interface should respond in a manner that is consistent with user
expectations.10Controlled autonomy.
The interface should facilitate user movement throughout
the WebApp, but it should do so in a manner that enforces navigation conventions that

have been established for the application.For example, navigation to secure portions
of the WebApp should be controlled by userID and password, and there should be no

navigation mechanism that enables a user to circumvent these controls.Efficiency.
The design of the WebApp and its interface should optimize the userÕs
work efficiency, not the efficiency of the developer who designs and builds it or the client-
server environment that executes it.
Tognozzi [Tog01] discusses this when he writes:
ÒThis simple truth is why it is so important for everyone involved in a software proj-

ect to appreciate the importance of making user productivity goal one and to under-
stand the vital difference between building an efficient system and empowering
anefficient user.Ó
Flexibility.
The interface should be flexible enough to enable some users to accomplishtasks directly and others to explore the WebApp in a somewhat random fashion.
In everycase, it should enable the user to understand where he is and provide the user with
functionality that can undo mistakes and retrace poorly chosen navigation paths.Focus.
The WebApp interface (and the content it presents) should stay focused on the
user task(s) at hand.In all hypermedia there is a tendency to route the user to looselyrelated content. Why? Because itÕs very easy to do! The problem is that the user can
rapidly become lost in many layers of supporting information and lose sight of the
original content that she wanted in the first place.FittÕslaw.
ÒThetimetoacquireatargetisafunctionofthedistancetoandsizeofthe
targetÓ[Tog01].Basedonastudyconductedinthe1950s[Fit54],FittÕslawÒisan
effectivemethodofmodelingrapid,aimedmovements,whereoneappendage(likea
hand)startsatrestataspecificstartposition,andmovestorestwithinatargetareaÓ

[Zha02].Ifasequenceofselectionsorstandardizedinputs(withmanydifferent

optionswithinthesequence)isdefinedbyausertask,thefirstselection(e.g.,mouse

pick)shouldbephysicallyclosetothenextselection.Forexample,consideraWebApp

home page interface at an e-commerce site that sells consumer electronics.Each user option implies a set of follow-on user choices or actions. For example,
the Òbuy a productÓ option requires that the user enter a product category followed
by the product name. The product category (e.g., audio equipment, televisions, DVD
10Tognozzi [Tog01] notes that the only way to be sure that user expectations are properly understood
is through comprehensive user testing (Chapter 20).WebRef
A search on the Web
will uncover many
available libraries, e.g.,
Java API packages,
interfaces, and classes

at java.sun.comorCOM, DCOM, and
TypeLibraries at 

msdn.Microsoft
.com.uote:ÒThe best journeyis the one with the
fewest steps.
Shorten the
distance between
the user and their
goal.ÓAuthor unknownpre75977_ch11.qxd  11/27/08  3:56 PM  Page 337
338PART TWOMODELINGplayers) appears as a pull-down menu as soon as Òbuy a productÓ is picked. There-fore, the next choice is immediately obvious (it is nearby) and the time to acquire it

is negligible. If, on the other hand, the choice appeared on a menu that was located
on the other side of the screen, the time for the user to acquire it (and then make the
choice) would be far too long.Human interface objects.
A vast library of reusable human interface objects has
been developed for WebApps. Use them.
Any interface object that can be Òseen, heard,touched or otherwise perceivedÓ [Tog01] by an end user can be acquired from any
one of a number of object libraries.Latency reduction.
Rather than making the user wait for some internal operation to
complete (e.g., downloading a complex graphical image), the WebApp should use mul-
titasking in a way that lets the user proceed with work as if the operation has been com-

pleted.In addition to reducing latency, delays must be acknowledged so that the user
understands what is happening. This includes (1) providing audio feedback when a

selection does not result in an immediate action by the WebApp, (2) displaying an

animated clock or progress bar to indicate that processing is under way, and (3) pro-

viding some entertainment (e.g., an animation or text presentation) while lengthy
processing occurs.Learnability.
A WebApp interface should be designed to minimize learning time, and
once learned, to minimize relearning required when the WebApp is revisited.
In generalthe interface should emphasize a simple, intuitive design that organizes content and
functionality into categories that are obvious to the user.
Metaphors.An interface that uses an interaction metaphor is easier to learn and
easier to use, as long as the metaphor is appropriate for the application and the user.
Ametaphor should call on images and concepts from the userÕs experience, but it does
not need to be an exact reproduction of a real-world experience. For example, an 

e-commerce site that implements automated bill paying for a financial institution,
uses a checkbook metaphor (not surprisingly) to assist the user in specifying and
scheduling bill payments. However, when a user ÒwritesÓ a check, he need not enter

the complete payee name but can pick from a list of payees or have the system select
based on the first few typed letters. The metaphor remains intact, but the user gets
an assist from the WebApp.
Maintain work product integrity.
A work product (e.g., a form completed by theuser, a user-specified list) must be automatically saved so that it will not be lost if an error
occurs.Each of us has experienced the frustration associated with completing alengthy WebApp form only to have the content lost because of an error (made by us,

by the WebApp, or in transmission from client to server). To avoid this, a WebApp

should be designed to autosave all user-specified data. The interface should support
this function and provide the user with an easy mechanism for recovering ÒlostÓ

information.Metaphors are anexcellent idea because
they mirror real-world

experience. Just be
sure that the metaphor
you choose is well
known to end users.pre75977_ch11.qxd  11/27/08  3:56 PM  Page 338
CHAPTER 11USER INTERFACE DESIGN339Readability.
All information presented through the interface should be readable byyoung and old.The interface designer should emphasize readable type styles, fontsizes, and color background choices that enhance contrast.Track state.
When appropriate, the state of the user interaction should be tracked and
stored so that a user can logoff and return later to pick up where she left off.
In general,cookies can be designed to store state information. However, cookies are a contro-
versial technology, and other design solutions may be more palatable for some users.
Visible navigation.
A well-designed WebApp interface provides Òthe illusion that users
are in the same place, with the work brought to themÓ[Tog01]. When this approach
isused, navigation is not a user concern. Rather, the user retrieves content objects
and selects functions that are displayed and executed through the interface.Interface Design ReviewThe scene:Doug MillerÕs office.
The players:Doug Miller (manager of the SafeHomesoftware engineering group) and Vinod Raman, a member
of the SafeHomeproduct software engineering team.The conversation:Doug:Vinod, have you and the team had a chance to
review the SafeHomeAssured.come-commerceinterface prototype?

Vinod:
Yeah . . . we all went through it from a technical
point of view, and I have a bunch of notes. I e-mailed
Ôem to Sharon [manager of the WebApp team for the

outsourcing vendor for the SafeHomee-commercewebsite] yesterday.
Doug:You and Sharon can get together and discuss the
small stuff . . . give me a summary of the important issues.
Vinod:
Overall, theyÕve done a good job, nothingground breaking, but itÕs a typical e-commerce interface,
decent aesthetics, reasonable layout, theyÕve hit all the
important functions . . .
Doug (smiling ruefully):But?Vinod:
Well, there are a few things . . . .
Doug:Such as . . .Vinod (showing Doug a sequence of story-
boards for the interface prototype):
HereÕs the
major functions menu thatÕs displayed on the home page:
Learn aboutSafeHome.Describe your home.GetSafeHomecomponent recommendations.Purchase aSafeHomesystem.Get technical support.
The problem isnÕt with these functions. TheyÕre all okay,

but the level of abstraction isnÕt right.
Doug:TheyÕre all major functions, arenÕt they?
Vinod:
They are, but hereÕs the thing . . . you can
purchase a system by inputting a list of components . . .no real need to describe the house if you donÕt want to.

IÕd suggest only four menu options on the home page:Learn aboutSafeHome.Specify theSafeHomesystem you need.Purchase aSafeHomesystem.Get technical support.
When you select Specify theSafeHomesystemyou need, youÕll then have the following options:SelectSafeHomecomponents.GetSafeHomecomponent recommendations.If youÕre a knowledgeable user, youÕll select components

from a set of categorized pull-down menus for sensors,
cameras, control panels, etc. If you need help, youÕll ask
for a recommendation and that will require that you
describe your house. I think itÕs a bit more logical.
Doug:I agree. Have you talked with Sharon about this?Vinod:
No, I want to discuss this with marketing first;then IÕll give her a call.SAFEHOMEpre75977_ch11.qxd  11/27/08  3:56 PM  Page 339
340PART TWOMODELINGNielsen and Wagner [Nie96] suggest a few pragmatic interface design guidelines
(based on their redesign of a major WebApp) that provide a nice complement to the
principles suggested earlier in this section:¥Reading speed on a computer monitor is approximately 25 percent slower
than reading speed for hardcopy. Therefore, do not force the user to read

voluminous amounts of text, particularly when the text explains the
operation of the WebApp or assists in navigation.
¥Avoid Òunder constructionÓ signsÑan unnecessary link is sure to disappoint.
¥Users prefer not to scroll. Important information should be placed within the
dimensions of a typical browser window.
¥Navigation menus and head bars should be designed consistently and should
be available on all pages that are available to the user. The design should not

rely on browser functions to assist in navigation.¥Aesthetics should never supersede functionality. For example, a simple

button might be a better navigation option than an aesthetically pleasing, but
vague image or icon whose intent is unclear.
¥Navigation options should be obvious, even to the casual user. The user

should not have to search the screen to determine how to link to other
content or services.A well-designed interface improves the userÕs perception of the content or services

provided by the site. It need not necessarily be flashy, but it should always be well

structured and ergonomically sound.11.5.2Interface Design Workflow for WebApps
Earlier in this chapter I noted that user interface design begins with the identification
of user, task, and environmental requirements. Once user tasks have been identified,

user scenarios (use cases) are created and analyzed to define a set of interface
objects and actions.Information contained within the requirements model forms the basis for thecreation of a screen layout that depicts graphical design and placement of icons, def-
inition of descriptive screen text, specification and titling for windows, and specifi-
cation of major and minor menu items. Tools are then used to prototype and

ultimately implement the interface design model. The following tasks represent a
rudimentary workflow for WebApp interface design:
1.Review information contained in the requirements model and refine

as required.
2.Develop a rough sketch of the WebApp interface layout.
An interfaceprototype (including the layout) may have been developed as part of the
requirements modeling activity. If the layout already exists, it should be

reviewed and refined as required. If the interface layout has not beenuote:ÒPeople have very
little patience for
poorly designed
WWW sites.ÓJakobNielsen
and
AnnetteWagner
pre75977_ch11.qxd  11/27/08  3:56 PM  Page 340
CHAPTER 11USER INTERFACE DESIGN341developed, you should work with stakeholders to develop it at this time. Aschematic first-cut layout sketch is shown in Figure 11.4.3.Map user objectives into specific interface actions.
For the vast major-ity of WebApps, the user will have a relatively small set of primary objectives.

These should be mapped into specific interface actions as shown in Figure11.4.

In essence, you must answer the following question: ÒHow does the interface

enable the user to accomplish each objective?Ó4.Define a set of user tasks that are associated with each action.
Eachinterface action (e.g., Òbuy a productÓ) is associated with a set of user tasks.
These tasks have been identified during requirements modeling. During de-
sign, they must be mapped into specific interactions that encompass naviga-
tion issues, content objects, and WebApp functions.
5.Storyboard screen images for each interface action.
As each action isconsidered, a sequence of storyboard images (screen images) should be created
to depict how the interface responds to user interaction. Content objects should
be identified (even if they have not yet been designed and developed), WebApp

functionality should be shown, and navigation links should be indicated.6.Refine interface layout and storyboards using input from aesthetic

design.In most cases, youÕll be responsible for rough layout and story-boarding, but the aesthetic look and feel for a major commercial site is
often developed by artistic, rather than technical, professionals. Aesthetic

design (Chapter 13) is integrated with the work performed by the interface
designer.
List of user objectivesObjective #1Objective #2
Objective #3
Objective #4
Objective #5Objective #nNavigationmenuMenu barmajor functionsGraphic, logo, and company nameGraphicHome page text copyFIGURE11.4Mapping userobjectives into
interface

actionspre75977_ch11.qxd  11/27/08  3:56 PM  Page 341
342PART TWOMODELING7.Identify user interface objects that are required to implement the
interface.
This task may require a search through an existing object libraryto find those reusable objects (classes) that are appropriate for the WebApp

interface. In addition, any custom classes are specified at this time.8.Develop a procedural representation of the userÕs interaction with

the interface.
This optional task uses UML sequence diagrams and/oractivity diagrams (Appendix 1) to depict the flow of activities (and decisions)
that occur as the user interacts with the WebApp.
9.Develop a behavioral representation of the interface.
This optionaltask makes use of UML state diagrams (Appendix 1) to represent state
transitions and the events that cause them. Control mechanisms (i.e., the
objects and actions available to the user to alter a WebApp state) are

defined.10.Describe the interface layout for each state.
Using design informationdeveloped in Tasks 2 and 5, associate a specific layout or screen image with

each WebApp state described in Task 8.
11.Refine and review the interface design model.
Review of the interfaceshould focus on usability.
It is important to note that the final task set you choose should be adapted to the
special requirements of the application that is to be built.11.6D
ESIGNEVALUATION
Once you create an operational user interface prototype, it must be evaluated

to determine whether it meets the needs of the user. Evaluation can span a formal-

ity spectrum that ranges from an informal Òtest drive,Ó in which a user provides

impromptu feedback to a formally designed study that uses statistical methods for
the evaluation of questionnaires completed by a population of end users.The user interface evaluation cycle takes the form shown in Figure 11.5. After thedesign model has been completed, a first-level prototype is created. The prototype is
evaluated by the user,
11who provides you with direct comments about the efficacy
of the interface. In addition, if formal evaluation techniques are used (e.g., ques-

tionnaires, rating sheets), you can extract information from these data (e.g., 
80 percent of all users did not like the mechanism for saving data files). Design mod-
ifications are made based on user input, and the next level prototype is created. The
evaluation cycle continues until no further modifications to the interface design are
necessary.
11It is important to note that experts in ergonomics and interface design may also conduct reviews
of the interface. These reviews are called heuristic evaluationsor cognitive walkthroughs.pre75977_ch11.qxd  11/27/08  3:56 PM  Page 342
CHAPTER 11USER INTERFACE DESIGN343The prototyping approach is effective, but is it possible to evaluate the quality of
a user interface before a prototype is built? If you identify and correct potentialproblems early, the number of loops through the evaluation cycle will be reduced

and development time will shorten. If a design model of the interface has been
created, a number of evaluation criteria [Mor81] can be applied during early design
reviews:1.The length and complexity of the requirements model or written specification
of the system and its interface provide an indication of the amount of learn-

ing required by users of the system.2.The number of user tasks specified and the average number of actions per
task provide an indication of interaction time and the overall efficiency of the

system.3.The number of actions, tasks, and system states indicated by the design model
imply the memory load on users of the system.4.Interface style, help facilities, and error handling protocol provide a general

indication of the complexity of the interface and the degree to which it will be
accepted by the user.
Once the first prototype is built, you can collect a variety of qualitative and quanti-tative data that will assist in evaluating the interface. To collect qualitative data, ques-

tionnaires can be distributed to users of the prototype. Questions can be: (1) simple
yes/no response, (2) numeric response, (3) scaled (subjective) response, (4) Likert
Buildprototype #ninterface
Evaluationis studied bydesignerUserevaluatesinterface
Designmodificationsare madeBuildprototype #1interface
Preliminary
designInterface design
is completeFIGURE11.5The interface
design evalua-
tion cyclepre75977_ch11.qxd  11/27/08  3:56 PM  Page 343
344PART TWOMODELINGscales (e.g., strongly agree, somewhat agree), (5) percentage (subjective) response,
or (6) open-ended.If quantitative data are desired, a form of time-study analysis can be conducted.Users are observed during interaction, and dataÑsuch as number of tasks correctly
completed over a standard time period, frequency of actions, sequence of actions,

time spent ÒlookingÓ at the display, number and types of errors, error recovery time,

time spent using help, and number of help references per standard time periodÑare
collected and used as a guide for interface modification.A complete discussion of user interface evaluation methods is beyond the scopeof this book. For further information, see [Hac98] and [Sto05].11.7S
UMMARYThe user interface is arguably the most important element of a computer-based sys-
tem or product. If the interface is poorly designed, the userÕs ability to tap the com-

putational power and informational content of an application may be severely
hindered. In fact, a weak interface may cause an otherwise well-designed and solidly
implemented application to fail.Threeimportantprinciplesguidethedesignofeffectiveuserinterfaces:(1)place
theuserincontrol,(2)reducetheuserÕsmemoryload,and(3)maketheinterfacecon-

sistent.Toachieveaninterfacethatabidesbytheseprinciples,anorganizeddesign

process must be conducted.The development of a user interface begins with a series of analysis tasks. Useranalysis defines the profiles of various end users and is gathered from a variety of
business and technical sources. Task analysis defines user tasks and actions using

either an elaborative or object-oriented approach, applying use cases, task and ob-
ject elaboration, workflow analysis, and hierarchical task representations to fully
understand the human-computer interaction. Environmental analysis identifies the

physical and social structures in which the interface must operate.Oncetaskshavebeenidentified,userscenariosarecreatedandanalyzedtodefine
asetofinterfaceobjectsandactions.Thisprovidesabasisforthecreationofascreen

layoutthatdepictsgraphicaldesignandplacementoficons,definitionofdescriptive

screentext,specificationandtitlingforwindows,andspecificationofmajorandminor

menuitems.Designissuessuchasresponsetime,commandandactionstructure,er-

rorhandling,andhelpfacilitiesareconsideredasthedesignmodelisrefined.Avariety

ofimplementationtoolsareusedtobuildaprototypeforevaluationbytheuser.
Like interface design for conventional software, the design of WebApp interfaces
describes the structure and organization of the user interface and includes a repre-
sentation of screen layout, a definition of the modes of interaction, and a description
of navigation mechanisms. A set of interface design principles and an interface de-
sign workflow guide a WebApp designer when layout and interface control mecha-

nisms are designed.pre75977_ch11.qxd  11/27/08  3:56 PM  Page 344
CHAPTER 11USER INTERFACE DESIGN345The user interface is the window into the software. In many cases, the interfacemolds a userÕs perception of the quality of the system. If the ÒwindowÓ is smudged,
wavy, or broken, the user may reject an otherwise powerful computer-based system.
PROBLEMSAND
POINTSTO
PONDER11.1.Describe the worst interface that you have ever worked with and critique it relative to theconcepts introduced in this chapter. Describe the best interface that you have ever worked with
and critique it relative to the concepts introduced in this chapter.
11.2.Develop two additional design principles that Òplace the user in control.Ó11.3.Develop two additional design principles that Òreduce the userÕs memory load.Ó
11.4.Develop two additional design principles that Òmake the interface consistent.Ó11.5.Consider one of the following interactive applications (or an application assigned by yourinstructor):a.A desktop publishing system
b.A computer-aided design system
c.An interior design system (as described in Section 11.3.2)
d.An automated course registration system for a university
e.A library management system
f.An Internet-based polling booth for public elections
g.A home banking system
h.An interactive application assigned by your instructor
Develop a user model, design model, mental model, and an implementation model, for any oneof these systems.11.6.Perform a detailed task analysis for any one of the systems listed in Problem 11.5 Useeither an elaborative or object-oriented approach.
11.7.Add at least five additional questions to the list developed for content analysis inSection11.3.3.

11.8.Continuing Problem 11.5, define interface objects and actions for the application youhave chosen. Identify each object type.
11.9.Develop a set of screen layouts with a definition of major and minor menu items for thesystem you chose in Problem 11.5.
11.10.Develop a set of screen layouts with a definition of major and minor menu items for theSafeHomesystem. You may elect to take a different approach than the one shown for the screen
layout in Figure 11.3.
11.11.Describe your approach to user help facilities for the task analysis design model andtask analysis you have performed as part of Problems 11.5 through 11.8.
11.12.Provide a few examples that illustrate why response time variability can be an issue.
11.13.Develop an approach that would automatically integrate error messages and a userhelp facility. That is, the system would automatically recognize the error type and provide a help
window with suggestions for correcting it. Perform a reasonably complete software design that
considers appropriate data structures and algorithms.11.14.Develop an interface evaluation questionnaire that contains 20 generic questions thatwould apply to most interfaces. Have 10 classmates complete the questionnaire for an interac-tive system that you all use. Summarize the results and report them to your class.pre75977_ch11.qxd  11/27/08  3:56 PM  Page 345
346PART TWOMODELINGFURTHER
READINGSAND
INFORMATION
SOURCESAlthough his book is not specifically about human-computer interfaces, much of what DonaldNorman (The Design of Everyday Things,reissue edition, Currency/Doubleday, 1990) has to say
about the psychology of effective design applies to the user interface. It is recommended read-
ing for anyone who is serious about doing high-quality interface design.Graphical user interfaces are ubiquitous in the modern world of computing. Whether itÕs an
ATM, a mobile phone, an electronic dashboard in an automobile, a website, or a business appli-

cation, the user interface provides a window into the software. It is for this reason that books

addressing interface design abound. Butow (User Interface Design for Mere Mortals,Addison-Wesley, 2007), Galitz (
The Essential Guide to User Interface Design,3d ed., Wiley, 2007), Lehikonen
and his colleagues (Personal Content Experience: Managing Digital Life in the Mobile Age,Wiley-
Interscience, 2007), Cooper and his colleagues (
About Face 3: The Essentials of Interaction Design,

3d ed., Wiley, 2007), Ballard 
(Designing the Mobile User Experience,Wiley, 2007), Nielsen
(Coordinating User Interfaces for Consistency,
Morgan-Kaufmann, 2006), Lauesen (User InterfaceDesign: A Software Engineering Perspective,Addison-Wesley, 2005), Barfield (
The User Interface:Concepts and Design,Bosko Books, 2004) all discuss usability, user interface concepts, principles,
and design techniques and contain many useful examples.Older books by Beyer and Holtzblatt (Contextual Design: A Customer Centered Approach to Sys-
tems Design,Morgan-Kaufmann, 2002), Raskin (The Humane Interface,Addison-Wesley, 2000),
Constantine and Lockwood (Software for Use,ACM Press, 1999), and Mayhew (
The Usability En-gineering Lifecycle,Morgan-Kaufmann, 1999) present treatments that provide additional design
guidelines and principles as well as suggestions for interface requirements elicitation, design
modeling, implementation, and testing.Johnson (GUI Bloopers: DonÕts and DoÕs for Software Developers and Web Designers,
Morgan-Kaufmann, 2000) provides useful guidance for those that learn more effectively by examining

counterexamples. An enjoyable book by Cooper (The Inmates Are Running the Asylum,SamsPublishing, 1999) discusses why high-tech products drive us crazy and how to design ones that
donÕt.
A wide variety of information sources on user interface design are available on the Internet.An up-to-date list of World Wide Web references that are relevant to user interface design can

befound at the SEPA website: 
www.mhhe.com/engcs/compsci/pressman/professional/
olc/ser.htm
.pre75977_ch11.qxd  11/27/08  3:56 PM  Page 346
Eachofushasencounteredadesignproblemandsilentlythought:
Iwonder
ifanyonehasdevelopedasolutionforthis?
TheanswerisalmostalwaysÑ
yes!The problem is finding the solution; ensuring that it does, in fact, fitthe problem youÕve encountered; understanding the constraints that may restrictthe manner in which the solution is applied; and finally, translating the proposed

solution into your design environment.
But what if the solution were codified in some manner? What if there was a stan-dard way of describing a problem (so you could look it up), and an organized
method for representing the solution to the problem? It turns out that software
problems have been codified and described using a standardized template, and so-

lutions to them (along with constraints) have been proposed. Called design patterns,347CHAPTER12PATTERN
-BASEDDESIGNWhat is it?Pattern-based design
creates a new application by findinga set of proven solutions to a clearly
delineated set of problems. Eachproblem and its solution is described by a design
pattern that has been cataloged and vetted by

other software engineers who have encountered
the problem and implemented the solution while
designing other applications. Each design pat-
tern provides you with a proven approach to

one part of the problem to be solved.
Who does it?A software engineer examines eachproblem encountered for a new application and
then attempts to find a relevant solution by
searching one or more patterns repositories.
Why is it important?
Have you ever heard thephrase Òreinventing the wheelÓ? It happens all
the time in software development, and itÕs a

waste of time and energy. By using existing

design patterns, you can acquire a proven solu-

tion for aspecific problem. As each pattern is

applied, solutions are integrated and the appli-
cation to be built moves closer to a complete
design.QUICKLOOKWhat are the steps?The requirements model isexamined in order to isolate the hierarchical set
of problems to be solved. The problem space is
partitioned so that subsets of problems associ-

ated with specific software functions and fea-
tures can be identified. Problems can also be
organized by type: architectural, component-
level, algorithmic, user interface, etc. Once a

subset of problems is defined, one or more pat-
tern repositories are searched to determine if an

existing design pattern, represented at an ap-

propriate level of abstraction, exists. Patterns

that are applicable are adapted to the specific
needs of the software to be built. Custom prob-
lem solving is applied in situations for which no
patterns can be found.
What is the work product?
A design model thatdepicts the architectural structure, user interface,

and component-level detail is developed.How do I ensure that IÕve done it right?As eachdesign pattern is translated into some element of

the design model, work products are reviewed for
clarity, correctness, completeness, and consis-

tency with requirements and with one another.
KEYCONCEPTSdesign mistakes . . . . .359
forces . . . . . . .349

frameworks . . .352

granularity . . . .369

patternlanguages . . . .353
patternsarchitectural . .360

behavioral . . .351
pre75977_ch12.qxd  11/27/08  3:58 PM  Page 347
this codified method for describing problems and their solution allows the softwareengineering community to capture design knowledge in a way that enables it to be
reused.The early history of software patterns begins not with a computer scientist but abuilding architect, Christopher Alexander, who recognized that a recurring set of

problems were encountered whenever a building was designed. He characterized
these recurring problems and their solutions as patterns,describing them in thefollowing manner [Ale77]:Each pattern describes a problem that occurs over and over again in our environment and
then describes the core of the solution to that problem in such a way that you can use the
solution a million times over without ever doing it the same way twice.
AlexanderÕs ideas were first translated into the software world in books by Gamma
[Gam95], Buschmann [Bus96], and their many colleagues.1Today, dozens of pattern
repositories exist, and pattern-based design can be applied in many different appli-
cation domains.348PART TWOMODELINGcomponent-level . . . . . . .362
generative . . .350

creational . . . .350

structural . . . .351

userinterface . . . .366
WebApps . . . .368
12.1D
ESIGNPATTERNS
A design patterncan be characterized as Òa three-part rule which expresses a rela-tion between a certain context, a problem, and a solutionÓ [Ale79]. For softwaredesign, contextallows the reader to understand the environment in which the prob-
lem resides and what solution might be appropriate within that environment. A set

of requirements, including limitations and constraints, acts as a system of forces
thatinfluences how the problem can be interpreted within its context and how the solu-
tion can be effectively applied.To better understand these concepts, consider a situation
2in which a person musttravel between New York and Los Angeles. In this context, travel will occur within

an industrialized country (the United States), using an existing transportation infra-
structure (e.g., roads, airlines, railways). The system of forces that will affect the way
in which the travel problem is solved will include: how quickly the person wants to
get from New York to LA, whether the trip will include site-seeing or stopovers, how

much money the person can spend, whether the trip is intended to accomplish a spe-
cific purpose, and the personal vehicles the person has at her disposal. Given these

forces, the problem (traveling from New York to LA) can be better defined. For

example, investigation (requirements gathering) indicates that the person has very

little money, owns only a bicycle (and is an avid cyclist), wants to make the trip to

raise money for her favorite charity, and has plenty of time to spare. The solution to

the problem, given the context and the system of forces, might be a cross-country1Earlier discussions of software patterns do exist, but these two classic books were the first cohesive
treatments of the subject.2This example has been adapted from [Cor98].
Forcesare thosecharacteristics of theproblem and attributes
of the solution that
constrain the way in
which the design can
be developed.pre75977_ch12.qxd  11/27/08  3:58 PM  Page 348
bike trip. If the forces were different (e.g., travel time must be minimized and the pur-pose of the trip is a business meeting), another solution might be more appropriate.It is reasonable to argue that most problems have multiple solutions, but that asolution is effective only if it is appropriate within the context of the existing prob-
lem. It is the system of forces that causes a designer to choose a specific solution.
The intent is to provide a solution that best satisfies the system of forces, even when

these forces are contradictory. Finally, every solution has consequences that may

have an impact on other aspects of the software and may themselves become part
of the system of forces for other problems to be solved within the larger system.Coplien [Cop05] characterizes an effective design pattern in the following way:¥It solves a problem: Patterns capture solutions, not just abstract principles orstrategies.¥It is a proven concept
: Patterns capture solutions with a track record, not theo-ries or speculation.¥The solution isnÕt obvious
: Many problem-solving techniques (such as softwaredesign paradigms or methods) try to derive solutions from first principles. The
best patterns generate
a solution to a problem indirectlyÑa necessary approachfor the most difficult problems of design.¥It describes a relationship: Patterns donÕt just describe modules, but describe

deeper system structures and mechanisms.¥The pattern has a significant human component (minimize human intervention).
All software serves human comfort or quality of life; the best patterns explicitly
appeal to aesthetics and utility.
Statedevenmorepragmatically,agooddesignpatterncaptureshard-earned,prag-
maticdesignknowledgeinawaythatenablesotherstoreusethatknowledgeÒamil-

liontimesoverwithouteverdoingitthesamewaytwice.ÓAdesignpatternsavesyou

fromÒreinventingthewheel,Óorworse,inventingaÒnewwheelÓthatisslightlyoutof

round,toosmallforitsintendeduse,andtoonarrowforthegrounditwillrollover.De-

signpatterns,ifusedeffectively,willinvariablymakeyouabettersoftwaredesigner.
12.1.1Kinds of Patterns
One of the reasons that software engineers are interested in (and intrigued by)
design patterns is that human beings are inherently good at pattern recognition. If
we werenÕt, weÕd be frozen in space and timeÑunable to learn from past experience,

unwilling to venture forward because of our inability to recognize situations that
might lead to high risk, unhinged by a world that seems to have no regularity or log-
ical consistency. Luckily, none of this occurs because we do recognize patterns in

virtually every aspect of our lives.In the real world, the patterns we recognize are learned over a lifetime of experi-
ence. We recognize them instantly and inherently understand what they mean

andhow they might be used. Some of these patterns provide us with insight into
CHAPTER 12PATTERN-BASED DESIGN349uote:ÒOur responsibilityis to do what we
can, learn what we
can, improve the
solutions, and pass
them on.ÓRichardP.
Feynmanpre75977_ch12.qxd  11/27/08  3:58 PM  Page 349
recurring phenomenon. For example, youÕre on your way home from work on the
interstate when your navigation system (or car radio) informs you that a serious
accident has occurred on the interstate in the opposing direction. YouÕre 4 miles from

the accident, but already you begin to see traffic slowing, recognizing a pattern that
weÕll call RubberNecking.
People in the travel lanes moving in your direction are
slowing at the sight of the accident to get a better view of what happened on the
opposite side of the highway. The 
RubberNecking
pattern yields remarkably pre-dictable results (a traffic jam), but it does nothing more than describe a phenome-
non. In patterns jargon, it might be called a nongenerative
pattern because itdescribes a context and a problem but it does not provide any clear-cut solution.
Whensoftwaredesignpatternsareconsidered,westrivetoidentifyanddocument
generative
patterns.Thatis,weidentifyapatternthatdescribesanimportantand
repeatableaspectofasystemandthatprovidesuswithawaytobuildthataspect

withinasystemofforcesthatareuniquetoagivencontext.Inanidealsetting,acol-

lectionofgenerativedesignpatternscouldbeusedtoÒgenerateÓanapplicationor

computer-basedsystemwhosearchitectureenablesittoadapttochange.Some-

timescalled
generativity,
Òthesuccessiveapplicationofseveralpatterns,eachencap-
sulatingitsownproblemandforces,unfoldsalargersolutionwhichemerges

indirectlyasaresultofthesmallersolutionsÓ[App00].
Design patterns span a broad spectrum of abstraction and application.Architectural patterns
describe broad-based design problems that are solved using astructural approach. Data patternsdescribe recurring data-oriented problems and thedata modeling solutions that can be used to solve them. Component patterns(alsoreferred to as design patterns) address problems associated with the development of
subsystems and components, the manner in which they communicate with one
another, and their placement within a larger architecture. 
Interface design patterns
describe common user interface problems and their solution with a system of forces
that includes the specific characteristics of end users. WebApp patterns
address aproblem set that is encountered when building WebApps and often incorporates

many of the other patterns categories just mentioned. At a lower level of abstraction,
idiomsdescribe how to implement all or part of a specific algorithm or data structurefor a software component within the context of a specific programming language.In their seminal book on design patterns, Gamma and his colleagues3[Gam95]focus on three types of patterns that are particularly relevant to object-oriented
design: creational patterns, structural patterns, and behavioral patterns.Creational patternsfocus on the Òcreation, composition, and representationÓ ofobjects. Gamma and his colleagues [Gam95] note that creational patterns
Òencapsulate knowledge about which concrete classes the system usesÒ but at
thesame timeÒhide how instances of these classes are created and put together.Ó

Creational patterns provide mechanisms that make the instantiation of objects
350PART TWOMODELINGA ÒgenerativeÓ pattern
describes the problem,
a context, and forces,
but it also describes a
pragmatic solution to
the problem.Is there a
way tocategorize pattern
types??3Gamma and his colleagues [Gam95] are often referred to as the ÒGang of FourÓ (GoF) in patterns
literature.pre75977_ch12.qxd  11/27/08  3:58 PM  Page 350
easier within a system and enforce Òconstraints on the type and number of objectsthat can be created within a systemÓ [Maa07].Structural patterns
focus on problems and solutions associated with how classesand objects are organized and integrated to build a larger structure. In essence, they

help to establish relationships between entities within a system. For example, struc-

tural patterns that focus on class-oriented issues might provide inheritance mecha-

nisms that lead to more effective program interfaces. Structural patterns that focus
on objects suggest techniques for combining objects within other objects or inte-
grating objects into a larger structure.Behavioral patterns
address problems associated with the assignment of respon-sibility between objects and the manner in which communication is effected
between objects.CHAPTER 12PATTERN-BASED DESIGN351A wide variety of design patterns that fit into
creational, structural, and behavioral categorieshave been proposed and can be found on the Web.
Wikipedia (www.wikipedia.org
) notes the following
sampling:Creational Patterns¥Abstract factory pattern:
centralize decision ofwhat factory to instantiate.
¥Factory method pattern:
centralize creation ofanobject of a specific type choosing one of several
implementations.¥Builder pattern:separate the construction of acomplex object from its representation so that the
sameconstruction process can create different

representations.¥Prototype pattern:
used when the inherent cost ofcreating a new object in the standard way (e.g., using
the ÒnewÓ keyword) is prohibitively expensive for a
given application.¥Singleton pattern:restrict instantiation of a class toone object.Structural Patterns¥Adapter pattern:ÒadaptsÓ one interface for a class
into one that a client expects.¥Aggregate pattern:a version of the compositepattern with methods for aggregation of children.
¥Bridge pattern:decouple an abstraction from itsimplementation so that the two can vary independently.
¥Composite pattern:a tree structure of objectswhere every object has the same interface.
¥Container pattern:create objects for the solepurpose of holding other objects and managing them.¥Proxy pattern:
a class functioning as an interface to
another thing.¥Pipes and filters:a chain of processes where theoutput of each process is the input of the next.Behavioral Patterns¥Chain of responsibility pattern:Commandobjects are handled or passed on to other objects by
logic-containing processing objects.¥Command pattern:Command objects encapsulatean action and its parameters.¥Event listener:Data are distributed to objects thatare registered to receive them.¥Interpreter pattern:Implement a specializedcomputer language to rapidly solve a specific set of
problems.¥Iterator pattern:Iterators are used to access theelements of an aggregate object sequentially without
exposing its underlying representation.¥Mediator pattern:Provides a unified interface to a
set of interfaces in a subsystem.
¥Visitor pattern:
A way to separate an algorithmfrom an object.¥Single-serving visitor pattern:
Optimize theimplementation of a visitor that is allocated, used only
once, and then deleted.¥Hierarchical visitor pattern:Provide a way to visitevery node in a hierarchical data structure such as a tree.
Comprehensive descriptions of each of these patterns can

be obtained via links at www.wikipedia.org
.INFOCreational, Structural, and Behavioral Patterns
pre75977_ch12.qxd  11/27/08  3:58 PM  Page 351
12.1.2Frameworks
Patterns themselves may not be sufficient to develop a complete design. In somecases it may be necessary to provide an implementation-specific skeletal infrastruc-

ture, called a 
framework,
for design work. That is, you can select a Òreusable mini-architecture
that provides the generic structure and behavior for a family of software
abstractions, along with a context . . . which specifies their collaboration and use
within a given domainÓ [Amb98].A framework is not an architectural pattern, but rather a skeleton with a collec-tion of Òplug pointsÓ (also called hooksand slots) that enable it to be adapted to a spe-cific problem domain. The plug points enable you to integrate problem-specific
classes or functionality within the skeleton. In an object-oriented context, a frame-
work is a collection of cooperating classes.Gamma and his colleagues [Gam95] describe the differences between designpatterns and frameworks in the following manner:1.Design patterns are more abstract than frameworks
. Frameworks can be embodiedincode, but only 
examplesof patterns can be embodied in code. A strength offrameworks is that they can be written down in programming languages and not
only studied but executed and reused directly....2.Design patterns are smaller architectural elements than frameworks
. A typical
framework contains several design patterns but the reverse is never true.3.Design patterns are less specialized than frameworks
. Frameworks always have aparticular application domain. In contrast, design patterns can be used in nearly any
kind of application. While more specialized design patterns are certainly possible,

even these wouldnÕt dictate an application architecture.
In essence, the designer of a framework will argue that one reusable mini-
architecture is applicable to all software to be developed within a limited domain of
application. To be most effective, frameworks are applied with no changes. Addi-

tional design elements may be added, but only via the plug points that allow the
designer to flesh out the framework skeleton.12.1.3Describing a Pattern
Pattern-based design begins with the recognition of patterns within the application
you intend to build, continues with a search to determine whether others have
addressed the pattern, and concludes with the application of an appropriate pattern
to the problem at hand. The second of these three tasks is often the most difficult.
How do you find patterns that fit your needs?An answer to this question must rely on effective communication of the problemthe pattern addresses, the context in which the pattern resides, the system of forces
that mold the context, and the solution that is proposed. To communicate this

information unambiguously, a standard form or template for pattern descriptions is

required. Although a number of different pattern templates have been proposed,352PART TWOMODELINGA frameworkis areusable Òmini-architectureÓ that
serves as a foundation

from which other
design patterns can be

applied.pre75977_ch12.qxd  11/27/08  3:58 PM  Page 352
almost all contain a major subset of the content suggested by Gamma and hiscolleagues [Gam95]. A simplified pattern template is shown in the sidebar.
CHAPTER 12PATTERN-BASED DESIGN353INFOThe names of design patterns should be chosen with care. One of the key techni-cal problems in pattern-based design is the inability to find existing patterns whenhundreds or thousands of candidate patterns exist. The search for the ÒrightÓ pattern
is aided immeasurably by a meaningful pattern name.A pattern template provides a standardized means for describing a design pattern.
Each of the template entries represents characteristics of the design pattern that can
be searched (e.g., via a database) so that the appropriate pattern can be found.12.1.4Pattern Languages and Repositories
When we use the term language,the first thing that comes to mind is either a natu-ral language (e.g., English, Spanish, Chinese) or a programming language (e.g., C,Java). In both cases the language has a syntax and semantics that are used to com-
municate ideas or procedural instructions in an effective manner.
When the term languageis used in the context of design patterns, it takes on aslightly different meaning. A pattern languageencompasses a collection of patterns,each described using a standardized template (Section 12.1.3) and interrelated to
show how these patterns collaborate to solve problems across an application
domain.4In a natural language, words are organized into sentences that impart meaning.
The structure of sentences is described by the languageÕs syntax. In a pattern lan-

guage, design patterns are organized in a way that provides a Òstructured method of

describing good design practices within a particular domain.Ó5uote:ÒPatterns are half-bakedÑmeaning
you always have
tofinish them

yourself and adapt
them to your own
environment.ÓMartinFowler
4Christopher Alexander originally proposed pattern languages for building architecture and urban
planning. Today, pattern languages have been developed for everything from the social sciences tothe software engineering process.5This Wikipedia description can be found at http://en.wikipedia.org/wiki/Pattern_language.
Design Pattern Template
Pattern name
Ñdescribes the essence of thepattern in a short but expressive name
ProblemÑdescribes the problem that the pattern addresses
MotivationÑprovides an example of the problem
ContextÑdescribes the environment in which the problemresides including the application domainForcesÑlists the system of forces that affect the manner in
which the problem must be solved; includes a discussion
of limitations and constraints that must be consideredSolutionÑprovides a detailed description of the solutionproposed for the problemIntentÑdescribes the pattern and what it does

CollaborationsÑdescribes how other patterns contribute to
the solutionConsequencesÑdescribes the potential trade-offs that must
be considered when the pattern is implemented and

the consequences of using the pattern
ImplementationÑidentifies special issues that should beconsidered when implementing the pattern
Known usesÑprovides examples of actual uses of thedesign pattern in real applications
Related patterns
Ñcross-references related design patterns
pre75977_ch12.qxd  11/27/08  3:58 PM  Page 353
In a way, a pattern language is analogous to a hypertext instruction manual for
problem solving in a specific application domain. The problem domain under con-sideration is first described hierarchically, beginning with broad design problems as-

sociated with the domain and then refining each of the broad problems into lower
levels of abstraction. In a software context, broad design problems tend to be archi-
tectural in nature and address the overall structure of the application and the data or

content that serve it. Architectural problems are refined to lower levels of abstrac-
tion, leading to design patterns that solve subproblems and collaborate with one
another at the component (or class) level. Rather than a sequential list of patterns,
apattern language represents an interconnected collection in which the user can

begin with a broad design problem and Òburrow downÓ to uncover specific problems

and their solutions.Dozens of pattern languages have been proposed for software design [Hil08]. Inmost cases, the design patterns that are part of pattern language are stored in a Web-

accessible patterns repository (e.g., [Boo08], [Cha03], [HPR02]). The repository pro-
vides an index of all design patterns and contains hypermedia links that enable the
user to understand the collaborations between patterns.12.2P
ATTERN
-BASEDSOFTWARE
DESIGNThe best designers in any field have an uncanny ability to see patterns that charac-
terize a problem and corresponding patterns that can be combined to create a solu-
tion. The software developers at Microsoft [Mic04] discuss this when they write:While pattern-based design is relatively new in the field of software development, indus-trial technology has used pattern-based design for decades, perhaps even centuries.
Catalogs of mechanisms and standard configurations provide design elements that are

used to engineer automobiles, aircraft, machine tools, and robots. Applying pattern-
based design to software development promises the same benefits to software as it does
to industrial technology: predictability, risk mitigation, and increased productivity.
Throughout the design process, you should look for every opportunity to applyexisting design patterns (when they meet the needs of the design) rather than creat-
ing new ones.12.2.1Pattern-Based Design in Context
Pattern-based design is not used in a vacuum. The concepts and techniques dis-
cussed for architectural, component-level, and user interface design (Chapters 9
through 11) are all used in conjunction with a pattern-based approach.In Chapter 8, I noted that a set of quality guidelines and attributes serve as thebasis for all software design decisions. The decisions themselves are influenced by
a set of fundamental design concepts (e.g., separation of concerns, stepwise refine-
ment, functional independence) that are achieved using heuristics that have evolved
over many decades, and best practices (e.g., techniques, modeling notation) that
354PART TWOMODELINGWebRef
For a listing of usefulpatterns languages

seec2.com/ppr/titles.html.
Additional information

can be obtained at
hillside.net/
patterns/.If you canÕt find apattern language that

addresses your
problem domain, look
for analogies in
another set of
patterns.
pre75977_ch12.qxd  11/27/08  3:58 PM  Page 354
have been proposed to make design easier to perform and more effective as a basisfor construction.Theroleofpattern-baseddesigninallofthisisillustratedinFigure12.1.Asoft-
waredesignerbeginswitharequirementsmodel(eitherexplicitorimplied)that

presentsanabstractrepresentationofthesystem.Therequirementsmodeldescribes

theproblemset,establishesthecontext,andidentifiesthesystemofforcesthathold

sway.Itmayimplythedesigninanabstractmanner,buttherequirementsmodel

doeslittletorepresentthedesignexplicitly.
Asyoubeginyourworkasadesigner,itÕsalwaysimportanttokeepquality
attributesinmind.Theseattributes(e.g.,adesignmustimplementallexplicitrequire-

mentsaddressedintherequirementsmodel)establishawaytoassesssoftwarequal-

itybutdolittletohelpyouactuallyachieveit.Thedesignyoucreateshouldexhibit

thefundamentaldesignconceptsdiscussedinChapter8.Therefore,youshouldap-

plyproventechniquesfortranslatingtheabstractionscontainedintherequirements

modelintoamoreconcreteformthatisthesoftwaredesign.Toaccomplishthis,

youÕllusethemethodsandmodelingtoolsavailableforarchitectural,component-

level,andinterfacedesign.ButonlywhenyouÕrefacedwithaproblem,context,and

systemofforcesthathavenotbeensolvedbefore.Ifasolutionalreadyexists,useit!

Andthatmeansapplyingapattern-baseddesignapproach.
CHAPTER 12PATTERN-BASED DESIGN355Design beginsConsiderdesign conceptsExtractproblem, contextforcesRequirementsmodelConsiderdesign qualityattributesBeginpattern-based
design tasksApply otherdesign methodsand notationyesnoAddressed bypattern?
DesignmodelFIGURE12.1Pattern-based
design in
contextpre75977_ch12.qxd  11/27/08  3:58 PM  Page 355
12.2.2Thinking in Patterns
In an excellent book on pattern-based design, Shalloway and Trott [Sha05] comment
on a Ònew way of thinkingÓ when one uses patterns as part of the design activity:I had to open my mind to a new way of thinking. And when I did so, I heard [Christopher]Alexander say that Ògood software design cannot be achieved simply by adding together
performing parts.ÓGood design begins by considering contextÑthe big picture. As context is evaluated,you extract a hierarchy of problems that must be solved. Some of these problems will
be global in nature, while others will address specific features and functions of the

software. All will be affected by a system of forces that will influence the nature of
the solution that is proposed.Shalloway and Trott [Sha05] suggest the following approach
6that enables adesigner to think in patterns:1.Be sure you understand the big pictureÑthe context in which the software to
be built resides. The requirements model should communicate this to you.2.Examining the big picture, extract the patterns that are present at that level

of abstraction.3.Begin your design with Òbig pictureÓ patterns that establish a context or
skeleton for further design work.4.ÒWork inward from the contextÓ [Sha05] looking for patterns at lower levels

of abstraction that contribute to the design solution.5.Repeat steps 1 to 4 until the complete design is fleshed out.6.Refine the design by adapting each pattern to the specifics of the software
youÕre trying to build.ItÕs important to note that patterns are not independent entities. Design patterns that

are present at a high level of abstraction will invariably influence the manner in

which other patterns are applied at lower levels of abstraction. In addition, patterns
often collaborate with one another. The implicationÑwhen you select an architec-

tural pattern, it may very well influence the component-level design patterns you
choose. Likewise, when you select a specific interface design pattern, you are some-

times forced to use other patterns that collaborate with it.To illustrate, consider the 
SafeHomeAssured.comWebApp. If you consider the
big picture, the WebApp must address a number of fundamental problems such as:
¥How to provide information about 
SafeHomeproducts and services¥How to sell SafeHomeproducts and services to customers¥How to establish Internet-based monitoring and control of an installed
security system356PART TWOMODELINGPattern-based designlooks interesting
for the problem
Ihave to solve.

How do I get
started??6Based on the work of Christopher Alexander [Ale79].
pre75977_ch12.qxd  11/27/08  3:58 PM  Page 356
Each of these fundamental problems can be further refined into a set of subprob-lems. For example How to sellvia the Internet
implies an E-commerce
pattern thatitself implies a large number of patterns at lower levels of abstraction. The 
E-commerce
pattern (likely, an architectural pattern) implies mechanisms for
setting up a customer account, displaying the products to be sold, selecting prod-
ucts for purchase, and so forth. Hence, if you think in patterns, it is important to

determine whether a pattern for setting up an account exists. If SetUpAccountisavailable as a viable pattern for the problem context, it may collaborate with

other patterns such as BuildInputForm, ManageFormsInput,
and Validate-
FormsEntry.
Each of these patterns delineates problems to be solved and solu-tions that may be applied.12.2.3Design Tasks
The following design tasks are applied when a pattern-based design philosophy is
used:1.Examine the requirements model and develop a problem hierarchy.

Describe each problem and subproblem by isolating the problem, the
context, and the system of forces that apply. Work from broad problems (high

level of abstraction) to smaller subproblems (at lower levels of abstraction).2.Determine if a reliable pattern language has been developed for the

problem domain.
As I noted in Section 12.1.4, a pattern language addressesproblems associated with a specific application domain. The SafeHomesoftware team would look for a pattern language developed specifically for
home security products. If that level of pattern language specificity could not
be found, the team would partition the SafeHomesoftware problem into aseries of generic problem domains (e.g., digital device monitoring problems,
user interface problems, digital video management problems) and search for
appropriate pattern languages.3.Beginning with a broad problem, determine whether one or more

architectural patterns is available for it.
If an architectural pattern isavailable, be certain to examine all collaborating patterns. If the pattern is

appropriate, adapt the design solution proposed and build a design model

element that adequately represents it. As I noted in Section 12.2.2, a broad
problem for the SafeHomeAssured.comWebApp is addressed with an 
E-commerce
pattern. This pattern will suggest a specific architecture foraddressing e-commerce requirements.4.Using the collaborations provided for the architectural pattern,

examine subsystem or component-level problems and search for

appropriate patterns to address them.
It may be necessary to searchthrough other pattern repositories as well as the list of patterns that corre-
sponds to the architectural solution. If an appropriate pattern is found, adaptCHAPTER 12PATTERN-BASED DESIGN357What are thetasksrequired to create
a pattern-based
design??pre75977_ch12.qxd  11/27/08  3:58 PM  Page 357
the design solution proposed and build a design model element thatadequately represents it. Be certain to apply step 7.5.Repeat steps 2 through 5 until all broad problems have been

addressed.
The implication is to begin with the big picture and elaborate tosolve problems at increasingly more detailed levels.6.If user interface design problems have been isolated (this is almost

always the case), search the many user interface design pattern

repositories for appropriate patterns.
Proceed in a manner similar tosteps 3, 4, and 5.7.Regardless of its level of abstraction, if a pattern language and/or

patterns repository or individual pattern shows promise, compare

the problem to be solved against the existing pattern(s) presented.

Be certain to examine context and forces to ensure that the pattern does, in
fact, provide a solution that is amenable to the problem.
8.Be certain to refine the design as it is derived from patterns using

design quality criteria as a guide.Although this design approach is top-down, real-life design solutions are sometimes
more complex. Gillis [Gil06] comments on this when he writes:Design patterns in software engineering are meant to be used in a deductive, rationalis-
tic fashion. So you have this general problem or requirement, X, design pattern Y solves
X, therefore use Y. Now, when I reflect on my own processÑand IÕve got reason to believe

that IÕm not alone hereÑI find that itÕs more organic than that, more inductive than

deductive, more bottom-up than top-down.
Obviously, thereÕs a balance to be achieved. When a project is in the initial bootstrap
phase and IÕm trying to make the jump from abstract requirements to a concrete design
solution, IÕll often perform a sort of breadth-first search...IÕve found design patterns to

be helpful, allowing me to quickly frame up the design problem in concrete terms.In addition, the pattern-based approach must be used in conjunction with other soft-ware design concepts and techniques.12.2.4Building a Pattern-Organizing Table
As pattern-based design proceeds, you may encounter trouble organizing and
categorizing candidate patterns from multiple pattern languages and repositories.
To help organize your evaluation of candidate patterns, Microsoft [Mic04] suggests

the creation of a pattern-organizing tablethat takes the general form shown inFigure 12.2.A pattern-organizing table can be implemented as a spreadsheet model using theform shown in the figure. An abbreviated list of problem statements, organized by
data/content, architecture, component-level, and user interface issues, is presented

in the left-hand (shaded) column. Four pattern typesÑdatabase, application,
358PART TWOMODELINGEntries in the table canbe supplemented with
an indication of the
relative applicability
ofthe pattern.
pre75977_ch12.qxd  11/27/08  3:58 PM  Page 358
implementation, and infrastructureÑare listed across the top row. The names of
candidate patterns are noted in the cells of the table.To provide entries for the organizing table, youÕll search through pattern
languages and repositories for patterns that address a particular problem statement.
When one or more candidate patterns is found, it is entered in the row correspon-
ding to the problem statement and the column that corresponds to the pattern type.
The name of the pattern is entered as a hyperlink to the URL of the Web address that

contains a complete description of the pattern.12.2.5Common Design Mistakes
Pattern-based design can make you a better software designer, but it is 
notapanacea. Like all design methods, you must begin with first principles, emphasizing
software quality fundamentals and ensuring that the design does, in fact, address the
needs expressed by the requirements model.A number of common mistakes occur when pattern-based design is used. In somecases, not enough time has been spent to understand the underlying problem and its
context and forces, and as a consequence, you select a pattern that looks right but

is inappropriate for the solution required. Once the wrong pattern is selected, you
refuse to see your error and force-fit the pattern. In other cases, the problem has
forces that are not considered by the pattern youÕve chosen, resulting in a poor orCHAPTER 12PATTERN-BASED DESIGN359Problem statement ...Problem statement ...Problem statement ...User interface
Problem statement ...Problem statement ...Problem statement ...Component-levelProblem statement ...Problem statement ...Problem statement ...ArchitectureProblem statement ...Problem statement ...Problem statement ...PatternName(s)
PatternName(s)
PatternName(s)
PatternName(s)
PatternName(s)
PatternName(s)PatternName(s)
PatternName(s)PatternName(s)

PatternName(s)PatternName(s)
PatternName(s)PatternName(s)

PatternName(s)PatternName(s)
PatternName(s)
PatternName(s)
PatternName(s)
PatternName(s)
PatternName(s)
DatabaseData/ContentApplicationImplementationInfrastructureFIGURE12.2A pattern-
organizing

table
Source:Adapted from[Mic04].DonÕt force a pattern,
even if it addresses the
problem at hand. If the
context and forces are
wrong, look for
another pattern.
pre75977_ch12.qxd  11/27/08  3:58 PM  Page 359
erroneous fit. Sometimes a pattern is applied too literally and the required adapta-tions for your problem space are not implemented.Can these mistakes be avoided? In most cases the answer is Òyes.Ó Every good de-signer looks for a second opinion and welcomes review of her work. The review tech-
niques discussed in Chapter 15 can help to ensure that the pattern-based design youÕve
developed will result in a high-quality solution for the software problem to be solved.12.3A
RCHITECTURALPATTERNS
If a house builder decides to construct a center-hall colonial, there is a single archi-
tectural style that can be applied. The details of the style (e.g., number of fireplaces,
fa“ade of the house, placement of doors and windows) can vary considerably, but once

the decision on the overall architecture of the house is made, the style is imposed

onthe design.
7Architectural patterns are a bit different. For example, every house (and every
architectural style for houses) employs a Kitchen
pattern. The Kitchen
pattern andpatterns it collaborates with address problems associated with the storage and
preparation of food, the tools required to accomplish these tasks, and rules for place-
ment of these tools relative to workflow in the room. In addition, the pattern might
address problems associated with countertops, lighting, wall switches, a central is-
land, flooring, and so on. Obviously, there is more than a single design for a kitchen,

often dictated by the context and system of forces. But every design can be conceived
within the context of the ÒsolutionÓ suggested by the Kitchen
pattern.As I have already noted, architectural patterns for software define a specificapproach for handling some characteristic of the system. Bosch [Bos00] and Booch
[Boo08] define a number of architectural pattern domains. Representative examples
are provided in the paragraphs that follow:
Access control.
There are many situations in which access to data, features, andfunctionality delivered by an application is limited to specifically defined end users.From an architectural point of view, access to some portion of the software archi-

tecture must be controlled rigorously.
Concurrency.
Many applications must handle multiple tasks in a manner that sim-ulates parallelism (i.e., this occurs whenever multiple ÒparallelÓ tasks or componentsare managed by a single processor). There are a number of different ways in which
an application can handle concurrency, and each can be presented by a different

architectural pattern. For example, one approach is to use an 
OperatingSystem-

ProcessManagement
pattern that provides built-in OS features that allow
360PART TWOMODELING7This implies that there will be a central foyer and hallway, that rooms will be placed to the left and
right of the foyer, that the house will have two (or more) stories, that the bedrooms of the housewill be upstairs, and so on. These ÒrulesÓ are imposed once the decision is made to use the center-
hall colonial style.A software architecturemay have a number of
architectural patterns

that address issues
such as concurrency,

persistence, and
distribution.What are
some typicalarchitectural
pattern domains??pre75977_ch12.qxd  11/27/08  3:58 PM  Page 360
components to execute concurrently. The pattern also incorporates OS functionality
that manages communication between processes, scheduling, and other capabilities
required to achieve concurrency. Another approach might be to define a task sched-

uler at the application level. A TaskScheduler
pattern contains a set of active ob-jects that each contains a tick()
operation [Bos00]. The scheduler periodically invokes
tick()
for each object, which then performs the functions it must perform before re-turning control back to the scheduler which then invokes the 
tick()
operation for thenext concurrent object.Distribution.Thedistributionproblemaddressesthemannerinwhichsystemsor
componentswithinsystemscommunicatewithoneanotherinadistributedenviron-
ment.Twosubproblemsareconsidered:(1)thewayinwhichentitiesconnecttoone

another,and(2)thenatureofthecommunicationthatoccurs.Themostcommon

architecturalpatternestablishedtoaddressthedistributionproblemisthe
Broker
pattern.AbrokeractsasaÒmiddlemanÓbetweentheclientcomponentandaservercom-

ponent.Theclientsendsamessagetothebroker(containingallappropriateinformation

forthecommunicationtobeeffected)andthebrokercompletestheconnection.
Persistence.
Data persists if it survives past the execution of the process that createdit. Persistent data are stored in a database or file and may be read or modified by otherprocesses at a later time. In object-oriented environments, the idea of a persistent ob-

ject extends the persistence concept a bit further. The values of all of the objectÕs at-

tributes, the general state of the object, and other supplementary information are stored
for future retrieval and use. In general, two architectural patterns are used to achieve
persistenceÑa DatabaseManagementSystempattern that applies the storage andretrieval capability of a DBMS to the application architecture or an Application Level-

Persistence
pattern that builds persistence features into the application architecture(e.g., word processing software that manages its own document structure).Before any one of the representative architectural patterns noted in the precedingparagraphs can be chosen, it must be assessed for its appropriateness for the appli-
cation and the overall architectural style, as well as the context and system of forces

that it specifies.CHAPTER 12PATTERN-BASED DESIGN361Design Pattern Repositories
Therearemanysourcesfordesignpatternsavail-
ableontheWeb.Somepatternscanbeobtained
fromindividuallypublishedpatternlanguages,while

othersareavailableaspartofapatternsportalorpatterns

repository.ThefollowingWebsourcesareworthalook:
Hillside.nethttp://hillside.net/patterns/
One of the WebÕs most comprehensive collections of
patterns and pattern languages.
Portland Pattern Repository
http://c2.com/ppr/index.html

Contains pointers to a wide variety of patterns

resources and collections.Pattern Index
http://c2.com/cgi/wiki?PatternIndex 
An Òeclectic collection of patternsÓ
BoochÕs Architecture Patterns Handbook
www.booch.com/architecture/index.jsp
INFOpre75977_ch12.qxd  11/27/08  3:58 PM  Page 361
12.4C
OMPONENT-LEVELDESIGNPATTERNS
Component-leveldesignpatternsprovideyouwithprovensolutionsthataddressone
ormoresubproblemsextractedfromtherequirementsmodel.Inmanycases,design

patternsofthistypefocusonsomefunctionalelementofasystem.Forexample,the

SafeHomeAssured.comapplicationmustaddressthefollowingdesignsubproblem:
HowcanwegetproductspecificationsandrelatedinformationforanySafeHomedevice?
Having enunciated the subproblem that must be solved, you should now considercontext and the system of forces that affect the solution. Examining the appropriate
requirements model use case, you learn that the consumer uses the specification for

a SafeHomedevice (e.g., a security sensor or camera) for informational purposes.However, other information that is related to the specification (e.g., pricing) may be

used when e-commerce functionality is selected.The solution to the subproblem involves a search. Since searching is a very com-
mon problem, it should come as no surprise that there are many search-related
patterns. Looking through a number of patterns repositories, you find the following
patterns, along with the problem that each solves:AdvancedSearch.
Users must find a specific item in a large collection ofitems.HelpWizard.
Users need help on a certain topic related to the website orwhen they need to find a specific page within the site.
SearchArea.
Users must find a page.SearchTips.
Users need to know how to control the search engine.362PART TWOMODELINGBibliographic reference to hundreds of architecturaland component design patterns
UI Patterns Collections
UI/HCI Patterns
www.hcipatterns.org/patterns.html
Jennifer TidwellÕs UI patterns
www.time-tripper.com/uipatterns/
Mobile UI Design Patterns
http://patterns.littlespringsdesign.com/

wikka.php?wakka=MobilePatterns
Pattern Language for UI Design
www.maplefish.com/todd/papers/

Experiences.htmlInteraction Design Library for Games
www.eelke.com/research/usability.html
UI Design Patterns
www.cs.helsinki.fi/u/salaakso/patterns/
Specialized Design Patterns:
Aircraft Avionics
http://g.oswego.edu/dl/acs/acs/acs.html
Business Information Systems
www.objectarchitects.de/arcus/cookbook/
Distributed Processingwww.cs.wustl.edu/~schmidt/
IBM Patterns for e-Business
www128.ibm.com/developerworks/patterns/
Yahoo! Design Pattern Library
http://developer.yahoo.com/ypatterns/
WebPatterns.org
http://webpatterns.org/
pre75977_ch12.qxd  11/27/08  3:58 PM  Page 362
SearchResults.
Users have to process a list of search results.SearchBox.
Users have to find an item or specific information.For SafeHomeAssured.comthe number of products is not particularly large,
andeach has a relatively simple categorization, so 
AdvancedSearch
andHelpWizard
are probably not necessary. Similarly, the search is simple enough
not to require SearchTips
. The description of SearchBox
, however, is given (in
part) as:Search Box
(Adapted fromwww.welie.com/patterns/showPattern.php?patternID=search.)
Problem:
The users need to find an item or specific information.Motivation:
Any situation in which a keyword search is applied across acollection of content objects organized as Web pages.
Context:Rather than using navigation to acquire information or content,
the user wants to do a direct search through content contained
on multiple Web pages. Any website that already has primary

navigation. User may want to search for an item in a category.

User might want to further specify a query.
Forces:
The website already has primary navigation. Users may want to
search for an item in a category. Users might want to further

specify a query using simple Boolean operators.Solution:Offer search functionality consisting of a search label, a keyword
field, a filter if applicable, and a ÒgoÓ button. Pressing the return

key has the same function as selecting the go button. Also pro-
vide Search Tips and examples in a separate page. A link to that

page is placed next to the search functionality. The edit box for

the search term is large enough to accommodate three typical
user queries (typically around 20 characters). If the number of
filters is more than 2, use a combo box for filters selection,
otherwise a radio button.The search results are presented on a new page with a clearlabel containing at least ÒSearch resultsÓ or similar. The search

function is repeated in the top part of the page with the entered
keywords, so that the users know what the keywords were.The pattern description continues with other entries as described in Section 12.1.3.
The pattern goes on to describe how the search results are accessed, presented,
matched, and so on. Based on this, the SafeHomeAssured.comteam can design thecomponents required to implement the search or (more likely) acquire existing
reusable components.CHAPTER 12PATTERN-BASED DESIGN363pre75977_ch12.qxd  11/27/08  3:58 PM  Page 363
12.5U
SERINTERFACE
DESIGNPATTERNS
Hundreds of user interface (UI) patterns have been proposed in recent years. Mostfall within one of the following 10 categories of patterns (discussed with a represen-
tative example8) as described by Tidwell [Tid02] and vanWelie [Wel01]:
Whole UI.Provide design guidance for top-level structure and navigation
throughout the entire interface.Pattern:TopLevelNavigation
Brief description:Used when a site or application implements a numberofmajor functions. Provides a top-level menu, often coupled with a logo or
364PART TWOMODELING8An abbreviated pattern template is used here. Full pattern descriptions (along with dozens of other
patterns) can be found at [Tid02] and [Wel01].Applying PatternsThe scene:Informal discussion during
the design of a software increment that implements sensorcontrol via the Internet for 
SafeHomeAssured.com.The players:Jamie (responsible for design) and Vinod
(SafeHomeAssured.comchief system architect).The conversation:Vinod:
So how is the design of the camera controlinterface coming along?

Jamie:Not too bad. IÕve designed most of the capabilityto connect to the actual sensors without too many problems.IÕve also started thinking about the interface for the users to

actually move, pan, and zoom the cameras from a remote
Web page, but IÕm not sure IÕve got it right yet.
Vinod:
What have you come up with?Jamie:Well,therequirementsarethatthecameracontrol
needstobehighlyinteractiveÑastheusermovesthecontrol,
thecamerashouldmoveassoonaspossible.So,Iwas

thinkingofhavingasetofbuttonslaidoutlikeanormal

camera,butwhentheuserclicksthem,itcontrolsthecamera.
Vinod:
Hmmm. Yeah, that would work, but IÕm not sure
itÕs rightÑfor each click of a control you need to wait for
the whole client-server communication to occur, and so

you wonÕt get a good sense of quick feedback.
Jamie:ThatÕs what I thoughtÑand why I wasnÕt very
happy with the approach, but IÕm not sure how elseImight do it.
Vinod:
Well, why not just use the
InteractiveDeviceControl
pattern!
Jamie:UhmmmÑwhatÕs that? I havenÕt heard of it?
Vinod:
ItÕs basically a pattern for exactly the problem
you are describing. The solution it proposes is basically to
create a control connection to the server with the device,

through which control commands can be sent. That way
you donÕt need to send normal HTTP requests. And the

pattern even shows how you can implement this using

some simple AJAX techniques. You have some simple

client-side JavaScript thatcommunicates directly with the

server and sends the commands as soon as the user does

anything.Jamie:Cool! ThatÕs just what I needed to solve this
thing. Where do I find it?
Vinod:
ItÕs available in an online repository. HereÕs
theURL.

Jamie:IÕll go check it out.Vinod:
YepÑbut remember to check the consequences
field for the pattern. I seem to remember that there was
something in there about needing to be careful about
issues of security. I think it might be because you are

creating a separate control channel and so bypassing the
normal Web security mechanisms.
Jamie:Good point. I probably wouldnÕt have thought
ofthat! Thanks.
SAFEHOMEpre75977_ch12.qxd  11/27/08  3:58 PM  Page 364
CHAPTER 12PATTERN-BASED DESIGN365identifying graphic, that enables direct navigation to any of the systemÕs
major functions.Details:Major functions (generally limited to between four and seven func-tion names) are listed across the top of the display (vertical column formatsare also possible) in a horizontal line of text. Each name provides a link to

the appropriate function or information source. Often used with the
BreadCrumbs
pattern discussed later.
Navigation elements:
Each function/content name represents a link to theappropriate function or content.Page layout.
Address the general organization of pages (for websites) or distinctscreen displays (for interactive applications).Pattern:CardStack
Brief description:Used when a number of specific subfunctions or contentcategories related to a feature or function must be selected in random order.
Provides the appearance of a stack of tabbed cards, each selectable with

amouse click and each representing specific subfunctions or content

categories.Details:Tabbed cards are a well-understood metaphor and are easy for the
user to manipulate. Each tabbed card (divider) may have a slightly differentformat. Some may require input and have buttons or other navigation mech-
anisms; others may be informational. May be combined with other patterns
such as DropDownList
,Fill-in-the-Blanks,and others.Navigation elements:
A mouse click on a tab causes the appropriate cardto appear. Navigation features within the card may also be present, but in

general, these should initiate a function that is related to card data, not cause
an actual link to some other display.
Forms and input.
Consider a variety of design techniques for completing form-level input.Pattern:Fill-in-the-Blanks
Brief description:Allow alphanumeric data to be entered in a Òtext box.ÓDetails:Data may be entered within a text box. In general, the data arevalidated and processed after some text or graphic indicator (e.g., a buttoncontaining Ògo,Ó Òsubmit,Ó ÒnextÓ) is picked. In many cases this pattern can be
combined with drop-down list or other patterns (e.g., SEARCH <drop down
list> FOR <fill-in-the-blanks
text box>).Navigation elements:
A text or graphic indicator that initiates validationand processing.Tables.
Provide design guidance for creating and manipulating tabular data of all
kinds.pre75977_ch12.qxd  11/27/08  3:58 PM  Page 365
Pattern:SortableTable
Brief description:Display a long list of records that can be sorted byselecting a toggle mechanism for any column label.
Details:Each row in the table represents a complete record. Each columnrepresents one field in the record. Each column header is actually a selec-table button that can be toggled to initiate an ascending or descending sort
on the field associated with the column for all records displayed. The table is
generally resizable and may have a scrolling mechanism if the number of
records is larger than available window space.Navigation elements:
Each column header initiates a sort on all records.No other navigation is provided, although in some cases, each record may
itself contain navigation links to other content or functionality.
Directdatamanipulation.
Addressdataediting,modification,andtransformation.
Pattern:BreadCrumbs
Brief description:Provides a full navigation path when the user is working
with a complex hierarchy of pages or display screens.
Details:Each page or display screen is given a unique identifier. The naviga-
tion path to the current location is specified in a predefined location for everydisplay. The path takes the form: 
home>major topic page>subtopic page>specific page>current page.
Navigation elements:
Any of the entries within the bread crumbs displaycan be used as a pointer to link back to a higher level of the hierarchy.
Navigation.
Assist the user in navigating through hierarchical menus, Web
pages, and interactive display screens.Pattern:EditInPlace

Brief description:Provide simple text editing capability for certain types of
content in the location that it is displayed. No need for the user to enter a textediting function or mode explicitly.
Details:The user sees content on the display that must be changed. Amouse double click on the content indicates to the system that editing isdesired. The content is highlighted to signify that editing mode is available
and the user makes appropriate changes.Navigation elements:
None.Searching.
Enable content-specific searches through information maintainedwithin a website or contained by persistent data stores that are accessible via aninteractive application.Pattern:SimpleSearch
Brief description:Provides the ability to search a website or persistent data
source for a simple data item described by an alphanumeric string.366PART TWOMODELINGpre75977_ch12.qxd  11/27/08  3:58 PM  Page 366
Details:Provides the ability to search either locally (one page or one file) or
globally (entire site or complete database) for the search string. Generates alist of ÒhitsÓ in order of their probability of meeting the userÕs needs. Does not

provide multiple item searches or special Boolean operations (see 
advanced
search pattern
).Navigation elements:
Each entry in the list of hits represents a navigationlink to the data referenced by the entry.
Page elements.Implement specific elements of a Web page or display screen.
Pattern:Wizard

Brief description:Takes the user through a complex task one step at a
time, providing guidance for the completion of the task through a series of
simple window displays.Details:Classic example is a registration process that contains four steps.The wizard pattern generates a window for each step, requesting specificinformation from the user one step at a time.Navigation elements:
Forward and back navigation allows the user torevisit each step in the wizard process.E-commerce.
Specific to websites, these patterns implement recurring elementsof e-commerce applications.Pattern:ShoppingCart

Brief description:Provides a list of items selected for purchase.
Details:Lists item, quantity, product code, availability (in stock, out of stock),
price, delivery information, shipping costs, and other relevant purchase infor-
mation. Also provides ability to edit (e.g., remove, change quantity).
Navigation elements:
Contains ability to proceed with shopping or go tocheckout.Miscellaneous.Patterns that do not easily fit into one of the preceding cate-gories. In some cases, these patterns are domain dependent or occur only forspecific classes of users.Pattern:ProgressIndicator
Brief description:Provides an indication of progress when an operation
takes longer than nseconds.Details:Represented as an animated icon or a message box that containssome visual indication (e.g., a rotating Òbarber pole,Ó a slider with a percent
complete indicator) that processing is under way. May also contain a text

content indication of the status of processing.Navigation elements:
Often contains a button that allows the user topause or cancel processing.CHAPTER 12PATTERN-BASED DESIGN367pre75977_ch12.qxd  11/27/08  3:58 PM  Page 367
Each of the preceding example patterns (and all patterns within each category)would also have a complete component-level design, including design classes,
attributes, operations, and interfaces.A comprehensive discussion of user interface patterns is beyond the scope of thisbook. If you have further interest, see [Duy02], [Bor01], [Tid02], and [Wel01] for

further information.12.6W
EBAPPDESIGNPATTERNS
Throughout this chapter youÕve learned that there are different types of patterns and
many different ways they can be categorized. When you consider the design prob-
lems that must be solved when a WebApp is to be built, itÕs worth considering pat-

tern categories by focusing on two dimensions: the design focus of the pattern and
its level of granularity. 
Design focusidentifies which aspect of the design model isrelevant (e.g., information architecture, navigation, interaction). 
Granularity
identi-fies the level of abstraction that is being considered (e.g., does the pattern apply to
the entire WebApp, to a single Web page, to a subsystem, or an individual WebApp

component?).12.6.1Design Focus
In earlier chapters I emphasized a design progression that begins by considering
architecture, component-level issues, and user interface representations. At each

step, the problems you consider and the solutions you propose begin at a high level
of abstraction and slowly become more detailed and specific. Stated another way,

design focus becomes ÒnarrowerÓ as you move further into design. The problems

(and solutions) you will encounter when designing an information architecture for a
WebApp are different from the problems (and solutions) that are encountered when

performing interface design. Therefore, it should come as no surprise that patterns

for WebApp design can be developed for different levels of design focus, so that you

can address the unique problems (and related solutions) that are encountered at
each level. WebApp patterns can be categorized using the following levels of

designfocus:
¥Information architecture patterns
relate to the overall structure of
theinformation space, and the ways in which users will interact with the

information.¥Navigation patterns
define navigation link structures, such as hierarchies,rings, tours, and so on.¥Interaction patterns
contribute to the design of the user interface. Patternsin this category address how the interface informs the user of the conse-
quences of a specific action, how a user expands content based on usage368PART TWOMODELINGYour focus becomes
ÒnarrowerÓ the further

you move into design.pre75977_ch12.qxd  11/27/08  3:58 PM  Page 368
context and user desires, how to best describe the destination that is impliedby a link, how to inform the user about the status of an ongoing interaction,
and interface-related issues.¥Presentationpatterns
assistinthepresentationofcontentasitispresented
totheuserviatheinterface.Patternsinthiscategoryaddresshowtoorganize

userinterfacecontrolfunctionsforbetterusability,howtoshowtherelation-

shipbetweenaninterfaceactionandthecontentobjectsitaffects,andhow

toestablisheffectivecontenthierarchies.
¥Functional patternsdefine the workflows, behaviors, processing, commu-nication, and other algorithmic elements within a WebApp.
In most cases, it would be fruitless to explore the collection of information architec-
ture patternswhen a problem in interaction design is encountered. You would ex-

amine interaction patterns,because that is the design focus that is relevant to the

work being performed.12.6.2Design Granularity
When a problem involves Òbig pictureÓ issues, you should attempt to develop

solutions (and use relevant patterns) that focus on the big picture. Conversely, when

the focus is very narrow (e.g., uniquely selecting one item from a small set of five or
fewer items), the solution (and the corresponding pattern) is targeted quite nar-
rowly. In terms of the level of granularity, patterns can be described at the follow-

ing levels:¥Architectural patterns.
This level of abstraction will typically relate topatterns that define the overall structure of the WebApp, indicate the rela-

tionships among different components or increments, and define the rules
for specifying relationships among the elements (pages, packages, compo-
nents, subsystems) of the architecture.¥Design patterns.These address a specific element of the design such asanaggregation of components to solve some design problem, relationships

among elements on a page, or the mechanisms for effecting component-to-

component communication. An example might be the Broadsheet
patternfor the layout of a WebApp home page.
¥Component patterns.This level of abstraction relates to individual small-scale elements of a WebApp. Examples include individual interaction

elements (e.g., radio buttons), navigation items (e.g., how might you format
links?) or functional elements (e.g., specific algorithms).It is also possible to define the relevance of different patterns to different classes
ofapplications or domains. For example, a collection of patterns (at different levels

of design focus and granularity) might be particularly relevant to e-business.CHAPTER 12PATTERN-BASED DESIGN369pre75977_ch12.qxd  11/27/08  3:58 PM  Page 369
370PART TWOMODELING12.7S
UMMARYDesign patterns provide a codified mechanism for describing problems and their
solution in a way that allows the software engineering community to capture design
knowledge for reuse. A pattern describes a problem, indicates the context enabling
the user to understand the environment in which the problem resides, and lists a sys-

tem of forces that indicate how the problem can be interpreted within its context and
how the solution can be applied. In software engineering work, we identify and doc-
ument generative patterns that describe an important and repeatable aspect of a sys-
tem and then provide us with a way to build that aspect within a system of forces

that is unique to a given context.Architectural patterns describe broad-based design problems that are solvedusing a structural approach. Data patterns describe recurring data-oriented prob-
lems and the data modeling solutions that can be used to solve them. Component
patterns (also referred to as design patterns) address problems associated with the
development of subsystems and components, the manner in which they communi-
cate with one another, and their placement within a larger architecture. Interface

design patterns describe common user interface problems and their solution with
asystem offorces that includes the specific characteristics of end users. WebApp

patterns address a problem set that is encountered when building WebApps and of-

ten incorporates many of the other patterns categories just mentioned. A frameworkHypermedia Design Patterns Repositories
The IAWiki website 
(http://iawiki.net/WebsitePatterns)
, a collaborativediscussion space for information architects, contains
manyuseful resources. Among them are links to a 

number of useful hypermedia patterns catalogs and

repositories. Hundreds of design patterns are 

represented:Hypermedia Design Patterns Repository
www.designpattern.lu.unisi.ch/
InteractionPatterns by Tom Erickson
www.pliant.org/personal/Tom_Erickson/
InteractionPatterns.htmlWeb Design Patterns by Martijn vanWelie
www.welie.com/patterns/
Web Patterns for UI Design 
http://harbinger.sims.berkeley.edu/

ui_designpatterns/webpatterns2/
webpatterns/home.phpPatterns for Personal Websites
www.rdrop.com/%7Ehalf/Creations/Writin

gs/Web.patterns/index.html
Improving Web Information Systems with Navigational
Patterns
http://www8.org/w8-papers/
5b-hypertext-
media/improving/
improving.html
An HTML 2.0 Pattern Language
www.anamorph.com/docs/patterns/

default.htmlCommon GroundÑA Pattern Language for HCI Design
www.mit.edu/~jtidwell/interaction_patterns

.htmlPatterns for Personal Websites 
www.rdrop.com/
~half/Creations/Writings/Web.patterns/

index.htmlIndexing Pattern Language
www.cs.brown.edu/
~rms/InformationStructures/Indexing/
Overview.html
INFOpre75977_ch12.qxd  11/27/08  3:58 PM  Page 370
provides an infrastructure in which patterns may reside and idioms describe pro-
gramming languageÐspecific implementation detail for all or part of a specific algo-
rithm or data structure. A standard form or template is used for pattern descriptions.
A pattern language encompasses a collection of patterns, each described using a
standardized template and interrelated to show how these patterns collaborate to
solve problems across an application domain.Pattern-based design is used in conjunction with architectural, component-level,and user interface design methods. The design approach begins with an examina-
tion of the requirements model to isolate problems, define context, and describe the
system of forces. Next, pattern languages for the problem domain are searched to
determine if patterns exist for the problems that have been isolated. Once appropri-
ate patterns have been found, they are used as a design guide.PROBLEMSAND
POINTSTO
PONDER12.1.Discuss the three ÒpartsÓ of a design pattern and provide a concrete example of each from
some field other than software.12.2.What is the difference between a nongenerative and a generative pattern?12.3.How do architectural patterns differ from component patterns?12.4.What is a framework and how does it differ from a pattern? What is an idiom and howdoes it differ from a pattern?
12.5.Using the design pattern template presented in Section 12.1.3, develop a completepattern description for a pattern suggested by your instructor.

12.6.Develop a skeletal pattern language for a sport with which you are familiar. You can
begin by addressing the context, the system of forces, and the broad problems that a coach andteam must solve. You need only specify pattern names and provide a one-sentence description

for each pattern.12.7.Find five patterns repositories and present an abbreviated description of the types ofpatterns contained in each.
12.8.When Christopher Alexander says Ògood design cannot be achieved simply by addingtogether performing parts,Ó what do you think he means?
12.9.Using the pattern-based design tasks noted in Section 12.2.3, develop a skeletal designfor the Òinterior design systemÓ described in Section 11.3.2.
12.10.Build a pattern-organizing table for the patterns you used in Problem 12.9.12.11.Using the design pattern template presented in Section 12.1.3, develop a completepattern description for the Kitchen
pattern mentioned in Section 12.3.12.12.The gang of four [Gam95] have proposed a variety of component patterns that areapplicable to object-oriented systems. Select one (these are available on the Web) and
discussit.
12.13.Find three patterns repositories for user interface patterns. Select one pattern from eachand present an abbreviated description of it.
12.14.Find three patterns repositories for WebApp patterns. Select one pattern from each and
present an abbreviated description of it.CHAPTER 12PATTERN-BASED DESIGN371pre75977_ch12.qxd  11/27/08  3:58 PM  Page 371
FURTHER
READINGAND
INFORMATION
SOURCESOver the past decade, many books on pattern-based design have been written for software
engineers. Gamma and his colleagues [Gam95] have written the seminal book on the subject.
More recent contributions include books by Lasater (Design Patterns,
Wordware Publishing, Inc.,
2007), Holzner (Design Patterns for Dummies,
For Dummies, 2006), Freeman and her colleagues(Head First Design Patterns,
OÕReilly Media, Inc., 2005), and Shalloway and Trott (
Design Patterns
Explained,2d. ed., Addison-Wesley, 2004). A special issues of 
IEEE Software(July/August, 2007)
discusses a wide variety of software patterns topics. Kent Beck (
Implementation Patterns,

Addison-Wesley, 2008) addresses patterns for coding and implementation issues that are

encountered during the construction activity.
Other books focus on design patterns as they are supplied in specific application develop-ment and language environments. Contributions in this area include: Bowers (
Pro CSS and
HTML Design Patterns,
Apress, 2007), Tropashko and Burleson (
SQL Design Patterns: Expert Guide
to SQL Programming,
Rampant Techpress, 2007), Mahemoff (
Ajax Design Patterns,
OÕReillyMedia, Inc., 2006), Metsker and Wake (
Design Patterns in Java,
Addison-Wesley, 2006), Nilsson
(Applying Domain-Driven Design and Patterns: With Examples in C# and .NET,
Addison-Wesley,
2006), Sweat (PHPArchitectÕs Guide to PHP Design Patterns,
Marco Tabini & Associates, Inc.,
2005), Metsker (Design Patterns C#,
Addison-Wesley, 2004), Grand and Merrill (
Visual Basic .NET
Design Patterns,
Wiley, 2003), Crawford and Kaplan (
J2EE Design Patterns,
OÕReilly Media, Inc.,2003), Juric et al. (J2EE Design Patterns Applied,
Wrox Press, 2002), and Marinescu and Roman(EJB Design Patterns,
Wiley, 2002).
Still other books address specific application domains. These include contributions byKuchana (
Software Architecture Design Patterns in Java,
Auerbach, 2004), Joshi (
CDesignPatterns and Derivatives Pricing,
Cambridge University Press, 2004), Douglass (Real-Time Design
Patterns,
Addison-Wesley, 2002), and Schmidt and Rising (
Design Patterns in Communication
Software,Cambridge University Press, 2001).Classic books by the architect Christopher Alexander (Notes on the Synthesis of Form,HarvardUniversity Press, 1964, and A Pattern Language: Towns, Buildings, Construction,
Oxford Univer-sity Press, 1977) are worthwhile reading for a software designer who intends to fully understand
design patterns.A wide variety of information sources on pattern-based design are available on the Internet.An up-to-date list of World Wide Web references that are relevant to pattern-based design can

be found at the SEPA website: 
www.mhhe.com/engcs/compsci/pressman/professional/
olc/ser.htm
.372PART TWOMODELINGpre75977_ch12.qxd  11/27/08  3:58 PM  Page 372
In his authoritative book on Web design, Jakob Nielsen [Nie00] states: ÒThere
are essentially two basic approaches to design: the artistic ideal of expressing
yourself and the engineering ideal of solving a problem for a customer.Ó Dur-
ing the first decade of Web development, the artistic idea was the approach that

many developers chose. Design occurred in an ad hoc manner and was usually
conducted as HTML was generated. Design evolved out of an artistic vision that
evolved as WebApp construction occurred.
Even today, many Web developers use WebApps as poster children for Òlimited
design.Ó They argue that WebApp immediacy and volatility mitigate against

formal design; that design evolves as an application is built (coded), and that
relatively little time should be spent on creating a detailed design model. This
argument has merit, but only for relatively simple WebApps. When content and
373CHAPTER13WEBAPPDESIGNWhat is it?Design for WebApps
encompasses technical and nontech-nical activities that include: establish-
ing the look and feel of the WebApp,
creating the aesthetic layout of the user inter-
face, defining the overall architectural structure,
developing the content and functionality that
reside within the architecture, and planning the
navigation that occurs within the WebApp.
Who does it?Web engineers, graphic designers,
content developers, and other stakeholders all
participate in the creation of a WebApp design

model.Why is it important?
Design allows you to createa model that can be assessed for quality and
improved before content and code are gener-
ated, tests are conducted, and end users become
involved in large numbers. Design is the place
where WebApp quality is established.
Whatarethesteps?
WebAppdesignencom-
passessixmajorstepsthataredrivenbyinforma-

tionobtainedduringrequirementsmodeling.

Contentdesignusesthecontentmodel(developed

duringanalysis)asthebasisforestablishing
QUICKLOOKthedesign of content objects. Aesthetic design

(also called graphic design) establishes the look
and feel that the end user sees. Architectural
design focuses on the overall hypermedia struc-

ture of all content objects and functions.
Interface design establishes the layout and inter-

action mechanisms that define the user interface.

Navigation design defines how the end user
navigates through the hypermedia structure,

and component design represents the detailed
internal structure of functional elements of the

WebApp.
What is the work product?
A design model thatencompasses content, aesthetics, architecture,
interface, navigation, and component-level de-

sign issues is the primary work product that is

produced during WebApp design.
How do I ensure that IÕve done it right?Eachelement of the design model is reviewed in an
effort to uncover errors, inconsistencies, or omis-

sions. In addition, alternative solutions are con-

sidered, and the degree to which the current
design model will lead to an effective implemen-

tation is also assessed.KEYCONCEPTScontentarchitecture . . .384
objects . . . . . . .382
designaesthetic . . . . .380
architectural . . .383

component-level . . . . . . . .390
content . . . . . .382

goals . . . . . . . .377

graphic . . . . . . .381

navigation . . . .388
pre75977_ch13.qxd  11/27/08  5:47 PM  Page 373
function are complex; when the size of the WebApp encompasses hundreds or thou-
sands of content objects, functions, and analysis classes; and when the success of
the WebApp will have a direct impact on the success of the business, design cannot

and should not be taken lightly.
This reality leads us to NielsenÕs second approachÑÒthe engineering ideal of solv-
ing a problem for a customer.Ó Web engineering
1adopts this philosophy, and a more
rigorous approach to WebApp design enables developers to achieve it.
374PART TWOMODELINGpyramid . . . . . .378
quality . . . . . . .374
MVCarchitecture . . . .386
OOHDM . . . . . . .390

WebApp
architecture . . . .386
1Web engineering[Pre08] is an adapted version of the software engineering approach that is pre-sented throughout this book. It proposes an agile, yet disciplined framework for building industry-quality Web-based systems and applications.2These quality attributes are quite similar to those presented in Chapters 8 and 14. The implication:
quality characteristics are universal for all software.13.1W
EBAPPDESIGNQUALITYDesign is the engineering activity that leads to a high-quality product. This leads usto a recurring question that is encountered in all engineering disciplines: What
isquality? In this section IÕll examine the answer within the context of WebApp

development.Every person who has surfed the Web or used a corporate Intranet has an opin-
ion about what makes a ÒgoodÓ WebApp. Individual viewpoints vary widely. Some

users enjoy flashy graphics; others want simple text. Some demand copious
information; others desire an abbreviated presentation. Some like sophisticated an-
alytical tools or database access; others like to keep it simple. In fact, the userÕs per-

ception of ÒgoodnessÓ (and the resultant acceptance or rejection of the WebApp as a

consequence) might be more important than any technical discussion of WebApp

quality.
But how is WebApp quality perceived? What attributes must be exhibited to
achieve goodness in the eyes of end users and at the same time exhibit the techni-
cal characteristics of quality that will enable you to correct, adapt, enhance, and sup-

port the application over the long term?
Inreality,allofthetechnicalcharacteristicsofdesignqualitydiscussedinChapter8
and the generic quality attributes presented in Chapter 14 apply to WebApps. How-

ever, the most relevant of these generic attributesÑusability, functionality, reliabil-

ity, efficiency, and maintainabilityÑprovide a useful basis for assessing the quality of

Web-based systems.
Olsina and his colleagues [Ols99] have prepared a Òquality requirement treeÓ thatidentifies a set of technical attributesÑusability, functionality, reliability, efficiency,

and maintainabilityÑthat lead to high-quality WebApps.
2Figure 13.1summarizes
their work. The criteria noted in the figure are of particular interest if you design,
build, and maintain WebApps over the long term.
uote:ÒIf products aredesigned to better
fit the natural
tendencies of
human behavior,

then people will
bemore satisfied,

more fulfilled, and
more productive.ÓSusanWeinschenk
pre75977_ch13.qxd  11/27/08  5:47 PM  Page 374
Offutt [Off02] extends the five major quality attributes noted in Figure 13.1by
adding the following attributes:Security.
WebApps have become heavily integrated with critical corporate and
government databases. E-commerce applications extract and then store sensitive
customer information. For these and many other reasons, WebApp security is para-

mount in many situations. The key measure of security is the ability of the WebApp

and its server environment to rebuff unauthorized access and/or thwart an outright

malevolent attack. A detailed discussion of WebApp security is beyond the scope of

this book. If you have further interest, see [Vac06], [Kiz05], or [Kal03].
Availability.
Even the best WebApp will not meet usersÕ needs if it is unavailable.
In a technical sense, availability is the measure of the percentage of time that a
WebApp is available for use. The typical end user expects WebApps to be available

24/7/365. Anything less is deemed unacceptable.3But Òup-timeÓ is not the only in-dicator of availability. Offutt [Off02] suggests that Òusing features available on only

one browser or one platformÓ makes the WebApp unavailable to those with a differ-

ent browser/platform configuration. The user will invariably go elsewhere.
Scalability.
CantheWebAppanditsserverenvironmentbescaledtohandle100,
1000,10,000,or100,000users?WilltheWebAppandthesystemswithwhichitis
interfacedhandlesignificantvariationinvolumeorwillresponsivenessdropdra-

matically(orceasealtogether)?ItisnotenoughtobuildaWebAppthatissuccessful.

It is equally important to build a WebApp that can accommodate the burden of suc-

cess (significantly more end users) and become even more successful.CHAPTER 13WEBAPP DESIGN375Web
applicationqualityUsabilityGlobal site understandabilityOnline feedback and help featuresInterface and aesthetic features

Special featuresSearching and retrieving capabilityNavigation and browsing featuresApplication domain-related featuresCorrect link processingError recovery
User input validation and recovery
Ease of correctionAdaptabilityExtensibilityResponse time performance
Page generation speedGraphics generation speedFunctionalityReliabilityEfficiencyMaintainabilityFIGURE13.1Qualityrequirements

tree.

Source:[Ols99].What arethemajor
attributes of
quality for
WebApps?
?3This expectation is, of course, unrealistic. Major WebApps must schedule ÒdowntimeÓ for fixes and
upgrades.pre75977_ch13.qxd  11/27/08  5:47 PM  Page 375
Time-to-market.
Although time-to-market is not a true quality attribute in thetechnical sense, it is a measure of quality from a business point of view. The first
WebApp to address a specific market segment often captures a disproportionate

number of end users.376PART TWOMODELINGThe following checklist, adapted frominformation presented at 
Webreference.com
,provides a set of questions that will help both Web
designers and end users assess overall WebApp quality:
¥Can content and/or function and/or navigation optionsbe tailored to the userÕs preferences?
¥Can content and/or functionality be customized to the
bandwidth at which the user communicates?¥Have graphics and other nontext media been used
appropriately? Are graphics file sizes optimized for
display efficiency?
¥Are tables organized and sized in a manner that makes
them understandable and displayed efficiently?
¥Is HTML optimized to eliminate inefficiencies?
¥Is the overall page design easy to read and navigate?¥Do all pointers provide links to information that is of

interest to users?¥Is it likely that most links have persistence on the 
Web?
¥Is the WebApp instrumented with site management

utilities that include tools for usage tracking, link testing,
local searching, and security?INFOWebApp DesignÑQuality Checklist
BillionsofWebpagesareavailableforthoseinsearchofinformation.Evenwell-
targetedWebsearchesresultinanavalancheofcontent.Withsomanysources
ofinformationtochoosefrom,howdoestheuserassessthequality(e.g.,veracity,

accuracy,completeness,timeliness)ofthecontentthatispresentedwithinaWebApp?

Tillman[Til00]suggestsausefulsetofcriteriaforassessingthequalityofcontent:
¥Can the scope and depth of content be easily determined to ensure that it
meets the userÕs needs?
¥Can the background and authority of the contentÕs authors be easily identified?
¥Is it possible to determine the currency of the content, the last update, and

what was updated?¥Are the content and its location stable (i.e., will they remain at the referenced
URL)?In addition to these content-related questions, the following might be added:¥Is content credible?¥Is content unique? That is, does the WebApp provide some unique benefit to

those who use it?¥Is content valuable to the targeted user community?¥Is content well organized? Indexed? Easily accessible?The checklists noted in this section represent only a small sampling of the issues that
should be addressed as the design of a WebApp evolves.
What shouldwe considerwhen assessing
content quality??pre75977_ch13.qxd  11/27/08  5:47 PM  Page 376
13.2D
ESIGNGOALSIn her regular column on Web design, Jean Kaiser [Kai02] suggests a set of design
goals that are applicable to virtually every WebApp regardless of application domain,

size, or complexity:
Simplicity.
Although it may seem old-fashioned, the aphorism Òall things in mod-erationÓ applies to WebApps. There is a tendency among some designers to provide
the end user with Òtoo muchÓÑexhaustive content, extreme visuals, intrusive ani-
mation, enormous Web pages, the list is long. Better to strive for moderation and

simplicity.
Contentshouldbeinformativebutsuccinctandshoulduseadeliverymode
(e.g.,text,graphics,video,audio)thatisappropriatetotheinformationthatisbeing

delivered.Aestheticsshouldbepleasing,butnotoverwhelming(e.g.,toomanycolors

tendtodistracttheuserratherthanenhancingtheinteraction).Architectureshould

achieveWebAppobjectivesinthesimplestpossiblemanner.Navigationshouldbe

straightforwardandnavigationmechanismsshouldbeintuitivelyobvioustotheend

user.Functionsshouldbeeasytouseandeasiertounderstand.
Consistency.
This design goal applies to virtually every element of the designmodel. Content should be constructed consistently (e.g., text formatting and fontstyles should be the same across all text documents; graphic art should have a con-
sistent look, color scheme, and style). Graphic design (aesthetics) should present a

consistent look across all parts of the WebApp. Architectural design should establish

templates that lead to a consistent hypermedia structure. Interface design should de-
fine consistent modes of interaction, navigation, and content display. Navigation

mechanisms should be used consistently across all WebApp elements. As Kaiser

[Kai02] notes: ÒRemember that to a visitor, a Web site is a physical place. It is con-

fusing if pages within a site are not consistent in design.ÒIdentity.
The aesthetic, interface, and navigational design of a WebApp must be
consistent with the application domain for which it is to be built. A website for a hip-hop group will undoubtedly have a different look and feel than a WebApp designed

for a financial services company. The WebApp architecture will be entirely different,

interfaces will be constructed to accommodate different categories of users; naviga-
tion will be organized to accomplish different objectives. You (and other design con-

tributors) should work to establish an identity for the WebApp through the design.
Robustness.Based on the identity that has been established, a WebApp often
makes an implicit ÒpromiseÓ to a user. The user expects robust content and functions
that are relevant to the userÕs needs. If these elements are missing or insufficient, it

is likely that the WebApp will fail.
Navigability.
I have already noted that navigation should be simple and consis-tent. It should also be designed in a manner that is intuitive and predictable. That is,CHAPTER 13WEBAPP DESIGN377uote:ÒJust because youcan, doesnÕt meanyou should.ÓJeanKaiser
uote:ÒTo some, Web
design focuses on
visual look and
feel. . . To others,

Web design is

aboutstructuring

information and
navigation through
the document
space. Others might
even consider Web

design to be about
the technology...

Inreality, design

includes all of these
things and maybe
more.ÓThomasPowell
pre75977_ch13.qxd  11/27/08  5:47 PM  Page 377
the user should understand how to move about the WebApp without having to
search for navigation links or instructions. For example, if a field of graphic icons or

images contains selected icons or images that will be used as navigation mecha-
nisms, these must be identified visually. Nothing is more frustrating than trying to

find the appropriate live link among many graphical images.It is also important to position links to major WebApp content and functions in a
predictable location on every Web page. If page scrolling is required (and this is often

the case), links at the top and bottom of the page make the userÕs navigation tasks

easier.
Visual Appeal.
Of all software categories, Web applications are unquestionably
the most visual, the most dynamic, and the most unapologetically aesthetic. Beauty
(visual appeal) is undoubtedly in the eye of the beholder, but many design charac-

teristics (e.g., the look and feel of content; interface layout; color coordination; the
balance of text, graphics, and other media; navigation mechanisms) do contribute to
visual appeal.Compatibility.
A WebApp will be used in a variety of environments (e.g., different
hardware, Internet connection types, operating systems, browsers) and must be
designed to be compatible with each.13.3A D
ESIGNPYRAMIDFOR
WEBAPPSWhat is WebApp design? This simple question is more difficult to answer than one

might believe. In our book [Pre08] on Web engineering, David Lowe and I discuss this

when we write:The creation of an effective design will typically require a diverse set of skills. Sometimes,for small projects, a single developer may need to be multi-skilled. For larger projects, it
may be advisable and/or feasible to draw on the expertise of specialists: Web engineers,

graphic designers, content developers, programmers, database specialists, information
architects, network engineers, security experts, and testers. Drawing on these diverse

skills allows the creation of a model that can be assessed for quality and improved 
beforecontent and code are generated, tests are conducted, and end-users become involved in

large numbers. If analysis is where WebApp quality is established,
then design is where thequality is truly embedded.The appropriate mix of design skills will vary depending upon the nature of theWebApp. Figure 13.2depicts a design pyramid for WebApps. Each level of the pyra-

mid represents a design action that is described in the sections that follow.
13.4W
EBAPPINTERFACE
DESIGNWhen a user interacts with a computer-based system, a set of fundamental
principlesand overriding design guidelines apply. These have been discussed in
378PART TWOMODELINGuote:ÒIf a site isperfectly usable
but it lacks an
elegant and
appropriate design
style, it will fail.ÓCurtCloninger
pre75977_ch13.qxd  11/27/08  5:47 PM  Page 378
Chapter 11.4Although WebApps present a few special user interface design chal-
lenges, the basic principles and guidelines are applicable.One of the challenges of interface design for WebApps is the indeterminate nature
of the userÕs entry point. That is, the user may enter the WebApp at a ÒhomeÓ loca-
tion (e.g., the home page) or may be linked into some lower level of the WebApp

architecture. In some cases, the WebApp can be designed in a way that reroutes the

user to a home location, but if this is undesirable, the WebApp design must provide

interface navigation features that accompany all content objects and are available
regardless of how the user enters the system.The objectives of a WebApp interface are to: (1) establish a consistent window
into the content and functionality provided by the interface, (2) guide the user

through a series of interactions with the WebApp, and (3) organize the navigation

options and content available to the user. To achieve a consistent interface, you

should first use aesthetic design (Section 13.5) to establish a coherent Òlook.Ó This
encompasses many characteristics, but must emphasize the layout and form of nav-
igation mechanisms. To guide user interaction, you may draw on an appropriate

metaphor5that enables the user to gain an intuitive understanding of the interface.To implement navigation options, you can select from one of a number of interac-

tion mechanisms:¥Navigation menus
Ñkeyword menus (organized vertically or horizontally) that
list key content and/or functionality. These menus may be implemented so
CHAPTER 13WEBAPP DESIGN379Interface
designAesthetic designContent designNavigation designArchitecture designComponent designusertechnologyFIGURE13.2A designpyramid for
WebApps
4Section 11.5 is dedicated to WebApp interface design. If you have not already done so, read it at
this time.5In this context, a 
metaphoris a representation (drawn from the userÕs real-world experience) thatcan be modeled within the context of the interface. A simple example might be a slider switch thatis used to control the auditory volume of an .mpg file.pre75977_ch13.qxd  11/27/08  5:47 PM  Page 379
that the user can choose from a hierarchy of subtopics that is displayed whenthe primary menu option is selected.¥Graphic icons
Ñbutton, switches, and similar graphical images that enable the
user to select some property or specify a decision.¥Graphic images
Ñsome graphical representation that is selectable by the user
and implements a link to a content object or WebApp functionality.
It is important to note that one or more of these control mechanisms should be
provided at every level of the content hierarchy.
13.5A
ESTHETICDESIGNAesthetic design, also called graphic design,
is an artistic endeavor that complementsthe technical aspects of WebApp design. Without it, a WebApp may be functional, but

unappealing. With it, a WebApp draws its users into a world that embraces them on

a visceral, as well as an intellectual level.But what is aesthetic? There is an old saying, Òbeauty exists in the eye of the be-holder.Ó This is particularly appropriate when aesthetic design for WebApps is con-

sidered. To perform effective aesthetic design, return to the user hierarchy developed

as part of the requirements model (Chapter 5) and ask, Who are the WebAppÕs users

and what ÒlookÓ do they desire?13.5.1Layout Issues
EveryWebpagehasalimitedamountofÒrealestateÓthatcanbeusedtosupportnon-

functionalaesthetics,navigationfeatures,informationalcontent,anduser-directed

functionality.Thedevelopmentofthisrealestateisplannedduringaestheticdesign.
Like all aesthetic issues, there are no absolute rules when screen layout is de-signed. However, a number of general layout guidelines are worth considering:
DonÕt be afraid of white space.
It is inadvisable to pack every squareinch of a Web page with information. The resulting clutter makes it difficult

for the user to identify needed information or features and create visual
chaos that is not pleasing to the eye.Emphasize content.After all, thatÕs the reason the user is there. Nielsen
[Nie00] suggests that the typical Web page should be 80 percent content with
the remaining real estate dedicated to navigation and other features.Organize layout elements from top-left to bottom-right.
The vastmajority of users will scan a Web page in much the same way as they scan
the page of a bookÑtop-left to bottom-right.6If layout elements have specific380PART TWOMODELINGWhatinteractionmechanisms are
available to
WebApp

designers??Not every Web

engineer (orsoftware engineer) has
artistic (aesthetic)

talent. If you fall into
this category, hire an

experienced graphic
designer for aesthetic
design work.?uote:ÒWe find that

people quickly
evaluate a site by
visual design
alone.ÓStanfordGuidelinesfor

Web Credibility
6There are exceptions that are cultural and language-based, but this rule does hold for most users.
pre75977_ch13.qxd  11/27/08  5:47 PM  Page 380
priorities, high-priority elements should be placed in the upper-left portion ofthe page real estate.Group navigation, content, and function geographically within the
page.Humans look for patterns in virtually all things. If there are no dis-cernable patterns within a Web page, user frustration is likely to increase

(due to unnecessary searching for needed information).DonÕt extend your real estate with the scrolling bar.
Although scroll-ing is often necessary, most studies indicate that users would prefer not to
scroll. It is better to reduce page content or to present necessary content on
multiple pages.Consider resolution and browser window size when designing layout.
Rather than defining fixed sizes within a layout, the design should specify all
layout items as a percentage of available space [Nie00].13.5.2Graphic Design Issues
Graphic design considers every aspect of the look and feel of a WebApp. The

graphic design process begins with layout (Section 13.5.1) and proceeds into a con-
sideration of global color schemes; text types, sizes, and styles; the use of supple-
mentary media (e.g., audio, video, animation); and all other aesthetic elements of
an application.AcomprehensivediscussionofgraphicdesignissuesforWebAppsisbeyondthescope
ofthisbook.Youcanobtaindesigntipsandguidelinesfrommanywebsitesthatare

dedicatedtothesubject(e.g.,
www.graphic-design.com
,www.grantasticdesigns
.com, www.wpdfd.com
) or from one or more print resources (e.g., [Roc06] and[Gor02]).CHAPTER 13WEBAPP DESIGN381Well-Designed Websites
Sometimes, the best way to understand goodWebApp design is to look at a few examples. In
his article, ÒThe Top Twenty Web Design Tips,Ó Marcelle
Toor (
www.graphic-design.com/Web/feature/

tips.html) suggests the following websites as examples of
good graphic design:www.creativepro.com/designresource/home/
787.htmlÑa design firm headed by Primo Angeli
www.workbook.com
Ñthis site showcases work byillustrators and designerswww.pbs.org/riverofsong
Ña television series forpublic TV and radio about American musicwww.RKDINC.com
Ña design firm with online
portfolio and good design tips
www.creativehotlist.com/index.html
Ña goodsource for well-designed sites developed by adagencies, graphics arts firms, and other

communications specialistswww.btdnyc.com
Ña design firm headed by Beth
Toudreau
INFOUsers tend to toleratevertical scrolling more

readily than horizontal
scrolling. Avoid wide

page formats.
pre75977_ch13.qxd  11/27/08  5:47 PM  Page 381
13.6C
ONTENTDESIGNContentdesignfocusesontwodifferentdesigntasks,eachaddressedbyindividuals
withdifferentskillsets.First,adesignrepresentationforcontentobjectsandthemech-

anismsrequiredtoestablishtheirrelationshiptooneanotherisdeveloped.Inaddition,

theinformationwithinaspecificcontentobjectiscreated.Thelattertaskmaybecon-

ductedbycopywriters,graphicdesigners,andotherswhogeneratethecontenttobe

usedwithinaWebApp.
13.6.1Content Objects
The relationship between content objects defined as part of a requirements model
for the WebApp and design objects representing content is analogous to the rela-

tionship between analysis classes and design components described in earlier chap-
ters. In the context of WebApp design, a content object is more closely aligned with

a data object for traditional software. A content object has attributes that include
content-specific information (normally defined during WebApp requirements mod-

eling) and implementation-specific attributes that are specified as part of design.Asanexample,considerananalysisclass,
ProductComponent,
developedfor
theSafeHomee-commercesystem.Theanalysisclassattribute,
description,isrepre-
sentedasadesignclassnamed
CompDescriptioncomposedoffivecontentobjects:
MarketingDescription,Photograph,TechDescription,Schematic,
andVideo
shownasshadedobjectsnotedinFigure13.3.Informationcontainedwithinthecon-

tentobjectisnotedasattributes.Forexample,
Photograph
(a.jpgimage)hastheat-
tributeshorizontaldimension,verticaldimension,
andborderstyle.
UMLassociationandanaggregation
7maybeusedtorepresentrelationships
betweencontentobjects.Forexample,theUMLassociationshowninFigure13.3

indicatesthatone
CompDescriptionisusedforeachinstanceofthe
ProductComponent
class.CompDescriptioniscomposedonthefivecontentob-
jectsshown.However,themultiplicitynotationshownindicatesthat
Schematic
andVideo
areoptional(0occurrencesarepossible),one
MarketingDescription
andone
TechDescription
arerequired,andoneormoreinstancesof
Photograph
areused.
13.6.2Content Design Issues
Once all content objects are modeled, the information that each object is to deliver
must be authored and then formatted to best meet the customerÕs needs. Content au-

thoring is the job of specialists in the relevant area who design the content object by
providing an outline of information to be delivered and an indication of the types of

generic content objects (e.g., descriptive text, graphic images, photographs) that will
be used to deliver the information. Aesthetic design (Section 13.5) may also be
applied to represent the proper look and feel for the content.382PART TWOMODELINGuote:ÒGood designerscan create
normalcy out
ofchaos; they

canclearly

communicate ideas
through the
organizing and
manipulating of
words and
pictures.ÓJefferyVeen
7Both of these representations are discussed in Appendix 1.
pre75977_ch13.qxd  11/27/08  5:47 PM  Page 382
As content objects are designed, they are ÒchunkedÓ [Pow02] to form WebApp
pages. The number of content objects incorporated into a single page is a functionof user needs, constraints imposed by download speed of the Internet connection,
and restrictions imposed by the amount of scrolling that the user will tolerate.13.7A
RCHITECTUREDESIGNArchitecture design is tied to the goals established for a WebApp, the content to be

presented, the users who will visit, and the navigation philosophy that has been
established. As an architectural designer, you must identify content architecture and

WebApp architecture. 
Content architecture
8focuses on the manner in which contentobjects (or composite objects such as Web pages) are structured for presentation and

navigation. WebApp architecture
addresses the manner in which the application isstructured to manage user interaction, handle internal processing tasks, effect nav-
igation, and present content.In most cases, architecture design is conducted in parallel with interface design,aesthetic design, and content design. Because the WebApp architecture may have a
CHAPTER 13WEBAPP DESIGN383ProductComponentpartNumber
partName

partType

description
pricecreateNewItem( )displayDescription( )
display TechSpec
MarketingDescriptiontext color
font style
font size
line spacing
text usage size
background colorPhotographhorizontal dimension
vertical dimension

border styleSchematichorizontal dimension
vertical dimension

border styleTechDescription
text color
font style
font size
line spacing
text image size
background colorVideo
horizontal dimension
vertical dimension

border style
audio volumeCompDescription1111Is part of
0..10..10..111..*SensorCameraControl PanelSoftFeatureFIGURE13.3Design repre-
sentation of
content objectsuote:Ò. . . thearchitectural
structure of a well
designed site is not
always apparent to
the userÑnor
should it be.ÓThomasPowell
8The term 
information architectureis also used to connote structures that lead to better organization,labeling, navigation, and searching of content objects.pre75977_ch13.qxd  11/27/08  5:47 PM  Page 383
strong influence on navigation, the decisions made during this design action willinfluence work conducted during navigation design.13.7.1Content Architecture
The design of content architecture focuses on the definition of the overall hyperme-

dia structure of the WebApp. Although custom architectures are sometimes created,

you always have the option of choosing from four different content structures
[Pow00]:Linear structures(Figure 13.4) are encountered when a predictable sequence of in-teractions (with some variation or diversion) is common. A classic example might be
a tutorial presentation in which pages of information along with related graphics,
short videos, or audio are presented only after prerequisite information has been
presented. The sequence of content presentation is predefined and generally linear.

Another example might be a product order entry sequence in which specific infor-
mation must be specified in a specific order. In such cases, the structures shown in

Figure 13.4are appropriate. As content and processing become more complex, the

purely linear flow shown on the left of the figure gives way to more sophisticated lin-
ear structures in which alternative content may be invoked or a diversion to acquire

complementary content (structure shown on the right side of Figure 13.4) occurs.Grid structures(Figure 13.5) are an architectural option that you can apply whenWebApp content can be organized categorically in two (or more) dimensions. For

example, consider a situation in which an e-commerce site sells golf clubs. The hori-

zontal dimension of the grid represents the type of club to be sold (e.g., woods, irons,
wedges, putters). The vertical dimension represents the offerings provided by vari-

ous golf club manufacturers. Hence, a user might navigate the grid horizontally to

find the putters column and then vertically to examine the offerings provided by
384PART TWOMODELINGWhat typesof contentarchitectures are
commonly
encountered??LinearLinearwithoptional flowLinearwithdiversionsFIGURE13.4Linear structures
pre75977_ch13.qxd  11/27/08  5:47 PM  Page 384
those manufacturers that sell putters. This WebApp architecture is useful only when
highly regular content is encountered [Pow00].Hierarchical structures
(Figure 13.6) are undoubtedly the most common WebApp
architecture. Unlike the partitioned software hierarchies discussed in Chapter 9 that
encourage flow of control only along vertical branches of the hierarchy, a WebApp

hierarchical structure can be designed in a manner that enables (via hypertext branch-
ing) flow of control horizontally across vertical branches of the structure. Hence, con-

tent presented on the far left-hand branch of the hierarchy can have hypertext links
that lead directly to content that exists in the middle or right-hand branch of the
structure. It should be noted, however, that although such branching allows rapid nav-

igation across WebApp content, it can lead to confusion on the part of the user.
A networked
or Òpure webÓ structure(Figure 13.7) is similar in many ways to thearchitecture that evolves for object-oriented systems. Architectural componentsCHAPTER 13WEBAPP DESIGN385FIGURE13.5Grid structure
FIGURE13.6Hierarchical
structure
pre75977_ch13.qxd  11/27/08  5:47 PM  Page 385
(inthis case, Web pages) are designed so that they may pass control (via hypertext
links) to virtually every other component in the system. This approach allows con-
siderable navigation flexibility, but at the same time, can be confusing to a user.
The architectural structures discussed in the preceding paragraphs can be com-bined to form composite structures.The overall architecture of a WebApp may be
hierarchical, but part of the structure may exhibit linear characteristics, while
another part of the architecture may be networked. Your goal as an architectural

designer is to match the WebApp structure to the content to be presented and the

processing to be conducted.13.7.2WebApp Architecture
WebApp architecture describes an infrastructure that enables a Web-based system or

application to achieve its business objectives. Jacyntho and his colleagues [Jac02b]
describe the basic characteristics of this infrastructure in the following manner:Applications should be built using layers in which different concerns are taken intoaccount; in particular, application data should be separated from the pageÕs contents

(navigation nodes) and these contents, in turn, should be clearly separated from the
interface look-and-feel (pages).The authors suggest a three-layer design architecture that decouples interface fromnavigation and from application behavior. They argue that keeping interface, appli-

cation, and navigation separate simplifies implementation and enhances reuse.The Model-View-Controller
(MVC) architecture [Kra88]9is one of a number ofsuggested WebApp infrastructure models that decouple the user interface from the
386PART TWOMODELINGFIGURE13.7Networkstructure
9It should be noted that MVC is actually an architectural design pattern developed for the Smalltalk
environment (see www.cetus-links.org/oo_smalltalk.html) and can be used for any interactiveapplication.pre75977_ch13.qxd  11/27/08  5:47 PM  Page 386
WebApp functionality and informational content. The 
model(sometimes referred toas the Òmodel objectÓ) contains all application-specific content and processing logic,
including all content objects, access to external data/information sources, and all
processing functionality that is application specific. The viewcontains all interface-specific functions and enables the presentation of content and processing logic, in-

cluding all content objects, access to external data/information sources, and all
processing functionality required by the end user. The 
controllermanages accesstothe model and the view and coordinates the flow of data between them. In a

WebApp, Òthe view is updated by the controller with data from the model based on

user inputÓ [WMT02]. A schematic representation of the MVC architecture is shown
in Figure 13.8.Referringtothefigure,userrequestsordataarehandledbythecontroller.Thecon-
trolleralsoselectstheviewobjectthatisapplicablebasedontheuserrequest.Once

thetypeofrequestisdetermined,abehaviorrequestistransmittedtothemodel,

whichimplementsthefunctionalityorretrievesthecontentrequiredtoaccommodate

therequest.Themodelobjectcanaccessdatastoredinacorporatedatabase,aspart

ofalocaldatastore,orasacollectionofindependentfiles.Thedatadevelopedbythe

modelmustbeformattedandorganizedbytheappropriateviewobjectandthen

transmittedfromtheapplicationserverbacktotheclient-basedbrowserfordisplay

onthecustomerÕsmachine.
In many cases, WebApp architecture is defined within the context of the develop-
ment environment in which the application is to be implemented. If you have further

interest, see [Fow03] for a discussion of development environments and their role in

the design of Web application architectures.
CHAPTER 13WEBAPP DESIGN387The MVC architecturedecouples the user
interface from WebApp

functionality and
information content.
BrowserClientHTML dataUserrequestor dataController
Manages user requests
Selects model behavior
Selects view responseView

Prepares data from model
Request updates from model
Presents view selected by
controllerModel
Encapsulates functionality
Encapsulates content objects
Incorporates all WebApp states
View selection
Behavior request(state change)Update requestServer
External data
Data frommodelFIGURE13.8The MVCArchitecture

Source:Adapted from[Jac02].pre75977_ch13.qxd  11/27/08  5:47 PM  Page 387
13.8N
AVIGATION
DESIGNOnce the WebApp architecture has been established and the components (pages,
scripts, applets, and other processing functions) of the architecture have been iden-
tified, you must define navigation pathways that enable users to access WebApp

content and functions. To accomplish this, you should (1) identify the semantics of

navigation for different users of the site, and (2) define the mechanics (syntax) of

achieving the navigation.13.8.1Navigation Semantics
Like many WebApp design actions, navigation design begins with a consideration of

the user hierarchy and related use cases (Chapter 5) developed for each category
ofuser (actor). Each actor may use the WebApp somewhat differently and therefore

have different navigation requirements. In addition, the use cases developed for
each actor will define a set of classes that encompass one or more content objects
or WebApp functions. As each user interacts with the WebApp, she encounters a

series of navigation semantic units(NSUs)ÑÒa set of information and related naviga-tion structures that collaborate in the fulfillment of a subset of related user
requirementsÓ [Cac02].An NSU is composed of a set of navigation elements called ways of navigating(WoN) [Gna99]. A WoN represents the best navigation pathway to achieve a naviga-

tional goal for a specific type of user. Each WoN is organized as a set of 
navigationalnodes(NN) that are connected by navigational links. In some cases, a navigationallink may be another NSU. Therefore, the overall navigation structure for a WebApp

may be organized as a hierarchy of NSUs.To illustrate the development of an NSU, consider the use case 
Select SafeHome
Components:Use Case: Select SafeHome Components
The WebApp will recommend product components
(e.g., control panels, sensors, cam-eras) and other features (e.g., PC-based functionality implemented in software) for eachroomand exterior entrance. If I request alternatives, the WebApp will provide them, if
they exist. I will be able to getdescriptive and pricing information
for each productcomponent. The WebApp will create and display a bill-of-materials
as I select variouscomponents. IÕll be able to give the bill-of-materials a name and save it for future
reference (see use case Save Configuration
).Theunderlineditemsintheuse-casedescriptionrepresentclassesandcontentobjects
thatwillbeincorporatedintooneormoreNSUsthatwillenableanewcustomerto

performthescenariodescribedinthe
SelectSafeHomeComponents
usecase.
Figure 13.9depicts a partial semantic analysis of the navigation implied by
theSelect SafeHome Components
use case. Using the terminology intro-ducedearlier, the figure also represents a way of navigating (WoN) for the
388PART TWOMODELINGuote:ÒJust wait, Gretel,until the moon
rises, and then we
shall see the
crumbs of bread
which I have
strewn about, they
will show us our
way home again.ÓHansel andGretelAn NSU describesthenavigation

requirements for each
use case. In essence,
the NSU shows how
an actor moves
between content
objects or WebApp

functions.pre75977_ch13.qxd  11/27/08  5:47 PM  Page 388
SafeHomeAssured.comWebApp. Important problem domain classes are shown
along with selected content objects (in this case the package of content objectsnamed CompDescription,an attribute of the ProductComponent
class). These itemsare navigation nodes. Each of the arrows represents a navigation link10and islabeled with the user-initiated action that causes the link to occur.
You can create an NSU for each use case associated with each user role. For
example, a 
new customerfor SafeHomeAssured.commay have three differentuse cases, all resulting in access to different information and WebApp functions. An

NSU is created for each goal.During the initial stages of navigation design, the WebApp content architecture is
assessed to determine one or more WoN for each use case. As noted earlier, a WoN

identifies navigation nodes (e.g., content) and then links that enable navigation
between them. The WoN are then organized into NSUs.
13.8.2Navigation Syntax
As design proceeds, your next task is to define the mechanics of navigation. A num-
ber of options are available as you develop an approach for implementing each NSU:¥Individual navigation linkÑincludes text-based links, icons, buttons and
switches, and graphical metaphors. You must choose navigation links that

are appropriate for the content and consistent with the heuristics that lead to
high-quality interface design.¥Horizontal navigation barÑlists major content or functional categories in a
bar containing appropriate links. In general, between four and seven cate-
gories are listed.CHAPTER 13WEBAPP DESIGN389<<navigation link>>select Room<<navigation link>>view BillOfMaterials<<navigation link>>return to Room
<<navigation link>>purchase ProductComponent<<navigation link>>recommend component(s)<<navigation link>>request alternative
<<navigation link>>show ProductComponent<<navigation link>>show description<<navigation link>>purchase ProductComponentRoomBillOfMaterialsProductComponentCompDescriptiontechDescriptionphotographschematicvideoMarketingDescriptionFIGURE13.9Creating an
NSUuote:ÓThe problem ofWeb site navigation

is conceptual,
technical, spatial,
philosophical and
logistic.
Consequently,

solutions tend to
call for complex
improvisational
combinations of
art, science and
organizational
psychology.Ó
TimHorgan
10These are sometimes referred to as 
navigation semantic links(NSL) [Cac02].In most situations,choose either hori-
zontal or vertical navi-

gation mechanisms,
but not both.pre75977_ch13.qxd  11/27/08  5:47 PM  Page 389
¥Vertical navigation columnÑ
(1) lists major content or functional categories, or(2) lists virtually all major content objects within the WebApp. If you choose

the second option, such navigation columns can ÒexpandÓ to present content
objects as part of a hierarchy (i.e., selecting an entry in the original column
causes an expansion that lists a second layer of related content objects).¥TabsÑ
a metaphor that is nothing more than a variation of the navigation bar
or column, representing content or functional categories as tab sheets that
are selected when a link is required.¥Site mapsÑprovide an all-inclusive table of contents for navigation to all

content objects and functionality contained within the WebApp.
In addition to choosing the mechanics of navigation, you should also establishappropriate navigation conventions and aids. For example, icons and graphical links

should look ÒclickableÓ by beveling the edges to give the image a three-dimensional
look. Audio or visual feedback should be designed to provide the user with an indi-

cation that a navigation option has been chosen. For text-based navigation, color
should be used to indicate navigation links and to provide an indication of links

already traveled. These are but a few of dozens of design conventions that make

navigation user-friendly.
13.9C
OMPONENT-LEVELDESIGNModern WebApps deliver increasingly sophisticated processing functions that (1) per-

form localized processing to generate content and navigation capability in a dynamic
fashion, (2) provide computation or data processing capability that are appropriate for

the WebAppÕs business domain, (3) provide sophisticated database query and access,

and (4) establish data interfaces with external corporate systems. To achieve these

(and many other) capabilities, you must design and construct program components
that are identical in form to software components for traditional software.The design methods discussed in Chapter 10 apply to WebApp components
withlittle, if any, modification. The implementation environment, programming lan-

guages, and design patterns, frameworks, and software may vary somewhat, but the
overall design approach remains the same.
13.10O
BJECT-ORIENTEDHYPERMEDIADESIGNMETHOD(OOHDM)A number of design methods for Web applications have been proposed over the past

decade. To date, no single method has achieved dominance.
11In this section I pres-ent a brief overview of one of the most widely discussed WebApp design methodsÑ

OOHDM.390PART TWOMODELINGThe site map should beaccessible from every

page. The map itself
should be organized so
that the structure of

WebApp information is

readily apparent.11In fact, relatively few Web developers use a specific method when designing a WebApp. Hopefully,
this ad hoc approach to design will change as time passes.pre75977_ch13.qxd  11/27/08  5:47 PM  Page 390
Daniel Schwabe and his colleagues [Sch95, Sch98b] originally proposed theObject-Oriented Hypermedia Design Method(OOHDM), which is composed of fourdifferent design activities: conceptual design, navigational design, abstract inter-facedesign, and implementation. A summary of these design activities is shown in

Figure13.10and discussed briefly in the sections that follow.
13.10.1Conceptual Design for OOHDM
OOHDM conceptual designcreates a representation of the subsystems, classes, and re-lationships that define the application domain for the WebApp. UML may be used
12tocreate appropriate class diagrams, aggregations, and composite class representations,
collaboration diagrams, and other information that describes the application domain.AsasimpleexampleofOOHDMconceptualdesign,considerthe
SafeHomeAssured.come-commerce application. A partial Òconceptual schemaÓ is 
shown in Figure 13.11.The class diagrams, aggregations, and related information developed as part of
WebApp analysis are reused during conceptual design to represent relationships

between classes.13.10.2Navigational Design for OOHDM
Navigationaldesign
identifiesasetofÒobjectsÓthatarederivedfromtheclasses
definedinconceptualdesign.AseriesofÒnavigationalclassesÓorÒnodesÓare
CHAPTER 13WEBAPP DESIGN391Work products
Design mechanismsDesign concerns
Modeling semanticsof the application
domainClasses, subsystems,relationships, attributesClassification,composition,
aggregation,
generalization
specializationConceptual designNavigational designAbstract interface
designImplementationNodes links, access
structures, navigational
contexts, navigational
transformations
Mapping betweenconceptual and
navigation objectsTakes into account user
profile and task.
Emphasis on cognitive
aspects.Abstract interface

objects, responses to
external events,

transformations
Mapping betweennavigation and
perceptible objectsModeling perceptibleobjects, implementing
chosen metaphors.
Describe interface for

navigational objects.Executable
WebApp
Resourceprovided by
target
environmentCorrectness;application
performance;

completenessFIGURE13.10Summary of the OOHDM method.Source:Adapted from [Sch95].12OOHDM does not prescribe a specific notation; however, the use of UML is common when this
method is applied.pre75977_ch13.qxd  11/27/08  5:47 PM  Page 391
definedtoencapsulatetheseobjects.UMLmaybeusedtocreateappropriateuse
cases,statecharts,andsequencediagramsÑallrepresentationsthatassistyouin

betterunderstandingnavigationalrequirements.Inaddition,designpatternsfornav-

igationaldesignmaybeusedasthedesignisdeveloped.OOHDMusesapredefined

setofnavigationclassesÑnodes,links,anchors,andaccessstructures[Sch98b].

AccessstructuresaremoreelaborateandincludemechanismssuchasaWebApp

index,asitemap,oraguidedtour.
Once navigation classes are defined, OOHDM Òstructures the navigation space bygrouping navigation objects into sets called contextsÓ [Sch98b]. A contextincludes adescription of the local navigation structure, restriction imposed on the access of

content objects, and methods (operations) required to effect access of content
objects. A context template (analogous to CRC cards discussed in Chapter 6) is de-
veloped and may be used to track the navigation requirements of each category of
user through the various contexts defined in OOHDM. Doing this, specific navigation
paths (what we called WoN in Section 13.8.1) emerge.
13.10.3Abstract Interface Design and Implementation
The abstract interface design 
actionspecifies the interface objects that the user sees
as WebApp interaction occurs. A formal model of interface objects, called an 
abstract

data view(ADV), is used to represent the relationship between interface objects and
navigation objects, and the behavioral characteristics of interface objects.392PART TWOMODELINGProductComponentpartNumber
partName

partType

description
pricecreateNewItem( )getDescription( )
getTechSpec
BillOfMaterialsidentifier
BoMList
numberItems
priceTotal
addEntry( )
deleteEntry( )

editEntry( )

name( )
computePrice( )BoMItemquantity
partNumber

partName

partType

priceaddtoList( )deletefromList( )
getNextListEntry( )
OrderorderNumber
customerInfo
billOfMaterials
shippingInfo
billingInfoRoomroomName
dimensions
exteriorWindows

exteriorDoorsSensorCameraControl PanelSoftFeaturecustomer continuescomponent selectioncustomerrequests purchasecomponent recommendationrequestedcustomer selects componentFIGURE13.11Partial conceptual schema for SafeHomeAssured.compre75977_ch13.qxd  11/27/08  5:47 PM  Page 392
The ADV model defines a Òstatic layoutÓ [Sch98b] that represents the interface
metaphor and includes a representation of navigation objects within the interfaceand the specification of the interface objects (e.g., menus, buttons, icons) that assist
in navigation and interaction. In addition, the ADV model contains a behavioral

component (similar to the UML state diagram) that indicates how external events
Òtrigger navigation and which interface transformations occur when the user inter-
acts with the applicationÓ [Sch01a].TheOOHDM
implementationactivityrepresentsadesigniterationthatisspe-
cifictotheenvironmentinwhichtheWebAppwilloperate.Classes,navigation,

andtheinterfaceareeachcharacterizedinamannerthatcanbeconstructedfor

theclient-serverenvironment,operatingsystems,supportsoftware,program-

minglanguages,andotherenvironmentalcharacteristicsthatarerelevanttothe

problem.13.11S
UMMARYThe quality of a WebAppÑdefined in terms of usability, functionality, reliability, effi-

ciency, maintainability, security, scalability, and time-to-marketÑis introduced dur-

ing design. To achieve these quality attributes, a good WebApp design should exhibit

the following characteristics: simplicity, consistency, identity, robustness, navigabil-

ity, and visual appeal. To achieve these characteristics, the WebApp design activity

focuses on six different elements of the design.Interface design describes the structure and organization of the user interface andincludes a representation of screen layout, a definition of the modes of interaction,
and a description of navigation mechanisms. A set of interface design principles and
an interface design workflow guide you when layout and interface control mecha-
nisms are designed.Aesthetic design, also called graphic design, describes the Òlook and feelÓ of theWebApp and includes color schemes; geometric layout; text size, font, and place-

ment; the use of graphics; and related aesthetic decisions. A set of graphic design
guidelines provides the basis for a design approach.
Content design defines the layout, structure, and outline for all content that is pre-
sented as part of the WebApp and establishes the relationships between content

objects. Content design begins with the representation of content objects, their as-
sociations, and relationships. A set of browsing primitives establishes the basis for
navigation design.Architecture design identifies the overall hypermedia structure for the WebApp
and encompasses both content architecture and WebApp architecture. Architectural

styles for content include linear, grid, hierarchical, and network structures. WebApp

architecture describes an infrastructure that enables a Web-based system or appli-

cation to achieve its business objectives.CHAPTER 13WEBAPP DESIGN393pre75977_ch13.qxd  11/27/08  5:47 PM  Page 393
Navigation design represents the navigational flow between content objects andfor all WebApp functions. Navigation semantics are defined by describing a set of
navigation semantic units. Each unit is composed of ways of navigating and naviga-
tional links and nodes. Navigation syntax depicts the mechanisms used for effecting
the navigation described as part of the semantics.Component design develops the detailed processing logic required to implementfunctional components that implement a complete WebApp function. Design

techniques described in Chapter 10 are applicable for the engineering of WebApp

components.The Object-Oriented Hypermedia Design Method (OOHDM) is one of a numberofmethods proposed for WebApp design. OOHDM suggests a design process that

includes conceptual design, navigational design, abstract interface design, and
implementation.PROBLEMSAND
POINTSTO
PONDER13.1.Why is the Òartistic idealÓ an insufficient design philosophy when modern WebApps are
built? Is there ever a case in which the artistic ideal is the philosophy to follow?13.2.In this chapter we select a broad array of quality attributes for WebApps. Select the three
that you believe are most important, and make an argument that explains why each should beemphasized in WebApp design work.
13.3.Add at least five additional questions to the WebApp DesignÑQuality Checklist presented
in Section 13.1.
13.4.You are a WebApp designer for 
FutureLearning Corporation
, a distance learning company.
You intend to implement an Internet-based Òlearning engineÓ that will enable you to deliver
course content to a student. The learning engine provides the basic infrastructure for delivering

learning content on any subject (content designers will prepare appropriate content). Develop
a prototype interface design for the learning engine.13.5.What is the most aesthetically pleasing website you have ever visited and why?13.6.Consider the content object Order,
generated once a user of SafeHomeAssured.comhas completed the selection of all components and is ready to finalize his purchase. Develop aUML description for Order
along with all appropriate design representations.13.7.What is the difference between content architecture and WebApp architecture?
13.8.Reconsidering the FutureLearningÒlearning engineÓ described in Problem 13.4, select acontent architecture that would be appropriate for the WebApp. Discuss why you made the

choice.13.9.Use UML to develop three or four design representations for content objects that wouldbe encountered as the Òlearning engineÓ described in Problem 13.4 is designed.
13.10.Do a bit of additional research on the MVC architecture and decide whether it would bean appropriate WebApp architecture for the Òlearning engineÓ discussed in Problem 13.4.

13.11.What is the difference between navigation syntax and navigation semantics?13.12.Define two or three NSUs for the SafeHomeAssured.comWebApp. Describe each in
some detail.
13.13.Write a brief paper on a hypermedia design method other than OOHDM.394PART TWOMODELINGpre75977_ch13.qxd  11/27/08  5:47 PM  Page 394
FURTHER
READINGSAND
INFORMATION
SOURCESVan Duyne and his colleagues (
The Design of Sites,2d ed., Prentice Hall, 2007) have written acomprehensive book that covers most important aspects of the WebApp design process. Design
process models and design patterns are covered in detail. Wodtke (
Information Architecture,
NewRiders Publishing, 2003), Rosenfeld and Morville (Information Architecture for the World Wide

Web,
OÕReilly & Associates, 2002), and Reiss (Practical Information Architecture,
Addison-Wesley,
2000) address content architecture and other topics.Although hundreds of books have been written on ÒWeb design,Ó very few of these discuss
any meaningful technical methods for doing design work. At best, a variety of useful guidelines
for WebApp design is presented, worthwhile examples of Web pages and Java programming are

shown, and the technical details important for implementing modern WebApps are discussed.

Among the many offerings in this category are books by Sklar (Principles of Web Design,
4th ed.,Course Technology, 2008), McIntire (
Visual Design for the Modern Web,
New Riders Press, 2007),Niederst (Web Design in a Nutshell,
3d ed., O-Reilly, 2006), Eccher (
Advanced Professional Web
Design,Charles River Media, 2006), Cederholm (Bulletproof Web Design
, New Riders Press, 2005),and Shelly and his colleagues (Web Design,
2d ed., Course Technology, 2005). PowellÕs [Pow02]
encyclopedic discussion and NielsenÕs [Nie00] in-depth discussion of design are also worthwhile

additions to any library.
Books by Beaird (The Principles of Beautiful Web Design,
SitePoint, 2007), Clarke andHolzschlag (Transcending CSS: The Fine Art of Web Design,
New Riders Press, 2006), and Golbeck(Art Theory for Web Design,
Addison Wesley, 2005) emphasize aesthetic design and are worth-
while reading for practitioners who have little background in the subject.The agile view of design (and other topics) for WebApps is presented by Wallace and his
colleagues (Extreme Programming for Web Projects,
Addison-Wesley, 2003). Conallen (
BuildingWeb Applications with UML,
2d ed., Addison-Wesley, 2002) and Rosenberg and Scott (
ApplyingUse-Case Driven Object Modeling with UML,Addison-Wesley, 2001) present detailed examples of
WebApps modeled using UML.
Design techniques are also mentioned within the context of books written about specificdevelopment environments. Interested readers should examine books on HTML, CSS, J2EE,

Java, .NET, XML, Perl, Ruby on Rails, Ajax, and a variety of WebApp creation applications

(Dreamweaver, HomePage, Frontpage, GoLive, MacroMedia Flash,
etc.) for useful design tidbits.AwidevarietyofinformationsourcesondesignforWebAppsisavailableontheInternet.
Anup-to-datelistofWorldWideWebreferencesthat are relevant to WebApp design can be

foundattheSEPAwebsite:
www.mhhe.com/engcs/compsci/pressman/professional/
olc/ser.htm
.CHAPTER 13WEBAPP DESIGN395pre75977_ch13.qxd  11/27/08  5:47 PM  Page 395
pre75977_ch13.qxd  11/27/08  5:47 PM  Page 396
QUALITYMANAGEMENT397PART
Three
In this part of Software Engineering: A PractitionerÕs Approach
youÕll learn about the principles, concepts, and techniques that
are applied to manage and control software quality. These
questions are addressed in the chapters that follow:¥What are the generic characteristics of high-quality software?¥How do we review quality and how are effective reviews
conducted?¥What is software quality assurance?¥What strategies are applicable for software testing?¥What methods are used to design effective test cases?¥Are there realistic methods that will ensure that software is
correct?¥How can we manage and control changes that always occur
as software is built?¥What measures and metrics can be used to assess the quality
of requirements and design models, source code, and test

cases?Once these questions are answered youÕll be better prepared toensure that high-quality software has been produced.pre75977_ch14.qxd  11/27/08  5:51 PM  Page 397
The drumbeat for improved software quality began in earnest as software
became increasingly integrated in every facet of our lives. By the 1990s,
major corporations recognized that billions of dollars each year were be-ing wasted on software that didnÕt deliver the features and functionality that were

promised. Worse, both government and industry became increasingly concerned

that a major software fault might cripple important infrastructure, costing tens

ofbillions more. By the turn of the century, 
CIO Magazine[Lev01] trumpetedtheheadline, ÒLetÕs Stop Wasting $78 Billion a Year,Ó lamenting the fact that

ÒAmerican businesses spend billions for software that doesnÕt do what itÕs sup-

posed to do.Ó InformationWeek
[Ric01] echoed the same concern:Despite good intentions, defective code remains the hobgoblin of the software indus-try, accounting for as much as 45% of computer-system downtime and costing U.S.

companies about $100 billion last year in lost productivity and repairs, says the
Standish Group, a market research firm. That doesnÕt include the cost of losing angry

customers. Because IT shops write applications that rely on packaged infrastructure
software, bad code can wreak havoc on custom apps as well....
Justhowbadisbadsoftware?Definitionsvary,butexpertssayittakesonlythreeor
fourdefectsper1,000linesofcodetomakeaprogramperformpoorly.Factorinthatmost

programmersinjectaboutoneerrorforevery10linesofcodetheywrite,multiplythatby

themillionsoflinesofcodeinmanycommercialproducts,thenfigureitcostssoftware

vendorsatleasthalftheirdevelopmentbudgetstofixerrorswhiletesting.Getthepicture?
398CHAPTER14QUALITYCONCEPTSKEYCONCEPTScostofquality . .407
good enough . . .406

liability . . . . . .410

managementactions . . . . . . .411
quality . . . . . . .399

qualitydilemma . . . . . .406
qualitydimensions . . . .401
quality factors .402

quantitativeview . . . . . . . .405
risks . . . . . . . .409

security . . . . . .410
What is it?The answer isnÕt as easy
as you might think. You know quality
when you see it, and yet, it can be an
elusive thing to define. But for com-puter software, quality is something that we must
define, and thatÕs what IÕll do in this chapter.
Who does it?EveryoneÑsoftware engineers,
managers, all stakeholdersÑinvolved in the
software process is responsible for quality.
Whyisitimportant?
Youcandoitright,oryou
candoitoveragain.Ifasoftwareteamstresses

qualityinallsoftwareengineeringactivities,it

reducestheamountofreworkthatitmustdo.

Thatresultsinlowercosts,andmoreimportantly,

improved time-to-market.QUICKLOOKWhat are the steps?To achieve high-quality
software, four activities must occur: proven soft-
ware engineering process and practice, solid
project management, comprehensive quality
control, and the presence of a quality assurance
infrastructure.What is the work product?
Software thatmeetsits customerÕs needs, performs accurately

and reliably, and provides value to all who

use it.How do I ensure that IÕve done it right?Track
quality by examining the results of all quality
control activities, and measure quality by exam-
ining errors before delivery and defects

released to the field.pre75977_ch14.qxd  11/27/08  5:51 PM  Page 398
CHAPTER 14QUALITY CONCEPTS399In 2005, ComputerWorld
[Hil05] lamented that Òbad software plagues nearly everyorganization that uses computers, causing lost work hours during computer down-time, lost or corrupted data, missed sales opportunities, high IT support and mainte-

nance costs, and low customer satisfaction. A year later, 
InfoWorld
[Fos06] wroteabout the Òthe sorry state of software qualityÓ reporting that the quality problem had
not gotten any better.
Today, software quality remains an issue, but who is to blame? Customers blame
developers, arguing that sloppy practices lead to low-quality software. Developers
blame customers (and other stakeholders), arguing that irrational delivery dates and
a continuing stream of changes force them to deliver software before it has been fully
validated. WhoÕs right? 
BothÑand thatÕs the problem. In this chapter, I consider soft-
ware quality as a concept and examine why itÕs worthy of serious consideration

whenever software engineering practices are applied.14.1W
HAT
ISQUALITY?In his mystical book, Zen and the Art of Motorcycle Maintenance,
Robert Persig [Per74]commented on the thing we call quality:Quality...youknowwhatitis,yetyoudonÕtknowwhatitis.ButthatÕsself-contradictory.
But some things are better than others; that is, they have more quality. But when you try

to say what the quality is, apart from the things that have it, it all goes poof! ThereÕs noth-

ing to talk about. But if you canÕt say what Quality is, how do you know what it is, or how

do you know that it even exists? If no one knows what it is, then for all practical purposes
it doesnÕt exist at all. But for all practical purposes it really does exist. What else are the

grades based on? Why else would people pay fortunes for some things and throw others
in the trash pile? Obviously some things are better than others . . . but whatÕs the better-

ness? . . . So round and round you go, spinning mental wheels and nowhere finding any-
place to get traction. What the hell is Quality? What is it?IndeedÑwhat is it?At a somewhat more pragmatic level, David Garvin [Gar84] of the Harvard Busi-ness School suggests that Òquality is a complex and multifaceted conceptÓ that can
be described from five different points of view. The 
transcendental view
argues (likePersig) that quality is something that you immediately recognize, but cannot explic-

itly define. The user viewsees quality in terms of an end userÕs specific goals. If a
product meets those goals, it exhibits quality. The 
manufacturerÕs view
defines qual-ity in terms of the original specification of the product. If the product conforms to the
spec, it exhibits quality. The 
product viewsuggests that quality can be tied to inher-ent characteristics (e.g., functions and features) of a product. Finally, the 
value-based
viewmeasures quality based on how much a customer is willing to pay for a prod-uct. In reality, quality encompasses all of these views and more.
Quality of designrefers to the characteristics that designers specify for a product.The grade of materials, tolerances, and performance specifications all contribute to
the quality of design. As higher-grade materials are used, tighter tolerances andWhat are the differentways in which quality
can be viewed?pre75977_ch14.qxd  11/27/08  5:51 PM  Page 399
greater levels of performance are specified, the design quality of a product increases,if the product is manufactured according to specifications.In software development, quality of design encompasses the degree to which thedesign meets the functions and features specified in the requirements model. Qualityof conformancefocuses on the degree to which the implementation follows thedesign and the resulting system meets its requirements and performance goals.But are quality of design and quality of conformance the only issues that softwareengineers must consider? Robert Glass [Gla98] argues that a more ÒintuitiveÓ rela-
tionship is in order:user satisfaction compliant product good quality delivery within budget and schedule
At the bottom line, Glass contends that quality is important, but if the user isnÕt
satisfied, nothing else really matters. DeMarco [DeM98] reinforces this view when he
states: ÒA productÕs quality is a function of how much it changes the world for the

better.Ó This view of quality contends that if a software product provides substantial

benefit to its end users, they may be willing to tolerate occasional reliability or per-
formance problems.14.2S
OFTWARE
QUALITYEven the most jaded software developers will agree that high-quality software is an
important goal. But how do we define softwarequality? In the most general sense,
software quality can be defined1as: An effective software process applied in a mannerthat creates a useful product that provides measurable value for those who produce it

and those who use it.There is little question that the preceding definition could be modified or extendedand debated endlessly. For the purposes of this book, the definition serves to

emphasize three important points:1.An effective software processestablishes the infrastructure that supports anyeffort at building a high-quality software product. The management aspects
of process create the checks and balances that help avoid project chaosÑa
key contributor to poor quality. Software engineering practices allow the

developer to analyze the problem and design a solid solutionÑboth critical
tobuilding high-quality software. Finally, umbrella activities such as change

management and technical reviews have as much to do with quality as any
other part of software engineering practice.2.A useful productdelivers the content, functions, and features that the enduser desires, but as important, it delivers these assets in a reliable, error-free
400PART THREEQUALITY MANAGEMENTuote:ÒPeopleforgethow
fastyoudidajobÑ

but they always
remember how
well you did it.ÓHowardNewton
1This definition has been adapted from [Bes04] and replaces a more manufacturing-oriented view
presented in earlier editions of this book.pre75977_ch14.qxd  11/27/08  5:51 PM  Page 400
way. A useful product always satisfies those requirements that have been
explicitly stated by stakeholders. In addition, it satisfies a set of implicit
requirements (e.g., ease of use) that are expected of all high-quality software.3.By adding value for both the producer and userof a software product, high-quality software provides benefits for the software organization and the end-

user community. The software organization gains added value because

high-quality software requires less maintenance effort, fewer bug fixes, and
reduced customer support. This enables software engineers to spend more
time creating new applications and less on rework. The user community
gains added value because the application provides a useful capability in

away that expedites some business process. The end result is (1) greater

software product revenue, (2) better profitability when an application

supports abusiness process, and/or (3) improved availability of information

that is crucial for the business.14.2.1GarvinÕs Quality Dimensions
David Garvin [Gar87] suggests that quality should be considered by taking a multidi-
mensional viewpoint that begins with an assessment of conformance and termi-
nates with a transcendental (aesthetic) view. Although GarvinÕs eight dimensions of

quality were not developed specifically for software, they can be applied when soft-

ware quality is considered:Performance quality.
Does the software deliver all content, functions, andfeatures that are specified as part of the requirements model in a way that
provides value to the end user?
Feature quality.
Does the software provide features that surprise and
delight first-time end users?
Reliability.
Does the software deliver all features and capability withoutfailure? Is it available when it is needed? Does it deliver functionality that iserror-free?Conformance.
Does the software conform to local and external softwarestandards that are relevant to the application? Does it conform to de factodesign and coding conventions? For example, does the user interface con-

form to accepted design rules for menu selection or data input?Durability.
Can the software be maintained (changed) or corrected(debugged) without the inadvertent generation of unintended side effects?Will changes cause the error rate or reliability to degrade with time?
Serviceability.
Can the software be maintained (changed) or corrected(debugged) in an acceptably short time period? Can support staff acquire allinformation they need to make changes or correct defects? Douglas Adams
[Ada93] makes a wry comment that seems appropriate here: ÒThe differenceCHAPTER 14QUALITY CONCEPTS401pre75977_ch14.qxd  11/27/08  5:51 PM  Page 401
between something that can go wrong and something that canÕt possibly go
wrong is that when something that canÕt possibly go wrong goes wrong it

usually turns out to be impossible to get at or repair.Ó
Aesthetics.ThereÕs no question that each of us has a different and very
subjective vision of what is aesthetic. And yet, most of us would agree thatan aesthetic entity has a certain elegance, a unique flow, and an obvious

ÒpresenceÓ that are hard to quantify but are evident nonetheless. Aesthetic
software has these characteristics.Perception.
In some situations, you have a set of prejudices that will influ-ence your perception of quality. For example, if you are introduced to a soft-
ware product that was built by a vendor who has produced poor quality in
the past, your guard will be raised and your perception of the current soft-
ware product quality might be influenced negatively. Similarly, if a vendor

has an excellent reputation, you may perceive quality, even when it does not

really exist.GarvinÕs quality dimensions provide you with a ÒsoftÓ look at software quality.
Many (but not all) of these dimensions can only be considered subjectively. For this

reason, you also need a set of ÒhardÓ quality factors that can be categorized in two
broad groups: (1) factors that can be directly measured (e.g., defects uncovered dur-

ing testing) and (2) factors that can be measured only indirectly (e.g., usability or
maintainability). In each case measurement must occur. You should compare the

software to some datum and arrive at an indication of quality.
14.2.2McCallÕs Quality Factors
McCall, Richards, and Walters [McC77] propose a useful categorization of factors

that affect software quality. These software quality factors, shown in Figure 14.1,

focus on three important aspects of a software product: its operational characteris-
tics, its ability to undergo change, and its adaptability to new environments.
Referring to the factors noted in Figure 14.1, McCall and his colleagues provide
the following descriptions:Correctness.The extent to which a program satisfies its specification and fulfills thecustomerÕs mission objectives.
Reliability.
The extent to which a program can be expected to perform its intended func-tion with required precision. [It should be noted that other, more complete definitions of
reliability have been proposed (see Chapter 25).]Efficiency.
The amount of computing resources and code required by a program toperform its function.
Integrity.
Extent to which access to software or data by unauthorized persons can becontrolled.
Usability.
Effort required to learn, operate, prepare input for, and interpret output of a
program.402PART THREEQUALITY MANAGEMENTpre75977_ch14.qxd  11/27/08  5:51 PM  Page 402
Maintainability.
Effort required to locate and fix an error in a program. [This is a verylimited definition.]Flexibility.
Effort required to modify an operational program.Testability.
Effort required to test a program to ensure that it performs its intendedfunction.
Portability.
Effort required to transfer the program from one hardware and/or softwaresystem environment to another.

Reusability.
Extent to which a program [or parts of a program] can be reused in otherapplicationsÑrelated to the packaging and scope of the functions that the programperforms.Interoperability.
Effort required to couple one system to another.
It is difficult, and in some cases impossible, to develop direct measures
2of thesequality factors. In fact, many of the metrics defined by McCall et al. can be measuredonly indirectly. However, assessing the quality of an application using these factors

will provide you with a solid indication of software quality.
14.2.3ISO 9126 Quality Factors
The ISO 9126 standard was developed in an attempt to identify the key quality
attributes for computer software. The standard identifies six key quality attributes:Functionality.
The degree to which the software satisfies stated needs asindicated by the following subattributes: suitability, accuracy, interoperability,

compliance, and security.
Reliability.
The amount of time that the software is available for use as indi-cated by the following subattributes: maturity, fault tolerance, recoverability.
CHAPTER 14QUALITY CONCEPTS403PRODUCT OPERATION
PRODUCT TRANSITIONPRODUCT REVISIONCorrectness                              Usability                              EfficiencyReliability                              IntegrityMaintainabilityFlexibility
Testability
Portability

Reusability
InteroperabilityFIGURE14.1McCallÕs
software

quality factorsuote:ÒThe bitternessofpoor quality

remains long after
the sweetness of
meeting the
schedule has been
forgotten.ÓKarlWeigers
(unattributed
quote)2A 
direct measureimplies that there is a single countable value that provides a direct indication ofthe attribute being examined. For example, the ÒsizeÓ of a program can be measured directly bycounting the number of lines of code.pre75977_ch14.qxd  11/27/08  5:51 PM  Page 403
Usability.
The degree to which the software is easy to use as indicated bythe following subattributes: understandability, learnability, operability.
Efficiency.
The degree to which the software makes optimal use of systemresources as indicated by the following subattributes: time behavior, resource
behavior.
Maintainability.
The ease with which repair may be made to the software asindicated by the following subattributes: analyzability, changeability, stability,
testability.
Portability.
The ease with which the software can be transposed from oneenvironment to another as indicated by the following subattributes: adapt-
ability, installability, conformance, replaceability.
Like other software quality factors discussed in the preceding subsections, the ISO9126 factors do not necessarily lend themselves to direct measurement. However,

they do provide a worthwhile basis for indirect measures and an excellent checklist

for assessing the quality of a system.14.2.4Targeted Quality Factors
The quality dimensions and factors presented in Sections 14.2.1 and 14.2.2 focus on
the software as a whole and can be used as a generic indication of the quality of an
application. A software team can develop a set of quality characteristics and associ-
ated questions that would probe3the degree to which each factor has been satisfied.For example, McCall identifies 
usabilityas an important quality factor. If you were
asked to review a user interface and assess its usability, how would you proceed?

You might start with the subattributes suggested by McCallÑunderstandability,

learnability, and operabilityÑbut what do these mean in a pragmatic sense?
To conduct your assessment, youÕll need to address specific, measurable (or at
least, recognizable) attributes of the interface. For example [Bro03]:Intuitiveness.
The degree to which the interface follows expected usage patternsso that even a novice can use it without significant training.
¥Is the interface layout conducive to easy understanding?¥Are interface operations easy to locate and initiate?¥Does the interface use a recognizable metaphor?¥Is input specified to economize key strokes or mouse clicks?¥Does the interface follow the three golden rules? (Chapter 11)¥Do aesthetics aid in understanding and usage?404PART THREEQUALITY MANAGEMENTuote:ÒAny activitybecomes creative
when the doer
cares about doing
it right, or better.Ó
JohnUpdike
Although itÕs tempting
to develop quantitative
measures for the
quality factors noted
here, you can also
create a simple
checklist of attributes
that provide a solid
indication that the
factor is present.3These characteristics and questions would be addressed as part of a software review (Chapter 15).
pre75977_ch14.qxd  11/27/08  5:51 PM  Page 404
Efficiency.
The degree to which operations and information can be located orinitiated.¥Does the interface layout and style allow a user to locate operations andinformation efficiently?¥Can a sequence of operations (or data input) be performed with an economy
of motion?¥Are output data or content presented so that it is understood immediately?¥Have hierarchical operations been organized in a way that minimizes the
depth to which a user must navigate to get something done?Robustness.The degree to which the software handles bad input data or inap-propriate user interaction.¥Will the software recognize the error if data at or just outside prescribed

boundaries is input? More importantly, will the software continue to operate

without failure or degradation?¥Will the interface recognize common cognitive or manipulative mistakes and

explicitly guide the user back on the right track?¥Does the interface provide useful diagnosis and guidance when an error

condition (associated with software functionality) is uncovered?
Richness.
The degree to which the interface provides a rich feature set.
¥Can the interface be customized to the specific needs of a user?¥Does the interface provide a macro capability that enables a user to identify a

sequence of common operations with a single action or command?As the interface design is developed, the software team would review the designprototype and ask the questions noted. If the answer to most of these questions is
Òyes,Ó it is likely that the user interface exhibits high quality. A collection of questions

similar to these would be developed for each quality factor to be assessed.14.2.5The Transition to a Quantitative View
In the preceding subsections, I have presented a variety of qualitative factors for the
ÒmeasurementÓ of software quality. The software engineering community strives to

develop precise measures for software quality and is sometimes frustrated by the
subjective nature of the activity. Cavano and McCall [Cav78] discuss this situation:
The determination of quality is a key factor in every day eventsÑwine tasting contests,sporting events [e.g., gymnastics], talent contests, etc. In these situations, quality is
judged in the most fundamental and direct manner: side by side comparison of objects
under identical conditions and with predetermined concepts. The wine may be judged
according to clarity, color, bouquet, taste, etc. However, this type of judgment is very sub-

jective; to have any value at all, it must be made by an expert.CHAPTER 14QUALITY CONCEPTS405pre75977_ch14.qxd  11/27/08  5:51 PM  Page 405
Subjectivity and specialization also apply to determining software quality. To help
solve this problem, a more precise definition of software quality is needed as well as away to derive quantitative measurements of software quality for objective analysis....

Since there is no such thing as absolute knowledge, one should not expect to measure

software quality exactly, for every measurement is partially imperfect. Jacob Bronkowski

described this paradox of knowledge in this way: ÒYear by year we devise more precise

instruments with which to observe nature with more fineness. And when we look at the
observations we are discomfited to see that they are still fuzzy, and we feel that they are

as uncertain as ever.Ó
In Chapter 23, IÕll present a set of software metrics that can be applied to the quan-titative assessment of software quality. In all cases, the metrics represent indirect
measures; that is, we never really measure qualitybut rather some manifestation ofquality. The complicating factor is the precise relationship between the variable that

is measured and the quality of software.14.3T
HESOFTWARE
QUALITYDILEMMAIn an interview [Ven03] published on the Web, Bertrand Meyer discusses what I call

the quality dilemma:If you produce a software system that has terrible quality, you lose because no one will
want to buy it. If on the other hand you spend infinite time, extremely large effort, and

huge sums of money to build the absolutely perfect piece of software, then itÕs going to

take so long to complete and it will be so expensive to produce that youÕll be out of busi-
ness anyway. Either you missed the market window, or you simply exhausted all your

resources. So people in industry try to get to that magical middle ground where the prod-
uct is good enough not to be rejected right away, such as during evaluation, but also not

the object of so much perfectionism and so much work that it would take too long or cost
too much to complete.ItÕs fine to state that software engineers should strive to produce high-quality
systems. ItÕs even better to apply good practices in your attempt to do so. But the
situation discussed by Meyer is real life and represents a dilemma for even the best
software engineering organizations.14.3.1ÒGood EnoughÓ Software
Stated bluntly, if we are to accept the argument made by Meyer, is it acceptable

toproduce Ògood enoughÓ software? The answer to this question must beÒyes,Ó

because major software companies do it every day. They create software with known

bugs and deliver it to a broad population of end users. They recognize that some of
the functions and features delivered in Version 1.0 may not be of the highest quality

and plan for improvements in Version 2.0. They do this knowing that some cus-

tomers will complain, but they recognize that time-to-market may trump better qual-
ity as long as the delivered product is Ògood enough.Ó406PART THREEQUALITY MANAGEMENTWhen youÕre facedwith the quality
dilemma (and
everyone is faced

withit at one time

oranother), try to

achieve balanceÑ
enough effort to

produce acceptable
quality without burying

the project.pre75977_ch14.qxd  11/27/08  5:51 PM  Page 406
Exactly what is Ògood enoughÓ? Good enough software delivers high-quality func-tions and features that users desire, but at the same time it delivers other more
obscure or specialized functions and features that contain known bugs. The soft-
ware vendor hopes that the vast majority of end users will overlook the bugs because

they are so happy with other application functionality.
This idea may resonate with many readers. If youÕre one of them, I can only askyou to consider some of the arguments against Ògood enough.ÓIt is true that Ògood enoughÓ may work in some application domains and for a fewmajor software companies. After all, if a company has a large marketing budget and
can convince enough people to buy version 1.0, it has succeeded in locking them in.

As I noted earlier, it can argue that it will improve quality in subsequent versions. By

delivering a good enough version 1.0, it has cornered the market.If you work for a small company be wary of this philosophy. When you deliver a
good enough (buggy) product, you risk permanent damage to your companyÕs repu-

tation. You may never get a chance to deliver version 2.0 because bad buzz may

cause your sales to plummet and your company to fold.If you work in certain application domains (e.g., real-time embedded software) orbuild application software that is integrated with hardware (e.g., automotive soft-
ware, telecommunications software), delivering software with known bugs can be

negligent and open your company to expensive litigation. In some cases, it can even
be criminal. No one wants good enough aircraft avionics software!So, proceed with caution if you believe that Ògood enoughÓ is a short cut that cansolve your software quality problems. It can work, but only for a few and only in a
limited set of application domains.414.3.2The Cost of Quality
TheargumentgoessomethinglikethisÑ
weknowthatqualityisimportant,butitcosts

ustimeandmoneyÑtoomuchtimeandmoneytogetthelevelofsoftwarequalitywe

reallywant.
Onitsface,thisargumentseemsreasonable(seeMeyerÕscommentsear-
lierinthissection).Thereisnoquestionthatqualityhasacost,butlackofqualityalso

hasacostÑnotonlytoenduserswhomustlivewithbuggysoftware,butalsotothe

softwareorganizationthathasbuiltandmustmaintainit.Therealquestionisthis:

whichcostshouldwebeworriedabout?
Toanswerthisquestion,youmustunderstand
boththecostofachievingqualityandthecostoflow-qualitysoftware.
The cost of qualityincludes all costs incurred in the pursuit of quality or in per-forming quality-related activities and the downstream costs of lack of quality. To

understand these costs, an organization must collect metrics to provide a baseline

for the current cost of quality, identify opportunities for reducing these costs, and

provide a normalized basis of comparison. The cost of quality can be divided into

costs associated with prevention, appraisal, and failure.CHAPTER 14QUALITY CONCEPTS4074A worthwhile discussion of the pros and cons of Ògood enoughÓ software can be found in [Bre02].
pre75977_ch14.qxd  11/27/08  5:52 PM  Page 407
Prevention costsinclude (1) the cost of management activities required to plan andcoordinate all quality control and quality assurance activities, (2) the cost of addedtechnical activities to develop complete requirements and design models, (3) test
planning costs, and (4) the cost of all training associated with these activities.Appraisal costs
include activities to gain insight into product condition the Òfirsttime throughÓ each process. Examples of appraisal costs include:¥Cost of conducting technical reviews (Chapter 15) for software engineering
work products¥Cost of data collection and metrics evaluation (Chapter 23)¥Cost of testing and debugging (Chapters 18 through 21)Failure costsare those that would disappear if no errors appeared before or aftershipping a product to customers. Failure costs may be subdivided into internal failure
costs and external failure costs. Internal failure costsare incurred when you detect anerror in a product prior to shipment. Internal failure costs include¥Cost required to perform rework (repair) to correct an error¥Cost that occurs when rework inadvertently generates side effects that must
be mitigated¥Costs associated with the collection of quality metrics that allow an organi-
zation to assess the modes of failureExternal failure costsare associated with defects found after the product has beenshipped to the customer. Examples of external failure costs are complaint resolution,

product return and replacement, help line support, and labor costs associated with
warranty work. A poor reputation and the resulting loss of business is another
external failure cost that is difficult to quantify but nonetheless very real. Bad things
happen when low-quality software is produced.In an indictment of software developers who refuse to consider external failurecosts, Cem Kaner [Kan95] states:Manyoftheexternalfailurecosts,suchasgoodwill,aredifficulttoquantify,andmanycom-
paniesthereforeignorethemwhencalculatingtheircost-benefittradeoffs.Otherexternal

failurecostscanbereduced(e.g.byprovidingcheaper,lower-quality,post-salesupport,or

bychargingcustomersforsupport)withoutincreasingcustomersatisfaction.Byignoring

thecoststoourcustomersofbadproducts,qualityengineersencouragequality
-relateddecision-makingthatvictimizesourcustomers,ratherthandelightingthem.
As expected, the relative costs to find and repair an error or defect increase dra-matically as we go from prevention to detection to internal failure to external failurecosts. Figure 14.2, based on data collected by Boehm and Basili [Boe01b] and illus-
trated by Cigital Inc. [Cig07], illustrates this phenomenon.The industry average cost to correct a defect during code generation is approxi-mately $977 per error. The industry average cost to correct the same error if it is
408PART THREEQUALITY MANAGEMENTDonÕt be afraid to incursignificant prevention
costs. Rest assured
that your investment
will provide an
excellent return.
uote:ÒIt takes less timeto do a thing right
than to explain
why you did it
wrong.ÓH. W.
Longfellowpre75977_ch14.qxd  11/27/08  5:52 PM  Page 408
discovered during system testing is $7,136 per error. Cigital Inc. [Cig07] considers a
large application that has 200 errors introduced during coding.According to industry average data, the cost of finding and correcting defects during thecoding phase is $977 per defect. Thus, the total cost for correcting the 200 ÒcriticalÓ
defects during this phase (200 $977) is approximately $195,400.Industry average data shows that the cost of finding and correcting defects during thesystem testing phase is $7,136 per defect. In this case, assuming that the system testing

phase revealed approximately 50 critical defects (or only 25% of those found by Cigital in
the coding phase), the cost of finding and fixing those defects (50 $7,136) would havebeen approximately $356,800. This would also have resulted in 150 critical errors going
undetected and uncorrected. The cost of finding and fixing these remaining 150 defects
in the maintenance phase (150 $14,102) would have been $2,115,300. Thus, the totalcost of finding and fixing the 200 defects after the coding phase would have been
$2,472,100 ($2,115,300 $356,800).Even if your software organization has costs that are half of the industry average(most have no idea what their costs are!), the cost savings associated with earlyquality control and assurance activities (conducted during requirements analysis
and design) are compelling.14.3.3Risks
InChapter1ofthisbook,IwroteÒpeoplebettheirjobs,theircomforts,theirsafety,their

entertainment,theirdecisions,andtheirverylivesoncomputersoftware.Itbetterbe

right.ÓTheimplicationisthatlow-qualitysoftwareincreasesrisksforboththedevel-

operandtheenduser. Intheprecedingsubsection,Idiscussedoneoftheserisks(cost).

Butthedownsideofpoorlydesignedandimplementedapplicationsdoesnotalways

stopwithdollarsandtime.Anextremeexample[Gag04]mightservetoillustrate.
CHAPTER 14QUALITY CONCEPTS409Requirements$139$455$977$7,136$14,102DesignCodingTestingMaintenance
$16,000.00$14,000.00
$12,000.00
$10,000.00$8,000.00
$6,000.00
$4,000.00
$2,000.00$-FIGURE14.2Relative cost ofcorrecting errors
and defects
Source: Adapted from
[Boe01b].pre75977_ch14.qxd  11/27/08  5:52 PM  Page 409
Throughout the month of November 2000 at a hospital in Panama, 28 patients
received massive overdoses of gamma rays during treatment for a variety of cancers.
In the months that followed, 5 of these patients died from radiation poisoning and
15 others developed serious complications. What caused this tragedy? A software
package, developed by a U.S. company, was modified by hospital technicians to

compute doses of radiation for each patient.The three Panamanian medical physicists, who ÒtweekedÓ the software to provide
additional capability, were charged with second-degree murder. The U.S. company

is faced with serious litigation in two countries. Gage and McCormick comment:This is not a cautionary tale for medical technicians, even though they can find them-selves fighting to stay out of jail if they misunderstand or misuse technology. This also

isnot a tale of how human beings can be injured or worse by poorly designed or poorly

explained software, although there are plenty of examples to make the point. This is a

warning for any creator of computer programs: that software quality matters, that appli-
cations must be foolproof, and thatÑwhether embedded in the engine of a car, a robotic

arm in a factory or a healing device in a hospitalÑpoorly deployed code can kill.Poor quality leads to risks, some of them very serious.14.3.4Negligence and Liability
The story is all too common. A governmental or corporate entity hires a major soft-
ware developer or consulting company to analyze requirements and then design and
construct a software-based ÒsystemÓ to support some major activity. The system

might support a major corporate function (e.g., pension management) or some gov-

ernmental function (e.g., health care administration or homeland security).Workbeginswiththebestofintentionsonbothsides,butbythetimethesystemis
delivered,thingshavegonebad.Thesystemislate,failstodeliverdesiredfeaturesand

functions,iserror-prone,anddoesnotmeetwithcustomerapproval.Litigationensues.
In most cases, the customer claims that the developer has been negligent (in themanner in which it has applied software practices) and is therefore not entitled to
payment. The developer often claims that the customer has repeatedly changed its
requirements and has subverted the development partnership in other ways. In every
case, the quality of the delivered system comes into question.
14.3.5Quality and Security
As the criticality of Web-based systems and applications grows, application security

has become increasingly important. Stated simply, software that does not exhibit

high quality is easier to hack, and as a consequence, low-quality software can indi-

rectly increase the security risk with all of its attendant costs and problems.In an interview in ComputerWorld,
author and security expert Gary McGraw com-
ments [Wil05]:
Software security relates entirely and completely to quality. You must think about secu-
rity, reliability, availability, dependabilityÑat the beginning, in the design, architecture,

test, and coding phases, all through the software life cycle [process]. Even people aware
410PART THREEQUALITY MANAGEMENTpre75977_ch14.qxd  11/27/08  5:52 PM  Page 410
of the software security problem have focused on late life-cycle stuff. The earlier you findthe software problem, the better. And there are two kinds of software problems. One is

bugs, which are implementation problems. The other is software flawsÑarchitectural

problems in the design. People pay too much attention to bugs and not enough on flaws.
To build a secure system, you must focus on quality, and that focus must begin dur-
ing design. The concepts and methods discussed in Part 2 of this book lead to a soft-ware architecture that reduces Òflaws.Ó By eliminating architectural flaws (thereby

improving software quality), you will make it far more difficult to hack the software.
14.3.6The Impact of Management Actions
Software quality is often influenced as much by management decisions as it is by
technology decisions. Even the best software engineering practices can be subverted
by poor business decisions and questionable project management actions.In Part 4 of this book I discuss project management within the context of the soft-ware process. As each project task is initiated, a project leader will make decisions
that can have a significant impact on product quality.
Estimation decisions.As I note in Chapter 26, a software team is rarely given theluxury of providing an estimate for a project 
beforedelivery dates are established andan overall budget is specified. Instead, the team conducts a Òsanity checkÓ to ensure
that delivery dates and milestones are rational. In many cases there is enormous
time-to-market pressure that forces a team to accept unrealistic delivery dates. As a
consequence, shortcuts are taken, activities that lead to higher-quality software may

be skipped, and product quality suffers. If a delivery date is irrational, it is important
to hold your ground. Explain why you need more time, or alternatively, suggest a

subset of functionality that can be delivered (with high quality) in the time allotted.Scheduling decisions.
When a software project schedule is established(Chapter27), tasks are sequenced based on dependencies. For example, because
component Adepends on processing that occurs within components B, C,
and D,component Acannot be scheduled for testing until components B, C,
and Dare fullytested. A project schedule would reflect this. But if time is very short, and Amust beavailable for further critical testing, you might decide to test Awithout its subordi-nate components (which are running slightly behind schedule), so that you can make
it available for other testing that must be done before delivery. After all, the deadline

looms. As a consequence, 
Amay have defects that are hidden, only to be discovered
much later. Quality suffers.
Risk-oriented decisions.Risk management (Chapter 28) is one of the key attrib-utes of a successful software project. You really do need to know what might go
wrong and establish a contingency plan if it does. Too many software teams prefer

blind optimism, establishing a development schedule under the assumption that
nothing will go wrong. Worse, they donÕt have a way of handling things that do go

wrong. As a consequence, when a risk becomes a reality, chaos reigns, and as the

degree of craziness rises, the level of quality invariably falls.
CHAPTER 14QUALITY CONCEPTS411pre75977_ch14.qxd  11/27/08  5:52 PM  Page 411
The software quality dilemma can best be summarized by stating MeskimenÕs
LawÑ
ThereÕs never time to do it right, but always time to do it over again.
My advice:taking the time to do it right is almost never the wrong decision.14.4A
CHIEVINGSOFTWARE
QUALITYSoftware quality doesnÕt just appear. It is the result of good project management and
solid software engineering practice. Management and practice are applied within
thecontext of four broad activities that help a software team achieve high software

quality: software engineering methods, project management techniques, quality
control actions, and software quality assurance.14.4.1Software Engineering Methods
If you expect to build high-quality software, you must understand the problem to be

solved. You must also be capable of creating a design that conforms to the problem

while at the same time exhibiting characteristics that lead to software that exhibits
the quality dimensions and factors discussed in Section 14.2.In Part 2 of this book, I presented a wide array of concepts and methods that canlead to a reasonably complete understanding of the problem and a comprehensive
design that establishes a solid foundation for the construction activity. If you apply

those concepts and adopt appropriate analysis and design methods, the likelihood
of creating high-quality software will increase substantially.
14.4.2Project Management Techniques
The impact of poor management decisions on software quality has been discussed in
Section 14.3.6. The implications are clear: if (1) a project manager uses estimation to
verify that delivery dates are achievable, (2) schedule dependencies are understood

and the team resists the temptation to use short cuts, (3) risk planning is conducted so
problems do not breed chaos, software quality will be affected in a positive way.
In addition, the project plan should include explicit techniques for quality andchange management. Techniques that lead to good project management practices

are discussed in Part 4 of this book.14.4.3Quality Control
Qualitycontrolencompassesasetofsoftwareengineeringactionsthathelpto

ensurethateachworkproductmeetsitsqualitygoals.Modelsarereviewedtoensure

thattheyarecompleteandconsistent.Codemaybeinspectedinordertouncover

andcorrecterrorsbeforetestingcommences.Aseriesoftestingstepsisappliedto

uncovererrorsinprocessinglogic,datamanipulation,andinterfacecommunication.

Acombinationofmeasurementandfeedbackallowsasoftwareteamtotunethe

processwhenanyoftheseworkproductsfailtomeetqualitygoals.Qualitycontrol

activitiesarediscussedindetailthroughouttheremainderofPart3ofthisbook.
412PART THREEQUALITY MANAGEMENTWhat do Ineed to do toaffect quality in a
positive way??What is
softwarequality control??pre75977_ch14.qxd  11/27/08  5:52 PM  Page 412
14.4.4Quality Assurance
Quality assurance establishes the infrastructure that supports solid software engi-neering methods, rational project management, and quality control actionsÑall
pivotal if you intend to build high-quality software. In addition, quality assurance
consists of a set of auditing and reporting functions that assess the effectiveness and
completeness of quality control actions. The goal of quality assurance is to provide

management and technical staff with the data necessary to be informed about prod-
uct quality, thereby gaining insight and confidence that actions to achieve product

quality are working. Of course, if the data provided through quality assurance iden-

tifies problems, it is managementÕs responsibility to address the problems and apply

the necessary resources to resolve quality issues. Software quality assurance is dis-
cussed in detail in Chapter 16.14.5S
UMMARYConcern for the quality of the software-based systems has grown as software
becomes integrated into every aspect of our daily lives. But it is difficult to develop
a comprehensive description of software quality. In this chapter quality has been

defined as an effective software process applied in a manner that creates a useful
product that provides measurable value for those who produce it and those who

use it.A wide variety of software quality dimensions and factors have been proposedover the years. All try to define a set of characteristics that, if achieved, will lead to

high software quality. McCallÕs and the ISO 9126 quality factors establish character-

istics such as reliability, usability, maintainability, functionality, and portability as

indicators that quality exists.Every software organization is faced with the software quality dilemma. Inessence, everyone wants to build high-quality systems, but the time and effort

required to produce ÒperfectÓ software are simply unavailable in a market-driven
world. The question becomes, should we build software that is Ògood enoughÓ?
Although many companies do just that, there is a significant downside that must be
considered.Regardless of the approach that is chosen, quality does have a cost that can bediscussed in terms of prevention, appraisal, and failure. Prevention costs include all
software engineering actions that are designed to prevent defects in the first place.
Appraisal costs are associated with those actions that assess software work prod-
ucts to determine their quality. Failure costs encompass the internal price of failure

and the external effects that poor quality precipitates.Software quality is achieved through the application of software engineeringmethods, solid management practices, and comprehensive quality controlÑall sup-
ported by a software quality assurance infrastructure. In the chapters that follow,

quality control and assurance are discussed in some detail.CHAPTER 14QUALITY CONCEPTS413WebRef
UsefullinkstoSQA
resourcescanbefoundat

www.niwotridge

.com/Resources/
PM-
SWEResources/
SoftwareQuality
Assurance.htmpre75977_ch14.qxd  11/27/08  5:52 PM  Page 413
PROBLEMSAND
POINTSTO
PONDER14.1.Describe how you would assess the quality of a university before applying to it. Whatfactors would be important? Which would be critical?14.2.Garvin [Gar84] describes five different views of quality. Provide an example of each using
one or more well-known electronic products with which you are familiar.

14.3.Using the definition of software quality proposed in Section 14.2, do you think itÕs possi-
ble to create a useful product that provides measurable value without using an effective
process? Explain your answer.
14.4.Add two additional questions to each of GarvinÕs quality dimensions presented in Section
14.2.1.
14.5.McCallÕs quality factors were developed during the 1970s. Almost every aspect of
computing has changed dramatically since the time that they were developed, and yet,McCallÕsfactors continue to apply to modern software. Can you draw any conclusions based on

this fact?14.6.Using the subattributes noted for the ISO 9126 quality factor ÒmaintainabilityÓ in Section14.2.3, develop a set of questions that explore whether or not these attributes are present.Follow the example shown in Section 14.2.4.14.7.Describe the software quality dilemma in your own words.14.8.What is Ògood enoughÓ software? Name a specific company and specific products thatyou believe were developed using the good enough philosophy.

14.9.Considering each of the four aspects of the cost of quality, which do you think is the most
expensive and why?
14.10.Do a Web search and find three other examples of ÒrisksÓ to the public that can be
directly traced to poor software quality. Consider beginning your search at 
http://
catless.ncl.ac.uk/risks.
14.11.Are qualityand securitythe same thing? Explain.14.12.Explain why it is that many of us continue to live by MeskimenÕs law. What is it about
the software business that causes this?FURTHER
READINGSAND
INFORMATION
SOURCESBasic software quality concepts are considered in books by Henry and Hanlon (Software QualityAssurance,
Prentice-Hall, 2008), Khan and his colleagues (Software Quality: Concepts andPractice,
Alpha Science International, Ltd., 2006), OÕRegan (APractical Approach to Software
Quality,
Springer, 2002), and Daughtrey (
Fundamental Concepts for the Software Quality Engineer,
ASQ Quality Press, 2001).Duvall and his colleagues (Continuous Integration: Improving Software Quality and Reducing
Risk,Addison-Wesley, 2007), Tian (
Software Quality Engineering,Wiley-IEEE Computer Society
Press, 2005), Kandt (Software Engineering Quality Practices,
Auerbach, 2005), Godbole (
SoftwareQuality Assurance: Principles and Practice,
Alpha ScienceInternational,Ltd.,2004),andGalin
(SoftwareQualityAssurance:FromTheorytoImplementation,
Addison-Wesley,2003)present
detailedtreatmentsofSQA.Qualityassuranceinthecontextoftheagileprocessisconsidered

byStamelos and Sfetsos (
Agile Software Development Quality Assurance,
IGI Global, 2007).Solid design leads to high software quality. Jayasawal and Patton (
Design for Trustworthy
Software,Prentice-Hall, 2006) and Ploesch (Contracts, Scenarios and Prototypes,
Springer, 2004)
discuss tools and techniques for developing ÒrobustÓ software.414PART THREEQUALITY MANAGEMENTpre75977_ch14.qxd  11/27/08  5:52 PM  Page 414
Measurement is an important component of software quality engineering. Ejiogu (SoftwareMetrics: The Discipline of Software Quality,
BookSurge Publishing, 2005), Kan (Metrics and Mod-els in Software Quality Engineering,Addison-Wesley, 2002), and Nance and Arthur (
ManagingSoftware Quality,
Springer, 2002) discuss important quality-related metrics and models. The
team-oriented aspects of software quality are considered by Evans (Achieving Software Quality
through Teamwork,
Artech House Publishers, 2004).AwidevarietyofinformationsourcesonsoftwarequalityisavailableontheInternet.Anup-to-
date list of World Wide Web references relevant to software quality can be found  atthe SEPA

website: www.mhhe.com/engcs/compsci/pressman/professional/olc/ser.htm.
CHAPTER 14QUALITY CONCEPTS415pre75977_ch14.qxd  11/27/08  5:52 PM  Page 415
Software reviews are a ÒfilterÓ for the software process. That is, reviews areapplied at various points during software engineering and serve to uncover

errors and defects that can then be removed. Software reviews ÒpurifyÓ soft-
ware engineering work products, including requirements and design models,
code, and testing data. Freedman and Weinberg [Fre90] discuss the need for

reviews this way:Technical work needs reviewing for the same reason that pencils need erasers: 
To err
is human.The second reason we need technical reviews is that although people aregood at catching some of their own errors, large classes of errors escape the origina-
tor more easily than they escape anyone else. The review process is, therefore, the

answer to the prayer of Robert Burns:O wad some power the giftie give usto see ourselves as other see usA reviewÑany reviewÑis a way of using the diversity of a group of people to:1.Point out needed improvements in the product of a single person or team;
416CHAPTER15REVIEWTECHNIQUESKEYCONCEPTSdefect amplification . . .418
defects . . . . . . .417

error density . .421

errors . . . . . . .417

recordkeeping . .427

reviewmetrics . . . . . .420

reporting . . . .427
reviewscosteffectiveness . .421
informal . . . . .424

sample-driven . . . . . .429
technical . . . . .426
What is it?YouÕll make mistakes as
you develop software engineeringwork products. ThereÕs no shame in

thatÑas long as you try hard, very
hard, to find and correct the mistakes before
they are delivered to end users. Technical

reviews are the most effective mechanism for

finding mistakes early in the software process.Who does it?Software engineers perform techni-
cal reviews, also called peer reviews, with their
colleagues.Why is it important?
If you find an error early inthe process, it is less expensive to correct. In addi-
tion, errors have a way of amplifying as the
process proceeds. So a relatively minor error left
untreated early in the process can be amplified
into a major set of errors later in the project.
Finally, reviews save time by reducing the amount

of rework that will be required late in the project.QUICKLOOKWhat are the steps?Your approach to reviews
will vary depending on the degree of formality

you select. In general, six steps are employed,
although not all are used for every type of

review: planning, preparation, structuring the
meeting, noting errors, making corrections
(done outside the review), and verifying that
corrections have been performed properly.
What is the work product?
The output of areview is a list of issues and/or errors that have
been uncovered. In addition, the technical status
of the work product is also indicated.How do I ensure that IÕve done it right?First,select the type of review that is appropriate for
your development culture. Follow the guidelines
that lead to successful reviews. If the reviews
that you conduct lead to higher-quality soft-
ware, youÕve done it right.pre75977_ch15.qxd  11/27/08  5:54 PM  Page 416
2.Confirm those parts of a product in which improvement is either not desired or not
needed;3.Achieve technical work of more uniform, or at least more predictable, quality than can be
achieved without reviews, in order to make technical work more manageable.Manydifferenttypesofreviewscanbeconductedaspartofsoftwareengineering.
Each has its place. An informal meeting around the coffee machine is a form ofreview, if technical problems are discussed. A formal presentation of software

architecture to an audience of customers, management, and technical staff is also a
form of review. In this book, however, I focus on 
technical or peer reviews,
exempli-fied by casual reviews,walkthroughs,
and inspections.A technical review (TR) is themost effective filter from a quality control standpoint. Conducted by software engi-
neers (and others) for software engineers, the TR is an effective means for uncover-

ing errors and improving software quality.
15.1C
OSTIMPACTOF
SOFTWARE
DEFECTSWithin the context of the software process, the terms 
defectand faultare synony-mous. Both imply a quality problem that is discovered 
afterthe software has beenreleased to end users (or to another framework activity in the software process). In
earlier chapters, we used the term errorto depict a quality problem that is discovered
by software engineers (or others) beforethe software is released to the end user (orto another framework activity in the software process).CHAPTER 15REVIEW TECHNIQUES417Reviews are like afilter in the software
process workflow. Too

few, and the flow is

Òdirty.Ó Too many, and

the flow slows to a
trickle. Use metrics to
determine which

reviews work and
emphasize them.
Remove ineffective
reviews from the flow
to accelerate the
process.1If software process improvement is considered, a quality problem that is propagated from one
process framework activity (e.g., modeling) to another (e.g., construction) can also be called aÒdefectÓ (because the problem should have been found before a work product (e.g., a design model)
was ÒreleasedÓ to the next activity.Bugs, Errors, and Defects
The goal of software quality control, and in abroader sense, quality management in general,is to remove quality problems in the software. Theseproblems are referred to by various namesÑbugs, faults,errors,or defectsto name a few. Are each of these terms
synonymous, or are there subtle differences between them?
In this book I make a clear distinction between an error(a quality problem found beforethe software is released toend users) and a defect(a quality problem found only afterthe software has been released to end users1). I make thisdistinction because errors and defects have very different

economic, business, psychological, and human impact. Assoftware engineers, we want to find and correct as many
errors as possible before the customer and/or end user
encounter them. We want to avoid defectsÑbecause

defects (justifiably) make software people look bad.It is important to note, however, that the temporal
distinction made between errors and defects in this book is
notmainstream thinking. The general consensus within thesoftware engineering community is that defects and errors,
faults, and bugs are synonymous. That is, the point in time
that the problem was encountered has no bearing on the
term used to describe the problem. Part of the argument in

favor of this view is that it is sometimes difficult to make a
INFOpre75977_ch15.qxd  11/27/08  5:54 PM  Page 417
418PART THREEQUALITY MANAGEMENTThe primary objective of technical reviews is to find errors during the process sothat they do not become defects after release of the software. The obvious benefit oftechnical reviews is the early discovery of errors so that they do not propagate to the

next step in the software process.A number of industry studies indicate that design activities introduce between 50and 65 percent of all errors (and ultimately, all defects) during the software process.

However, review techniques have been shown to be up to 75 percent effective

[Jon86] in uncovering design flaws. By detecting and removing a large percentage of

these errors, the review process substantially reduces the cost of subsequent activi-
ties in the software process.15.2D
EFECTAMPLIFICATIONAND
REMOVAL
A defect amplification model[IBM81] can be used to illustrate the generation anddetection of errors during the design and code generation actions of a software
process. The model is illustrated schematically in Figure 15.1. A box represents a soft-
ware engineering action. During the action, errors may be inadvertently generated.
Review may fail to uncover newly generated errors and errors from previous steps,

resulting in some number of errors that are passed through. In some cases, errors
passed through from previous steps are amplified (amplification factor, 
x) by currentwork. The box subdivisions represent each of these characteristics and thepercent of

efficiency for detecting errors, a function of the thoroughness of the review.
Figure 15.2 illustrates a hypothetical example of defect amplification for a softwareprocess in which no reviews are conducted. Referring to the figure, each test step is

assumed to uncover and correct 50 percent of all incoming errors without intro-

ducingany new errors (an optimistic assumption). Ten preliminary design defects are

amplified to 94 errors before testing commences. Twelve latent errors (defects) are

released to the field. Figure 15.3 considers the same conditions except that design and
code reviews are conducted as part of each software engineering action. In this case,

10initial preliminary (architectural) design errors are amplified to 24 errors before

testing commences. Only three latent errors exist. The relative costs associated with
the discovery and correction of errors, overall cost (with and without review for our

hypothetical example) can be established. The number of errors uncovered during

each of the steps noted in Figures 15.2 and 15.3 is multiplied by the cost to remove an
clear distinction between pre- and post-release (e.g.,consider an incremental process used in agile
development).Regardless of how you choose to interpret theseterms, recognize that the point in time at which a

problem is discovered does matter and that softwareengineers should try hardÑ
very
hardÑto find problemsbefore their customers and end users encounter them. If
you have further interest in this issue, a reasonably

thorough discussion of the terminology surrounding

ÒbugsÓ can be found at
www.softwaredevelopment.ca/bugs.shtml
.The primary objective
of an FTR is to find
errors before they are

passed on to another
software engineering
activity or released to
the end user.
uote:ÒSome maladies, asdoctors say, at their

beginning are easy
to cure but difficult
to recognize É but
in the course of time
when they have not
at first been
recognized and
treated, become
easy to recognize
but difficult to
cure.ÓNiccoloMachiavellipre75977_ch15.qxd  11/27/08  5:54 PM  Page 418
CHAPTER 15REVIEW TECHNIQUES419Errors passed throughDevelopment stepDefectsDetectionErrors fromprevious stepAmplified errors 1 : xNewly generated errorsPercentefficiencyfor errordetectionErrors passedto next stepFIGURE15.1Defect amplifi-cation model6Preliminary design
01000%1064Detail design4 × 1.5   x = 1.5250%3710
27Code/unit test102527 × 3
     x = 320%94To integration
94Integration test0050%47Validation test
0050%24System test0050%12Latent errors(defects)FIGURE15.2Defect amplifi-cationÑno
reviews
Preliminary design 
0100Detail design25Code/unit test25To integration
Integration test0050%Validation test
0050%System test0050%Latent errors(defects)32170%50%21   1.5
24632460%510  3††155
1012FIGURE15.3Defect amplifi-cationÑ
reviews

conductedpre75977_ch15.qxd  11/27/08  5:54 PM  Page 419
error (1.5 cost units for design, 6.5 cost units before test, 15 cost units during test, and67 cost units after release).2Using these data, the total cost for development andmaintenance when reviews are conducted is 783 cost units. When no reviews are
conducted, total cost is 2177 unitsÑnearly three times more costly.
To conduct reviews, you must expend time and effort, and your development
organization must spend money. However, the results of the preceding example

leave little doubt that you can pay now or pay much more later.
15.3R
EVIEWMETRICSAND
THEIRUSETechnical reviews are one of many actions that are required as part of good software

engineering practice. Each action requires dedicated human effort, Since available
project effort is finite, it is important for a software engineering organization to

understand the effectiveness of each action by defining a set of metrics (Chapter 23)
that can be used to assess their efficacy.
Although many metrics can be defined for technical reviews, a relatively smallsubset can provide useful insight. The following review metrics can be collected for

each review that is conducted:¥Preparation effort, E
pÑthe effort (in person-hours) required to review a workproduct prior to the actual review meeting¥Assessment effort, EaÑthe effort (in person-hours) that is expended during theactual review¥Rework effort, ErÑthe effort (in person-hours) that is dedicated to the correc-tion of those errors uncovered during the review
¥Work product size, WPS
Ña measure of the size of the work product that hasbeen reviewed (e.g., the number of UML models, or the number of document
pages, or the number of lines of code)¥Minor errors found, ErrminorÑthe number of errors found that can be catego-rized as minor (requiring less than some prespecified effort to correct)¥Major errors found, ErrmajorÑthe number of errors found that can be catego-rized as major (requiring more than some prespecified effort to correct)These metrics can be further refined by associating the type of work product that was
reviewed for the metrics collected.15.3.1Analyzing Metrics
Before analysis can begin, a few simple computations must occur. The total review

effort and the total number of errors discovered are defined as:
EreviewEpEaErErrtotErrminorErrmajor420PART THREEQUALITY MANAGEMENT2These multipliers are somewhat different than the data presented in Figure 14.2, which is more
current. However, they serve to illustrate the costs of defect amplification nicely.pre75977_ch15.qxd  11/27/08  5:54 PM  Page 420
Error densityrepresents the errors found per unit of work product reviewed.Error density For example, if a requirements model is reviewed to uncover errors, inconsistencies,
and omissions, it would be possible to compute the error density in a number of dif-
ferent ways. The requirements model contains 18 UML diagrams as part of 32 over-

all pages of descriptive materials. The review uncovers 18 minor errors and 4 major

errors. Therefore, Err
tot22. Error density is 1.2 errors per UML diagram or 0.68errors per requirements model page.If reviews are conducted for a number of different types of work products (e.g.,requirements model, design model, code, test cases), the percentage of errors

uncovered for each review can be computed against the total number of errors

found for all reviews. In addition, the error density for each work product can be
computed.Once data are collected for many reviews conducted across many projects, aver-age values for error density enable you to estimate the number of errors to be found
in a new (as yet unreviewed document). For example, if the average error density for

a requirements model is 0.6 errors per page, and a new requirement model is 32

pages long, a rough estimate suggests that your software team will find about 19 or
20 errors during the review of the document. If you find only 6 errors, youÕve done
an extremely good job in developing the requirements model or your review
approach was not thorough enough.Once testing has been conducted (Chapters 17 through 20), it is possible to collectadditional error data, including the effort required to find and correct errors uncov-

ered during testing and the error density of the software. The costs associated with
finding and correcting an error during testing can be compared to those for reviews.
This is discussed in Section 15.3.2.15.3.2Cost Effectiveness of Reviews
It is difficult to measure the cost effectiveness of any technical review in real time. A
software engineering organization can assess the effectiveness of reviews and their
cost benefit only after reviews have been completed, review metrics have been col-
lected, average data have been computed, and then the downstream quality of the
software is measured (via testing).Returning to the example presented in Section 15.3.1, the average error densityfor requirements models was determined to be 0.6 errors per page. The effort
required to correct a minor model error (immediately after the review) was found to
require 4person-hours. The effort required for a major requirement error was found

to be 18person-hours. Examining the review data collected, you find that minor

errors occur about 6 times more frequently than major errors. Therefore, you can

estimate that the average effort to find and correct a requirements error during
review is about 6 person-hours.ErrtotWPSCHAPTER 15REVIEW TECHNIQUES421pre75977_ch15.qxd  11/27/08  5:54 PM  Page 421
Requirements-related errors uncovered during testing require an average of 45
person-hours to find and correct (no data are available on the relative severity of theerror). Using the averages noted, we get:Effort saved per error EtestingEreviews45 6 30 person-hours/errorSince 22 errors were found during the review of the requirements model, a saving of
about 660 person-hours of testing effort would be achieved. And thatÕs just for

requirements-related errors. Errors associated with design and code would add to
the overall benefit. The bottom lineÑeffort saved leads to shorter delivery cycles and

improved time to market.
In his book on peer reviews, Karl Wiegers [Wie02] discusses anecdotal data from
major companies that have used inspections(a relatively formal type of technicalreview) as part of their software quality control activities. Hewlett Packard reported
a 10 to 1 return on investment for inspections and noted that actual product delivery

accelerated by an average of 1.8 calendar months. AT&T indicated that inspections

reduced the overall cost of software errors by a factor of 10 and that quality improved

by an order of magnitude and productivity increased by 14 percent. Others report
similar benefits. Technical reviews (for design and other technical activities) provide

a demonstrable cost benefit and actually save time.But for many software people, this statement is counterintuitive. ÒReviews take
time,Ó software people argue, Òand we donÕt have the time to spare!Ó They argue that

time is a precious commodity on every software project and the ability to review
Òevery work product in detailÓ absorbs too much time.The examples presented earlier in this section indicate otherwise. More impor-tantly, industry data for software reviews has been collected for more than two

decades and is summarized qualitatively using the graphs illustrated in Figure 15.4.422PART THREEQUALITY MANAGEMENTPlanningRequirementsWithout
inspectionsWith
inspectionsDeploymentDesignCodeTest
Effort
TimeFIGURE15.4Effort
expended with
and without
reviews

Source:Adapted from[Fag86].pre75977_ch15.qxd  11/27/08  5:54 PM  Page 422
Referring to the figure, the effort expended when reviews are used does increase
early in the development of a software increment, but this early investment for
reviews pays dividends because testing and corrective effort is reduced. As impor-
tant, the deployment date for development with reviews is sooner than the deploy-
ment date without reviews. Reviews donÕt take time, they save it!
15.4R
EVIEWS: A FORMALITYSPECTRUMTechnical reviews should be applied with a level of formality that is appropriate for

the product to be built, the project time line, and the people who are doing the work.

Figure 15.5 depicts a reference model for technical reviews [Lai02] that identifies four
characteristics that contribute to the formality with which a review is conducted.Each of the reference model characteristics helps to define the level of reviewformality. The formality of a review increases when (1) distinct roles are explicitly

defined for the reviewers, (2) there is a sufficient amount of planning and prepara-
tion for the review, (3) a distinct structure for the review (including tasks and inter-

nal work products) is defined, and (4) follow-up by the reviewers occurs for any
corrections that are made.To understand the reference model, letÕs assume that youÕve decided to review the
interface design for SafeHomeAssured.com. You can do this in a variety of different

ways that range from relatively casual to extremely rigorous. If you decide that the
casual approach is most appropriate, you ask a few colleagues (peers) to examine

the interface prototype in an effort to uncover potential problems. All of you decide

that there will be no advance preparation, but that you will evaluate the prototype in
a reasonably structured wayÑlooking at layout first, aesthetics next, navigation op-
tions after that, and so on. As the designer, you decide to take a few notes, but noth-

ing formal.CHAPTER 15REVIEW TECHNIQUES423ReviewPlanning& preparationRolesindividualsplayMeetingstructureCorrection &verificationFIGURE15.5Reference
model for
technical
reviews
pre75977_ch15.qxd  11/27/08  5:54 PM  Page 423
Butwhatiftheinterfaceispivotaltothesuccessoftheentireproject?Whatifhuman
livesdependedonaninterfacethatwasergonomicallysound?Youmightdecidethat
amorerigorousapproachwasnecessary.Areviewteamwouldbeformed.Eachper-

sonontheteamwouldhaveaspecificroletoplayÑleadingtheteam,recordingfind-

ings,presentingthematerial,andsoon.Eachreviewerwouldbegivenaccesstothe

workproduct(inthiscase,theinterfaceprototype)beforethereviewandwouldspend

timelookingforerrors,inconsistencies,andomissions.Asetofspecifictaskswould

beconductedbasedonanagendathatwasdevelopedbeforethereviewoccurred.The

resultsofthereviewwouldbeformallyrecorded,andtheteamwoulddecideonthe

statusoftheworkproductbasedontheoutcomeofthereview.Membersofthereview

teammightalsoverifythatthecorrectionsmadeweredoneproperly.
In this book I consider two broad categories of technical reviews: informal reviewsand more formal technical reviews. Within each broad category, a number of differ-

ent approaches can be chosen. These are presented in the sections that follow.
15.5I
NFORMALREVIEWSInformal reviews include a simple desk check of a software engineering work
product with a colleague, a casual meeting (involving more than two people) for

thepurpose of reviewing a work product, or the review-oriented aspects of pair

programming (Chapter 3).A simple desk check
or a casual meetingconducted with a colleague is a review.
However, because there is no advance planning or preparation, no agenda or meet-

ing structure, and no follow-up on the errors that are uncovered, the effectiveness of

such reviews is considerably lower than more formal approaches. But a simple desk
check can and does uncover errors that might otherwise propagate further into the

software process.One way to improve the efficacy of a desk check review is to develop a set of sim-
ple review checklists for each major work product produced by the software team.
The questions posed within the checklist are generic, but they will serve to guide the

reviewers as they check the work product. For example, letÕs reexamine a desk check

of the interface prototype for SafeHomeAssured.com. Rather than simply playingwith the prototype at the designerÕs workstation, the designer and a colleague

examine the prototype using a checklist for interfaces:¥Is the layout designed using standard conventions? Left to right? Top to

bottom?¥Does the presentation need to be scrolled?¥Are color and placement, typeface, and size used effectively?
¥Are all navigation options or functions represented at the same level of
abstraction?¥Are all navigation choices clearly labeled?424PART THREEQUALITY MANAGEMENTpre75977_ch15.qxd  11/27/08  5:54 PM  Page 424
and so on. Any errors or issues noted by the reviewers are recorded by the designerfor resolution at a later time. Desk checks may be scheduled in an ad hoc manner,

or they may be mandated as part of good software engineering practice. In general,
the amount of material to be reviewed is relatively small and the overall time spent

on a desk check spans little more than one or two hours.In Chapter 3, I described pair programming
in the following manner: ÒXP recom-mends that two people work together at one computer workstation to create code
for a story. This provides a mechanism for real-time problem solving (two heads are

often better than one) and real-time quality assurance.ÓPair programming can be characterized as a continuous desk check. Rather thanscheduling a review at some point in time, pair programming encourages continu-

ous review as a work product (design or code) is created. The benefit is immediate
discovery of errors and better work product quality as a consequence.
In their discussion of the efficacy of pair programming, Williams and Kessler
[Wil00] state:
Anecdotal and initial statistical evidence indicates that pair programming is a powerfultechnique for productively generating high quality software products. The pair works and
shares ideas together to tackle the complexities of software development. They continu-
ously perform inspections on each otherÕs artifacts leading to the earliest, most efficient

form of defect removal possible. In addition, they keep each other intently focused on the

task at hand.Some software engineers argue that the inherent redundancy built into pair pro-gramming is wasteful of resources. After all, why assign two people to a job that one
person can accomplish? The answer to this question can be found in Section 15.3.2.
If the quality of the work product produced as a consequence of pair programming
is significantly better than the work of an individual, the quality-related savings can
more than justify the ÒredundancyÓ implied by pair programming.CHAPTER 15REVIEW TECHNIQUES425Review ChecklistsEven when reviews are well organized andproperly conducted, itÕs not a bad idea to
provide reviewers with a Òcrib sheet.Ó That is, itÕs
worthwhile to have a checklist that provides each reviewer

with the questions that should be asked about the specific
work product that is undergoing review.
One of the most comprehensive collections of reviewchecklists has been developed by NASA at the Goddard
Space Flight Center and is available at http://
sw-assurance.gsfc.nasa.gov/disciplines/
quality/index.phpOther useful technical review checklists have also beenproposed by:Process Impact (www.processimpact.com/
pr_goodies.shtml)Software Dioxide(www.softwaredioxide.com/
Channels/ConView.asp?id=6309
)Macadamian(www.macadamian.com
)The Open Group Architecture Review Checklist
(www.opengroup.org/architecture/

togaf7-doc/arch/p4/comp/clists/syseng.htm)DFAS
[downloadable] (www.dfas.mil/
technology/pal/ssps/docstds/spm036.doc)INFOpre75977_ch15.qxd  11/27/08  5:54 PM  Page 425
15.6F
ORMALTECHNICALREVIEWSA formal technical review
(FTR) is a software quality control activity performed bysoftware engineers (and others). The objectives of an FTR are: (1) to uncover errors
in function, logic, or implementation for any representation of the software; (2) to

verify that the software under review meets its requirements; (3) to ensure that the
software has been represented according to predefined standards; (4) to achieve
software that is developed in a uniform manner; and (5) to make projects more man-
ageable. In addition, the FTR serves as a training ground, enabling junior engineers
to observe different approaches to software analysis, design, and implementation.
The FTR also serves to promote backup and continuity because a number of people
become familiar with parts of the software that they may not have otherwise seen.The FTR is actually a class of reviews that includes walkthroughsand inspections.Each FTR is conducted as a meeting and will be successful only if it is properly
planned, controlled, and attended. In the sections that follow, guidelines similar to

those for a walkthrough are presented as a representative formal technical review.

If you have interest in software inspections, as well as additional information on
walkthroughs, see [Rad02], [Wie02], or [Fre90].
15.6.1The Review Meeting
Regardless of the FTR format that is chosen, every review meeting should abide by
the following constraints:¥Between three and five people (typically) should be involved in the review.
¥Advance preparation should occur but should require no more than two
hours of work for each person.¥The duration of the review meeting should be less than two hours.Given these constraints, it should be obvious that an FTR focuses on a specific (and
small) part of the overall software. For example, rather than attempting to review an

entire design, walkthroughs are conducted for each component or small group of
components. By narrowing the focus, the FTR has a higher likelihood of uncovering

errors.The focus of the FTR is on a work product (e.g., a portion of a requirements model,a detailed component design, source code for a component). The individual who has
developed the work productÑthe producerÑinforms the project leader that the work
product is complete and that a review is required. The project leader contacts a
review leader,
who evaluates the product for readiness, generates copies of productmaterials, and distributes them to two or three reviewersfor advance preparation.Each reviewer is expected to spend between one and two hours reviewing the prod-
uct, making notes, and otherwise becoming familiar with the work. Concurrently, the

review leader also reviews the product and establishes an agenda for the review
meeting, which is typically scheduled for the next day.
426PART THREEQUALITY MANAGEMENTuote:ÒThere is no urgeso great as for one
man to edit
another manÕs

work.ÓMarkTwain
WebRef
The NASA SATC
Formal Inspection

Guidebookcan bedownloaded from
satc.gsfc.nasa
.gov/Documents/

fi/gdb/fi.pdf.An FTR focuses on arelatively small portion

of a work product.pre75977_ch15.qxd  11/27/08  5:54 PM  Page 426
The review meeting is attended by the review leader, all reviewers, and the pro-
ducer. One of the reviewers takes on the role of a
recorder,
that is, the individual whorecords (in writing) all important issues raised during the review. The FTR begins
with an introduction of the agenda and a brief introduction by the producer. The pro-

ducer then proceeds to Òwalk throughÓ the work product, explaining the material,
while reviewers raise issues based on their advance preparation. When valid prob-
lems or errors are discovered, the recorder notes each.
At the end of the review, all attendees of the FTR must decide whether to: (1) ac-
cept the product without further modification, (2) reject the product due to severe er-
rors (once corrected, another review must be performed), or (3) accept the product
provisionally (minor errors have been encountered and must be corrected, but no

additional review will be required). After the decision is made, all FTR attendees

complete a sign-off, indicating their participation in the review and their concur-
rence with the review teamÕs findings.
15.6.2Review Reporting and Record Keeping
During the FTR, a reviewer (the recorder) actively records all issues that have been
raised. These are summarized at the end of the review meeting, and a review issueslistis produced. In addition, a formal technical review summary report
is completed. Areview summary report answers three questions:1.What was reviewed?2.Who reviewed it?3.What were the findings and conclusions?The review summary report is a single page form (with possible attachments). It be-
comes part of the project historical record and may be distributed to the project
leader and other interested parties.The review issues list serves two purposes: (1) to identify problem areas withinthe product and (2) to serve as an action item checklist that guides the producer as
corrections are made. An issues list is normally attached to the summary report.You should establish a follow-up procedure to ensure that items on the issues list
have been properly corrected. Unless this is done, it is possible that issues raised can

Òfall between the cracks.Ó One approach is to assign the responsibility for follow-up
to the review leader.
15.6.3Review Guidelines
Guidelines for conducting formal technical reviews must be established in advance,

distributed to all reviewers, agreed upon, and then followed. A review that is un-
controlled can often be worse than no review at all. The following represents a min-
imum set of guidelines for formal technical reviews:1.Review the product, not the producer.
An FTR involves people and egos. Con-
ducted properly, the FTR should leave all participants with a warm feeling of
CHAPTER 15REVIEW TECHNIQUES427In some situations, itÕs
a good idea to have
someone other than
the producer walk
through the product
undergoing review.

This leads to a literal
interpretation of the
work product and
better error recogni-

tion.DonÕt point out errors
harshly. One way to be

gentle is to ask a
question that enables
the producer to
discover the error.
pre75977_ch15.qxd  11/27/08  5:54 PM  Page 427
accomplishment. Conducted improperly, the FTR can take on the aura of an
inquisition. Errors should be pointed out gently; the tone of the meeting
should be loose and constructive; the intent should not be to embarrass or
belittle. The review leader should conduct the review meeting to ensure that
the proper tone and attitude are maintained and should immediately halt a
review that has gotten out of control.2.Set an agenda and maintain it.One of the key maladies of meetings of alltypes is drift. An FTR must be kept on track and on schedule. The review
leader is chartered with the responsibility for maintaining the meeting sched-
ule and should not be afraid to nudge people when drift sets in.3.Limit debate and rebuttal.When an issue is raised by a reviewer, there may
not be universal agreement on its impact. Rather than spending time debat-
ing the question, the issue should be recorded for further discussion off-line.4.Enunciate problem areas, but donÕt attempt to solve every problem noted.
A re-view is not a problem-solving session. The solution of a problem can often
be accomplished by the producer alone or with the help of only one other in-
dividual. Problem solving should be postponed until after the review meeting.5.Take written notes.
It is sometimes a good idea for the recorder to make noteson a wall board, so that wording and priorities can be assessed by other re-
viewers as information is recorded. Alternatively, notes may be entered di-

rectly into a notebook computer.
6.Limit the number of participants and insist upon advance preparation.
Two
heads are better than one, but 14 are not necessarily better than 4. Keep the

number of people involved to the necessary minimum. However, all review

team members must prepare in advance. Written comments should be
solicited by the review leader (providing an indication that the reviewer

hasreviewed the material).
7.Develop a checklist for each product that is likely to be reviewed.
A checklisthelps the review leader to structure the FTR meeting and helps each reviewer
to focus on important issues. Checklists should be developed for analysis,
design, code, and even testing work products.
8.Allocate resources and schedule time for FTRs.
For reviews to be effective, they
should be scheduled as tasks during the software process. In addition, time
should be scheduled for the inevitable modifications that will occur as the
result of an FTR.9.Conduct meaningful training for all reviewers.
To be effective all review partici-
pants should receive some formal training. The training should stress both
process-related issues and the human psychological side of reviews. Freed-
man and Weinberg [Fre90] estimate a one-month learning curve for every

20people who are to participate effectively in reviews.
428PART THREEQUALITY MANAGEMENTuote:ÒA meeting is toooften an event in
which minutes are
taken and hours
are wasted.ÓAuthor unknownuote:ÒIt is one of themost beautiful
compensations of
life, that no man
can sincerely try to

help another
without helping
himself.ÓRalph Waldo
Emersonpre75977_ch15.qxd  11/27/08  5:54 PM  Page 428
10.Review your early reviews.Debriefing can be beneficial in uncovering prob-
lems with the review process itself. The very first product to be reviewedshould be the review guidelines themselves.Because many variables (e.g., number of participants, type of work products, tim-ing and length, specific review approach) have an impact on a successful review, a

software organization should experiment to determine what approach works best in
a local context.15.6.4Sample-Driven Reviews
In an ideal setting, every software engineering work product would undergo a for-
mal technical review. In the real word of software projects, resources are limited and

time is short. As a consequence, reviews are often skipped, even though their value

as a quality control mechanism is recognized.Thelin and his colleagues [The01] suggest a sample-driven review process inwhich samples of all software engineering work products are inspected to determine
which work products are most error prone. Full FTR resources are then focused only
on those work products that are likely (based on data collected during sampling) to
be error prone.To be effective, the sample-driven review process must attempt to quantify those
work products that are primary targets for full FTRs. To accomplish this, the follow-

ing steps are suggested [The01]:1.Inspect a fraction aiof each software work product i.Record the number offaults fifound within ai.2.Develop a gross estimate of the number of faults within work product ibymultiplying fiby 1/ai.3.Sort the work products in descending order according to the gross estimate
of the number of faults in each.4.Focus available review resources on those work products that have the high-
est estimated number of faults.The fraction of the work product that is sampled must be representative of the work
product as a whole and large enough to be meaningful to the reviewers who do the
sampling. As aiincreases, the likelihood that the sample is a valid representation ofthe work product also increases. However, the resources required to do sampling

also increase. A software engineering team must establish the best value for aiforthe types of work products produced.3CHAPTER 15REVIEW TECHNIQUES4293Thelin and his colleagues have conducted a detailed simulation that can assist in making this
determination. See [The01] for details.Reviews take time, butitÕs time well spend.

However, if time is

short and you have no

other option, do not
dispense with reviews.
Rather, use sample-

driven reviews.pre75977_ch15.qxd  11/27/08  5:54 PM  Page 429
15.7S
UMMARYThe intent of every technical review is to find errors and uncover issues that would have
a negative impact on the software to be deployed. The sooner an error is uncovered and

corrected, the less likely that error will propagate to other software engineering work
products and amplify itself, resulting in significantly more effort to correct it.To determine whether quality control activities are working, a set of metrics
should be collected. Review metrics focus on the effort required to conduct the re-
view and the types and severity of errors uncovered during the review. Once metrics

data are collected, they can be used to assess the efficacy of the reviews you do con-
duct. Industry data indicates that reviews provide a significant return on investment.
A reference model for review formality identifies the roles people play, planning
and preparation, meeting structure, correction approach, and verification as the

characteristics that indicate the degree of formality with which a review is con-
ducted. Informal reviews are casual in nature, but can still be used effectively to un-

cover errors. Formal reviews are more structured and have the highest probability of

leading to high-quality software.430PART THREEQUALITY MANAGEMENTQuality IssuesThe scene:Doug MillerÕs office as the
SafeHomesoftware project begins.The players:Doug Miller (manager of the SafeHomesoftware engineering team) and other members of theproduct software engineering team.The conversation:
Doug:I know we didnÕt spend time developing a quality
plan for this project, but weÕre already into it and wehave to consider quality É right?Jamie:Sure. WeÕve already decided that as we develop the
requirements model [Chapters 6 and 7], Ed has committed todevelop a testing procedure for each requirement.Doug:ThatÕs really good, but weÕre not going to wait
until testing to evaluate quality, are we?

Vinod:
No! Of course not. WeÕve got reviews scheduled
into the project plan for this software increment. WeÕll
begin quality control with the reviews.Jamie:IÕm a bit concerned that we wonÕt have enough
time to conduct all the reviews. In fact, I know we wonÕt.

Doug:Hmmm. So what do you propose?Jamie:I say we select those elements of the requirementsand design model that are most critical to SafeHomeandreview them.
Vinod:
But what if we miss something in a part of the
model we donÕt review?

Shakira:I read something about a sampling technique[Section 15.6.4] that might help us target candidates forreview. (Shakira explains the approach.)
Jamie:Maybe É but IÕm not sure we even have time tosample every element of the models.

Vinod:
What do you want us to do, Doug?Doug:LetÕs steal something from Extreme Programming
[Chapter 3]. WeÕll develop the elements of each model in
pairsÑtwo peopleÑand conduct an informal review of

each as we go. WeÕll then target ÒcriticalÓ elements for a

more formal team review, but keep those reviews to a

minimum. That way, everything gets looked at by more

than one set of eyes, but we still maintain our delivery

dates.Jamie:That means weÕre going to have to revise theschedule.
Doug:So be it. Quality trumps schedule on this project.SAFEHOMEpre75977_ch15.qxd  11/27/08  5:54 PM  Page 430
Informal reviews are characterized by minimal planning and preparation and littlerecord keeping. Desk checks and pair programming fall into the informal review category.
A formal technical review is a stylized meeting that has been shown to be ex-tremely effective in uncovering errors. Walkthroughs and inspections establish de-
fined roles for each reviewer, encourage planning and advance preparation, require

the application of defined review guidelines, and mandate record keeping and sta-
tus reporting. Sample-driven reviews can be used when it is not possible to conduct
formal technical reviews for all work products.PROBLEMSAND
POINTSTO
PONDER15.1. Explain the difference between an errorand a defect.15.2.Why canÕt we just wait until testing to find and correct all software errors?
15.3.Assume that 10 errors have been introduced in the requirements model and that eacherror will be amplified by a factor of 2:1 into design and an addition 20 design errors are intro-duced and then amplified 1.5:1 into code where an additional 30 errors are introduced. Assume
further that all unit testing will find 30 percent of all errors, integration will find 30 percent of
the remaining errors, and validation tests will find 50 percent of the remaining errors. No
reviews are conducted. How many errors will be released to the field.15.4.Reconsider the situation described in Problem 15.3, but now assume that requirements,design, and code reviews are conducted and are 60 percent effective in uncovering all errors at
that step. How many errors will be released to the field?15.5.Reconsider the situation described in Problems 15.3 and 15.4. If each of the errorsreleased to the field costs $4,800 to find and correct and each error found in review costs $240to find and correct, how much money is saved by conducting reviews?15.6.Describe the meaning of Figure 15.4 in your own words.15.7.Which of the reference model characteristics do you think has the strongest bearing onreview formality? Explain why.

15.8.Can you think of a few instances in which a desk check might create problems rather thanprovide benefits?

15.9.A formal technical review is effective only if everyone has prepared in advance. How do yourecognize a review participant who has not prepared? What do you do if youÕre the review leader?
15.10.Considering all of the review guidelines presented in Section 15.6.3, which do you thinkis most important and why?FURTHER
READINGSAND
INFORMATION
SOURCESThere have been relatively few books written on software reviews. Recent editions that provide
worthwhile guidance include books by Wong (
Modern Software Review,
IRM Press, 2006), Radice(High Quality, Low Cost Software Inspections,
Paradoxicon Publishers, 2002), Wiegers (
PeerReviews in Software: A Practical Guide
, Addison-Wesley, 2001), and Gilb and Graham (
SoftwareInspection,Addison-Wesley, 1993). Freedman and Weinberg (
Handbook of Walkthroughs,
Inspections and Technical Reviews,
Dorset House, 1990) remains a classic text and continues to
provide worthwhile information about this important subject.
A wide variety of information sources on software reviews is available on the Internet.Anup-to-date list of World Wide Web references relevant to software reviews can be found

atthe SEPA website: 
www.mhhe.com/engcs/compsci/pressman/professional/olc/

ser.htm
.CHAPTER 15REVIEW TECHNIQUES431pre75977_ch15.qxd  11/27/08  5:54 PM  Page 431
The software engineering approach described in this book works toward asingle goal: to produce on-time, high-quality software. Yet many readers

will be challenged by the question: ÒWhat is software quality?ÓPhilip Crosby [Cro79], in his landmark book on quality, provides a wry answer
to this question:The problem of quality management is not what people donÕt know about it. The prob-
lem is what they think they do know. . . .
In this regard, quality has much in common with sex. Everybody is for it. (Undercertain conditions, of course.) Everyone feels they understand it. (Even though they
wouldnÕt want to explain it.) Everyone thinks execution is only a matter of following

natural inclinations. (After all, we do get along somehow.) And, of course, most peo-

ple feel that problems in these areas are caused by other people. (If only they would
take the time to do things right.)432CHAPTER16SOFTWARE
QUALITYASSURANCEKEYCONCEPTSformal approaches . . . . .438
goals . . . . . . . . .436
ISO 9001:2000standard . . . . . .445
Six Sigma . . . . . .441

softwarereliability . . . . . .442
softwaresafety . . . . . . . .443
SQAelements of . . .434

plan . . . . . . . . .445

statistical . . . . .439

tasks . . . . . . . .436
What is it?ItÕs not enough to talk the
talk by saying that software quality isimportant. You have to (1) explicitly

define what is meant when you sayÒsoftware quality,Ó (2) create a set of activities that

will help ensure that every software engineering

work product exhibits high quality, (3) perform

quality control and assurance activities on every

software project, (4) use metrics to develop strate-
gies for improving your software process and, as
a consequence, the quality of the end product.Who does it?Everyone involved in the software
engineering process is responsible for quality.
Why is it important?
You can do it right, or you
can do it over again. If a software team stresses
quality in all software engineering activities, it
reduces the amount of rework that it must do.
That results in lower costs, and more importantly,

improved time-to-market.What are the steps?Before software qualityassurance (SQA) activities can be initiated, it isQUICKLOOKimportant to define 
software qualityat a num-ber of different levels of abstraction. Once you

understand what quality is, a software team
must identify a set of SQA activities that will fil-
ter errors out of work products before they are
passed on.What is the work product?
A Software QualityAssurance Plan is created to define a software
teamÕs SQA strategy. During modeling and cod-

ing, the primary SQA work product is the output

of technical reviews (Chapter 15). During testing
(Chapters 17 through 20), test plans and proce-
dures are produced. Other work products asso-
ciated with process improvement may also be
generated.How do I ensure that IÕve done it right?Finderrors before they become defects! That is,
workto improve your defect removal efficiency

(Chapter 23), thereby reducing the amount
ofrework that your software team has to

perform.
pre75977_ch16.qxd  11/27/08  6:07 PM  Page 432
Indeed, quality is a challenging conceptÑone that I addressed in some detail inChapter 14.1Some software developers continue to believe that software quality is somethingyou begin to worry about after code has been generated. Nothing could be further
from the truth! Software quality assurance
(often called quality management) is an um-brella activity (Chapter 2) that is applied throughout the software process.Software quality assurance (SQA) encompasses (1) an SQA process, (2) specificquality assurance and quality control tasks (including technical reviews and a multi-
tiered testing strategy), (3) effective software engineering practice (methods and
tools), (4) control of all software work products and the changes made to them
(Chapter 22), (5) a procedure to ensure compliance with software development stan-
dards (when applicable), and (6) measurement and reporting mechanisms.In this chapter, I focus on the management issues and the process-specific activ-
ities that enable a software organization to ensure that it does Òthe right things at the
right time in the right way.Ó
16.1B
ACKGROUNDISSUESQuality control and assurance are essential activities for any business that producesproducts to be used by others. Prior to the twentieth century, quality control was the

sole responsibility of the craftsperson who built a product. As time passed and mass
production techniques became commonplace, quality control became an activity

performed by people other than the ones who built the product.The first formal quality assurance and control function was introduced at BellLabs in 1916 and spread rapidly throughout the manufacturing world. During the
1940s, more formal approaches to quality control were suggested. These relied on
measurement and continuous process improvement [Dem86] as key elements of

quality management.Today, every company has mechanisms to ensure quality in its products. In fact,
explicit statements of a companyÕs concern for quality have become a marketing

ploy during the past few decades.The history of quality assurance in software development parallels the history ofquality in hardware manufacturing. During the early days of computing (1950s and
1960s), quality was the sole responsibility of the programmer. Standards for quality

assurance for software were introduced in military contract software development
during the 1970s and have spread rapidly into software development in the com-
mercial world [IEE93]. Extending the definition presented earlier, software quality

assurance is a Òplanned and systematic pattern of actionsÓ [Sch98c] that are required
to ensure high quality in software. The scope of quality assurance responsibility
might best be characterized by paraphrasing a once-popular automobile commercial:
ÒQuality Is Job #1.Ó The implication for software is that many different con
stituenciesCHAPTER 16SOFTWARE QUALITY ASSURANCE 4331If you have not read Chapter 14, you should do so now.
uote:ÒYou made too
many wrong
mistakes.ÓYogiBerra
pre75977_ch16.qxd  11/27/08  6:07 PM  Page 433
434PART THREEQUALITY MANAGEMENThave software quality assurance responsibilityÑsoftware engineers, project man-agers, customers, salespeople, and the individuals who serve within an SQA group.
The SQA group serves as the customerÕs in-house representative. That is, the
people who perform SQA must look at the software from the customerÕs point of

view. Does the software adequately meet the quality factors noted in Chapter 14? Has

software development been conducted according to preestablished standards? Have
technical disciplines properly performed their roles as part of the SQA activity? The
SQA group attempts to answer these and other questions to ensure that software
quality is maintained.16.2E
LEMENTSOF
SOFTWARE
QUALITYASSURANCESoftware quality assurance encompasses a broad range of concerns and activities
that focus on the management of software quality. These can be summarized in the

following manner [Hor03]:Standards.
The IEEE, ISO, and other standards organizations have pro-
duced a broad array of software engineering standards and related docu-
ments. Standards may be adopted voluntarily by a software engineering
organization or imposed by the customer or other stakeholders. The job of
SQA is to ensure that standards that have been adopted are followed and
that all work products conform to them.Reviews and audits.
Technical reviews are a quality control activity
performed by software engineers for software engineers (Chapter 15).Their intent is to uncover errors. Audits are a type of review performed by

SQA personnel with the intent of ensuring that quality guidelines are being
followed for software engineering work. For example, an audit of the

review process might be conducted to ensure that reviews are being
performed in a manner that will lead to the highest likelihood of
uncovering errors.
Testing.
Software testing (Chapters 17 through 20) is a quality control func-tion that has one primary goalÑto find errors. The job of SQA is to ensurethat testing is properly planned and efficiently conducted so that it has the
highest likelihood of achieving its primary goal.Error/defect collection and analysis.
The only way to improve is to
measure how youÕre doing. SQA collects and analyzes error and defect datato better understand how errors are introduced and what software engineer-
ing activities are best suited to eliminating them.Change management.Change is one of the most disruptive aspects ofany software project. If it is not properly managed, change can lead to con-fusion, and confusion almost always leads to poor quality. SQA ensures that

adequate change management practices (Chapter 22) have been instituted.WebRef
An in-depth discussionof SQA, including
awide array of

definitions, can
beobtained at

www.swqual

.com/newsletter/
vol2/no1/
vol2no1.html.pre75977_ch16.qxd  11/27/08  6:07 PM  Page 434
Education.Every software organization wants to improve its software
engineering practices. A key contributor to improvement is education of soft-
ware engineers, their managers, and other stakeholders. The SQA organiza-
tion takes the lead in software process improvement (Chapter 30) and is a

key proponent and sponsor of educational programs.Vendor management.
Three categories of software are acquired fromexternal software vendorsÑshrink-wrapped packages
(e.g., Microsoft Office),a tailored shell[Hor03] that provides a basic skeletal structure that is custom
tailored to the needs of a purchaser, and 
contracted software
that is customdesigned and constructed from specifications provided by the customer
organization. The job of the SQA organization is to ensure that high-quality
software results by suggesting specific quality practices that the vendor
should follow (when possible), and incorporating quality mandates as part of
any contract with an external vendor.
Security management.With the increase in cyber crime and new govern-
ment regulations regarding privacy, every software organization should insti-
tute policies that protect data at all levels, establish firewall protection for
WebApps, and ensure that software has not been tampered with internally.

SQA ensures that appropriate process and technology are used to achieve
software security.
Safety.
Because software is almost always a pivotal component of human-rated systems (e.g., automotive or aircraft applications), the impact of hiddendefects can be catastrophic. SQA may be responsible for assessing the impact
of software failure and for initiating those steps required to reduce risk.Risk management.Although the analysis and mitigation of risk (Chapter28) is the concern of software engineers, the SQA organization ensures thatrisk management activities are properly conducted and that risk-related
contingency plans have been established.In addition to each of these concerns and activities, SQA works to ensure that soft-
ware support activities (e.g., maintenance, help lines, documentation, and manuals)

are conducted or produced with quality as a dominant concern.CHAPTER 16SOFTWARE QUALITY ASSURANCE 435uote:ÒExcellence is theunlimited ability to
improve the quality
of what you have
to offer.Ó
RickPetin
Quality Management Resources
There are dozens of quality managementresources available on the Web, including
professional societies, standards organizations, andgeneral information sources. The sites that follow provide

agood starting point:
American Society for Quality (ASQ) Software Divisionwww.asq.org/software
Association for Computer Machinery
www.acm.org
Data and Analysis Center for Software (DACS)www.dacs.dtic.mil/
International Organization for Standardization (ISO)
www.iso.ch
ISO SPICEwww.isospice.com
INFOpre75977_ch16.qxd  11/27/08  6:07 PM  Page 435
16.3SQA T
ASKS, GOALS, ANDMETRICSSoftware quality assurance is composed of a variety of tasks associated with two dif-ferent constituenciesÑthe software engineers who do technical work and an SQA
group that has responsibility for quality assurance planning, oversight, record keep-

ing, analysis, and reporting.Software engineers address quality (and perform quality control activities) byapplying solid technical methods and measures, conducting technical reviews, and
performing well-planned software testing.16.3.1SQA Tasks
The charter of the SQA group is to assist the software team in achieving a high-
quality end product. The Software Engineering Institute recommends a set of SQA
actions that address quality assurance planning, oversight, record keeping, analysis,

and reporting. These actions are performed (or facilitated) by an independent SQA
group that:Prepares an SQA plan for a project.
The plan is developed as part ofproject planning and is reviewed by all stakeholders. Quality assurance
actionsperformed by the software engineering team and the SQA group aregoverned by the plan. The plan identifies evaluations to be performed,

audits and reviews to be conducted, standards that are applicable to the
project, procedures for error reporting and tracking, work products that
areproduced by the SQA group, and feedback that will be provided to the

software team.Participates in the development of the projectÕs software process
description.The software team selects a process for the work to beperformed. The SQA group reviews the process description for compli-
ancewith organizational policy, internal software standards, externally

imposed standards (e.g., ISO-9001), and other parts of the software
projectplan.
436PART THREEQUALITY MANAGEMENTMalcolm Baldridge National Quality Award
www.quality.nist.gov
Software Engineering Institutewww.sei.cmu.edu/
Software Testing and Quality Engineering
www.stickyminds.com
Six Sigma Resourceswww.isixsigma.com/
www.asq.org/sixsigma/
TickIT International: Quality certification topics
www.tickit.org/international.htm
Total Quality Management (TQM)
Generalinformation:
www.gslis.utexas.edu/~rpollock/tqm.html
Articles: 
www.work911.com/tqmarticles.htm

Glossary: 
www.quality.org/TQM-MSI/TQM-glossary

.htmlWhat is therole of anSQA group??pre75977_ch16.qxd  11/27/08  6:07 PM  Page 436
Reviewssoftwareengineeringactivitiestoverifycompliancewiththe
definedsoftwareprocess.
TheSQAgroupidentifies,documents,andtracks
deviationsfromtheprocessandverifiesthatcorrectionshavebeenmade.
Audits designated software work products to verify compliance with
those defined as part of the software process.
The SQA group reviewsselected work products; identifies, documents, and tracks deviations; verifies
that corrections have been made; and periodically reports the results of its
work to the project manager.
Ensures that deviations in software work and work products are
documented and handled according to a documented procedure.

Deviations may be encountered in the project plan, process description,
applicable standards, or software engineering work products.Records any noncompliance and reports to senior management.
Noncompliance items are tracked until they are resolved.In addition to these actions, the SQA group coordinates the control and management
of change (Chapter 22) and helps to collect and analyze software metrics.16.3.2Goals, Attributes, and Metrics
The SQA actions described in the preceding section are performed to achieve a set
of pragmatic goals:Requirements quality.
The correctness, completeness, and consistencyofthe requirements model will have a strong influence on the quality of all

work products that follow. SQA must ensure that the software team has

properly reviewed the requirements model to achieve a high level of quality.
Design quality.
Every element of the design model should be assessed bythe software team to ensure that it exhibits high quality and that the designitself conforms to requirements. SQA looks for attributes of the design that
are indicators of quality.
Code quality.
Source code and related work products (e.g., other descrip-tive information) must conform to local coding standards and exhibit charac-teristics that will facilitate maintainability. SQA should isolate those attributes

that allow a reasonable analysis of the quality of code.Quality control effectiveness.
A software team should apply limited re-sources in a way that has the highest likelihood of achieving a high-qualityresult. SQA analyzes the allocation of resources for reviews and testing to
assess whether they are being allocated in the most effective manner.
Figure 16.1(adapted from [Hya96]) identifies the attributes that are indicators for
the existence of quality for each of the goals discussed. Metrics that can be used to
indicate the relative strength of an attribute are also shown.CHAPTER 16SOFTWARE QUALITY ASSURANCE 437uote:ÒQuality is neveran accident; it is
always the result of
high intention,
sincere effort,
intelligent direction
and skillful
execution; it
represents the wise
choice of many
alternatives.ÓWilliamA.
Fosterpre75977_ch16.qxd  11/27/08  6:07 PM  Page 437
438PART THREEQUALITY MANAGEMENTFIGURE16.1GoalAttributeMetricRequirement qualityAmbiguityNumber of ambiguous modifiers (e.g., many, large,
human-friendly)CompletenessNumber of TBA, TBDUnderstandabilityNumber of sections/subsections
Volatility
Number of changes per requirementTime (by activity) when change is requested
Traceability
Number of requirements not traceable to design/codeModel clarityNumber of UML models
Number of descriptive pages per model
Number of UML errorsDesign qualityArchitectural integrityExistence of architectural model

Component completenessNumber of components that trace to architectural model
Complexity of procedural designInterface complexityAverage number of pick to get to a typical function or content
Layout appropriatenessPatterns
Number of patterns used
Code qualityComplexityCyclomatic complexityMaintainabilityDesign factors (Chapter 8)UnderstandabilityPercent internal comments
Variable naming conventions
ReusabilityPercent reused componentsDocumentationReadability indexQC effectiveness
Resource allocationStaff hour percentage per activity

Completion rateActual vs. budgeted completion timeReview effectivenessSee review metrics (Chapter 14)

Testing effectivenessNumber of errors found and criticality
Effort required to correct an error
Origin of errorSoftware quality goals, attributes, and metrics
Source:Adapted from [Hya96].16.4F
ORMALAPPROACHESTO
SQAIn the preceding sections, I have argued that software quality is everyoneÕs job and
that it can be achieved through competent software engineering practice as well as
through the application of technical reviews, a multi-tiered testing strategy, better

control of software work products and the changes made to them, and the applica-
tion of accepted software engineering standards. In addition, quality can be definedpre75977_ch16.qxd  11/27/08  6:07 PM  Page 438
in terms of a broad array of quality attributes and measured (indirectly) using avariety of indices and metrics.Over the past three decades, a small, but vocal, segment of the software engineer-ing community has argued that a more formal approach to software quality assurance
is required. It can be argued that a computer program is a mathematical object. A rig-
orous syntax and semantics can be defined for every programming language, and a

rigorous approach to the specification of software requirements (Chapter 21) is avail-
able. If the requirements model (specification) and the programming language can be
represented in a rigorous manner, it should be possible to apply mathematic proof of

correctness to demonstrate that a program conforms exactly to its specifications.Attempts to prove programs correct are not new. Dijkstra [Dij76a] and Linger,
Mills, and Witt [Lin79], among others, advocated proofs of program correctness and

tied these to the use of structured programming concepts (Chapter 10).16.5S
TATISTICAL
SOFTWARE
QUALITYASSURANCEStatistical quality assurance reflects a growing trend throughout industry to become
more quantitative about quality. For software, statistical quality assurance implies

the following steps:1.Information about software errors and defects is collected and categorized.2.An attempt is made to trace each error and defect to its underlying cause
(e.g., nonconformance to specifications, design error, violation of standards,

poor communication with the customer).3.Using the Pareto principle (80 percent of the defects can be traced to 20 per-
cent of all possible causes), isolate the 20 percent (the vital few).4.Once the vital few causes have been identified, move to correct the problems

that have caused the errors and defects.This relatively simple concept represents an important step toward the creation of
an adaptive software process in which changes are made to improve those elements

of the process that introduce error.
16.5.1A Generic Example
To illustrate the use of statistical methods for software engineering work, assume

that a software engineering organization collects information on errors and defects
for a period of one year. Some of the errors are uncovered as software is being de-

veloped. Others (defects) are encountered after the software has been released to its
end users. Although hundreds of different problems are uncovered, all can be

tracked to one (or more) of the following causes:¥Incomplete or erroneous specifications (IES)¥Misinterpretation of customer communication (MCC)CHAPTER 16SOFTWARE QUALITY ASSURANCE 439WebRef
Useful information on
SQA and formal quality

methods can be found
at www.gslis

.utexas.edu/
~rpollock/tqm
.html.What stepsare requiredto perform
statistical SQA??uote:ÒA statistical
analysis, properly
conducted, is a
delicate dissection
of uncertainties,
asurgery of

suppositions.ÓM.J.Moroney
pre75977_ch16.qxd  11/27/08  6:07 PM  Page 439
¥Intentional deviation from specifications (IDS)¥Violation of programming standards (VPS)
¥Error in data representation (EDR)¥Inconsistent component interface (ICI)¥Error in design logic (EDL)¥Incomplete or erroneous testing (IET)¥Inaccurate or incomplete documentation (IID)¥Error in programming language translation of design (PLT)
¥Ambiguous or inconsistent human/computer interface (HCI)¥Miscellaneous (MIS)To apply statistical SQA, the table in Figure 16.2is built. The table indicates that IES,
MCC, and EDR are the vital few causes that account for 53 percent of all errors. It
should be noted, however, that IES, EDR, PLT, and EDL would be selected as the vital

few causes if only serious errors are considered. Once the vital few causes are
determined, the software engineering organization can begin corrective action. For
example, to correct MCC, you might implement requirements gathering techniques

(Chapter 5) to improve the quality of customer communication and specifications. To

improve EDR, you might acquire tools for data modeling and perform more stringent

data design reviews.It is important to note that corrective action focuses primarily on the vital few. As
the vital few causes are corrected, new candidates pop to the top of the stack.Statistical quality assurance techniques for software have been shown to provide
substantial quality improvement [Art97]. In some cases, software organizations
440PART THREEQUALITY MANAGEMENTTotal
SeriousModerateMinorErrorNo.
%No.
%No.
%No.
%IES20522%3427%6818%10324%
MCC15617%12
9%6818%7617%
IDS485%11%24
6%23
5%VPS253%00%15
4%10
2%EDR13014%2620%6818%36
8%ICI586%97%18
5%31
7%EDL455%1411%12
3%19
4%IET9510%12
9%35
9%4811%
IID364%22%20
5%14
3%PLT
60
6%1512%19
5%26
6%HCI283%32%17
4%82%MIS566%00%15
4%41
9%Totals942100%128100%379100%435100%
FIGURE16.2Data collectionfor statistical
SQAuote:Ò20 percent of thecode has 80
percent of the
errors. Find them,
fix them!ÓLowellArthur
pre75977_ch16.qxd  11/27/08  6:07 PM  Page 440
have achieved a 50 percent reduction per year in defects after applying thesetechniques.The application of the statistical SQA and the Pareto principle can be summarizedin a single sentence: Spend your time focusing on things that really matter, but first be

sure that you understand what really matters!16.5.2Six Sigma for Software Engineering
SixSigma
isthemostwidelyusedstrategyforstatisticalqualityassuranceinindus-
trytoday.OriginallypopularizedbyMotorolainthe1980s,theSixSigmastrategy

Òisarigorousanddisciplinedmethodologythatusesdataandstatisticalanalysisto

measureandimproveacompanyÕsoperationalperformancebyidentifyingandelim-

inatingdefectsÕinmanufacturingandservice-relatedprocessesÓ[ISI08].Theterm

SixSigmaisderivedfromsixstandarddeviationsÑ3.4instances(defects)permillion

occurrencesÑimplyinganextremelyhighqualitystandard.TheSixSigmamethod-

ologydefinesthreecoresteps:
¥Definecustomer requirements and deliverables and project goals via well-defined methods of customer communication.¥Measurethe existing process and its output to determine current qualityperformance (collect defect metrics).¥Analyzedefect metrics and determine the vital few causes.If an existing software process is in place, but improvement is required, Six Sigma

suggests two additional steps:¥Improve
the process by eliminating the root causes of defects.¥Controlthe process to ensure that future work does not reintroduce thecauses of defects.These core and additional steps are sometimes referred to as the DMAIC (define,

measure, analyze, improve, and control) method.
If an organization is developing a software process (rather than improving an
existing process), the core steps are augmented as follows:¥Designthe process to (1) avoid the root causes of defects and (2) to meetcustomer requirements.¥Verify
that the process model will, in fact, avoid defects and meet customerrequirements.This variation is sometimes called the DMADV (define, measure, analyze, design,

and verify) method.A comprehensive discussion of Six Sigma is best left to resources dedicated to thesubject. If you have further interest, see [ISI08], [Pyz03], and [Sne03].CHAPTER 16SOFTWARE QUALITY ASSURANCE 441What are thecore steps ofthe Six Sigma
methodology??pre75977_ch16.qxd  11/27/08  6:07 PM  Page 441
16.6S
OFTWARE
RELIABILITYThere is no doubt that the reliability of a computer program is an important elementof its overall quality. If a program repeatedly and frequently fails to perform, it mat-

ters little whether other software quality factors are acceptable.Software reliability, unlike many other quality factors, can be measured directly
and estimated using historical and developmental data. Software reliabilityis definedin statistical terms as Òthe probability of failure-free operation of a computer program
in a specified environment for a specified timeÓ [Mus87]. To illustrate, program 
Xisestimated to have a reliability of 0.999 over eight elapsed processing hours. In other

words, if program Xwere to be executed 1000 times and require a total of eight hoursof elapsed processing time (execution time), it is likely to operate correctly (without
failure) 999 times.Whenever software reliability is discussed, a pivotal question arises: What is meantby the term failure? In the context of any discussion of software quality and reliabil-
ity, failure is nonconformance to software requirements. Yet, even within this defini-

tion, there are gradations. Failures can be only annoying or catastrophic. One failure
can be corrected within seconds, while another requires weeks or even months to
correct. Complicating the issue even further, the correction of one failure may in fact

result in the introduction of other errors that ultimately result in other failures.16.6.1Measures of Reliability and Availability
Early work in software reliability attempted to extrapolate the mathematics of hard-
ware reliability theory to the prediction of software reliability. Most hardware-related

reliability models are predicated on failure due to wear rather than failure due to de-
sign defects. In hardware, failures due to physical wear (e.g., the effects of tempera-

ture, corrosion, shock) are more likely than a design-related failure. Unfortunately,

the opposite is true for software. In fact, all software failures can be traced to design
or implementation problems; wear (see Chapter 1) does not enter into the picture.There has been an ongoing debate over the relationship between key concepts in
hardware reliability and their applicability to software. Although an irrefutable link
has yet to be established, it is worthwhile to consider a few simple concepts that
apply to both system elements.If we consider a computer-based system, a simple measure of reliability is mean-time-between-failure(MTBF):MTBF MTTF MTTRwhere the acronyms MTTF and MTTR are mean-time-to-failureand mean-time-to-repair,2respectively.
442PART THREEQUALITY MANAGEMENTuote:ÒThe unavoidableprice of reliability
is simplicity.Ó
C.A. R.Hoare
Software reliabilityproblems can almost
always be traced
todefects in design or

implementation.2Although debugging (and related corrections) may be required as a consequence of failure, in many
cases the software will work properly after a restart with no other change.It is important to note
that MTBF and related
measures are based on
CPU time, not wall
clock time.pre75977_ch16.qxd  11/27/08  6:07 PM  Page 442
Many researchers argue that MTBF is a far more useful measure than otherquality-related software metrics discussed in Chapter 23. Stated simply, an end user
is concerned with failures, not with the total defect count. Because each defect con-
tained within a program does not have the same failure rate, the total defect count

provides little indication of the reliability of a system. For example, consider a pro-

gram that has been in operation for 3000 processor hours without failure. Many de-
fects in this program may remain undetected for tens of thousand of hours before
they are discovered. The MTBF of such obscure errors might be 30,000 or even

60,000 processor hours. Other defects, as yet undiscovered, might have a failure rate

of 4000 or 5000 hours. Even if every one of the first category of errors (those with
long MTBF) is removed, the impact on software reliability is negligible.
However, MTBF can be problematic for two reasons: (1) it projects a time span be-
tween failures, but does not provide us with a projected failure rate, and (2) MTBF can

be misinterpreted to mean average life span even though this is notwhat it implies.An alternative measure of reliability is failures-in-time(FIT)Ña statistical measureof how many failures a component will have over one billion hours of operation.

Therefore, 1 FIT is equivalent to one failure in every billion hours of operation.
In addition to a reliability measure, you should also develop a measure of avail-
ability. 
Software availabilityis the probability that a program is operating according torequirements at a given point in time and is defined asAvailability 
 100%The MTBF reliability measure is equally sensitive to MTTF and MTTR. The avail-ability measure is somewhat more sensitive to MTTR, an indirect measure of the
maintainability of software.16.6.2Software Safety
Software safetyis a software quality assurance activity that focuses on the identificationand assessment of potential hazards that may affect software negatively and cause an
entire system to fail. If hazards can be identified early in the software process, software
design features can be specified that will either eliminate or control potential hazards.A modeling and analysis process is conducted as part of software safety. Initially,
hazards are identified and categorized by criticality and risk. For example, some of

the hazards associated with a computer-based cruise control for an automobile
might be: (1) causes uncontrolled acceleration that cannot be stopped, (2) does not
respond to depression of brake pedal (by turning off), (3) does not engage when
switch is activated, and (4) slowly loses or gains speed. Once these system-level haz-
ards are identified, analysis techniques are used to assign severity and probability of
occurrence.3To be effective, software must be analyzed in the context of the entire
MTTFMTTF MTTRCHAPTER 16SOFTWARE QUALITY ASSURANCE 443Some aspects ofavailability (not
discussed here) have
nothing to do with
failure. For example,
scheduling downtime
(for support functions)

causes the software to
be unavailable.uote:ÒThe safety of thepeople shall be the
highest law.Ó
Cicero3This approach is similar to the risk analysis methods described in Chapter 28. The primary differ-
ence is the emphasis on technology issues rather than project-related topics.pre75977_ch16.qxd  11/27/08  6:07 PM  Page 443
system. For example, a subtle user input error (people are system components) may
be magnified by a software fault to produce control data that improperly positions a
mechanical device. If and only if a set of external environmental conditions is met,

the improper position of the mechanical device will cause a disastrous failure. Analy-
sis techniques [Eri05] such as fault tree analysis, real-time logic, and Petri net mod-

els can be used to predict the chain of events that can cause hazards and the
probability that each of the events will occur to create the chain.Once hazards are identified and analyzed, safety-related requirements can bespecified for the software. That is, the specification can contain a list of undesirable
events and the desired system responses to these events. The role of software in
managing undesirable events is then indicated.Althoughsoftwarereliabilityandsoftwaresafetyarecloselyrelatedtooneanother,
itisimportanttounderstandthesubtledifferencebetweenthem.Softwarereliability

usesstatisticalanalysistodeterminethelikelihoodthatasoftwarefailurewilloccur.

However,theoccurrenceofafailuredoesnotnecessarilyresultinahazardormishap.

Softwaresafetyexaminesthewaysinwhichfailuresresultinconditionsthatcanlead

toamishap.Thatis,failuresarenotconsideredinavacuum,butareevaluatedinthe

contextofanentirecomputer-basedsystemanditsenvironment.
A comprehensive discussion of software safety is beyond the scope of this book.If you have further interest in software safety and related system issues, see [Smi05],
[Dun02], and [Lev95].16.7T
HEISO 9000 QUALITYSTANDARDS
4A quality assurance system
may be defined as the organizational structure, responsi-
bilities, procedures, processes, and resources for implementing quality management
[ANS87]. Quality assurance systems are created to help organizations ensure their
products and services satisfy customer expectations by meeting their specifications.
These systems cover a wide variety of activities encompassing a productÕs entire life

cycle including planning, controlling, measuring, testing and reporting, and improv-

ing quality levels throughout the development and manufacturing process. ISO 9000
describes quality assurance elements in generic terms that can be applied to any
business regardless of the products or services offered.TobecomeregisteredtooneofthequalityassurancesystemmodelscontainedinISO
9000,acompanyÕsqualitysystemandoperationsarescrutinizedbythird-partyauditors

forcompliancetothestandardandforeffectiveoperation.Uponsuccessfulregistration,

acompanyisissuedacertificatefromaregistrationbodyrepresentedbytheauditors.

Semiannualsurveillanceauditsensurecontinuedcompliancetothestandard.
444PART THREEQUALITY MANAGEMENTuote:ÒI cannot imagineany condition
which would
causethis ship to

founder. Modern

shipbuilding has
gone beyond that.ÓE.I.Smith,
captain of the
TitanicWebRef
A worthwhile collection
of papers on software
safety can be found at
www.safeware-

eng.com/.4This section, written by Michael Stovsky, has been adapted from ÒFundamentals of ISO 9000,Ó
aworkbook developed for 
Essential Software Engineering,a video curriculum developed by R. S.Pressman & Associates, Inc. Reprinted with permission.pre75977_ch16.qxd  11/27/08  6:07 PM  Page 444
The requirements delineated by ISO 9001:2000 address topics such as manage-ment responsibility, quality system, contract review, design control, document and
data control, product identification and traceability, process control, inspection and

testing, corrective and preventive action, control of quality records, internal quality
audits, training, servicing, and statistical techniques. In order for a software organi-
zation to become registered to ISO 9001:2000, it must establish policies and proce-
dures to address each of the requirements just noted (and others) and then be able
to demonstrate that these policies and procedures are being followed. If you desire
further information on ISO 9001:2000, see [Ant06], [Mut03], or [Dob04].CHAPTER 16SOFTWARE QUALITY ASSURANCE 445WebRef
Extensive links to ISO9000/9001 resources
can be found at
www.tantara.ab

.ca/info.htm.The ISO 9001:2000 Standard
The following outline defines the basicelements of the ISO 9001:2000 standard.Comprehensive information on the standard can be
obtained from the International Organization for

Standardization (www.iso.ch
) and other Internet

sources (e.g., www.praxiom.com
).Establish the elements of a quality management system.Develop, implement, and improve the system.
Define a policy that emphasizes the importance of the
system.Document the quality system.Describe the process.
Produce an operational manual.
Develop methods for controlling (updating) documents.
Establish methods for record keeping.Support quality control and assurance.
Promotetheimportanceofqualityamongallstakeholders.

Focus on customer satisfaction.Define a quality plan that addresses objectives,responsibilities, and authority.
Define communication mechanisms among stakeholders.Establish review mechanisms for the quality managementsystem.Identify review methods and feedback mechanisms.
Define follow-up procedures.Identify quality resources including personnel, training,and infrastructure elements.Establish control mechanisms.
For planning
For customer requirements
For technical activities (e.g., analysis, design, testing)
For project monitoring and managementDefine methods for remediation.Assess quality data and metrics.
Define approach for continuous process and qualityimprovement.INFO16.8T
HESQA PLANThe SQA Planprovides a road map for instituting software quality assurance. Developed
by the SQA group (or by the software team if an SQA group does not exist), the planserves as a template for SQA activities that are instituted for each software project.A standard for SQA plans has been published by the IEEE [IEE93]. The standardrecommends a structure that identifies: (1) the purpose and scope of the plan, (2) a
description of all software engineering work products (e.g., models, documents,
source code) that fall within the purview of SQA, (3) all applicable standards and
practices that are applied during the software process, (4) SQA actions and taskspre75977_ch16.qxd  11/27/08  6:07 PM  Page 445
(including reviews and audits) and their placement throughout the softwareprocess,(5) the tools and methods that support SQA actions and tasks, (6) software

configuration management (Chapter 22) procedures, (7) methods for assembling,
safeguarding, and maintaining all SQA-related records, and (8) organizational roles
and responsibilities relative to product quality.
446PART THREEQUALITY MANAGEMENTSoftware Quality Management
Objective:The objective of SQA tools is toassist a project team in assessing andimproving the quality of software work product.Mechanics:Tools mechanics vary. In general, the intent
is to assess the quality of a specific work product. Note:Awide array of software testing tools (see Chapters 17

through 20) are often included within the SQA tools
category.
Representative Tools:
5ARM,developed by NASA (satc.gsfc.nasa.gov/tools/index.html), provides measures that can beused to assess the quality of a software requirementsdocument.QPR ProcessGuide and Scorecard,developed by QPRSoftware (www.qpronline.com
), provides support
for Six Sigma and other quality management
approaches.Quality Tools and Templates,
developed by iSixSigma(www.isixsigma.com/tt/
), describes a wide arrayof useful tools and methods for quality management.NASA Quality Resources,developed by the GoddardSpace Flight Center (sw-assurance.gsfc.nasa
.gov/index.php) provides useful forms, templates,
checklists, and tools for SQA.SOFTWARE
TOOLS5Tools noted here do not represent an endorsement, but rather a sampling of tools in this category.
In most cases, tool names are trademarked by their respective developers.16.9S
UMMARYSoftware quality assurance is a software engineering umbrella activity that is appliedat each step in the software process. SQA encompasses procedures for the effective
application of methods and tools, oversight of quality control activities such as tech-

nical reviews and software testing, procedures for change management, procedures
for assuring compliance to standards, and measurement and reporting mechanisms.To properly conduct software quality assurance, data about the software engi-
neering process should be collected, evaluated, and disseminated. Statistical SQA
helps to improve the quality of the product and the software process itself. Software

reliability models extend measurements, enabling collected defect data to be ex-
trapolated into projected failure rates and reliability predictions.In summary, you should note the words of Dunn and Ullman [Dun82]: ÒSoftware
quality assurance is the mapping of the managerial precepts and design disciplines
of quality assurance onto the applicable managerial and technological space of
software engineering.Ó The ability to ensure quality is the measure of a mature
engineering discipline. When the mapping is successfully accomplished, mature
software engineering is the result.pre75977_ch16.qxd  11/27/08  6:07 PM  Page 446
PROBLEMSAND
POINTSTO
PONDER16.1.Some people say that Òvariation control is the heart of quality control.Ó Since every pro-gram that is created is different from every other program, what are the variations that we lookfor and how do we control them?16.2.Is it possible to assess the quality of software if the customer keeps changing what it issupposed to do?
16.3.Quality and reliability are related concepts but are fundamentally different in a numberof ways. Discuss the differences.
16.4.Can a program be correct and still not be reliable? Explain.16.5.Can a program be correct and still not exhibit good quality? Explain.16.6.Why is there often tension between a software engineering group and an independentsoftware quality assurance group? Is this healthy?
16.7.You have been given the responsibility for improving the quality of software across your
organization. What is the first thing that you should do? WhatÕs next?

16.8.Besides counting errors and defects, are there other countable characteristics of softwarethat imply quality? What are they and can they be measured directly?
16.9.The MTBF concept for software is open to criticism. Explain why?16.10.Consider two safety-critical systems that are controlled by computer. List at least three
hazards for each that can be directly linked to software failures.
16.11.Acquire a copy of ISO 9001:2000 and ISO 9000-3. Prepare a presentation that discussesthree ISO 9001 requirements and how they apply in a software context.FURTHER
READINGSAND
INFORMATION
SOURCESBooksbyHoyle(
QualityManagementFundamentals,
Butterworth-Heinemann,2007),Tian
(SoftwareQualityEngineering,
Wiley-IEEEComputerSocietyPress,2005),ElEmam(
TheROIfrom
SoftwareQuality,
Auerbach,2005),Horch(
PracticalGuidetoSoftwareQualityManagement,
ArtechHouse,2003),andNanceandArthur(
ManagingSoftwareQuality,
Springer,2002)areexcellent
management-levelpresentationsonthebenefitsofformalqualityassuranceprogramsforcom-
putersoftware.BooksbyDeming[Dem86],Juran(
JuranonQualitybyDesign,
FreePress,1992),
andCrosby([Cro79]and
QualityIsStillFree,
McGraw-Hill,1995)donotfocusonsoftware,but
aremustreadingforseniormanagerswithsoftwaredevelopmentresponsibility.Gluckmanand

Roome(
EverydayHeroesoftheQualityMovement,
DorsetHouse,1993)humanizesqualityissues
bytellingthestoryoftheplayersinthequalityprocess.Kan(
MetricsandModelsinSoftwareQual-
ityEngineering,
Addison-Wesley,1995)presentsaquantitativeviewofsoftwarequality.
Books by Evans (Total Quality: Management, Organization and Strategy,
4th ed., South-Western College Publishing, 2004), Bru (
Six Sigma for Managers,McGraw-Hill, 2005), and Dobb
(ISO 9001:2000 Quality Registration Step-by-Step,
3d ed., Butterworth-Heinemann, 2004) are rep-resentative of the many books written on TQM, Six Sigma, and ISO 9001:2000, respectively.
Pham (System Software Reliability, Springer, 2006), Musa (
Software Reliability Engineering:More Reliable Software, Faster Development and Testing,
2d ed., McGraw-Hill, 2004) and Peled
(Software Reliability Methods, Springer, 2001) have written practical guides that describe meth-
ods for measuring and analyzing software reliability.
Vincoli (
Basic Guide to System Safety,
Wiley, 2006), Dhillon (
Engineering Safety,
World Scien-
tific Publishing Co., Inc., 2003), Hermann (Software Safety and Reliability,
Wiley-IEEE Computer
Society Press, 2000), Storey (Safety-Critical Computer Systems,Addison-Wesley, 1996), and
Leveson [Lev95] are the most comprehensive discussions of software and system safety
published to date. In addition, van der Meulen (Definitions for Hardware and Software Safety
CHAPTER 16SOFTWARE QUALITY ASSURANCE 447pre75977_ch16.qxd  11/27/08  6:07 PM  Page 447
Engineers,Springer-Verlag, 2000) offers a complete compendium of important concepts and
terms for reliability and safety; Gartner (Testing Safety-Related Software,
Springer-Verlag, 1999)
provides specialized guidance for testing safety critical systems; Friedman and Voas (
SoftwareAssessment: Reliability Safety and Testability,
Wiley, 1995) provide useful models for assessing
reliability and safety. Ericson (
Hazard Analysis Techniques for System Safety,
Wiley, 2005)
addresses the increasingly important domain of hazard analysis.A wide variety of information sources on software quality assurance and related topics isavailable on the Internet. An up-to-date list of World Wide Web references relevant to SQA can

be found at the SEPA website 
www.mhhe.com/engcs/compsci/pressman/professional/

olc/ser.htm
.448PART THREEQUALITY MANAGEMENTpre75977_ch16.qxd  11/27/08  6:07 PM  Page 448
Astrategy for software testing provides a road map that describes the steps
to be conducted as part of testing, when these steps are planned and then
undertaken, and how much effort, time, and resources will be required.
Therefore, any testing strategy must incorporate test planning, test case design,

test execution, and resultant data collection and evaluation.A software testing strategy should be flexible enough to promote a customizedtesting approach. At the same time, it must be rigid enough to encourage reason-

able planning and management tracking as the project progresses. Shooman
[Sho83] discusses these issues:In many ways, testing is an individualistic process, and the number of different typesof tests varies as much as the different development approaches. For many years, our449CHAPTER17SOFTWARE
TESTINGSTRATEGIES
Whatisit?
Softwareistestedto
uncovererrorsthatweremadeinad-
vertentlyasitwasdesignedand

constructed.Buthowdoyouconduct
thetests?Shouldyoudevelopaformalplanfor

yourtests?Shouldyoutesttheentireprogramas

awholeorruntestsonlyonasmallpartofit?

ShouldyoureruntestsyouÕvealreadyconducted

asyouaddnewcomponentstoalargesystem?

Whenshouldyouinvolvethecustomer?These

andmanyotherquestionsareansweredwhen

youdevelopasoftwaretestingstrategy.
Who does it?A strategy for software testing isdeveloped by the project manager, software

engineers, and testing specialists.Whyisitimportant?
Testingoftenaccountsfor
moreprojecteffortthananyothersoftwareengi-

neeringaction.Ifitisconductedhaphazardly,

timeiswasted,unnecessaryeffortisexpended,

andevenworse,errorssneakthroughundetected.

Itwouldthereforeseemreasonable to establish

a systematic strategy for testing software.What are the steps?Testing begins Òin the smallÓ
and progresses Òto the large.Ó By this I meanQUICKLOOKthat early testing focuses on a single component
or a small group of related components and
applies tests to uncover errors in the data and
processing logic that have been encapsulated
by the component(s). After components are
tested they must be integrated until the complete
system is constructed. At this point, a series of
high-order tests are executed to uncover errors
in meeting customer requirements. As errors are
uncovered, they must be diagnosed and cor-
rected using a process that is called debugging.What is the work product?
A Test Specification
documents the software teamÕs approach to test-

ing by defining a plan that describes an overall
strategy and a procedure that defines specific
testing steps and the types of tests that will be
conducted.How do I ensure that IÕve done it right?Byreviewing the Test Specification
prior to testing,you can assess the completeness of test cases
and testing tasks. An effective test plan and pro-

cedure will lead to the orderly construction of
the software and the discovery of errors at each

stage in the construction process.KEYCONCEPTSalpha test . . . . . .
469beta test . . . . . . .
469class testing . . . . .
466configurationreview . . . . . . . .
468debugging . . . . . .
473deployment
testing . . . . . . . . .
472independent
test group . . . . . .
452pre75977_ch17.qxd  11/27/08  6:09 PM  Page 449
450PART THREEQUALITY MANAGEMENTintegrationtesting . . . . . . . . .
459regression
testing . . . . . . . . .
467system testing . . .
470unit testing . . . . .
456validation
testing . . . . . . . . .
467V&V . . . . . . . . . .450
only defense against programming errors was careful design and the native intelligenceof the programmer. We are now in an era in which modern design techniques [and tech-

nical reviews] are helping us to reduce the number of initial errors that are inherent in the
code. Similarly, different test methods are beginning to cluster themselves into several

distinct approaches and philosophies.These Òapproaches and philosophiesÓ are what I call strategy
Ñthe topic to be pre-sented in this chapter. In Chapters 18 through 20, the testing methods and tech-
niques that implement the strategy are presented.17.1A S
TRATEGIC
APPROACHTO
SOFTWARE
TESTINGTesting is a set of activities that can be planned in advance and conducted system-

atically. For this reason a template for software testingÑa set of steps into which you

can place specific test case design techniques and testing methodsÑshould be
defined for the software process.A number of software testing strategies have been proposed in the literature.Allprovide you with a template for testing and all have the following generic

characteristics:¥To perform effective testing, you should conduct effective technical reviews

(Chapter 15). By doing this, many errors will be eliminated before testing
commences.¥Testing begins at the component level and works ÒoutwardÓ toward the

integration of the entire computer-based system.¥Different testing techniques are appropriate for different software engi-
neering approaches and at different points in time.¥Testing is conducted by the developer of the software and (for large projects)

an independent test group.¥Testing and debugging are different activities, but debugging must be accom-

modated in any testing strategy.
A strategy for software testing must accommodate low-level tests that are neces-sary to verify that a small source code segment has been correctly implemented
aswell as high-level tests that validate major system functions against customer

requirements. A strategy should provide guidance for the practitioner and a set of

milestones for the manager. Because the steps of the test strategy occur at a time

when deadline pressure begins to rise, progress must be measurable and problems

should surface as early as possible.17.1.1Verification and Validation
Software testing is one element of a broader topic that is often referred to as verifi-
cation and validation (V&V). Verification
refers to the set of tasks that ensure thatWebRef
Useful resources forsoftware testing can be
found at www.mtsu

.edu/~storm/.pre75977_ch17.qxd  11/27/08  6:09 PM  Page 450
software correctly implements a specific function. Validation
refers to a different setof tasks that ensure that the software that has been built is traceable to customerrequirements. Boehm [Boe81] states this another way:Verification: ÒAre we building the product right?Ó
Validation: ÒAre we building the right product?Ó
The definition of V&V encompasses many software quality assurance activities(Chapter 16).1Verification and validation includes a wide array of SQA activities: technical
reviews, quality and configuration audits, performance monitoring, simulation, feasi-bility study, documentation review, database review, algorithm analysis, development

testing, usability testing, qualification testing, acceptance testing, and installation test-
ing. Although testing plays an extremely important role in V&V, many other activities

are also necessary.
Testing does provide the last bastion from which quality can be assessed and,
more pragmatically, errors can be uncovered. But testing should not be viewed as a

safety net. As they say, ÒYou canÕt test in quality. If itÕs not there before you begin test-

ing, it wonÕt be there when youÕre finished testing.Ó Quality is incorporated into soft-

ware throughout the process of software engineering. Proper application of methods
and tools, effective technical reviews, and solid management and measurement all
lead to quality that is confirmed during testing.Miller [Mil77] relates software testing to quality assurance by stating that Òtheunderlying motivation of program testing is to affirm software quality with methods
that can be economically and effectively applied to both large-scale and small-scale
systems.Ó17.1.2Organizing for Software Testing
For every software project, there is an inherent conflict of interest that occurs as
testing begins. The people who have built the software are now asked to test the soft-
ware. This seems harmless in itself; after all, who knows the program better than its
developers? Unfortunately, these same developers have a vested interest in demon-

strating that the program is error-free, that it works according to customer require-

ments, and that it will be completed on schedule and within budget. Each of these
interests mitigate against thorough testing.From a psychological point of view, software analysis and design (along with
coding) are constructive tasks. The software engineer analyzes, models, and then
creates a computer program and its documentation. Like any builder, the software
CHAPTER 17SOFTWARE TESTING STRATEGIES451uote:ÒTesting is the
unavoidable part
of any responsible
effort to develop a
software system.ÓWilliamHowden
DonÕt get sloppy andview testing as a
Òsafety netÓ that will
catch all errors that

occurred because of

weak software engi-
neering practices. It
wonÕt. Stress quality
and error detection

throughout the
software process.1It should be noted that there is a strong divergence of opinion about what types of testing consti-
tute Òvalidation.Ó Some people believe that alltesting is verification and that validation is conductedwhen requirements are reviewed and approved, and later, by the user when the system is opera-tional. Other people view unit and integration testing (Sections 17.3.1 and 17.3.2) as verification
and higher-order testing (Sections 17.6 and 17.7) as validation.uote:ÒOptimism is theoccupational
hazard of
programming;
testing is the
treatment.ÓKentBeck
pre75977_ch17.qxd  11/27/08  6:09 PM  Page 451
engineer is proud of the edifice that has been built and looks askance at anyonewho attempts to tear it down. When testing commences, there is a subtle, yet def-

inite, attempt to ÒbreakÓ the thing that the software engineer has built. From the

point of view of the builder, testing can be considered to be (psychologically)

destructive. So the builder treads lightly, designing and executing tests that will

demonstrate that the program works, rather than uncovering errors. Unfortunately,

errors will be present. And, if the software engineer doesnÕt find them, the cus-

tomer will!There are often a number of misconceptions that you might infer erroneouslyfrom the preceding discussion: (1) that the developer of software should do no test-
ing at all, (2) that the software should be Òtossed over the wallÓ to strangers who will

test it mercilessly, (3) that testers get involved with the project only when the testing

steps are about to begin. Each of these statements is incorrect.The software developer is always responsible for testing the individual units(components) of the program, ensuring that each performs the function or exhibits
the behavior for which it was designed. In many cases, the developer also conducts
integration testingÑa testing step that leads to the construction (and test) of the
complete software architecture. Only after the software architecture is complete
does an independent test group become involved.
The role of an independent test group(ITG) is to remove the inherent problems
associated with letting the builder test the thing that has been built. Independent
testing removes the conflict of interest that may otherwise be present. After all, ITG

personnel are paid to find errors.However, you donÕt turn the program over to ITG and walk away. The developer
and the ITG work closely throughout a software project to ensure that thorough tests
will be conducted. While testing is conducted, the developer must be available to
correct errors that are uncovered.
The ITG is part of the software development project team in the sense that itbecomes involved during analysis and design and stays involved (planning and spec-

ifying test procedures) throughout a large project. However, in many cases the ITG

reports to the software quality assurance organization, thereby achieving a degree
of independence that might not be possible if it were a part of the software engi-
neering organization.17.1.3Software Testing StrategyÑThe Big Picture
The software process may be viewed as the spiral illustrated in Figure 17.1. Initially,

system engineering defines the role of software and leads to software requirements
analysis, where the information domain, function, behavior, performance, con-

straints, and validation criteria for software are established. Moving inward along

the spiral, you come to design and finally to coding. To develop computer software,

you spiral inward (counterclockwise) along streamlines that decrease the level of
abstraction on eachturn.
452PART THREEQUALITY MANAGEMENTAn independent testgroup does not have
the Òconflict of
interestÓ that builders
of the software might
experience.uote:ÒThe first mistake
that people make
is thinking that the
testing team is
responsible for
assuring quality.Ó
BrianMarick
pre75977_ch17.qxd  11/27/08  6:09 PM  Page 452
A strategy for software testing may also be viewed in the context of the spiral(Figure 17.1). Unit testingbegins at the vortex of the spiral and concentrates on eachunit (e.g., component, class, or WebApp content object) of the software as imple-
mented in source code. Testing progresses by moving outward along the spiral to

integration testing,
where the focus is on design and the construction of the softwarearchitecture. Taking another turn outward on the spiral, you encounter 
validation
testing,where requirements established as part of requirements modeling are vali-dated against the software that has been constructed. Finally, you arrive at 
system
testing,where the software and other system elements are tested as a whole. To test
computer software, you spiral out in a clockwise direction along streamlines that

broaden the scope of testing with each turn.Considering the process from a procedural point of view, testing within the con-
text of software engineering is actually a series of four steps that are implemented
sequentially. The steps are shown in Figure 17.2. Initially, tests focus on each
CHAPTER 17SOFTWARE TESTING STRATEGIES453System testingValidation testing
Integration testingUnit testingCodeDesignRequirementsSystem engineeringFIGURE17.1Testing
strategyUnittestCodeDesignRequirementsTesting
ﬁdirectionﬂIntegration testHigh-ordertestsFIGURE17.2Software
testing stepsWhat is theoverallstrategy for
software testing??WebRef
Useful resources forsoftware testers can
befound at 
www.SQAtester.com
.pre75977_ch17.qxd  11/27/08  6:09 PM  Page 453
component individually, ensuring that it functions properly as a unit. Hence, the
name unit testing.Unit testing makes heavy use of testing techniques that exercisespecific paths in a componentÕs control structure to ensure complete coverage and

maximum error detection. Next, components must be assembled or integrated to
form the complete software package. Integration testing
addresses the issues associ-ated with the dual problems of verification and program construction. Test case

design techniques that focus on inputs and outputs are more prevalent during
integration, although techniques that exercise specific program paths may be used
to ensure coverage of major control paths. After the software has been integrated

(constructed), a set of high-order tests
is conducted. Validation criteria (estab-
lishedduring requirements analysis) must be evaluated. 
Validation testing
provides
final assurance that software meets all informational, functional, behavioral, and
performance requirements.The last high-order testing step falls outside the boundary of software engineer-ing and into the broader context of computer system engineering. Software, once

validated, must be combined with other system elements (e.g., hardware, people,

databases). System testingverifies that all elements mesh properly and that overall
system function/performance is achieved.454PART THREEQUALITY MANAGEMENTThe scene:Doug MillerÕs office, as
component-level design continues andconstruction of certain components begins.
The players:Doug Miller, software engineering
manager, Vinod, Jamie, Ed, and ShakiraÑmembers of
the SafeHomesoftware engineering team.The conversation:Doug:It seems to me that we havenÕt spent enough time
talking about testing.
Vinod:
True, but weÕve all been just a little busy. And
besides, we have been thinking about it . . . in fact, morethan thinking.Doug (smiling):I know . . . weÕre all overloaded, butweÕve still got to think down the line.
Shakira:I like the idea of designing unit tests before Ibegin coding any of my components, so thatÕs what IÕve
been trying to do. I have a pretty big file of tests to run

once code for my components is complete.Doug:ThatÕs an Extreme Programming [an agile
software development process, see Chapter 3] concept, no?Ed:Itis.EventhoughweÕrenotusingExtreme Programming
per se, we decided that itÕd be a good idea to design unit
tests before we build the componentÑthe design gives us
all of the information we need.
Jamie:IÕve been doing the same thing.Vinod:
And IÕve taken on the role of the integrator, so
every time one of the guys passes a component to me,
IÕllintegrate it and run a series of regression tests on the

partially integrated program. IÕve been working to

designa set of appropriate tests for each function in the

system.Doug (to Vinod):
How often will you run the tests?Vinod:
Every day...until the system is integrated...
well, I mean until the software increment we plan todeliver is integrated.Doug:You guys are way ahead of me!
Vinod (laughing):
Anticipation is everything in the
software biz, Boss.SAFEHOMEPreparing for Testing
pre75977_ch17.qxd  11/27/08  6:09 PM  Page 454
17.1.4Criteria for Completion of Testing
A classic question arises every time software testing is discussed: ÒWhen are wedone testingÑhow do we know that weÕve tested enough?Ó Sadly, there is no defin-

itive answer to this question, but there are a few pragmatic responses and early
attempts at empirical guidance.One response to the question is: ÒYouÕre never done testing; the burden simply
shifts from you (the software engineer) to the end user.Ó Every time the user executes

a computer program, the program is being tested. This sobering fact underlines the
importance of other software quality assurance activities. Another response (some-
what cynical but nonetheless accurate) is: ÒYouÕre done testing when you run out of

time or you run out of money.Ó
Although few practitioners would argue with these responses, you need more rig-orous criteria for determining when sufficient testing has been conducted. The
cleanroom software engineeringapproach (Chapter 21) suggests statistical use tech-niques [Kel00] that execute a series of tests derived from a statistical sample of all

possible program executions by all users from a targeted population. Others (e.g.,
[Sin99]) advocate using statistical modeling and software reliability theory to predict
the completeness of testing.By collecting metrics during software testing and making use of existing softwarereliability models, it is possible to develop meaningful guidelines for answering the
question: ÒWhen are we done testing?Ó There is little debate that further work
remains to be done before quantitative rules for testing can be established, but the
empirical approaches that currently exist are considerably better than raw intuition.
17.2S
TRATEGIC
ISSUESLater in this chapter, I present a systematic strategy for software testing. But even the

best strategy will fail if a series of overriding issues are not addressed. Tom Gilb

[Gil95] argues that a software testing strategy will succeed when software testers:Specify product requirements in a quantifiable manner long before testing com-mences.Although the overriding objective of testing is to find errors, a good testing
strategy also assesses other quality characteristics such as portability, maintain-

ability, and usability (Chapter 14). These should be specified in a way that is meas-

urable so that testing results are unambiguous.State testing objectives explicitly.
The specific objectives of testing should bestated in measurable terms. For example, test effectiveness, test coverage, mean-

time-to-failure, the cost to find and fix defects, remaining defect density or fre-

quency of occurrence, and test work-hours should be stated within the test plan.
Understand the users of the software and develop a profile for each user category.
Use cases that describe the interaction scenario for each class of user can reduce
overall testing effort by focusing testing on actual use of the product.
CHAPTER 17SOFTWARE TESTING STRATEGIES455When arewe finishedtesting??WebRef
Acomprehensive
glossaryoftestingterms

canbefoundat
www.testingstandards
.co.uk/living_
glossary.htm
.Whatguidelineslead to a
successful
software testing
strategy??WebRef
An excellent list oftesting resources can
be found at www
.io.com/~wazmo/
qa/.pre75977_ch17.qxd  11/27/08  6:09 PM  Page 455
Develop a testing plan that emphasizes Òrapid cycle testing.Ó
Gilb [Gil95] recom-mends that a software team Òlearn to test in rapid cycles (2 percent of projecteffort) of customer-useful, at least field Ôtrialable,Õ increments of functionality

and/or quality improvement.Ó The feedback generated from these rapid cycle tests

can be used to control quality levels and the corresponding test strategies.Build ÒrobustÓ software that is designed to test itself.Software should be designedin a manner that uses antibugging (Section 17.3.1) techniques. That is, software
should be capable of diagnosing certain classes of errors. In addition, the design
should accommodate automated testing and regression testing.Use effective technical reviews as a filter prior to testing.
Technical reviews
(Chapter 15) can be as effective as testing in uncovering errors. For this reason,

reviews can reduce the amount of testing effort that is required to produce high-
quality software.Conduct technical reviews to assess the test strategy and test cases themselves.
Technical reviews can uncover inconsistencies, omissions, and outright errors in

the testing approach. This saves time and also improves product quality.
Develop a continuous improvement approach for the testing process.
The test strat-egy should be measured. The metrics collected during testing should be used as
part of a statistical process control approach for software testing.17.3T
ESTSTRATEGIESFOR
CONVENTIONALSOFTWARE
2There are many strategies that can be used to test software. At one extreme, you can

wait until the system is fully constructed and then conduct tests on the overall sys-

tem in hopes of finding errors. This approach, although appealing, simply does not
work. It will result in buggy software that disappoints all stakeholders. At the other
extreme, you could conduct tests on a daily basis, whenever any part of the system

is constructed. This approach, although less appealing to many, can be very effec-

tive. Unfortunately, some software developers hesitate to use it. What to do?
A testing strategy that is chosen by most software teams falls between the twoextremes. It takes an incremental view of testing, beginning with the testing of indi-
vidual program units, moving to tests designed to facilitate the integration of the

units, and culminating with tests that exercise the constructed system. Each of these
classes of tests is described in the sections that follow.
17.3.1Unit Testing
Unit testingfocuses verification effort on the smallest unit of software designÑthesoftware component or module. Using the component-level design description as a456PART THREEQUALITY MANAGEMENTuote:ÒTesting only
toend-user

requirements is
like inspecting a
building based
onthe work done

by the interior
designer at the
expense of the
foundations,
girders, and
plumbing.ÓBorisBeizer
2Throughout this book, I use the terms 
conventional softwareor traditional softwareto refer to com-mon hierarchical or call-and-return software architectures that are frequently encountered in avariety of application domains. Traditional software architectures are notobject-oriented and donot encompass WebApps.pre75977_ch17.qxd  11/27/08  6:09 PM  Page 456
guide, important control paths are tested to uncover errors within the boundary of
the module. The relative complexity of tests and the errors those tests uncover is lim-

ited by the constrained scope established for unit testing. The unit test focuses on the
internal processing logic and data structures within the boundaries of a component.
This type of testing can be conducted in parallel for multiple components.Unit-test considerations.
Unit tests are illustrated schematically in Figure 17.3.The module interface is tested to ensure that information properly flows into and outof the program unit under test. Local data structures are examined to ensure that
data stored temporarily maintains its integrity during all steps in an algorithmÕs

execution. All independent paths through the control structure are exercised to ensure
that all statements in a module have been executed at least once. Boundary conditions
are tested to ensure that the module operates properly at boundaries established to
limit or restrict processing. And finally, all error-handling paths are tested.
Data flow across a component interface is tested before any other testing is initi-ated. If data do not enter and exit properly, all other tests are moot. In addition, local

data structures should be exercised and the local impact on global data should be as-
certained (if possible) during unit testing.Selective testing of execution paths is an essential task during the unit test. Test
cases should be designed to uncover errors due to erroneous computations, incor-

rect comparisons, or improper control flow.
Boundary testing is one of the most important unit testing tasks. Software oftenfails at its boundaries. That is, errors often occur when the nth element of an
n-dimensional array is processed, when the ith repetition of a loop with ipasses isinvoked, when the maximum or minimum allowable value is encountered. Test

cases that exercise data structure, control flow, and data values just below, at, and

just above maxima and minima are very likely to uncover errors.
CHAPTER 17SOFTWARE TESTING STRATEGIES457TestcasesModuleInterfaceLocal data structures
Boundary conditions
Independent paths
Error-handling pathsFIGURE17.3Unit testItÕs not a bad idea to
design unit test cases
beforeyou developcode for a component.
It helps ensure that
youÕll develop code
that will pass the tests.Whaterrors
arecommonly
foundduringunit

testing??pre75977_ch17.qxd  11/27/08  6:09 PM  Page 457
A good design anticipates error conditions and establishes error-handling pathsto reroute or cleanly terminate processing when an error does occur. Yourdon
[You75] calls this approach 
antibugging.Unfortunately, there is a tendency to incor-
porate error handling into software and then never test it. A true story may serve to
illustrate:A computer-aided design system was developed under contract. In one transaction pro-cessing module, a practical joker placed the following error handling message after a

series of conditional tests that invoked various control flow branches: ERROR! THERE IS

NO WAY YOU CAN GET HERE. This Òerror messageÓ was uncovered by a customer during

user training!Among the potential errors that should be tested when error handling is evalu-ated are: (1) error description is unintelligible, (2) error noted does not correspond to
error encountered, (3) error condition causes system intervention prior to error han-
dling, (4) exception-condition processing is incorrect, or (5) error description does
not provide enough information to assist in the location of the cause of the error.
Unit-test procedures.
Unit testing is normally considered as an adjunct to thecoding step. The design of unit tests can occur before coding begins or after sourcecode has been generated. A review of design information provides guidance for

establishing test cases that are likely to uncover errors in each of the categories dis-

cussed earlier. Each test case should be coupled with a set of expected results.
Because a component is not a stand-alone program, driver and/or stub softwaremust often be developed for each unit test. The unit test environment is illustrated in

Figure 17.4. In most applications a driveris nothing more than a Òmain programÓ thataccepts test case data, passes such data to the component (to be tested), and prints458PART THREEQUALITY MANAGEMENTWebRef
Useful information on a
wide variety of articles

and resources for
Òagile testingÓ can be
found at testing
.com/agile/.Be sure that youdesign tests to execute
every error-handling

path. If you donÕt, the
path may fail when it
is invoked, exacer-
bating an already dicey
situation.TestcasesInterfaceLocal data structures
Boundary conditions
Independent paths
Error-handling pathsModuleto betestedStubStubDriverRESULTSFIGURE17.4Unit-test
environment
pre75977_ch17.qxd  11/27/08  6:09 PM  Page 458
relevant results. Stubsserve to replace modules that are subordinate (invoked by) the
component to be tested. A stub or Òdummy subprogramÓ uses the subordinate mod-uleÕs interface, may do minimal data manipulation, prints verification of entry, and

returns control to the module undergoing testing.Drivers and stubs represent testing Òoverhead.Ó That is, both are software that
must be written (formal design is not commonly applied) but that is not delivered with
the final software product. If drivers and stubs are kept simple, actual overhead is rel-

atively low. Unfortunately, many components cannot be adequately unit tested with

ÒsimpleÓ overhead software. In such cases, complete testing can be postponed until

the integration test step (where drivers or stubs are also used).Unit testing is simplified when a component with high cohesion is designed.When only one function is addressed by a component, the number of test cases is
reduced and errors can be more easily predicted and uncovered.
17.3.2Integration Testing
A neophyte in the software world might ask a seemingly legitimate question once all
modules have been unit tested: ÒIf they all work individually, why do you doubt that

theyÕll work when we put them together?Ó The problem, of course, is Òputting them

togetherÓÑinterfacing. Data can be lost across an interface; one component can
have an inadvertent, adverse effect on another; subfunctions, when combined, may
not produce the desired major function; individually acceptable imprecision may be
magnified to unacceptable levels; global data structures can present problems.
Sadly, the list goes on and on.
Integration testing is a systematic technique for constructing the software archi-tecture while at the same time conducting tests to uncover errors associated with

interfacing. The objective is to take unit-tested components and build a program
structure that has been dictated by design.There is often a tendency to attempt nonincremental integration; that is, to con-struct the program using a Òbig bangÓ approach. All components are combined in
advance. The entire program is tested as a whole. And chaos usually results! A set
of errors is encountered. Correction is difficult because isolation of causes is com-
plicated by the vast expanse of the entire program. Once these errors are corrected,
new ones appear and the process continues in a seemingly endless loop.Incremental integration is the antithesis of the big bang approach. The programis constructed and tested in small increments, where errors are easier to isolate and
correct; interfaces are more likely to be tested completely; and a systematic test
approach may be applied. In the paragraphs that follow, a number of different incre-

mental integration strategies are discussed.Top-down integration.
Top-down integration testing
is an incremental approachto construction of the software architecture. Modules are integrated by moving
downward through the control hierarchy, beginning with the main control module
CHAPTER 17SOFTWARE TESTING STRATEGIES459There are some situa-tions in which you will
not have the resources
to do comprehensive
unit testing. Select
critical or complex
modules and unit test
only those.TakingtheÒbigbangÓ
approachtointegration

isalazystrategythat

isdoomedtofailure.

Integrateincremen-

tally,testingasyougo.
When you develop aproject schedule, youÕll
have to consider the
manner in which inte-
gration will occur so
that components will
be available when
needed.pre75977_ch17.qxd  11/27/08  6:09 PM  Page 459
(main program). Modules subordinate (and ultimately subordinate) to the main con-trol module are incorporated into the structure in either a depth-first or breadth-first
manner.
Referring to Figure 17.5, depth-first integration
integrates all components on amajor control path of the program structure. Selection of a major path is somewhat
arbitrary and depends on application-specific characteristics. For example, selecting

the left-hand path, components M1, M2, M5would be integrated first. Next, M8or (ifnecessary for proper functioning of M2) M6would be integrated. Then, the centraland right-hand control paths are built. Breadth-first integration
incorporates all com-ponents directly subordinate at each level, moving across the structure horizontally.

From the figure, components M
2, M3, and M4would be integrated first. The next con-trol level, M5, M6, and so on, follows. The integration process is performed in a seriesof five steps:1.The main control module is used as a test driver and stubs are substituted for
all components directly subordinate to the main control module.2.Depending on the integration approach selected (i.e., depth or breadth first),
subordinate stubs are replaced one at a time with actual components.3.Tests are conducted as each component is integrated.
4.On completion of each set of tests, another stub is replaced with the real
component.5.Regression testing (discussed later in this section) may be conducted to
ensure that new errors have not been introduced.The process continues from step 2 until the entire program structure is built.460PART THREEQUALITY MANAGEMENTWhat are thesteps fortop-down
integration??M1M3M2M7M6M5M8M4FIGURE17.5Top-down
integrationpre75977_ch17.qxd  11/27/08  6:09 PM  Page 460
The top-down integration strategy verifies major control or decision points earlyin the test process. In a Òwell-factoredÓ program structure, decision making occurs
at upper levels in the hierarchy and is therefore encountered first. If major control
problems do exist, early recognition is essential. If depth-first integration is selected,
a complete function of the software may be implemented and demonstrated. Early
demonstration of functional capability is a confidence builder for all stakeholders.Top-down strategy sounds relatively uncomplicated, but in practice, logistical
problems can arise. The most common of these problems occurs when processing
at low levels in the hierarchy is required to adequately test upper levels. Stubs
replace low-level modules at the beginning of top-down testing; therefore, no sig-

nificant data can flow upward in the program structure. As a tester, you are left with

three choices: (1) delay many tests until stubs are replaced with actual modules,
(2)develop stubs that perform limited functions that simulate the actual module, or

(3) integrate the software from the bottom of the hierarchy upward.The first approach (delay tests until stubs are replaced by actual modules) cancause you to lose some control over correspondence between specific tests and

incorporation of specific modules. This can lead to difficulty in determining the cause
of errors and tends to violate the highly constrained nature of the top-down
approach. The second approach is workable but can lead to significant overhead, as

stubs become more and more complex. The third approach, called bottom-up inte-
gration is discussed in the paragraphs that follow.
Bottom-up integration.
Bottom-up integration testing,
as its name implies, beginsconstruction and testing with atomic modules(i.e., components at the lowest levelsin the program structure). Because components are integrated from the bottom up,the functionality provided by components subordinate to a given level is always

available and the need for stubs is eliminated. A bottom-up integration strategy may
be implemented with the following steps:1.Low-level components are combined into clusters (sometimes called builds)
that perform a specific software subfunction.2.A driver(a control program for testing) is written to coordinate test case inputand output.3.The cluster is tested.4.Drivers are removed and clusters are combined moving upward in the

program structure.Integration follows the pattern illustrated in Figure 17.6. Components are com-bined to form clusters 1, 2, and 3. Each of the clusters is tested using a driver (shown
as a dashed block). Components in clusters 1 and 2 are subordinate to Ma. Drivers D1and D2are removed and the clusters are interfaced directly to M
a. Similarly, driver D
3for cluster 3 is removed prior to integration with module M
b. Both Maand Mbwillultimately be integrated with component Mc, and so forth.CHAPTER 17SOFTWARE TESTING STRATEGIES461Whatproblemsmay be
encountered
whentop-down

integration is
chosen??What are the
steps forbottom-up
integration??Bottom-up integrationeliminates the need for
complex stubs.pre75977_ch17.qxd  11/27/08  6:09 PM  Page 461
As integration moves upward, the need for separate test drivers lessens. In fact,
if the top two levels of program structure are integrated top down, the number ofdrivers can be reduced substantially and integration of clusters is greatly simplified.Regression testing.
Each time a new module is added as part of integration test-ing, the software changes. New data flow paths are established, new I/O may occur,
and new control logic is invoked. These changes may cause problems with functions

that previously worked flawlessly. In the context of an integration test strategy,

regression testingis the reexecution of some subset of tests that have already beenconducted to ensure that changes have not propagated unintended side effects.In a broader context, successful tests (of any kind) result in the discovery of errors,
and errors must be corrected. Whenever software is corrected, some aspect of the
software configuration (the program, its documentation, or the data that support it)
is changed. Regression testing helps to ensure that changes (due to testing or for
other reasons) do not introduce unintended behavior or additional errors.Regression testing may be conducted manually, by reexecuting a subset of all test
cases or using automated capture/playback tools. Capture/playbacktools
enable thesoftware engineer to capture test cases and results for subsequent playback and
comparison. The regression test suite(the subset of tests to be executed) containsthree different classes of test cases:¥A representative sample of tests that will exercise all software functions.¥Additional tests that focus on software functions that are likely to be affected
by the change.¥Tests that focus on the software components that have been changed.
462PART THREEQUALITY MANAGEMENTMcMaD2D3D1MbCluster 1Cluster 3Cluster 2FIGURE17.6Bottom-upintegrationRegression testing isan important strategy

for reducing Òside
effects.Ó Run regres-
sion tests every time

amajor change is

made to the software
(including the
integration of new
components).pre75977_ch17.qxd  11/27/08  6:09 PM  Page 462
As integration testing proceeds, the number of regression tests can grow quitelarge. Therefore, the regression test suite should be designed to include only those
tests that address one or more classes of errors in each of the major program func-
tions. It is impractical and inefficient to reexecute every test for every program func-
tion once a change has occurred.Smoke testing.
Smoke testing
is an integration testing approach that is com-monly used when product software is developed. It is designed as a pacing mecha-nism for time-critical projects, allowing the software team to assess the project on
a frequent basis. In essence, the smoke-testing approach encompasses the follow-

ing activities:1.Software components that have been translated into code are integrated into
a build.A build includes all data files, libraries, reusable modules, and engi-neered components that are required to implement one or more product
functions.2.A series of tests is designed to expose errors that will keep the build from
properly performing its function. The intent should be to uncover Òshow-

stopperÓ errors that have the highest likelihood of throwing the software
project behind schedule.3.The build is integrated with other builds, and the entire product (in its current
form) is smoke tested daily. The integration approach may be top down or

bottom up.The daily frequency of testing the entire product may surprise some readers. How-ever, frequent tests give both managers and practitioners a realistic assessment of

integration testing progress. McConnell [McC96] describes the smoke test in the
following manner:The smoke test should exercise the entire system from end to end. It does not have to beexhaustive, but it should be capable of exposing major problems. The smoke test should

be thorough enough that if the build passes, you can assume that it is stable enough to
be tested more thoroughly.
Smoke testing provides a number of benefits when it is applied on complex, time-
critical software projects:¥Integration risk is minimized.
Because smoke tests are conducted daily,
incompatibilities and other show-stopper errors are uncovered early, thereby
reducing the likelihood of serious schedule impact when errors are
uncovered.
¥The quality of the end product is improved.
Because the approach is construc-tion (integration) oriented, smoke testing is likely to uncover functional

errors as well as architectural and component-level design errors. If these
errors are corrected early, better product quality will result.
CHAPTER 17SOFTWARE TESTING STRATEGIES463Smoke testing mightbe characterized as a
rolling integration
strategy. The software

is rebuilt (with new
components added)
and smoke tested
every day.
uote:ÒTreat the daily

build as the
heartbeat of the
project. If thereÕs

no heartbeat, the
project is dead.ÓJimMcCarthy
Whatbenefits canbe derived from
smoke testing??pre75977_ch17.qxd  11/27/08  6:09 PM  Page 463
¥Error diagnosis and correction are simplified.Like all integration testingapproaches, errors uncovered during smoke testing are likely to be associ-
ated with Ònew software incrementsÓÑthat is, the software that has just been
added to the build(s) is a probable cause of a newly discovered error.
¥Progressiseasiertoassess.
Witheachpassingday,moreofthesoftwarehas
beenintegratedandmorehasbeendemonstratedtowork.Thisimprovesteam

moraleandgivesmanagersagoodindicationthatprogressisbeingmade.
Strategic options.
There has been much discussion (e.g., [Bei84]) about the rela-tive advantages and disadvantages of top-down versus bottom-up integration test-
ing. In general, the advantages of one strategy tend to result in disadvantages for the
other strategy. The major disadvantage of the top-down approach is the need for

stubs and the attendant testing difficulties that can be associated with them. Prob-
lems associated with stubs may be offset by the advantage of testing major control
functions early. The major disadvantage of bottom-up integration is that Òthe pro-

gram as an entity does not exist until the last module is addedÓ [Mye79]. This draw-

back is tempered by easier test case design and a lack of stubs.Selection of an integration strategy depends upon software characteristics and,sometimes, project schedule. In general, a combined approach (sometimes called
sandwich testing
) that uses top-down tests for upper levels of the program structure,

coupled with bottom-up tests for subordinate levels may be the best compromise.As integration testing is conducted, the tester should identify critical modules. Acritical modulehas one or more of the following characteristics: (1) addresses severalsoftware requirements, (2) has a high level of control (resides relatively high in the
program structure), (3) is complex or error prone, or (4) has definite performance

requirements. Critical modules should be tested as early as is possible. In addition,
regression tests should focus on critical module function.Integrationtestworkproducts.
Anoverallplanforintegrationofthesoftware
andadescriptionofspecifictestsisdocumentedina
Test Specification.
Thisworkprod-
uctincorporatesatestplanandatestprocedureandbecomespartofthesoftware
configuration.Testingisdividedintophasesandbuildsthataddressspecificfunc-

tionalandbehavioralcharacteristicsofthesoftware.Forexample,integrationtesting

forthe
SafeHomesecuritysystemmightbedividedintothefollowingtestphases:
¥User interaction
(command input and output, display representation, errorprocessing and representation)¥Sensor processing(acquisition of sensor output, determination of sensorconditions, actions required as a consequence of conditions)¥Communications functions
(ability to communicate with central monitoringstation)¥Alarm processing(tests of software actions that occur when an alarm isencountered)464PART THREEQUALITY MANAGEMENTWebRef
Pointerstocommentary
ontestingstrategies

canbefoundat

www.qalinks.com
.What is aÒcriticalmoduleÓ and
whyshould we

identify it??pre75977_ch17.qxd  11/27/08  6:09 PM  Page 464
Each of these integration test phases delineates a broad functional categorywithin the software and generally can be related to a specific domain within the soft-ware architecture. Therefore, program builds (groups of modules) are created to cor-

respond to each phase. The following criteria and corresponding tests are applied for
all test phases:Interface integrity.
Internal and external interfaces are tested as each module(orcluster) is incorporated into the structure.
Functional validity.
Tests designed to uncover functional errors are conducted.
Information content.Tests designed to uncover errors associated with local or
global data structures are conducted.Performance.Tests designed to verify performance bounds established during
software design are conducted.A schedule for integration, the development of overhead software, and related
topics are also discussed as part of the test plan. Start and end dates for each phase
are established and Òavailability windowsÓ for unit-tested modules are defined. A
brief description of overhead software (stubs and drivers) concentrates on charac-

teristics that might require special effort. Finally, test environment and resources are

described. Unusual hardware configurations, exotic simulators, and special test
tools or techniques are a few of many topics that may also be discussed.The detailed testing procedure that is required to accomplish the test plan isdescribed next. The order of integration and corresponding tests at each integration
step are described. A listing of all test cases (annotated for subsequent reference)
and expected results are also included.A history of actual test results, problems, or peculiarities is recorded in a Test
Reportthat can be appended to the Test Specification,
if desired.Information con-tained in this section can be vital during software maintenance. Appropriate refer-
ences and appendixes are also presented.Likeallotherelementsofasoftwareconfiguration,thetestspecificationformat
maybetailoredtothelocalneedsofasoftwareengineeringorganization.Itisimpor-

tanttonote,however,thatanintegrationstrategy(containedinatestplan)andtest-

ingdetails(describedinatestprocedure)areessentialingredientsandmustappear.
17.4T
ESTSTRATEGIESFOR
OBJECT-ORIENTEDSOFTWARE
3The objective of testing, stated simply, is to find the greatest possible number of

errors with a manageable amount of effort applied over a realistic time span.

Although this fundamental objective remains unchanged for object-oriented software,

the nature of object-oriented software changes both testing strategy and testing
tactics (Chapter 19).CHAPTER 17SOFTWARE TESTING STRATEGIES4653Basic object-oriented concepts are presented in Appendix 2.
What criteriashould beused to design
integration tests??pre75977_ch17.qxd  11/27/08  6:09 PM  Page 465
17.4.1Unit Testing in the OO Context
Whenobject-orientedsoftwareisconsidered,theconceptoftheunitchanges.
Encapsulationdrivesthedefinitionofclassesandobjects.Thismeansthateachclass

andeachinstanceofaclasspackagesattributes(data)andtheoperationsthat

manipulatethesedata.Anencapsulatedclassisusuallythefocusofunittesting.How-

ever,operations(methods)withintheclassarethesmallesttestableunits.Becausea

classcancontainanumberofdifferentoperations,andaparticularoperationmay

existaspartofanumberofdifferentclasses,thetacticsappliedtounittestingmust

change.You can no longer test a single operation in isolation (the conventional view of
unit testing) but rather as part of a class. To illustrate, consider a class hierarchy in

which an operation Xis defined for the superclass and is inherited by a number ofsubclasses. Each subclass uses operation X, but it is applied within the context of the
private attributes and operations that have been defined for the subclass. Because
the context in which operation Xis used varies in subtle ways, it is necessary to testoperation Xin the context of each of the subclasses. This means that testing opera-tion Xin a stand-alone fashion (the conventional unit-testing approach) is usually
ineffective in the object-oriented context.Class testing for OO software is the equivalent of unit testing for conventional
software. Unlike unit testing of conventional software, which tends to focus on the

algorithmic detail of a module and the data that flow across the module interface,

class testing for OO software is driven by the operations encapsulated by the class
and the state behavior of the class.17.4.2Integration Testing in the OO Context
Because object-oriented software does not have an obvious hierarchical control
structure, traditional top-down and bottom-up integration strategies (Section 17.3.2)

have little meaning. In addition, integrating operations one at a time into a class (the
conventional incremental integration approach) is often impossible because of the

Òdirect and indirect interactions of the components that make up the classÓ [Ber93].There are two different strategies for integration testing of OO systems [Bin94b].The first, thread-based testing,integrates the set of classes required to respond to oneinput or event for the system. Each thread is integrated and tested individually.

Regression testing is applied to ensure that no side effects occur. The second inte-

gration approach, use-based testing,begins the construction of the system by testingthose classes (called independent classes) that use very few (if any) serverclasses.After the independent classes are tested, the next layer of classes, called dependent
classes,that use the independent classes are tested. This sequence of testing layersof dependent classes continues until the entire system is constructed.TheuseofdriversandstubsalsochangeswhenintegrationtestingofOOsystems
isconducted.Driverscanbeusedtotestoperationsatthelowestlevelandforthe

testingofwholegroupsofclasses.Adrivercanalsobeusedtoreplacetheuserinter-

facesothattestsofsystemfunctionalitycanbeconductedpriortoimplementation
466PART THREEQUALITY MANAGEMENTClass testing for OOsoftware is analogous to
module testing for
conventional software. It
is not advisable to test
operations in isolation.An important strategy
for integration testing
of OO software is
thread-based testing.
Threads are sets of
classes that respond to
an input or event. Use-
based tests focus on
classes that do not
collaborate heavily
with other classes.pre75977_ch17.qxd  11/27/08  6:09 PM  Page 466
ofthe interface. Stubs can be used in situations in which collaboration between
classes is required but one or more of the collaborating classes has not yet been fully
implemented.Cluster testingis one step in the integration testing of OO software. Here, a cluster
of collaborating classes (determined by examining the CRC and object-relationship
model) is exercised by designing test cases that attempt to uncover errors in the

collaborations.17.5T
ESTSTRATEGIESFOR
WEBAPPSThe strategy for WebApp testing adopts the basic principles for all software testing

and applies a strategy and tactics that are used for object-oriented systems. The
following steps summarize the approach:1.The content model for the WebApp is reviewed to uncover errors.
2.The interface model is reviewed to ensure that all use cases can be
accommodated.3.The design model for the WebApp is reviewed to uncover navigation errors.
4.The user interface is tested to uncover errors in presentation and/or naviga-

tion mechanics.5.Each functional component is unit tested.6.Navigation throughout the architecture is tested.7.The WebApp is implemented in a variety of different environmental configu-

rations and is tested for compatibility with each configuration.8.Security tests are conducted in an attempt to exploit vulnerabilities in the
WebApp or within its environment.
9.Performance tests are conducted.10.The WebApp is tested by a controlled and monitored population of end users.

The results of their interaction with the system are evaluated for content and
navigation errors, usability concerns, compatibility concerns, and WebApp

reliability and performance.Because many WebApps evolve continuously, the testing process is an ongoing
activity, conducted by support staff who use regression tests derived from the tests

developed when the WebApp was first engineered. Methods for WebApp testing are

considered in Chapter 20.17.6V
ALIDATION
TESTINGValidation testing begins at the culmination of integration testing, when individual

components have been exercised, the software is completely assembled as a pack-
age, and interfacing errors have been uncovered and corrected. At the validation

orsystem level, the distinction between conventional software, object-oriented
CHAPTER 17SOFTWARE TESTING STRATEGIES467The overall strategy forWebApp testing can

besummarized in the

10 steps noted here.WebRef
Excellent articles on
WebApp testing can be

found at www
.stickyminds.com/
testing.asp.pre75977_ch17.qxd  11/27/08  6:09 PM  Page 467
software, and WebApps disappears. Testing focuses on user-visible actions and
user-recognizable output from the system.Validation can be defined in many ways, but a simple (albeit harsh) definition is
that validation succeeds when software functions in a manner that can be reason-
ably expected by the customer. At this point a battle-hardened software developer

might protest: ÒWho or what is the arbiter of reasonable expectations?Ó If a SoftwareRequirements Specificationhas been developed, it describes all user-visible attributesof the software and contains a Validation Criteria
section that forms the basis for avalidation-testing approach.17.6.1Validation-Test Criteria
Software validation is achieved through a series of tests that demonstrate conform-
ity with requirements. A test plan outlines the classes of tests to be conducted, and
a test procedure defines specific test cases that are designed to ensure that all func-
tional requirements are satisfied, all behavioral characteristics are achieved, all con-
tent is accurate and properly presented, all performance requirements are attained,
documentation is correct, and usability and other requirements are met (e.g., trans-
portability, compatibility, error recovery, maintainability).
After each validation test case has been conducted, one of two possible condi-tions exists: (1) The function or performance characteristic conforms to specification
and is accepted or (2) a deviation from specification is uncovered and a deficiency

list is created. Deviations or errors discovered at this stage in a project can rarely be

corrected prior to scheduled delivery. It is often necessary to negotiate with the cus-

tomer to establish a method for resolving deficiencies.17.6.2Configuration Review
An important element of the validation process is a configuration review.
The intentof the review is to ensure that all elements of the software configuration have been
properly developed, are cataloged, and have the necessary detail to bolster the sup-
port activities. The configuration review, sometimes called an audit, is discussed in

more detail in Chapter 22.17.6.3Alpha and Beta Testing
It is virtually impossible for a software developer to foresee how the customer will
really use a program. Instructions for use may be misinterpreted; strange combina-
tions of data may be regularly used; output that seemed clear to the tester may be
unintelligible to a user in the field.When custom software is built for one customer, a series of acceptance tests are
conducted to enable the customer to validate all requirements. Conducted by the end
user rather than software engineers, an acceptance test can range from an informal
Òtest driveÓ to a planned and systematically executed series of tests. In fact, accept-
ance testing can be conducted over a period of weeks or months, thereby uncover-

ing cumulative errors that might degrade the system over time.
468PART THREEQUALITY MANAGEMENTLike all other testingsteps, validation tries
to uncover errors, but

the focus is at the
requirements levelÑ
on things that will be
immediately apparent
to the end user.
uote:ÒGiven enough
eyeballs, all bugs
are shallow (e.g.,
given a large
enough beta-tester
and co-developer
base, almost every

problem will be
characterized
quickly and the
fixobvious to

someone).ÓE.Raymond
pre75977_ch17.qxd  11/27/08  6:09 PM  Page 468
If software is developed as a product to be used by many customers, it is imprac-tical to perform formal acceptance tests with each one. Most software productbuilders use a process called alpha and beta testing to uncover errors that only the

end user seems able to find.The alpha testis conducted at the developerÕs site by a representative group of end
users. The software is used in a natural setting with the developer Òlooking over the

shoulderÓ of the users and recording errors and usage problems. Alpha tests are con-
ducted in a controlled environment.
The beta testis conducted at one or more end-user sites. Unlike alpha testing, thedeveloper generally is not present. Therefore, the beta test is a ÒliveÓ application of

the software in an environment that cannot be controlled by the developer. The cus-

tomer records all problems (real or imagined) that are encountered during beta test-
ing and reports these to the developer at regular intervals. As a result of problems
reported during beta tests, you make modifications and then prepare for release of
the software product to the entire customer base.A variation on beta testing, called customer acceptance testing,is sometimes per-formed when custom software is delivered to a customer under contract. The cus-
tomer performs a series of specific tests in an attempt to uncover errors before

accepting the software from the developer. In some cases (e.g., a major corporate or

governmental system) acceptance testing can be very formal and encompass many

days or even weeks of testing.CHAPTER 17SOFTWARE TESTING STRATEGIES469What is thedifferencebetween an alpha
test and a beta
test??The scene:Doug MillerÕs office, as
component-level design continues and construction ofcertain components continues.
The players:Doug Miller, software engineering
manager, Vinod, Jamie, Ed, and ShakiraÑmembers of
the SafeHomesoftware engineering team.The conversation:Doug:The first increment will be ready for validation inwhat...about three weeks?

Vinod:
ThatÕs about right. Integration is going well.
WeÕre smoke testing daily, finding some bugs but nothing
we canÕt handle. So far, so good.
Doug:Talk to me about validation.
Shakira:Well, weÕll use all of the use cases as the
basisfor our test design. I havenÕt started yet, but IÕll be
developing tests for all of the use cases that IÕve been
responsible for.
Ed:Same here.Jamie:Me too, but weÕve got to get our act together foracceptance test and also for alpha and beta testing, no?Doug:Yes.InfactIÕvebeenthinking;wecouldbringinan
outsidecontractortohelpuswithvalidation.Ihavethe
moneyinthebudget...anditÕdgiveusanewpointofview.
Vinod:
I think weÕve got it under control.Doug:IÕm sure you do, but an ITG gives us anindependent look at the software.
Jamie:WeÕretightontimehere,Doug.IforonedonÕthave
thetimetobabysitanybodyyoubringintodothejob.

Doug:I know, I know. But if an ITG works from
requirements and use cases, not too much babysittingwillbe required.
Vinod:
I still think weÕve got it under control.Doug:I hear you, Vinod, but I going to overrule on this
one. LetÕs plan to meet with the ITG rep later this week.
Get Ôem started and see what they come up with.
Vinod:
Okay, maybe itÕll lighten the load a bit.
SAFEHOMEPreparing for Validation
pre75977_ch17.qxd  11/27/08  6:09 PM  Page 469
17.7S
YSTEMTESTINGAt the beginning of this book, I stressed the fact that software is only one element ofa larger computer-based system. Ultimately, software is incorporated with other sys-

tem elements (e.g., hardware, people, information), and a series of system integra-

tion and validation tests are conducted. These tests fall outside the scope of the
software process and are not conducted solely by software engineers. However,

steps taken during software design and testing can greatly improve the probability

of successful software integration in the larger system.A classic system-testing problem is Òfinger pointing.Ó This occurs when an erroris uncovered, and the developers of different system elements blame each other for

the problem. Rather than indulging in such nonsense, you should anticipate poten-

tial interfacing problems and (1) design error-handling paths that test all information
coming from other elements of the system, (2) conduct a series of tests that simulate
bad data or other potential errors at the software interface, (3) record the results of

tests to use as ÒevidenceÓ if finger pointing does occur, and (4) participate in plan-

ning and design of system tests to ensure that software is adequately tested.System testingis actually a series of different tests whose primary purpose is tofully exercise the computer-based system. Although each test has a different pur-
pose, all work to verify that system elements have been properly integrated and per-

form allocated functions. In the sections that follow, I discuss the types of system

tests that are worthwhile for software-based systems.17.7.1Recovery Testing
Many computer-based systems must recover from faults and resume processing

with little or no downtime. In some cases, a system must be fault tolerant; that is,
processing faults must not cause overall system function to cease. In other cases, a

system failure must be corrected within a specified period of time or severe eco-
nomic damage will occur.
Recovery testing
is a system test that forces the software to fail in a variety of waysand verifies that recovery is properly performed. If recovery is automatic (performed

by the system itself), reinitialization, checkpointing mechanisms, data recovery, and

restart are evaluated for correctness. If recovery requires human intervention, the

mean-time-to-repair (MTTR) is evaluated to determine whether it is within accept-
able limits.17.7.2Security Testing
Anycomputer-basedsystemthatmanagessensitiveinformationorcausesactions

thatcanimproperlyharm(orbenefit)individualsisatargetforimproperorillegal

penetration.Penetrationspansabroadrangeofactivities:hackerswhoattemptto

penetratesystemsforsport,disgruntledemployeeswhoattempttopenetratefor

revenge,dishonestindividualswhoattempttopenetrateforillicitpersonalgain.
470PART THREEQUALITY MANAGEMENTuote:ÒLike death andtaxes, testing is
both unpleasant
and inevitable.ÓEdYourdon
pre75977_ch17.qxd  11/27/08  6:09 PM  Page 470
Security testingattempts to verify that protection mechanisms built into a systemwill, in fact, protect it from improper penetration. To quote Beizer [Bei84]: ÒThe sys-
temÕs security must, of course, be tested for invulnerability from frontal attackÑbut

must also be tested for invulnerability from flank or rear attack.Ó
During security testing, the tester plays the role(s) of the individual who desires topenetrate the system. Anything goes! The tester may attempt to acquire passwords
through external clerical means; may attack the system with custom software
designed to break down any defenses that have been constructed; may overwhelm

the system, thereby denying service to others; may purposely cause system errors,
hoping to penetrate during recovery; may browse through insecure data, hoping to

find the key to system entry.
Given enough time and resources, good security testing will ultimately penetratea system. The role of the system designer is to make penetration cost more than the
value of the information that will be obtained.17.7.3Stress Testing
Earlier software testing steps resulted in thorough evaluation of normal program
functions and performance. Stress tests are designed to confront programs with
abnormal situations. In essence, the tester who performs stress testing asks: ÒHow

high can we crank this up before it fails?ÓStress testingexecutes a system in a manner that demands resources in abnor-mal quantity, frequency, or volume. For example, (1) special tests may be designed

that generate ten interrupts per second, when one or two is the average rate,

(2)input data rates may be increased by an order of magnitude to determine how

input functions will respond, (3) test cases that require maximum memory or other
resources are executed, (4) test cases that may cause thrashing in a virtual oper-
ating system are designed, (5) test cases that may cause excessive hunting for
disk-resident data are created. Essentially, the tester attempts to break the

program.A variation of stress testing is a technique called sensitivity testing.In some situa-tions (the most common occur in mathematical algorithms), a very small range of
data contained within the bounds of valid data for a program may cause extreme and
even erroneous processing or profound performance degradation. Sensitivity testing
attempts to uncover data combinations within valid input classes that may cause

instability or improper processing.17.7.4Performance Testing
For real-time and embedded systems, software that provides required function but

does not conform to performance requirements is unacceptable. Performance test-
ing is designed to test the run-time performance of software within the context of an
integrated system. Performance testing occurs throughout all steps in the testing
process. Even at the unit level, the performance of an individual module may beCHAPTER 17SOFTWARE TESTING STRATEGIES471uote:ÒIf youÕre trying to
find true system
bugs and you
havenÕt subjected
your software to a
real stress test,
then itÕs high time

you started.ÓBorisBeizer
pre75977_ch17.qxd  11/27/08  6:09 PM  Page 471
assessed as tests are conducted. However, it is not until all system elements are fully
integrated that the true performance of a system can be ascertained.Performance tests are often coupled with stress testing and usually require bothhardware and software instrumentation. That is, it is often necessary to measure
resource utilization (e.g., processor cycles) in an exacting fashion. External instru-
mentation can monitor execution intervals, log events (e.g., interrupts) as they oc-
cur, and sample machine states on a regular basis. By instrumenting a system, the

tester can uncover situations that lead to degradation and possible system failure.
17.7.5Deployment Testing
In many cases, software must execute on a variety of platforms and under more
thanone operating system environment. 
Deployment testing,
sometimes calledconfiguration testing,
exercises the software in each environment in which it is to
operate. In addition, deployment testing examines all installation procedures and
specialized installation software (e.g., ÒinstallersÓ) that will be used by customers,
and all documentation that will be used to introduce the software to end users.As an example, consider the Internet-accessible version of 
SafeHomesoftwarethat would allow a customer to monitor the security system from remote locations.
The SafeHomeWebApp must be tested using all Web browsers that are likely to be
encountered. A more thorough deployment test might encompass combinations
ofWeb browsers with various operating systems (e.g., Linux, Mac OS, Windows).

Because security is a major issue, a complete set of security tests would be integrated

with the deployment test.472PART THREEQUALITY MANAGEMENTTest Planning and Management
Objective:These tools assist a software teamin planning the testing strategy that is chosenand managing the testing process as it is conducted.Mechanics:Tools in this category address test planning,
test storage, management and control, requirementstraceability, integration, error tracking, and report

generation. Project managers use them to supplement
project scheduling tools. Testers use these tools to plan

testing activities and to control the flow of information as

the testing process proceeds.Representative Tools:
4QaTraqTestCaseManagementTool,
developedby
TraqSoftware(
www.testmanagement.com
),Òencouragesastructuredapproachtotestmanagement.Ó
QADirector,
developed by Compuware Corp.(www.compuware.com/qacenter
), provides asingle point of control for managing all phases of the
testing process.TestWorks,
developed by Software Research, Inc.(www.soft.com/Products/index.html
),contains a fully integrated suite of testing tools
including tools for test management and reporting.
OpensourceTesting.org
(www.opensourcetesting.org/testmgt.php
)lists a variety of open-source test management and
planning tools.NI TestStand,
developed by National Instruments Corp.(www.ni.com
), allows you to Òdevelop, manage,
and execute test sequences written in any
programming language.ÓSOFTWARE
TOOLS4Tools noted here do not represent an endorsement, but rather a sampling of tools in this category.
In most cases, tool names are trademarked by their respective developers.pre75977_ch17.qxd  11/27/08  6:09 PM  Page 472
17.8T
HEARTOF
DEBUGGINGSoftware testing is a process that can be systematically planned and specified. Test-
case design can be conducted, a strategy can be defined, and results can be evalu-
ated against prescribed expectations.Debuggingoccurs as a consequence of successful testing. That is, when a testcase uncovers an error, debugging is the process that results in the removal of the

error. Although debugging can and should be an orderly process, it is still very much

an art. As a software engineer, you are often confronted with a ÒsymptomaticÓ indi-

cation of a software problem as you evaluate the results of a test. That is, the exter-
nal manifestation of the error and its internal cause may have no obvious
relationship to one another. The poorly understood mental process that connects a

symptom to a cause is debugging.17.8.1The Debugging Process
Debugging is not testing but often occurs as a consequence of testing.5Referring toFigure 17.7, the debugging process begins with the execution of a test case. Results
are assessed and a lack of correspondence between expected and actual perform-
ance is encountered. In many cases, the noncorresponding data are a symptom of
an underlying cause as yet hidden. The debugging process attempts to match symp-
tom with cause, thereby leading to error correction.
The debugging process will usually have one of two outcomes: (1) the cause willbe found and corrected or (2) the cause will not be found. In the latter case, the per-

son performing debugging may suspect a cause, design a test case to help validate

that suspicion, and work toward error correction in an iterative fashion.Why is debugging so difficult? In all likelihood, human psychology (see Sec-tion17.8.2) has more to do with an answer than software technology. However, a

few characteristics of bugs provide some clues:
1.The symptom and the cause may be geographically remote. That is, the
symptom may appear in one part of a program, while the cause may actually
be located at a site that is far removed. Highly coupled components

(Chapter8) exacerbate this situation.
2.The symptom may disappear (temporarily) when another error is corrected.3.Thesymptommayactuallybecausedbynonerrors(e.g.,round-off

inaccuracies).4.The symptom may be caused by human error that is not easily traced.CHAPTER 17SOFTWARE TESTING STRATEGIES473uote:ÒWe found to our
surprise that it
wasnÕt as easy to
get programs right
as we had thought.
I can remember
the exact instant
when I realized
that a large part of
my life from then
on was going to be
spent in finding
mistakes in my
own programs.ÓMauriceWilkes,
discovers
debugging,1949
5In making the statement, we take the broadest possible view of testing. Not only does the devel-
oper test software prior to release, but the customer/user tests software every time it is used!Be certain to avoid a
third outcome: The
cause is found, but the
ÒcorrectionÓ does not

solve the problem or
introduces still another
error.
Why isdebugging sodifficult??pre75977_ch17.qxd  11/27/08  6:09 PM  Page 473
5.The symptom may be a result of timing problems, rather than processingproblems.6.It may be difficult to accurately reproduce input conditions (e.g., a real-time
application in which input ordering is indeterminate).7.The symptom may be intermittent. This is particularly common in embedded
systems that couple hardware and software inextricably.
8.The symptom may be due to causes that are distributed across a number of
tasks running on different processors.During debugging, youÕll encounter errors that range from mildly annoying (e.g.,an incorrect output format) to catastrophic (e.g., the system fails, causing serious
economic or physical damage). As the consequences of an error increase, the

amount of pressure to find the cause also increases. Often, pressure forces some
software developers to fix one error and at the same time introduce two more.17.8.2Psychological Considerations
Unfortunately,thereappearstobesomeevidencethatdebuggingprowessisaninnate

humantrait.SomepeoplearegoodatitandothersarenÕt.Althoughexperimental

evidenceondebuggingisopentomanyinterpretations,largevariancesindebugging
474PART THREEQUALITY MANAGEMENTRegressiontestsCorrectionsIdentifiedcausesAdditional testsSuspected causesResultsDebuggingTest
CasesFIGURE17.7Thedebugging
process
ÒEveryone
knows thatdebugging is
twice as hard as
writing a pro-
gram in the first
place. So if you
are as clever as
you can be when
you write it, how
will you ever
debug it?ÓBrianKernighan?pre75977_ch17.qxd  11/27/08  6:09 PM  Page 474
abilityhavebeenreportedforprogrammerswiththesameeducationandexperience.
Commentingonthehumanaspectsofdebugging,Shneiderman[Shn80]states:
Debugging is one of the more frustrating parts of programming. It has elements of prob-lem solving or brain teasers, coupled with the annoying recognition that you have made
a mistake. Heightened anxiety and the unwillingness to accept the possibility of errors
increases the task difficulty. Fortunately, there is a great sigh of relief and a lessening of

tension when the bug is ultimately . . . corrected.Although it may be difficult to ÒlearnÓ debugging, a number of approaches to theproblem can be proposed. I examine them in Section 17.8.3.CHAPTER 17SOFTWARE TESTING STRATEGIES475Set a time limit, saytwo hours, on the
amount of time you
spend trying to debug

a problem on your
own. After that, get
help!Debugging
The scene:EdÕs cubical as code and
unit testing is conducted.The players:Ed and ShakiraÑmembers of theSafeHomesoftware engineering team.The conversation:
Shakira (looking in through the entrance to
the cubical):Hey...where were you at lunchtime?
Ed:Right here...working.Shakira:You look miserable
...whatÕs the matter?
Ed (sighing audibly):IÕve been working on this...
bug since I discovered it at 9:30 this morning and itÕs

what, 2:45...IÕm clueless.
Shakira:I thought we all agreed to spend no morethanone hour debugging stuff on our own; then we get

help, right?Ed:Yeah, but...
Shakira (walking into the cubical):So whatÕs the
problem?Ed:ItÕs complicated, and besides, IÕve been looking at
this for, what, 5 hours. YouÕre not going to see it in
5minutes.
Shakira:Indulge me ... whatÕs the problem?
[Ed explains the problem to Shakira, who looks at it forabout 30 seconds without speaking, then...]

Shakira (a smile is gathering on her face):Uh,right there, the variable named 
setAlarmCondition.

ShouldnÕt it be set to ÒfalseÓ before the loop gets started?
[Ed stares at the screen in disbelief, bends forward, and
begins to bang his head gently against the monitor.

Shakira, smiling broadly now, stands and walks out.]
SAFEHOME17.8.3Debugging Strategies
Regardless of the approach that is taken, debugging has one overriding objectiveÑ
to find and correct the cause of a software error or defect. The objective is realized
by a combination of systematic evaluation, intuition, and luck. Bradley [Bra85]
describes the debugging approach in this way:Debugging is a straightforward application of the scientific method that has been devel-oped over 2,500 years. The basis of debugging is to locate the problemÕs source [the

cause] by binary partitioning, through working hypotheses that predict new values to be
examined.Take a simple non-software example: A lamp in my house does not work. If nothing
in the house works, the cause must be in the main circuit breaker or outside; I look aroundpre75977_ch17.qxd  11/27/08  6:09 PM  Page 475
to see whether the neighborhood is blacked out. I plug the suspect lamp into a workingsocket and a working appliance into the suspect circuit. So goes the alternation of
hypothesis and test.In general, three debugging strategies have been proposed [Mye79]: (1) bruteforce, (2) backtracking, and (3) cause elimination. Each of these strategies can
beconducted manually, but modern debugging tools can make the process much

more effective.Debugging tactics.The brute force
category of debugging is probably the mostcommon and least efficient method for isolating the cause of a software error. You
apply brute force debugging methods when all else fails. Using a Òlet the computer
find the errorÓ philosophy, memory dumps are taken, run-time traces are invoked,

and the program is loaded with output statements. You hope that somewhere in the

morass of information that is produced youÕll find a clue that can lead to the cause
of an error. Although the mass of information produced may ultimately lead to

success, it more frequently leads to wasted effort and time. Thought must be
expended first!Backtracking
is a fairly common debugging approach that can be used success-fully in small programs. Beginning at the site where a symptom has been uncovered,

the source code is traced backward (manually) until the cause is found. Unfortu-
nately, as the number of source lines increases, the number of potential backward

paths may become unmanageably large.The third approach to debuggingÑcause eliminationÑis manifested by inductionor deduction and introduces the concept of binary partitioning. Data related to the
error occurrence are organized to isolate potential causes. A Òcause hypothesisÓ is
devised and the aforementioned data are used to prove or disprove the hypothesis.

Alternatively, a list of all possible causes is developed and tests are conducted to

eliminate each. If initial tests indicate that a particular cause hypothesis shows
promise, data are refined in an attempt to isolate the bug.
Automated debugging.Each of these debugging approaches can be supple-mented with debugging tools that can provide you with semiautomated support as
debugging strategies are attempted. Hailpern and Santhanam [Hai02] summarize
the state of these tools when they note, Ò. . . many new approaches have been pro-

posed and many commercial debugging environments are available. Integrated

development environments (IDEs) provide a way to capture some of the language-

specific predetermined errors (e.g., missing end-of-statement characters, unde-
fined variables, and so on) without requiring compilation.Ó A wide variety of
debugging compilers, dynamic debugging aids (ÒtracersÓ), automatic test-case
generators, and cross-reference mapping tools are available. However, tools are

not a substitute for careful evaluation based on a complete design model and clear
source code.476PART THREEQUALITY MANAGEMENTuote:ÒThefirststepin
fixingabroken

programisgetting

ittofailrepeatably

(onthesimplest

examplepossible).Ó
T.Duff
pre75977_ch17.qxd  11/27/08  6:09 PM  Page 476
The people factor.
Any discussion of debugging approaches and tools is incom-plete without mention of a powerful allyÑother people! A fresh viewpoint, un-clouded by hours of frustration, can do wonders.7A final maxim for debugging mightbe: ÒWhen all else fails, get help!Ó17.8.4Correcting the Error
Once a bug has been found, it must be corrected. But, as we have already noted, the
correction of a bug can introduce other errors and therefore do more harm than
good. Van Vleck [Van89] suggests three simple questions that you should ask before

making the ÒcorrectionÓ that removes the cause of a bug:
1.Is the cause of the bug reproduced in another part of the program?
In many situ-ations, a program defect is caused by an erroneous pattern of logic that may
be reproduced elsewhere. Explicit consideration of the logical pattern may
result in the discovery of other errors.
2.What Ònext bugÓ might be introduced by the fix IÕm about to make?
Before thecorrection is made, the source code (or, better, the design) should be evalu-

ated to assess coupling of logic and data structures. If the correction is to be
made in a highly coupled section of the program, special care must be taken
when any change is made.CHAPTER 17SOFTWARE TESTING STRATEGIES477DebuggingObjective:These tools provide automatedassistance for those who must debug softwareproblems. The intent is to provide insight that may bedifficult to obtain if approaching the debugging process

manually.
Mechanics:Most debugging tools are programminglanguage and environment specific.Representative Tools:
6Borland Gauntlet,distributed by Borland(www.borland.com
), assists in both testing anddebugging.Coverty Prevent SQS, developed by Coverty
(www.coverty.com
), provides debugging
assistance for both C++ and Java.C++Test,
developed by Parasoft (www.parasoft.com
),is a unit-testing tool that supports a full range of tests

on C and C++ code. Debugging features assist in the
diagnosis of errors that are found.CodeMedic,developed by NewPlanet Software(www.newplanetsoftware.com/medic/
),provides a graphical interface for the standard UNIX

debugger, 
gdb,and implements its most important
features. gdbcurrently supports C/C++, Java,
PalmOS, various embedded systems, assembly
language, FORTRAN, and Modula-2.
GNATS
, a freeware application (www.gnu.org/
software/gnats/), is a set of tools for tracking bug
reports.
SOFTWARE
TOOLS6Tools noted here do not represent an endorsement, but rather a sampling of tools in this category.
In most cases, tool names are trademarked by their respective developers.7The concept of pair programming (recommended as part of the Extreme Programming model dis-
cussed in Chapter 3) provides a mechanism for ÒdebuggingÓ as the software is designed and coded.uote:ÒThe best testerisnÕt the one who
finds the most
bugsÉ the best

tester is the one
who gets the most
bugs fixed.ÓCemKaner et al.
pre75977_ch17.qxd  11/27/08  6:09 PM  Page 477
3.What could we have done to prevent this bug in the first place?This question isthe first step toward establishing a statistical software quality assurance ap-proach (Chapter 16). If you correct the process as well as the product, the bug
will be removed from the current program and may be eliminated from all

future programs.17.9S
UMMARYSoftware testing accounts for the largest percentage of technical effort in the soft-
ware process. Regardless of the type of software you build, a strategy for systematic
test planning, execution, and control begins by considering small elements of the
software and moves outward toward the program as a whole.
The objective of software testing is to uncover errors. For conventional software,
this objective is achieved through a series of test steps. Unit and integration tests
concentrate on functional verification of a component and incorporation of compo-
nents into the software architecture. Validation testing demonstrates traceability to

software requirements, and system testing validates software once it has been
incorporated into a larger system. Each test step is accomplished through a series of
systematic test techniques that assist in the design of test cases. With each testing

step, the level of abstraction with which software is considered is broadened.The strategy for testing object-oriented software begins with tests that exercisethe operations within a class and then moves to thread-based testing for integration.

Threads are sets of classes that respond to an input or event. Use-based tests focus
on classes that do not collaborate heavily with other classes.WebApps are tested in much the same way as OO systems. However, tests are
designed to exercise content, functionality, the interface, navigation, and aspects of

WebApp performance and security.
Unlike testing (a systematic, planned activity), debugging can be viewed as an
art. Beginning with a symptomatic indication of a problem, the debugging activity
must track down the cause of an error. Of the many resources available during

debugging, the most valuable is the counsel of other members of the software
engineering staff.PROBLEMSAND
POINTSTO
PONDER17.1.Using your own words, describe the difference between verification and validation.Doboth make use of test-case design methods and testing strategies?
17.2.List some problems that might be associated with the creation of an independent testgroup. Are an ITG and an SQA group made up of the same people?
17.3.Is it always possible to develop a strategy for testing software that uses the sequence oftesting steps described in Section 17.1.3? What possible complications might arise for embed-ded systems?17.4.Why is a highly coupled module difficult to unit test?478PART THREEQUALITY MANAGEMENTpre75977_ch17.qxd  11/27/08  6:09 PM  Page 478
17.5.The concept of ÒantibuggingÓ (Section 17.2.1) is an extremely effective way to provide
built-in debugging assistance when an error is uncovered:
a.Develop a set of guidelines for antibugging.
b.Discuss advantages of using the technique.
c.Discuss disadvantages.
17.6.How can project scheduling affect integration testing?17.7.Is unit testing possible or even desirable in all circumstances? Provide examples to justify
your answer.
17.8.Who should perform the validation testÑthe software developer or the software user?Justify your answer.

17.9.Develop a complete test strategy for the SafeHomesystem discussed earlier in this book.Document it in a Test Specification.

17.10.As a class project, develop a Debugging Guidefor your installation. The guide shouldprovide language and system-oriented hints that have been learned through the school of hard
knocks! Begin with an outline of topics that will be reviewed by the class and your instructor.

Publish the guide for others in your local environment.
FURTHER
READINGSAND
INFORMATION
SOURCESVirtuallyeverybookonsoftwaretestingdiscussesstrategiesalongwithmethodsfortest-case

design.EverettandRaymond(
SoftwareTesting,
Wiley-IEEEComputerSocietyPress,2007),Black
(PragmaticSoftwareTesting,
Wiley,2007),Spillerandhiscolleagues(
SoftwareTestingProcess:Test
Management,RockyNook,2007),Perry(
EffectiveMethodsforSoftwareTesting,
3ded.,Wiley,2005),
Lewis(
SoftwareTestingandContinuousQualityImprovement,
2ded.,Auerbach,2004),Loveland
andhiscolleagues(
SoftwareTestingTechniques,
CharlesRiverMedia,2004),Burnstein(
Practical
SoftwareTesting,
Springer,2003),Dustin(
EffectiveSoftwareTesting,
Addison-Wesley,2002),Craig
andKaskiel(
SystematicSoftwareTesting,
ArtechHouse,2002),Tamres(
IntroducingSoftwareTest-
ing,Addison-Wesley,2002),Whittaker(
HowtoBreakSoftware,
Addison-Wesley,2002),andKaner
andhiscolleagues(
LessonsLearnedinSoftwareTesting,
Wiley,2001)areonlyasmallsamplingof
manybooksthatdiscusstestingprinciples,concepts,strategies,andmethods.
For those readers with interest in agile software development methods, Crispin and House(Testing Extreme Programming,
Addison-Wesley, 2002) and Beck (
Test Driven Development: By
Example,Addison-Wesley, 2002) present testing strategies and tactics for Extreme Program-
ming. Kamer and his colleagues (Lessons Learned in Software Testing,
Wiley, 2001) present a
collection of over 300 pragmatic ÒlessonsÓ (guidelines) that every software tester should learn.

Watkins (
Testing IT: An Off-the-Shelf Testing Process,
Cambridge University Press, 2001) estab-lishes an effective testing framework for all types of developed and acquired software. Manges
and OÕBrien (Agile Testing with Ruby and Rails,
Apress, 2008) addresses testing strategies andtechniques for the Ruby programming language and Web framework.
Sykes and McGregor (Practical Guide to Testing Object-Oriented Software,
Addison-Wesley,
2001), Bashir and Goel (Testing Object-Oriented Software,
Springer-Verlag, 2000), Binder (
Testing
Object-Oriented Systems,Addison-Wesley, 1999), Kung and his colleagues (
Testing Object-
Oriented Software,IEEE Computer Society Press, 1998), and Marick (The Craft of Software Testing,
Prentice-Hall, 1997) present strategies and methods for testing OO systems.Guidelines for debugging are contained in books by Grıtker and his colleagues (The Devel-operÕs Guide to Debugging,
Springer, 2008), Agans (
Debugging,Amacon, 2006), Zeller (Why
Programs Fail: A Guide to Systematic Debugging,
Morgan Kaufmann, 2005), Tells and Hsieh (
TheScience of Debugging,The Coreolis Group, 2001), and Robbins (Debugging Applications,Microsoft Press, 2000). Kaspersky (Hacker Debugging Uncovered,
A-List Publishing, 2005)addresses the technology of debugging tools. Younessi (
Object-Oriented Defect Management of
Software,Prentice-Hall, 2002) presents techniques for managing defects that are encountered inCHAPTER 17SOFTWARE TESTING STRATEGIES479pre75977_ch17.qxd  11/27/08  6:09 PM  Page 479
object-oriented systems. Beizer [Bei84] presents an interesting Òtaxonomy of bugsÓ that can leadto effective methods for test planning.Books by Madisetti and Akgul (Debugging Embedded Systems,Springer, 2007), Robbins
(Debugging Microsoft .NET 2.0 Applications,Microsoft Press, 2005), Best (Linux Debugging and
Performance Tuning,
Prentice-Hall, 2005), Ford and Teorey (
Practical Debugging in C++,
Prentice-Hall, 2002), Brown (Debugging Perl,McGraw-Hill, 2000), and Mitchell (
Debugging Java,
McGraw-
Hill, 2000) address the special nature of debugging for the environments implied by their titles.
A wide variety of information sources on software testing strategies are available on theInternet. An up-to-date list of World Wide Web references that are relevant to software testing

strategies can be found at the SEPA website: 
www.mhhe.com/engcs/compsci/pressman/
professional/olc/ser.htm
.480PART THREEQUALITY MANAGEMENTpre75977_ch17.qxd  11/27/08  6:09 PM  Page 480
Testing presents an interesting anomaly for software engineers, who by theirnature are constructive people. Testing requires that the developer discard

preconceived notions of the ÒcorrectnessÓ of software just developed andthen work hard to design test cases to ÒbreakÓ the software. Beizer [Bei90]
describes this situation effectively when he states:ThereÕsamyththatifwewerereallygoodatprogramming,therewouldbenobugsto
catch.Ifonlywecouldreallyconcentrate,ifonlyeveryoneusedstructuredprogram-

ming,top-downdesign,
...thentherewouldbenobugs.Sogoesthemyth.Thereare
bugs,themythsays,becausewearebadatwhatwedo;andifwearebadatit,we

shouldfeelguiltyaboutit.Therefore,testingandtestcasedesignisanadmissionof

failure,whichinstillsagoodlydoseofguilt.Andthetediumoftestingisjustpunish-

mentforourerrors.Punishmentforwhat?Forbeinghuman?Guiltforwhat?Forfail-

ingtoachieveinhumanperfection?Fornotdistinguishingbetweenwhatanother

programmerthinksandwhathesays?Forfailingtobetelepathic?Fornotsolving

humancommunicationsproblemsthathavebeenkickedaround...forfortycenturies?
Should testing instill guilt? Is testing really destructive? The answer to these ques-tions is ÒNo!ÓIn this chapter, I discuss techniques for software test-case design for conven-
tional applications. Test-case design focuses on a set of techniques for the cre-

ation of test cases that meet overall testing objectives and the testing strategies

discussed in Chapter 17.481CHAPTER18TESTINGCONVENTIONALAPPLICATIONS
What is it?Once source code hasbeen generated, software must betested to uncover (and correct) as
many errors as possible before deliv-ery to your customer. Your goal is to design a

series of test cases that have a high likelihood of
finding errorsÑbut how? ThatÕs where software

testing techniques enter the picture. These tech-
niques provide systematic guidance for design-
ing tests that (1) exercise the internal logic and

interfaces of every software component and (2)

exercise the input and output domains of the pro-
gram to uncover errors in program function,
behavior, and performance.
QUICKLOOKWho does it?During early stages of testing, asoftware engineer performs all tests. However,

as the testing process progresses, testing spe-
cialists may become involved.Why is it important?
Reviews and other SQAactions can and do uncover errors, but they are
not sufficient. Every time the program is executed,

the customer tests it! Therefore, you have to exe-
cute the program before it gets to the customer
with the specific intent of finding and removing all
errors. In order to find the highest possible num-
ber of errors, tests must be conducted systemati-
cally andtest cases must be designed using

disciplined techniques.KEYCONCEPTSbasis path testing . . . . . . . . .485
black-boxtesting . . . . . . . . .495
boundary valueanalysis . . . . . . . .498
control structuretesting . . . . . . . . .492
cyclomaticcomplexity . . . . . .488
equivalencepartitioning . . . . . .497
flow graph . . . . . .485

graph-based testingmethods . . . . . . . .495
graph matrices . . .491

model-based testing . . . . . . . . .502
orthogonal arraytesting . . . . . . . . .499
patterns . . . . . . . .507

specializedenvironments . . . .503
white-box testing . . . . . . . . .485
pre75977_ch18.qxd  11/27/08  6:12 PM  Page 481
482PART THREEQUALITY MANAGEMENT18.1S
OFTWARE
TESTINGFUNDAMENTALS
The goal of testing is to find errors, and a good test is one that has a high probabil-ity of finding an error. Therefore, you should design and implement a computer-

based system or a product with ÒtestabilityÓ in mind. At the same time, the tests

themselves must exhibit a set of characteristics that achieve the goal of finding the
most errors with a minimum of effort.Testability.
James Bach1provides the following definition for testability: Ò
Softwaretestabilityis simply how easily [a computer program] can be tested.Ó The followingcharacteristics lead to testable software.Operability.
ÒThe better it works, the more efficiently it can be tested.Ó If a systemis designed and implemented with quality in mind, relatively few bugs will blockthe execution of tests, allowing testing to progress without fits and starts.Observability.
ÒWhat you see is what you test.Ó Inputs provided as part of testing
produce distinct outputs. System states and variables are visible or queriable dur-
ing execution. Incorrect output is easily identified. Internal errors are automatically
detected and reported. Source code is accessible.Controllability.
ÒThe better we can control the software, the more the testing can
be automated and optimized.Ó All possible outputs can be generated through some
combination of input, and I/O formats are consistent and structured. All code is
executable through some combination of input. Software and hardware states anduote:ÒEvery program
does something
right, it just may
not be the thing we
want it to do.ÓAuthorunknown
What are thecharacter-istics of
testability??1The paragraphs that follow are used with permission of James Bach (copyright 1994) and have been
adapted from material that originally appeared in a posting in the newsgroup comp.software-eng.What are the steps?For conventional applica-tions, software is tested from two different per-
spectives: (1) internal program logic is exercised

using Òwhite boxÓ test-case design techniques
and (2) software requirements are exercised
using Òblack boxÓ test-case design techniques.
Use cases assist in the design of tests to uncover
errors at the software validation level. In every

case, the intent is to find the maximum number
of errors with the minimum amount of effort

andtime.
What is the work product?
A set of test casesdesigned to exercise both internal logic,
interfaces, component collaborations, and

external requirements is designed and docu-

mented, expected results are defined, and actual
results are recorded.How do I ensure that IÕve done it right?Whenyou begin testing, change your point of view. Try

hard to ÒbreakÓ the software! Design test cases
in a disciplined fashion and review the test cases
you do create for thoroughness. In addition, you
can evaluate test coverage and track error
detection activities.pre75977_ch18.qxd  11/27/08  6:12 PM  Page 482
variables can be controlled directly by the test engineer. Tests can be conveniently
specified, automated, and reproduced.Decomposability.
ÒBy controlling the scope of testing, we can more quicklyisolate problems and perform smarter retesting.Ó The software system is built from
independent modules that can be tested independently.
Simplicity.
ÒThe less there is to test, the more quickly we can test it.Ó The pro-gram should exhibit functional simplicity(e.g., the feature set is the minimum nec-essary to meet requirements);structural simplicity
(e.g., architecture is modularizedto limit the propagation of faults), and code simplicity(e.g., a coding standard isadopted for ease of inspection and maintenance).Stability.
ÒThe fewer the changes, the fewer the disruptions to testing.Ó Changesto the software are infrequent, controlled when they do occur, and do not invali-

date existing tests. The software recovers well from failures.
Understandability.
ÒThe more information we have, the smarter we will test.Ó The
architectural design and the dependencies between internal, external, and shared
components are well understood. Technical documentation is instantly accessible,

well organized, specific and detailed, and accurate. Changes to the design are
communicated to testers.You can use the attributes suggested by Bach to develop a software configuration
(i.e., programs, data, and documents) that is amenable to testing.Test Characteristics.
And what about the tests themselves? Kaner, Falk, and
Nguyen [Kan93] suggest the following attributes of a ÒgoodÓ test:A good test has a high probability of finding an error.
To achieve this goal, the
tester must understand the software and attempt to develop a mental picture ofhow the software might fail. Ideally, the classes of failure are probed. For example,

one class of potential failure in a graphical user interface is the failure to recognize
proper mouse position. A set of tests would be designed to exercise the mouse in
an attempt to demonstrate an error in mouse position recognition.A good test is not redundant.Testing time and resources are limited. There is no
point in conducting a test that has the same purpose as another test. Every test
should have a different purpose (even if it is subtly different).A good test should be Òbest of breedÓ[Kan93]. In a group of tests that have a simi-lar intent, time and resource limitations may mitigate toward the execution of only
a subset of these tests. In such cases, the test that has the highest likelihood of
uncovering a whole class of errors should be used.
A good test should be neither too simple nor too complex.Although it is sometimespossible to combine a series of tests into one test case, the possible side effects

associated with this approach may mask errors. In general, each test should be
executed separately.
CHAPTER 18TESTING CONVENTIONAL APPLICATIONS483uote:ÒErrors are morecommon, more
pervasive, and

more troublesome
in software than
with other
technologies.ÓDavidParnas
What is aÒgoodÓtest??pre75977_ch18.qxd  11/27/08  6:12 PM  Page 483
18.2I
NTERNALAND
EXTERNALVIEWSOF
TESTINGAny engineered product (and most other things) can be tested in one of two ways:(1)Knowing the specified function that a product has been designed to perform, tests

can be conducted that demonstrate each function is fully operational while at the same
time searching for errors in each function. (2) Knowing the internal workings of a prod-
uct, tests can be conducted to ensure that Òall gears mesh,Ó that is, internal operations
are performed according to specifications and all internal components have been ade-
quately exercised. The first test approach takes an external view and is called black-box
testing. The second requires an internal view and is termed white-box testing.2Black-box testing
alludes to tests that are conducted at the software interface.Ablack-box test examines some fundamental aspect of a system with little regard

for the internal logical structure of the software. White-box testingof software is pred-icated on close examination of procedural detail. Logical paths through the software
and collaborations between components are tested by exercising specific sets of
conditions and/or loops.At first glance it would seem that very thorough white-box testing would leadtoÒ100 percent correct programs.Ó All we need do is define all logical paths, develop

test cases to exercise them, and evaluate results, that is, generate test cases to
exercise program logic exhaustively. Unfortunately, exhaustive testing presents
484PART THREEQUALITY MANAGEMENTDesigning Unique Tests
The scene:VinodÕs cubical.
The players:Vinod and EdÑmembers of the
SafeHomesoftware engineering team.The conversation:Vinod:
So these are the test cases you intend to run forthe passwordValidation
operation.Ed:Yeah, they should cover pretty much all possibilities
for the kinds of passwords a user might enter.

Vinod:
So letÕs see . . . you note that the correct
password will be 8080, right?
Ed:Uh huh.Vinod:
And you specify passwords 1234 and 6789 totest for error in recognizing invalid passwords?
Ed:Right, and I also test passwords that are close to thecorrect password, see . . . 8081 and 8180.Vinod:
Those are okay, but I donÕt see much point in
running both the 1234 and 6789 inputs. TheyÕreredundant . . . test the same thing, donÕt they?
Ed:Well, theyÕre different values.
Vinod:
ThatÕs true, but if 1234 doesnÕt uncover an
error...in other words
...the 
passwordValidation
operation notes that itÕs an invalid password, itÕs not likely
that 6789 will show us anything new.
Ed:I see what you mean.Vinod:
IÕm not trying to be picky here . . . itÕs just that
we have limited time to do testing, so itÕs a good idea to
run tests that have a high likelihood of finding new errors.Ed:Not a problem . . . IÕll give this a bit more thought.SAFEHOME2The terms 
functional testingand structural testingare sometimes used in place of black-box andwhite-box testing, respectively.uote:ÒThere is only onerule in designing
test cases: cover all
features, but do
not make too
many test cases.ÓTsuneoYamaura
White-box tests can bedesigned only after
component-level design
(or source code)
exists. The logical
details of the program
must be available.pre75977_ch18.qxd  11/27/08  6:12 PM  Page 484
certain logistical problems. For even small programs, the number of possible logicalpaths can be very large. White-box testing should not, however, be dismissed as

impractical. A limited number of important logical paths can be selected and
exercised. Important data structures can be probed for validity.
CHAPTER 18TESTING CONVENTIONAL APPLICATIONS485Exhaustive Testing
Consider a 100-line program in the languageC. After some basic data declaration, theprogram contains two nested loops that execute from 1 to20 times each, depending on conditions specified at input.
Inside the interior loop, four if-then-else constructs are
required. There are approximately 1014possible paths thatmay be executed in this program!To put this number in perspective, we assume that a
magic test processor (ÒmagicÓ because no such processorexists) has been developed for exhaustive testing. The
processor can develop a test case, execute it, and evaluate
the results in one millisecond. Working 24 hours a day,

365daysayear,theprocessorwouldworkfor3170years

to test the program. This would, undeniably, cause havoc

in most development schedules.Therefore, it is reasonable to assert that exhaustive
testing is impossible for large software systems.INFO18.3W
HITE-BOXTESTINGWhite-box testing,sometimes called glass-box testing,is a test-case design philoso-phy that uses the control structure described as part of component-level design toderive test cases. Using white-box testing methods, you can derive test cases that
(1)guarantee that all independent paths within a module have been exercised at

least once, (2) exercise all logical decisions on their true and false sides, (3) execute

all loops at their boundaries and within their operational bounds, and (4) exercise
internal data structures to ensure their validity.
18.4B
ASISPATH
TESTINGBasis path testingis a white-box testing technique first proposed by Tom McCabe
[McC76]. The basis path method enables the test-case designer to derive a logical
complexity measure of a procedural design and use this measure as a guide for defin-
ing a basis set of execution paths. Test cases derived to exercise the basis set are guar-

anteed to execute every statement in the program at least one time during testing.18.4.1Flow Graph Notation
Before we consider the basis path method, a simple notation for the representation
of control flow, called a 
flow graph
(or program graph
) must be introduced.3The flowgraph depicts logical control flow using the notation illustrated in Figure 18.1. Each
structured construct (Chapter 10) has a corresponding flow graph symbol.uote:ÒBugs lurk incorners and
congregate at
boundaries.ÓBorisBeizer
3In actuality, the basis path method can be conducted without the use of flow graphs. However, they
serve as a useful notation for understanding control flow and illustrating the approach.pre75977_ch18.qxd  11/27/08  6:12 PM  Page 485
Toillustratetheuseofaflowgraph,considertheproceduraldesignrepresentationin
Figure18.2a.Here,aflowchartisusedtodepictprogramcontrolstructure.Figure18.2b
maps the flowchart into a corresponding flow graph (assuming that no compound
conditions are contained in the decision diamonds of the flowchart). Referring to
Figure 18.2b, each circle, called a 
flow graph node,
represents one or more proceduralstatements. A sequence of process boxes and a decision diamond can map into a sin-
gle node. The arrows on the flow graph, called edgesor links,represent flow of con-trol and are analogous to flowchart arrows. An edge must terminate at a node, even

if the node does not represent any procedural statements (e.g., see the flow graph
symbol for the if-then-else construct). Areas bounded by edges and nodes are called
regions.When counting regions, we include the area outside the graph as a region.4486PART THREEQUALITY MANAGEMENTIfWhileThe structured constructs in flow graph form:
Where each circle represents one or morenonbranching PDL or source code statementsUntilCaseSequenceFIGURE18.1Flow graphnotation1310(a)692458711(b)12,34,569101187R1R3R2R4RegionNodeEdgeFIGURE18.2(a) Flowchart and (b) flow graph4A more detailed discussion of graphs and their uses is presented in Section 18.6.1.
A flow graph should bedrawn only when the
logical structure of a

component is complex.
The flow graph allows
you to trace program
paths more readily.
pre75977_ch18.qxd  11/27/08  6:12 PM  Page 486
When compound conditions are encountered in a procedural design, the genera-tion of a flow graph becomes slightly more complicated. A compound conditionoccurs when one or more Boolean operators (logical OR, AND, NAND, NOR) is pres-

ent in a conditional statement. Referring to Figure 18.3, the program design language
(PDL) segment translates into the flow graph shown. Note that a separate node is
created for each of the conditions aand bin the statement IF aOR b.Each node thatcontains a condition is called a predicate nodeand is characterized by two or moreedges emanating from it.18.4.2Independent Program Paths
An independent pathis any path through the program that introduces at least onenew set of processing statements or a new condition. When stated in terms of a flow
graph, an independent path must move along at least one edge that has not been

traversed before the path is defined. For example, a set of independent paths for the

flow graph illustrated in Figure 18.2bis
Path 1: 1-11Path 2: 1-2-3-4-5-10-1-11
Path 3: 1-2-3-6-8-9-10-1-11
Path 4: 1-2-3-6-7-9-10-1-11Note that each new path introduces a new edge. The path
1-2-3-4-5-10-1-2-3-6-8-9-10-1-11is not considered to be an independent path because it is simply a combination ofalready specified paths and does not traverse any new edges.Paths 1 through 4 constitute a basis setfor the flow graph in Figure 18.2b. That is,if you can design tests to force execution of these paths (a basis set), every statement
in the program will have been guaranteed to be executed at least one time and every
condition will have been executed on its true and false sides. It should be noted thatCHAPTER 18TESTING CONVENTIONAL APPLICATIONS487Predicatenode..
.IF a OR bthen procedure   xelse procedure   yENDIFybaxxFIGURE18.3Compoundlogicpre75977_ch18.qxd  11/27/08  6:12 PM  Page 487
the basis set is not unique. In fact, a number of different basis sets can be derived fora given procedural design.How do you know how many paths to look for? The computation of cyclomaticcomplexity provides the answer. 
Cyclomatic complexityis a software metric that pro-vides a quantitative measure of the logical complexity of a program. When used in
the context of the basis path testing method, the value computed for cyclomatic com-
plexity defines the number of independent paths in the basis set of a program and
provides you with an upper bound for the number of tests that must be conducted to

ensure that all statements have been executed at least once.Cyclomatic complexity has a foundation in graph theory and provides you withan
extremely useful software metric. Complexity is computed in one of three ways:1.The number of regions of the flow graph corresponds to the cyclomatic
complexity.
2.Cyclomatic complexity V(G) for a flow graph Gis defined asV(G) EN2where Eis the number of flow graph edges and Nis the number of flowgraph nodes.3.Cyclomatic complexity V(G) for a flow graph Gis also defined asV(G) P1where Pis the number of predicate nodes contained in the flow graph G.Referring once more to the flow graph in Figure 18.2b, the cyclomatic complexity can
be computed using each of the algorithms just noted:1.The flow graph has four regions.2.V(G)11 edges 9 nodes 24.3.V(G)3 predicate nodes 14.Therefore, the cyclomatic complexity of the flow graph in Figure 18.2bis 4.
More important, the value for V(G) provides you with an upper bound for the num-
ber of independent paths that form the basis set and, by implication, an upper bound
on the number of tests that must be designed and executed to guarantee coverage

of all program statements.488PART THREEQUALITY MANAGEMENTCyclomatic complexityis a useful metric for
predicting those
modules that are likely
to be error prone. Use

it for test planning as
well as test-case
design.How do Icomputecyclomatic
complexity??Cyclomatic complexityprovides the upper
bound on the number
of test cases that will
be required to
guarantee that every

statement in the
program has been
executed at least one
time.The scene:ShakiraÕs cubicle.
The players:Vinod and ShakiraÑmembers of the
SafeHomesoftware engineering team who are workingon test planning for the security function.The conversation:Shakira:Look . . . I know that we should unit-test all thecomponents for the security function, but there are a lot ofÔem and if you consider the number of operations thatSAFEHOMEUsing Cyclomatic Complexitypre75977_ch18.qxd  11/27/08  6:12 PM  Page 488
18.4.3Deriving Test Cases
The basis path testing method can be applied to a procedural design or to sourcecode. In this section, I present basis path testing as a series of steps. The procedure
average,
depicted in PDL in Figure 18.4, will be used as an example to illustrate eachstep in the test-case design method. Note that average,
although an extremely sim-ple algorithm, contains compound conditions and loops. The following steps can be
applied to derive the basis set:1.Using the design or code as a foundation, draw a corresponding

flow graph.
A flow graph is created using the symbols and constructionrules presented in Section 18.4.1. Referring to the PDL foraverage
inFigure18.4, a flow graph is created by numbering those PDL statements that

will be mapped into corresponding flow graph nodes. The corresponding
flow graph is shown in Figure 18.5.2.Determine the cyclomatic complexity of the resultant flow graph.

Thecyclomatic complexity 
V(G) is determined by applying the algorithms
described in Section 18.4.2. It should be noted that V(G) can be determined
without developing a flow graph by counting all conditional statements in
the PDL (for the procedure average,
compound conditions count as two) andadding 1. Referring to Figure 18.5,V(G) 6 regionsV(G) 17 edges 13 nodes 2 6V(G) 5 predicate nodes 1 6CHAPTER 18TESTING CONVENTIONAL APPLICATIONS489have to be exercised, I donÕt know
...ma
ybe we shouldforget white-box testing, integrate everything, and start
running black-box tests.Vinod:
You figure we donÕt have enough time to do
component tests, exercise the operations, and thenintegrate?Shakira:The deadline for the first increment is gettingcloser than IÕd like...yeah, IÕm concerned.

Vinod:
Why donÕt you at least run white-box tests on
the operations that are likely to be the most error prone?
Shakira (exasperated):And exactly how do I knowwhich are the most error prone?
Vinod:
Vof G.Shakira:Huh?Vinod:
Cyclomatic complexityÑVof G. Just computeV(G) for each of the operations within each of the components and see which have the highest values forV(G). TheyÕre the ones that are most likely to be error
prone.Shakira:And how do I compute Vof G?Vinod:
ItÕs really easy. HereÕs a book that describes how
to do it.
Shakira (leafing through the pages):
Okay, it
doesnÕt look hard. IÕll give it a try. The ops with 
the highest V(G) will be the candidates for white-box
tests.Vinod:
Just remember that there are no guarantees.Acomponent with a low 
V(G) can still be error prone.
Shakira:Alright. But at least thisÕll help me to narrowdown the number of components that have to undergowhite-box testing.uote:ÒThe Ariane 5rocket blew up on
lift-off due solely
to a software
defect (a bug)
involving the
conversion of a 64-
bit floating point
value into a 16-bit
integer. The rocket

and its four
satellites were
uninsuredandworth $500
million. [Path tests
that exercised the
conversion path]
would have found
the bug but were
vetoed for
budgetary

reasons.ÓA news reportpre75977_ch18.qxd  11/27/08  6:12 PM  Page 489
490PART THREEQUALITY MANAGEMENTPROCEDURE average;INTERFACE RETURNS average, total.input, total.valid;
INTERFACE ACCEPTS value, minimum, maximum;
TYPE value[1:100] IS SCALAR ARRAY;
TYPE average, total.input, total.valid;
 minimum, maximum, sum IS SCALAR;

TYPE i IS INTEGER;* This procedure computes the average of 100 or fewer
 numbers that lie between bounding values; it also computes the

 sum and the total number valid.
i = 1;total.input = total.valid = 0;
sum = 0;
DO WHILE value[i] <> Œ999 AND total.input < 100ENDDOIF total.valid > 0ENDIFEND averageincrement total.input by 1;IF value[i] > = minimum AND value[i] < = maximumENDIFincrement i by 1;THEN average = sum / total.valid;ELSE average = Œ999;THEN increment total.valid by 1;
 sum = s sum + value[i]

ELSE skip13645789101112132FIGURE18.4PDL with
nodes
identified12345678910111213FIGURE18.5Flow graph forthe procedure

average3.Determine a basis set of linearly independent paths.The value of V(G)provides the upper bound on the number of linearly independent paths
through the program control structure. In the case of procedureaverage,
weexpect to specify six paths:Path 1: 1-2-10-11-13Path 2: 1-2-10-12-13pre75977_ch18.qxd  11/27/08  6:12 PM  Page 490
Path 3: 1-2-3-10-11-13Path 4: 1-2-3-4-5-8-9-2-. . .
Path 5: 1-2-3-4-5-6-8-9-2-. . .
Path 6: 1-2-3-4-5-6-7-8-9-2-. . .The ellipsis (. . .) following paths 4, 5, and 6 indicates that any path throughthe remainder of the control structure is acceptable. It is often worthwhile to
identify predicate nodes as an aid in the derivation of test cases. In this case,

nodes 2, 3, 5, 6, and 10 are predicate nodes.4.Prepare test cases that will force execution of each path in the basis

set.Data should be chosen so that conditions at the predicate nodes areappropriately set as each path is tested. Each test case is executed and com-
pared to expected results. Once all test cases have been completed, the tester
can be sure that all statements in the program have been executed at least
once.It is important to note that some independent paths (e.g., path 1 in our example)cannot be tested in stand-alone fashion. That is, the combination of data required to
traverse the path cannot be achieved in the normal flow of the program. In such
cases, these paths are tested as part of another path test.18.4.4Graph Matrices
The procedure for deriving the flow graph and even determining a set of basis paths
is amenable to mechanization. A data structure, called a 
graph matrix,
can be quiteuseful for developing a software tool that assists in basis path testing.A graph matrix is a square matrix whose size (i.e., number of rows and columns)is equal to the number of nodes on the flow graph. Each row and column corre-
sponds to an identified node, and matrix entries correspond to connections (an edge)

between nodes. A simple example of a flow graph and its corresponding graph
matrix [Bei90] is shown in Figure 18.6.CHAPTER 18TESTING CONVENTIONAL APPLICATIONS49113425abcdefgFlow graph134
2513425aeg
cfdbConnected tonodeNodeGraph matrixFIGURE18.6Graph matrixpre75977_ch18.qxd  11/27/08  6:12 PM  Page 491
Referring to the figure, each node on the flow graph is identified by numbers,
while each edge is identified by letters. A letter entry is made in the matrix tocorrespond to a connection between two nodes. For example, node 3 is connected

to node 4 by edge b.To this point, the graph matrix is nothing more than a tabular representation of a
flow graph. However, by adding a 
link weightto each matrix entry, the graph matrix
can become a powerful tool for evaluating program control structure during testing.
The link weight provides additional information about control flow. In its simplest

form, the link weight is 1 (a connection exists) or 0 (a connection does not exist). But
link weights can be assigned other, more interesting properties:
¥The probability that a link (edge) will be execute.¥The processing time expended during traversal of a link¥The memory required during traversal of a link¥The resources required during traversal of a link.Beizer [Bei90] provides a thorough treatment of additional mathematical algo-
rithms that can be applied to graph matrices. Using these techniques, the analysis
required to design test cases can be partially or fully automated.18.5C
ONTROLSTRUCTURETESTINGThe basis path testing technique described in Section 18.4 is one of a number of tech-
niques for control structure testing. Although basis path testing is simple and highly
effective, it is not sufficient in itself. In this section, other variations on control struc-

ture testing are discussed. These broaden testing coverage and improve the quality

of white-box testing.18.5.1Condition Testing
Condition testing[Tai89] is a test-case design method that exercises the logical con-
ditions contained in a program module. A simple condition is a Boolean variable or
a relational expression, possibly preceded with one NOT (Â) operator. A relational

expression takes the formE1<relational-operator> E2where E1andE2are arithmetic expressions and <relational-operator> is one of thefollowing: ,,,(nonequality), , or. A compound conditionis composed oftwo or more simple conditions, Boolean operators, and parentheses. We assume

that Boolean operators allowed in a compound condition include OR (), AND (&),and NOT (Â). A condition without relational expressions is referred to as a Boolean
expression.If a condition is incorrect, then at least one component of the condition is incor-rect. Therefore, types of errors in a condition include Boolean operator errors
492PART THREEQUALITY MANAGEMENTWhat is agraph matrixand how do I
extend it for use
in testing??uote:ÒPaying more
attention to
running tests than
to designing them
is a classic
mistake.ÓBrianMarick
Errors are much more
common in the
neighborhood of

logical conditions than
they are in the locus of
sequential processing
statements.pre75977_ch18.qxd  11/27/08  6:12 PM  Page 492
(incorrect/missing/extra Boolean operators), Boolean variable errors, Booleanparenthesis errors, relational operator errors, and arithmetic expression errors. The
condition testing method focuses on testing each condition in the program to ensure
that it does not contain errors.18.5.2Data Flow Testing
The data flow testing method [Fra93] selects test paths of a program according to the
locations of definitions and uses of variables in the program. To illustrate the data

flow testing approach, assume that each statement in a program is assigned a unique
statement number and that each function does not modify its parameters or global
variables. For a statement with Sas its statement number,
DEF(S) {X| statement Scontains a definition of X}USE(S) {X| statement Scontains a use of X}If statement Sis aniforloop statement,its DEF set is empty and its USE set is basedon the condition of statement S.The definition of variable Xat statement Sis said tobe liveat statement SÕif there exists a path from statement Sto statement SÕthat con-tains no other definition of X.A definition-use (DU) chain
of variable Xis of the form [X, S, SÕ], where Sand SÕarestatement numbers, Xis in DEF(S) and USE(SÕ), and the definition of Xin statementSis live at statementSÕ.One simple data flow testing strategy is to require that every DU chain be covered
at least once. We refer to this strategy as the DU testing strategy. It has been shown

that DU testing does not guarantee the coverage of all branches of a program. How-

ever, a branch is not guaranteed to be covered by DU testing only in rare situations

such as if-then-else constructs in which thethen parthas no definition of any vari-able and theelse partdoes not exist. In this situation, the else branch of theifstate-ment is not necessarily covered by DU testing.
18.5.3Loop Testing
Loops are the cornerstone for the vast majority of all algorithms implemented in
software. And yet, we often pay them little heed while conducting software tests.Loop testingis a white-box testing technique that focuses exclusively on thevalidity of loop constructs. Four different classes of loops [Bei90] can be defined: sim-
ple loops, concatenated loops, nested loops, and unstructured loops (Figure 18.7).Simple loops.The following set of tests can be applied to simple loops, where nis the maximum number of allowable passes through the loop.1.Skip the loop entirely.
2.Only one pass through the loop.3.Two passes through the loop.
CHAPTER 18TESTING CONVENTIONAL APPLICATIONS493It is unrealistic toassume that data flow
testing will be used
extensively when
testing a large system.
However, it can be

used in a targeted
fashion for areas of
software that are
suspect.uote:ÒGood testers aremasters at noticing
Ôsomething funnyÕ
and acting on it.ÓBrianMarick
pre75977_ch18.qxd  11/27/08  6:12 PM  Page 493
4.mpasses through the loop where mn.5.n1, n, n1 passes through the loop.Nested loops.If we were to extend the test approach for simple loops to nestedloops, the number of possible tests would grow geometrically as the level of nestingincreases. This would result in an impractical number of tests. Beizer [Bei90] sug-
gests an approach that will help to reduce the number of tests:1.Start at the innermost loop. Set all other loops to minimum values.2.Conduct simple loop tests for the innermost loop while holding the outer
loops at their minimum iteration parameter (e.g., loop counter) values. Add
other tests for out-of-range or excluded values.3.Work outward, conducting tests for the next loop, but keeping all other outer

loops at minimum values and other nested loops to ÒtypicalÓ values.4.Continue until all loops have been tested.Concatenated loops.Concatenated loops can be tested using the approachdefined for simple loops, if each of the loops is independent of the other. However,

if two loops are concatenated and the loop counter for loop 1 is used as the initial
value for loop 2, then the loops are not independent. When the loops are not inde-
pendent, the approach applied to nested loops is recommended.Unstructured loops.
Whenever possible, this class of loops should be redesigned
to reflect the use of the structured programming constructs (Chapter 10).494PART THREEQUALITY MANAGEMENTSimple loopsNested loopsConcatenatedloopsUnstructuredloopsFIGURE18.7Classes ofLoopsYou canÕt test unstruc-
tured loops effectively.

Refactor them.pre75977_ch18.qxd  11/27/08  6:12 PM  Page 494
18.6B
LACK-BOXTESTINGBlack-box testing
, also called behavioral testing,
focuses on the functional require-ments of the software. That is, black-box testing techniques enable you to derive setsof input conditions that will fully exercise all functional requirements for a program.
Black-box testing is not an alternative to white-box techniques. Rather, it is a com-

plementary approach that is likely to uncover a different class of errors than white-

box methods.Black-box testing attempts to find errors in the following categories: (1) incorrector missing functions, (2) interface errors, (3) errors in data structures or external
database access, (4) behavior or performance errors, and (5) initialization and
termination errors.Unlikewhite-boxtesting,whichisperformedearlyinthetestingprocess,black-
boxtestingtendstobeappliedduringlaterstagesoftesting(seeChapter17).Because

black-boxtestingpurposelydisregardscontrolstructure,attentionisfocusedonthe

informationdomain.Testsaredesignedtoanswerthefollowingquestions:
¥How is functional validity tested?¥How are system behavior and performance tested?¥What classes of input will make good test cases?¥Is the system particularly sensitive to certain input values?¥How are the boundaries of a data class isolated?¥What data rates and data volume can the system tolerate?¥What effect will specific combinations of data have on system operation?By applying black-box techniques, you derive a set of test cases that satisfy the fol-
lowing criteria [Mye79]: (1) test cases that reduce, by a count that is greater than one,

the number of additional test cases that must be designed to achieve reasonable
testing, and (2) test cases that tell you something about the presence or absence of
classes of errors, rather than an error associated only with the specific test at hand.18.6.1Graph-Based Testing Methods
The first step in black-box testing is to understand the objects5that are modeled insoftware and the relationships that connect these objects. Once this has been
accomplished, the next step is to define a series of tests that verify Òall objects have
the expected relationship to one anotherÓ [Bei95]. Stated in another way, software

testing begins by creating a graph of important objects and their relationships andCHAPTER 18TESTING CONVENTIONAL APPLICATIONS495Whatquestions doblack-box tests
answer??A graph represents therelationships between
data objects and
program objects,
enabling you to derive
test cases that search
for errors associated

with these
relationships.5In this context, you should consider the term 
objectsin the broadest possible context. It encom-passes data objects, traditional components (modules), and object-oriented elements of computersoftware.uote:ÒTo err is human,
to find a bug is
divine.ÓRobertDunn
pre75977_ch18.qxd  11/27/08  6:12 PM  Page 495
then devising a series of tests that will cover the graph so that each object and rela-
tionship is exercised and errors are uncovered.
To accomplish these steps, you begin by creating a 
graph
Ña collection of nodesthat represent objects, linksthat represent the relationships between objects, nodeweightsthat describe the properties of a node (e.g., a specific data value or statebehavior), and link weightsthat describe some characteristic of a link.The symbolic representation of a graph is shown in Figure 18.8a. Nodes arerepresented as circles connected by links that take a number of different forms.
Adirected link(represented by an arrow) indicates that a relationship moves in only
one direction. A bidirectional link,also called a symmetric link,implies that the rela-tionship applies in both directions. Parallel links
are used when a number of differentrelationships are established between graph nodes.As a simple example, consider a portion of a graph for a word-processing
application (Figure 18.8b) whereObject #1newFile (menu selection)Object #2documentWindow
Object #3documentText
Referring to the figure, a menu select on 
newFilegenerates a document window.
The node weight of documentWindow
provides a list of the window attributes that
are to be expected when the window is generated. The link weight indicates that the496PART THREEQUALITY MANAGEMENTNew filemenuselectMenu select generatesDocumentwindowDocumenttextIs represented asContains(b)Object#1Directed linkObject#2Object#3Undirected linkParallel linksNode weight(value)(a)Allows editing of(link weight)(generation time < 1.0 sec)Attributes:Start dimension: default setting

          or preferences

Background color: white
Text color: default color 

  or preferences
FIGURE18.8(a) Graph
notation; (b)
simple
examplepre75977_ch18.qxd  11/27/08  6:12 PM  Page 496
window must be generated in less than 1.0 second. An undirected link establishes asymmetric relationship between the newFilemenu selection and documentText,
and parallel links indicate relationships between documentWindow
anddocumentText.
In reality, a far more detailed graph would have to be generated
asaprecursor to test-case design. You can then derive test cases by traversing the

graph and covering each of the relationships shown. These test cases are designed

in an attempt to find errors in any of the relationships. Beizer [Bei95] describes a
number of behavioral testing methods that can make use of graphs:Transaction flow modeling.
The nodes represent steps in some transac-tion (e.g., the steps required to make an airline reservation using an online
service), and the links represent the logical connection between steps (e.g.,
flightInformationInput
is followed by validationAvailabilityProcessing
).Thedata flow diagram (Chapter 7) can be used to assist in creating graphs of

this type.Finitestatemodeling.
Thenodesrepresentdifferentuser-observablestates
ofthesoftware(e.g.,eachoftheÒscreensÓthatappearasanorderentryclerk
takesaphoneorder),andthelinksrepresentthetransitionsthatoccurtomove

fromstatetostate(e.g.,
orderInformation
isverifiedduring
inventoryAvail-
abilityLook-upandisfollowedby
customerBillingInformation
input).The
statediagram(Chapter7)canbeusedtoassistincreatinggraphsofthistype.
Data flow modeling.
The nodes are data objects, and the links are thetransformations that occur to translate one data object into another. For
example, the node FICA tax withheld (
FTW) is computed from gross wages
(GW) using the relationship, FTW0.62GW.
Timing modeling.
The nodes are program objects, and the links are thesequential connections between those objects. Link weights are used to
specify the required execution times as the program executes.A detailed discussion of each of these graph-based testing methods is beyondthescope of this book. If you have further interest, see [Bei95] for a comprehensive

coverage.
18.6.2Equivalence Partitioning
Equivalence partitioningis a black-box testing method that divides the input domainof a program into classes of data from which test cases can be derived. An ideal test
case single-handedly uncovers a class of errors (e.g., incorrect processing of all

character data) that might otherwise require many test cases to be executed before
the general error is observed.Test-casedesignforequivalencepartitioningisbasedonanevaluationof
equivalenceclasses
foraninputcondition.Usingconceptsintroducedinthepreced-
ingsection, if a set of objects can be linked by relationships that are symmetric,
CHAPTER 18TESTING CONVENTIONAL APPLICATIONS497Input classes areknown relatively early
in the software
process. For this
reason, begin thinking
about equivalence
partitioning as the

design is created.pre75977_ch18.qxd  11/27/08  6:12 PM  Page 497
transitive, and reflexive, an equivalence class is present [Bei95]. An equivalence
class represents a set of valid or invalid states for input conditions. Typically, an input

condition is either a specific numeric value, a range of values, a set of related values,

or a Boolean condition. Equivalence classes may be defined according to the
following guidelines:1.If an input condition specifies a range, one valid and two invalid equivalence

classes are defined.2.If an input condition requires a specific value, one valid and two invalid

equivalence classes are defined.3.If an input condition specifies a member of a set, one valid and one invalid

equivalence class are defined.4.If an input condition is Boolean, one valid and one invalid class are defined.
By applying the guidelines for the derivation of equivalence classes, test cases foreach input domain data item can be developed and executed. Test cases are selected

so that the largest number of attributes of an equivalence class are exercised at once.18.6.3Boundary Value Analysis
A greater number of errors occurs at the boundaries of the input domain rather than
in the Òcenter.Ó It is for this reason that 
boundary value analysis(BVA) has been de-
veloped as a testing technique. Boundary value analysis leads to a selection of test
cases that exercise bounding values.Boundary value analysis is a test-case design technique that complements equiv-alence partitioning. Rather than selecting any element of an equivalence class, BVA

leads to the selection of test cases at the ÒedgesÓ of the class. Rather than focusing
solely on input conditions, BVA derives test cases from the output domain as well

[Mye79].Guidelines for BVA are similar in many respects to those provided for equivalence
partitioning:1.Ifaninputconditionspecifiesarangeboundedbyvalues
aandb,testcases
shouldbedesignedwithvalues
aandbandjustaboveandjustbelow
aandb.2.If an input condition specifies a number of values, test cases should be devel-
oped that exercise the minimum and maximum numbers. Values just above

and below minimum and maximum are also tested.3.Applyguidelines1and2tooutputconditions.Forexample,assumethatatem-

peratureversuspressuretableisrequiredasoutputfromanengineeringanaly-

sisprogram.Testcasesshouldbedesignedtocreateanoutputreportthat

producesthemaximum(andminimum)allowablenumberoftableentries.
4.If internal program data structures have prescribed boundaries (e.g., a table
has a defined limit of 100 entries), be certain to design a test case to exercise
the data structure at its boundary.
498PART THREEQUALITY MANAGEMENTHow do Idefineequivalence
classes for
testing??uote:ÒAn effective way
to test code is to
exercise it at its
natural
boundaries.ÓBrianKernighan
BVA extends
equivalence
partitioning by focusing

on data at the ÒedgesÓ
of an equivalence
class.pre75977_ch18.qxd  11/27/08  6:12 PM  Page 498
Most software engineers intuitively perform BVA to some degree. By applying
these guidelines, boundary testing will be more complete, thereby having a higher
likelihood for error detection.18.6.4Orthogonal Array Testing
There are many applications in which the input domain is relatively limited. That is,
the number of input parameters is small and the values that each of the parameters
may take are clearly bounded. When these numbers are very small (e.g., three input
parameters taking on three discrete values each), it is possible to consider every
input permutation and exhaustively test the input domain. However, as the number

of input values grows and the number of discrete values for each data item increases,
exhaustive testing becomes impractical or impossible.Orthogonal array testing
can be applied to problems in which the input domain isrelatively small but too large to accommodate exhaustive testing. The orthogonal
array testing method is particularly useful in finding region faultsÑan error category
associated with faulty logic within a software component.To illustrate the difference between orthogonal array testing and more conven-
tional Òone input item at a timeÓ approaches, consider a system that has three input
items, X, Y,
andZ.Each of these input items has three discrete values associated withit. There are 3327 possible test cases. Phadke [Pha97] suggests a geometric viewof the possible test cases associated with X, Y, and Z illustrated in Figure 18.9.

Referring to the figure, one input item at a time may be varied in sequence along each

input axis. This results in relatively limited coverage of the input domain (repre-

sented by the left-hand cube in the figure).When orthogonal array testing occurs, an L9 orthogonal array
of test cases iscreated. The L9 orthogonal array has a Òbalancing propertyÓ [Pha97]. That is, test
cases (represented by dark dots in the figure) are Òdispersed uniformly throughout
the test domain,Ó as illustrated in the right-hand cube in Figure 18.9. Test coverage

across the input domain is more complete.CHAPTER 18TESTING CONVENTIONAL APPLICATIONS499YYXXZZOne input item at a timeL9 orthogonal array
FIGURE18.9A geometricview of test
cases
Source: [Pha97]Orthogonal array
testing enables you to
design test cases that
provide maximum test
coverage with a
reasonable number of
test cases.pre75977_ch18.qxd  11/27/08  6:12 PM  Page 499
To illustrate the use of the L9 orthogonal array, consider the 
sendfunction for afax application. Four parameters, P1, P2, P3, and P4, are passed to the sendfunction.Each takes on three discrete values. For example, P1 takes on values:
P11, send it nowP12, send it one hour laterP13, send it after midnightP2, P3, and P4 would also take on values of 1, 2, and 3, signifying other sendfunctions.If a Òone input item at a timeÓ testing strategy were chosen, the followingsequenceoftests(P1,P2,P3,P4)wouldbespecified:(1,1,1,1),(2,1,1,1),(3,1,1,1),

(1, 2, 1, 1), (1, 3, 1, 1), (1, 1, 2, 1), (1, 1, 3, 1), (1, 1, 1, 2), and (1, 1, 1, 3). Phadke [Pha97]
assesses these test cases by stating:Such test cases are useful only when one is certain that these test parameters do notinteract. They can detect logic faults where a single parameter value makes the software
malfunction. These faults are called single mode faults.This method cannot detect logicfaults that cause malfunction when two or more parameters simultaneously take certain
values; that is, it cannot detect any interactions. Thus its ability to detect faults is limited.Given the relatively small number of input parameters and discrete values,exhaustive testing is possible. The number of tests required is 3481, large but man-ageable. All faults associated with data item permutation would be found, but theeffort required is relatively high.The orthogonal array testing approach enables you to provide good test coverage
with far fewer test cases than the exhaustive strategy. An L9 orthogonal array for the

fax sendfunction is illustrated in Figure 18.10.500PART THREEQUALITY MANAGEMENTTest
caseTest parameters
P1P2P3P4
123312231123231312123123123111222333123456789FIGURE18.10An L9 orthog-onal arraypre75977_ch18.qxd  11/27/08  6:12 PM  Page 500
Phadke [Pha97] assesses the result of tests using the L9 orthogonal array in thefollowing manner:Detect and isolate all single mode faults.
A single mode fault is a consistent prob-lem with any level of any single parameter. For example, if all test cases of factor P1
1cause an error condition, it is a single mode failure. In this example tests 1, 2 and 3[Figure18.10] will show errors. By analyzing the information about which tests show

errors, one can identify which parameter values cause the fault. In this example, by not-

ing that tests 1, 2, and 3 cause an error, one can isolate [logical processing associated

with Òsend it nowÓ (P11)] as the source of the error. Such an isolation of fault is
important to fix the fault.Detect all double mode faults.
If there exists a consistent problem when specificlevels of two parameters occur together, it is called a 
double mode fault.Indeed, a doublemode fault is an indication of pairwise incompatibility or harmful interactions between
two test parameters.Multimode faults.
Orthogonal arrays [of the type shown] can assure the detection ofonly single and double mode faults. However, many multimode faults are also detected

by these tests.You can find a detailed discussion of orthogonal array testing in [Pha89].
CHAPTER 18TESTING CONVENTIONAL APPLICATIONS501Test-Case Design
Objective:To assist the software team in
developing a complete set of test cases for bothblack-box and white-box testing.Mechanics:These tools fall into two broad categories:static testing tools and dynamic testing tools. Threedifferent types of static testing tools are used in the

industry: code-based testing tools, specialized testing

languages, and requirements-based testing tools. Code-
based testing tools accept source code as input and
perform a number of analyses that result in the generation

of test cases. Specialized testing languages (e.g., ATLAS)

enable a software engineer to write detailed test
specifications that describe each test case and the logistics
for its execution. Requirements-based testing tools isolate
specific user requirements and suggest test cases (or
classes of tests) that will exercise the requirements.
Dynamic testing tools interact with an executing program,
checking path coverage, testing assertions about the value

of specific variables, and otherwise instrumenting the

execution flow of the program.Representative Tools:
6McCabeTest,
developed by McCabe & Associates(www.mccabe.com
), implements a variety of path
testing techniques derived from an assessment of
cyclomatic complexity and other software metrics.TestWorks,
developed by Software Research, Inc.(www.soft.com/Products
), is a complete set ofautomated testing tools that assists in the design of tests
cases for software developed in C/C++ and Java and
provides support for regression testing.
T-VEC Test Generation System,
developed by T-VEC
Technologies (
www.t-vec.com
), is a tool set that
supports unit, integration, and validation testing by

assisting in the design of test cases using information

contained in an OO requirements specification.e-TEST Suite,developed by Empirix, Inc. (www.empirix
.com), encompasses a complete set of tools for testing
WebApps, including tools that assist test-case design

and test planning.SOFTWARE
TOOLS6Tools noted here do not represent an endorsement, but rather a sampling of tools in this category.
In most cases, tool names are trademarked by their respective developers.pre75977_ch18.qxd  11/27/08  6:12 PM  Page 501
18.7M
ODEL-BASEDTESTINGModel-based testing(MBT) is a black-box testing technique that uses informationcontained in the requirements model as the basis for the generation of test cases. Inmany cases, the model-based testing technique uses UML state diagrams, an ele-
ment of the behavioral model (Chapter 7), as the basis for the design of test cases.7The MBT technique requires five steps:1.Analyze an existing behavioral model for the software or create one.

Recall that a behavioral model
indicates how software will respond to exter-nal events or stimuli. To create the model, you should perform the steps

discussed in Chapter 7: (1) evaluate all use cases to fully understand the
sequence of interaction within the system, (2) identify events that drive the
interaction sequence and understand how these events relate to specific
objects, (3) create a sequence for each use case, (4) build a UML state

diagram for the system (e.g., see Figure 7.6), and (5) review the behavioral
model to verify accuracy and consistency.
2.Traverse the behavioral model and specify the inputs that will force

the software to make the transition from state to state.
The inputs willtrigger events that will cause the transition to occur.
3.Review the behavioral model and note the expected outputs as the

software makes the transition from state to state.
Recall that eachstate transition is triggered by an event and that as a consequence of the
transition, some function is invoked and outputs are created. For each set of

inputs (test cases) you specified in step 2, specify the expected outputs as
they are characterized in the behavioral model. ÒA fundamental assumption
of this testing is that there is some mechanism, atest oracle
, that will deter-mine whether or not the results of a test execution are correctÓ [DAC03]. In

essence, a test oracle establishes the basis for any determination of the cor-

rectness of the output. In most cases, the oracle is the requirements model,
but it could also be another document or application, data recorded else-
where, or even a human expert.
4.Execute the test cases.Tests can be executed manually or a test script can
be created and executed using a testing tool.5.Compare actual and expected results and take corrective action as

required.
MBT helps to uncover errors in software behavior, and as a consequence, it is
extremely useful when testing event-driven applications.502PART THREEQUALITY MANAGEMENTuote:ÒItÕs hard enough
to find an error in
your code when
youÕre looking for
it; itÕs even harder

when youÕve
assumed your code
is error-free.Ó
SteveMcConnell
7Model-based testing can also be used when software requirements are represented with decision
tables, grammars, or Markov chains [DAC03].pre75977_ch18.qxd  11/27/08  6:12 PM  Page 502
18.8T
ESTINGFOR
SPECIALIZEDENVIRONMENTS,ARCHITECTURES, ANDAPPLICATIONS
Unique guidelines and approaches to testing are sometimes warranted when spe-cialized environments, architectures, and applications are considered. Although the

testing techniques discussed earlier in this chapter and in Chapters 19and 20can

often be adapted to specialized situations, itÕs worth considering their unique needs

individually.
18.8.1Testing GUIs
Graphical user interfaces (GUIs) will present you with interesting testing challenges.
Because reusable components are now a common part of GUI development envi-

ronments, the creation of the user interface has become less time consuming and
more precise (Chapter 11). But, at the same time, the complexity of GUIs has grown,

leading to more difficulty in the design and execution of test cases.Because many modern GUIs have the same look and feel, a series of standardtests can be derived. Finite-state modeling graphs may be used to derive a series of
tests that address specific data and program objects that are relevant to the GUI. This
model-based testing technique was discussed in Section 18.7.Because of the large number of permutations associated with GUI operations, GUItesting should be approached using automated tools. A wide array of GUI testing
tools has appeared on the market over the past few years.
818.8.2Testing of Client-Server Architectures
The distributed nature of client-server environments, the performance issues asso-

ciated with transaction processing, the potential presence of a number of different
hardware platforms, the complexities of network communication, the need to serv-
ice multiple clients from a centralized (or in some cases, distributed) database, and

the coordination requirements imposed on the server all combine to make testing of
client-server architectures and the software that resides within them considerably
more difficult than stand-alone applications. In fact, recent industry studies indicate
a significant increase in testing time and cost when client-server environments are

developed.In general, the testing of client-server software occurs at three different levels:(1)Individual client applications are tested in a ÒdisconnectedÓ mode; the operation

of the server and the underlying network are not considered. (2) The client software
and associated server applications are tested in concert, but network operations are
not explicitly exercised. (3) The complete client-server architecture, including net-

work operation and performance, is tested.
CHAPTER 18TESTING CONVENTIONAL APPLICATIONS5038Hundreds, if not thousands, of GUI testing tool resources can be evaluated on the Web. A good
starting point for open-source tools is www.opensourcetesting.org/functional.php.uote:ÒThe topic oftesting is one
areain which a

good deal of
commonality exists
between traditional
system and client/
server systems.Ó
KelleyBourne
WebRef
Useful client-severtesting information and

resources can be found
at www.csst-

technologies.com.pre75977_ch18.qxd  11/27/08  6:12 PM  Page 503
